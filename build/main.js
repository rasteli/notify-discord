/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@actions/core/lib/command.js":
/*!***************************************************!*\
  !*** ./node_modules/@actions/core/lib/command.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/core/lib/utils.js");
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/core.js":
/*!************************************************!*\
  !*** ./node_modules/@actions/core/lib/core.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __webpack_require__(/*! ./command */ "./node_modules/@actions/core/lib/command.js");
const file_command_1 = __webpack_require__(/*! ./file-command */ "./node_modules/@actions/core/lib/file-command.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/core/lib/utils.js");
const os = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const path = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const oidc_utils_1 = __webpack_require__(/*! ./oidc-utils */ "./node_modules/@actions/core/lib/oidc-utils.js");
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __webpack_require__(/*! ./summary */ "./node_modules/@actions/core/lib/summary.js");
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __webpack_require__(/*! ./summary */ "./node_modules/@actions/core/lib/summary.js");
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __webpack_require__(/*! ./path-utils */ "./node_modules/@actions/core/lib/path-utils.js");
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/file-command.js":
/*!********************************************************!*\
  !*** ./node_modules/@actions/core/lib/file-command.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const os = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/core/lib/utils.js");
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/oidc-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@actions/core/lib/oidc-utils.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __webpack_require__(/*! @actions/http-client */ "./node_modules/@actions/http-client/lib/index.js");
const auth_1 = __webpack_require__(/*! @actions/http-client/lib/auth */ "./node_modules/@actions/http-client/lib/auth.js");
const core_1 = __webpack_require__(/*! ./core */ "./node_modules/@actions/core/lib/core.js");
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/path-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@actions/core/lib/path-utils.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/summary.js":
/*!***************************************************!*\
  !*** ./node_modules/@actions/core/lib/summary.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
const fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@actions/core/lib/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/@actions/github/lib/context.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
const fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
const os_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
class Context {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
            }
            else {
                const path = process.env.GITHUB_EVENT_PATH;
                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
    }
    get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
        if (process.env.GITHUB_REPOSITORY) {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            return { owner, repo };
        }
        if (this.payload.repository) {
            return {
                owner: this.payload.repository.owner.login,
                repo: this.payload.repository.name
            };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/github.js":
/*!****************************************************!*\
  !*** ./node_modules/@actions/github/lib/github.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokit = exports.context = void 0;
const Context = __importStar(__webpack_require__(/*! ./context */ "./node_modules/@actions/github/lib/context.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/github/lib/utils.js");
exports.context = new Context.Context();
/**
 * Returns a hydrated octokit ready to use for GitHub Actions
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokit(token, options, ...additionalPlugins) {
    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
    return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));
}
exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/internal/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@actions/github/lib/internal/utils.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
const httpClient = __importStar(__webpack_require__(/*! @actions/http-client */ "./node_modules/@actions/http-client/lib/index.js"));
function getAuthString(token, options) {
    if (!token && !options.auth) {
        throw new Error('Parameter token or opts.auth is required');
    }
    else if (token && options.auth) {
        throw new Error('Parameters token and opts.auth may not both be specified');
    }
    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
}
exports.getAuthString = getAuthString;
function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
}
exports.getProxyAgent = getProxyAgent;
function getApiBaseUrl() {
    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
}
exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/@actions/github/lib/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
const Context = __importStar(__webpack_require__(/*! ./context */ "./node_modules/@actions/github/lib/context.js"));
const Utils = __importStar(__webpack_require__(/*! ./internal/utils */ "./node_modules/@actions/github/lib/internal/utils.js"));
// octokit + plugins
const core_1 = __webpack_require__(/*! @octokit/core */ "./node_modules/@octokit/core/dist-web/index.js");
const plugin_rest_endpoint_methods_1 = __webpack_require__(/*! @octokit/plugin-rest-endpoint-methods */ "./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js");
const plugin_paginate_rest_1 = __webpack_require__(/*! @octokit/plugin-paginate-rest */ "./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js");
exports.context = new Context.Context();
const baseUrl = Utils.getApiBaseUrl();
exports.defaults = {
    baseUrl,
    request: {
        agent: Utils.getProxyAgent(baseUrl)
    }
};
exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
/**
 * Convience function to correctly format Octokit Options to pass into the constructor.
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
    // Auth
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
        opts.auth = auth;
    }
    return opts;
}
exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@actions/http-client/lib/auth.js":
/*!*******************************************************!*\
  !*** ./node_modules/@actions/http-client/lib/auth.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ "./node_modules/@actions/http-client/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@actions/http-client/lib/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const https = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const pm = __importStar(__webpack_require__(/*! ./proxy */ "./node_modules/@actions/http-client/lib/proxy.js"));
const tunnel = __importStar(__webpack_require__(/*! tunnel */ "./node_modules/tunnel/index.js"));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@actions/http-client/lib/proxy.js":
/*!********************************************************!*\
  !*** ./node_modules/@actions/http-client/lib/proxy.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports.parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/@acuminous/bitsyntax/lib/parse.js").parse;
module.exports.match = __webpack_require__(/*! ./lib/interp */ "./node_modules/@acuminous/bitsyntax/lib/interp.js").match;
module.exports.build = __webpack_require__(/*! ./lib/constructor */ "./node_modules/@acuminous/bitsyntax/lib/constructor.js").build;
module.exports.write = __webpack_require__(/*! ./lib/constructor */ "./node_modules/@acuminous/bitsyntax/lib/constructor.js").write;

module.exports.matcher = module.exports.compile = __webpack_require__(/*! ./lib/compile */ "./node_modules/@acuminous/bitsyntax/lib/compile.js").compile;
module.exports.builder = __webpack_require__(/*! ./lib/compile */ "./node_modules/@acuminous/bitsyntax/lib/compile.js").compile_builder;


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/compile.js":
/*!**********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/compile.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Compile patterns to recognisers and constructors



__webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js");
var $ = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

var parse = (__webpack_require__(/*! ./parse */ "./node_modules/@acuminous/bitsyntax/lib/parse.js").parse);
var interp = __webpack_require__(/*! ./interp */ "./node_modules/@acuminous/bitsyntax/lib/interp.js"),
  parse_int = interp.parse_int,
  parse_float = interp.parse_float;
var construct = __webpack_require__(/*! ./constructor */ "./node_modules/@acuminous/bitsyntax/lib/constructor.js"),
  write_int = construct.write_int,
  write_float = construct.write_float;

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);

var lines = [];
function $start() {
  lines = [];
}
function $line(/* format , args */) {
  lines.push($.apply(null, arguments));
}
function $result() {
  return lines.join('\n');
}

function bits_expr(segment) {
  if (typeof segment.size === 'string') {
    return $('%s * %d', var_name(segment.size), segment.unit);
  }
  else {
    return (segment.size * segment.unit).toString();
  }
}

function get_number(segment) {
  $line('bits = %s;\n', bits_expr(segment));
  var parser = (segment.type === 'integer') ?
    'parse_int' : 'parse_float';
  var be = segment.bigendian, sg = segment.signed;
  $line("byteoffset = offset / 8; offset += bits");
  $line("if (offset > binsize) { return false; }");
  $line("else { result = %s(bin, byteoffset, bits / 8, %s, %s); }",
        parser, be, sg);
}

function get_binary(segment) {
  $line("byteoffset = offset / 8;");
  if (segment.size === true) {
    $line("offset = binsize;");
    $line("result = bin.slice(byteoffset);");
  }
  else {
    $line("bits = %s;", bits_expr(segment));
    $line("offset += bits;");
    $line("if (offset > binsize) { return false; }");
    $line("else { result = bin.slice(byteoffset,",
          "byteoffset + bits / 8); }");
  }
}

function get_string(segment) {
  $line("byteoffset = offset / 8;");
  var strlen = segment.value.length;
  var strlenbits = strlen * 8;
  $line("offset += %d;", strlenbits);
  $line("if (offset > binsize) { return false; }");
  $line("else { result = bin.toString(byteoffset,",
        $("byteoffset + %d); }", strlen));
}

function skip_bits(segment) {
  if (typeof segment.size === 'string') {
    // Damn. Have to look up the size.
    $line("var skipbits = %s * %d;",
          var_name(segment.size), segment.unit);
    $line("if (offset + skipbits > binsize) { return false; }");
    $line("else { offset += skipbits; }");
  }
  else if (segment.size === true) {
    $line("if (offset % 8 === 0) { offset = binsize; }");
    $line("else { return false; }");
  }
  else {
    var bits = segment.unit * segment.size;
    $line("if (offset + %d > binsize) { return false; }", bits);
    $line("else { offset += %d; }", bits);
  }
}

function match_seg(segment) {
  if (segment.name === '_') {
    skip_bits(segment);
  }
  else {
    var assign_result;
    switch (segment.type) {
    case 'integer':
    case 'float':
      get_number(segment);
      break;
    case 'binary':
      get_binary(segment);
      break;
    case 'string':
      get_string(segment);
      break;
    }
    $line("if (result === false) return false;");
    if (segment.name) {
      // variable is given a value in the environment
      $line("else if (%s !== undefined) {", var_name(segment.name));
      // .. and it is not the same as that matched
      $line("if (%s != result) return false;",
            var_name(segment.name));
      $line("}");
      // variable is free
      $line('else %s = result;', var_name(segment.name));
    }
    else {
      var repr = JSON.stringify(segment.value);
      $line("else if (result != %s) return false;", repr);
    }
  }
}

function var_name(name) {
  return  'var_' + name;
}

function variables(segments) {
  var names = {};
  for (var i = 0; i < segments.length; i++) {
    var name = segments[i].name;
    if (name && name !== '_') {
      names[name] = true;
    }
    name = segments[i].size;
    if (typeof name === 'string') {
      names[name] = true;
    }
  }
  return Object.keys(names);
}

function compile_pattern(segments) {
  $start();
  $line("return function(binary, env) {");
  $line("'use strict';");
  $line("var bin = binary, env = env || {};");
  $line("var offset = 0, binsize = bin.length * 8;");
  $line("var bits, result, byteoffset;");
  var varnames = variables(segments);
  for (var v = 0; v < varnames.length; v++) {
    var name = varnames[v];
    $line("var %s = env['%s'];", var_name(name), name);
  }

  var len = segments.length;
  for (var i = 0; i < len; i++) {
    var segment = segments[i];
    $line("// " + JSON.stringify(segment));
    match_seg(segment);
  }

  $line("if (offset == binsize) {");
  $line("return {");
  for (var v = 0; v < varnames.length; v++) {
    var name = varnames[v];
    $line("%s: %s,", name, var_name(name));
  }
  $line('};');
  $line('}'); // if offset == binsize
  $line("else return false;");
  $line("}"); // end function

  var fn = new Function('parse_int', 'parse_float', $result());
  return fn(parse_int, parse_float);
}


function write_seg(segment) {
  switch (segment.type) {
  case 'string':
    $line("offset += buf.write(%s, offset, 'utf8');",
          JSON.stringify(segment.value));
    break;
  case 'binary':
    $line("val = bindings['%s'];", segment.name);
    if (segment.size === true) {
      $line('size = val.length;');
    }
    else if (typeof segment.size === 'string') {
      $line("size = (bindings['%s'] * %d) / 8;",
            segment.size, segment.unit);
    }
    else {
      $line("size = %d;", (segment.size * segment.unit) / 8);
    }
    $line('val.copy(buf, offset, 0, size);');
    $line('offset += size;');
    break;
  case 'integer':
  case 'float':
    write_number(segment);
    break;
  }
}

function write_number(segment) {
  if (segment.name) {
    $line("val = bindings['%s'];", segment.name);
  }
  else {
    $line("val = %d", segment.value);
  }
  var writer = (segment.type === 'integer') ?
    'write_int' : 'write_float';
  if (typeof segment.size === 'string') {
    $line("size = (bindings['%s'] * %d) / 8;",
          segment.size, segment.unit);
  }
  else {
    $line('size = %d;', (segment.size * segment.unit) / 8);
  }
  $line('%s(buf, val, offset, size, %s);',
        writer, segment.bigendian);
  $line('offset += size;');
}

function size_of(segments) {
  var variable = [];
  var fixed = 0;

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (typeof segment.size === 'string' ||
        segment.size === true) {
      variable.push(segment);
    }
    else if (segment.type === 'string') {
      fixed += Buffer.byteLength(segment.value);
    }
    else {
      fixed += (segment.size * segment.unit) / 8;
    }
  }

  $line('var buffersize = %d;', fixed);

  if (variable.length > 0) {
    for (var j = 0; j < variable.length; j++) {
      var segment = variable[j];
      if (segment.size === true) {
        $line("buffersize += bindings['%s'].length;", segment.name);
      }
      else {
        $line("buffersize += (bindings['%s'] * %d) / 8;",
              segment.size, segment.unit);
      }
    }
  }
}

function emit_write(segments) {
  $line('var val, size;');

  var len = segments.length;
  for (var i = 0; i < len; i++) {
    var segment = segments[i];
    $line('// %s', JSON.stringify(segment));
    write_seg(segment);
  }
}

function compile_ctor(segments) {
  $start();
  $line('return function(bindings) {');
  $line("'use strict';");
  size_of(segments);
  $line('var buf = Buffer.alloc(buffersize);');
  $line('var offset = 0;');
  emit_write(segments);
  $line('return buf;');
  $line('}'); // end function

  return new Function('write_int', 'write_float', 'Buffer',
                      $result())(write_int, write_float, Buffer);
}

module.exports.compile_pattern = compile_pattern;
module.exports.compile = function() {
  var str = [].join.call(arguments, ',');
  var p = parse(str);
  return compile_pattern(p);
};
module.exports.compile_builder = function() {
  var str = [].join.call(arguments, ',');
  var p = parse(str);
  return compile_ctor(p);
};


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/constructor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// -*- js-indent-level: 2 -*-

// Constructors given patterns



var ints = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js");
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);

// Interpret the pattern, writing values into a buffer
function write(buf, offset, pattern, bindings) {
  for (var i=0, len = pattern.length; i < len; i++) {
    var segment = pattern[i];
    switch (segment.type) {
    case 'string':
      offset += buf.write(segment.value, offset, 'utf8');
      break;
    case 'binary':
      offset += writeBinary(segment, buf, offset, bindings);
      break;
    case 'integer':
      offset += writeInteger(segment, buf, offset, bindings);
      break;
    case 'float':
      offset += writeFloat(segment, buf, offset, bindings);
      break;
    }
  }
  return offset;
}

function build(pattern, bindings) {
  var bufsize = size_of(pattern, bindings);
  var buf = Buffer.alloc(bufsize);
  write(buf, 0, pattern, bindings);
  return buf;
}

// In bytes
function size_of_segment(segment, bindings) {
  // size refers to a variable
  if (typeof segment.size === 'string') {
    return (bindings[segment.size] * segment.unit) / 8;
  }
  if (segment.type === 'string') {
    return Buffer.byteLength(segment.value, 'utf8');
  }
  if (segment.type === 'binary' && segment.size === true) {
    var val = bindings[segment.name];
    return val.length;
  }
  return (segment.size * segment.unit) / 8;
}

// size of the to-be-constructed binary, in bytes
function size_of(segments, bindings) {
  var size = 0;
  for (var i=0, len = segments.length; i < len; i++) {
    size += size_of_segment(segments[i], bindings);
  }
  return size;
}

function writeBinary(segment, buf, offset, bindings) {
  var bin = bindings[segment.name];
  var size = size_of_segment(segment, bindings);
  bin.copy(buf, offset, 0, size);
  return size;
}

// TODO in ff might use the noAssert argument to Buffer.write*() but
// need to check that it does the right thing wrt little-endian

function writeInteger(segment, buf, offset, bindings) {
  var value = (segment.name) ? bindings[segment.name] : segment.value;
  var size = size_of_segment(segment, bindings);
  return write_int(buf, value, offset, size, segment.bigendian);
}

function write_int(buf, value, offset, size, bigendian) {
  switch (size) {
  case 1:
    buf.writeUInt8(value, offset);
    break;
  case 2:
    (bigendian) ?
      buf.writeUInt16BE(value, offset) :
      buf.writeUInt16LE(value, offset);
    break;
  case 4:
    (bigendian) ?
      buf.writeUInt32BE(value, offset) :
      buf.writeUInt32LE(value, offset);
    break;
  case 8:
    (bigendian) ?
      ints.writeUInt64BE(buf, value, offset) :
      ints.writeUInt64LE(buf, value, offset);
    break;
  default:
    throw new Error("integer size * unit must be 8, 16, 32 or 64");
  }
  return size;
}

function writeFloat(segment, buf, offset, bindings) {
  var value = (segment.name) ? bindings[segment.name] : segment.value;
  var size = size_of_segment(segment, bindings);
  return write_float(buf, value, offset, size, segment.bigendian);
}

function write_float(buf, value, offset, size, bigendian) {
  if (size === 4) {
    (bigendian) ?
      buf.writeFloatBE(value, offset) :
      buf.writeFloatLE(value, offset);
  }
  else if (size === 8) {
    (bigendian) ?
      buf.writeDoubleBE(value, offset) :
      buf.writeDoubleLE(value, offset);
  }
  else {
    throw new Error("float size * unit must be 32 or 64");
  }
  return size;
}

var parse = (__webpack_require__(/*! ./parse */ "./node_modules/@acuminous/bitsyntax/lib/parse.js").parse);

module.exports.write = write;
module.exports.build = build;
module.exports.write_int = write_int;
module.exports.write_float = write_float;

module.exports.builder = function(pstr) {
  pstr = (arguments.length > 1) ? [].join.call(arguments, ',') : pstr;
  var pattern = parse(pstr);
  return function(vars) {
    return build(pattern, vars);
  };
};


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/interp.js":
/*!*********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/interp.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// -*- js-indent: 2 -*-
// Interpreter for bit syntax AST.
// Grammar:
//
// pattern   := segment ("," segment)*
// segment   := (value | var) (":" size)? ("/" specifier ("-" specifier)*)? | string
// var       := "_" | identifier
// size      := integer | var
// specifier := "little" | "big" | "signed" | "unsigned" | "unit" ":" 0..256 | type
// type      := "integer" | "binary" | "float"
//
// where integer has the obvious meaning, and identifier is anything
// other than "_" that fits the JavaScript identifier specification.
//

// We'll use an object to represent each segment, and an array of
// segments for a pattern. We won't try to optimise for groups of
// patterns; we'll just step through each to see if it works. We rely
// a hypothetical prior step to check that it's a valid pattern.

// ? compile to intermediate instructions ?

// A segment looks like
// {
//    type: string, // 'string' is special case
//    size: integer | true, // true means 'all remaining'
//    name: string | null, // (may be '_')
//    value: value | null, // either name OR value
//    unit: integer,
//    signed: boolean,
//    bigendian: boolean
// }



var ints    = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js"),
    debug   = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('bitsyntax-Interpreter');

function parse_int(bin, off, sizeInBytes, bigendian, signed) {
  switch (sizeInBytes) {
  case 1:
    return (signed) ? bin.readInt8(off) : bin.readUInt8(off);
  case 2:
    return (bigendian) ?
      (signed) ? bin.readInt16BE(off) : bin.readUInt16BE(off) :
      (signed) ? bin.readInt16LE(off) : bin.readUInt16LE(off);
  case 4:
    return (bigendian) ?
      (signed) ? bin.readInt32BE(off) : bin.readUInt32BE(off) :
      (signed) ? bin.readInt32LE(off) : bin.readUInt32LE(off);
  case 8:
    return (bigendian) ?
      ((signed) ? ints.readInt64BE : ints.readUInt64BE)(bin, off) :
      ((signed) ? ints.readInt64LE : ints.readUInt64LE)(bin, off);
  default:
    throw "Integers must be 8-, 16-, 32- or 64-bit";
  }
}

function parse_float(bin, off, sizeInBytes, bigendian) {
  switch (sizeInBytes) {
  case 4:
    return (bigendian) ? bin.readFloatBE(off) : bin.readFloatLE(off);
  case 8:
    return (bigendian) ? bin.readDoubleBE(off) : bin.readDoubleLE(off);
  default:
    throw "Floats must be 32- or 64-bit";
  }
}

function size_of(segment, bound) {
  var size = segment.size;
  if (typeof size === 'string') {
    return bound[size];
  }
  else {
    return size;
  }
}

function new_scope(env) {
  function scope() {};
  scope.prototype = env;
  return new scope();
}

function bindings(scope) {
  var s = {};
  for (var k in scope) {
    if (scope.hasOwnProperty(k)) {
      s[k] = scope[k];
    }
  }
  return s;
}

function match(pattern, binary, boundvars) {
  var offset = 0, vars = new_scope(boundvars);
  var binsize = binary.length * 8;

  function skip_bits(segment) {
    debug("skip bits"); debug(segment);
    var size = size_of(segment, vars);
    if (size === true) {
      if (offset % 8 === 0) {
        offset = binsize;
        return true;
      }
      else {
        return false;
      }
    }

    var bits = segment.unit * size;
    if (offset + bits > binsize) {
      return false;
    }
    else {
      offset += bits;
    }
  }

  function get_integer(segment) {
    debug("get_integer"); debug(segment);
    // let's do only multiples of eight bits for now
    var unit = segment.unit, size = size_of(segment, vars);
    var bitsize = size * unit;
    var byteoffset = offset / 8; // NB assumes aligned
    offset += bitsize;
    if (bitsize % 8 > 0 || (offset > binsize)) {
      return false;
    }
    else {
      return parse_int(binary, byteoffset, bitsize / 8,
                       segment.bigendian, segment.signed);
    }
  }

  function get_float(segment) {
    debug("get_float"); debug(segment);
    var unit = segment.unit; var size = size_of(segment, vars);
    var bitsize = size * unit;
    var byteoffset = offset / 8; // assume aligned
    offset += bitsize;
    if (offset > binsize) {
      return false;
    }
    else {
      return parse_float(binary, byteoffset,
                         bitsize / 8, segment.bigendian);
    }
  }

  function get_binary(segment) {
    debug("get_binary"); debug(segment);
    var unit = segment.unit, size = size_of(segment, vars);
    var byteoffset = offset / 8; // NB alignment

    if (size === true) {
      offset = binsize;
      return binary.slice(byteoffset);
    }
    else {
      var bitsize = size * unit;
      if (bitsize % 8 > 0 || (offset + bitsize) > binsize) {
        return false;
      }
      else {
        offset += bitsize;
        return binary.slice(byteoffset, byteoffset + bitsize / 8);
      }
    }
  }

  function get_string(segment) {
    debug("get_string"); debug(segment);
    var len = segment.value.length;
    var byteoffset = offset / 8;

    offset += len * 8;
    if (offset > binsize) {
      return false;
    }
    // FIXME bytes vs UTF8 characters
    return binary.slice(byteoffset, byteoffset + len).toString('utf8');
  }

  var patternlen = pattern.length;
  for (var i = 0;  i < patternlen; i++) {
    var segment = pattern[i];
    var result = false;
    if (segment.name === '_') {
      result = skip_bits(segment);
    }
    else {
      switch (segment.type) {
      case 'string':
        result = get_string(segment);
        break;
      case 'integer':
        result = get_integer(segment);
        break;
      case 'float':
        result = get_float(segment);
        break;
      case 'binary':
        result = get_binary(segment);
        break;
      }

      if (result === false) {
        return false;
      }
      else if (segment.name) {
        vars[segment.name] = result;
      }
      else if (segment.value != result) {
        return false;
      }
    }
  }
  if (offset == binsize) {
    return bindings(vars);
  }
  else {
    return false;
  }
}

module.exports.match = match;
module.exports.parse_int = parse_int;
module.exports.parse_float = parse_float;


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/parse.js":
/*!********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/parse.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parse patterns in string form into the form we use for interpreting
// (and later, for compiling).



var ast = __webpack_require__(/*! ./pattern */ "./node_modules/@acuminous/bitsyntax/lib/pattern.js");
var parser = __webpack_require__(/*! ./parser */ "./node_modules/@acuminous/bitsyntax/lib/parser.js");

function parse_pattern(string) {
  var segments = parser.parse(string);
  for (var i=0, len = segments.length; i < len; i++) {
    var s = segments[i];
    if (s.string != undefined) {
      segments[i] = ast.string(s.string);
    }
    else if (s.value != undefined) {
      segments[i] = ast.value(s.value, s.size, s.specifiers);
    }
    else if (s.name != undefined) {
      segments[i] = ast.variable(s.name, s.size, s.specifiers);
    }
    else {
      throw "Unknown segment " + s;
    }
  }
  return segments;
}

module.exports.parse = function() {
  var str = [].join.call(arguments, ',');
  return parse_pattern(str);
};


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/parser.js ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "segmentTail": parse_segmentTail,
        "segment": parse_segment,
        "string": parse_string,
        "chars": parse_chars,
        "char": parse_char,
        "hexDigit": parse_hexDigit,
        "identifier": parse_identifier,
        "number": parse_number,
        "size": parse_size,
        "specifierList": parse_specifierList,
        "specifierTail": parse_specifierTail,
        "specifier": parse_specifier,
        "unit": parse_unit,
        "ws": parse_ws
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ws();
        if (result0 !== null) {
          result1 = parse_segment();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_segmentTail();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_segmentTail();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segmentTail() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ws();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_ws();
            if (result2 !== null) {
              result3 = parse_segment();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, seg) { return seg; })(pos0, result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_string();
        if (result0 !== null) {
          result0 = (function(offset, str) { return {string: str}; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_identifier();
          if (result0 !== null) {
            result1 = parse_size();
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result2 = parse_specifierList();
              result2 = result2 !== null ? result2 : "";
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, v, size, specs) { return {name: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_number();
            if (result0 !== null) {
              result1 = parse_size();
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                result2 = parse_specifierList();
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, v, size, specs) { return {value: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_string() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 34) {
            result1 = "\"";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "";    })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 34) {
            result0 = "\"";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_chars();
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 34) {
                result2 = "\"";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, chars) { return chars; })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_chars() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_char();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_char();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_char() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        if (/^[^"\\\0-\x1F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\"\\\\\\0-\\x1F]");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 2) === "\\\"") {
            result0 = "\\\"";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\\\"\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return '"';  })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 2) === "\\\\") {
              result0 = "\\\\";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\\\\\\\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) { return "\\"; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 2) === "\\/") {
                result0 = "\\/";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\/\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) { return "/";  })(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 2) === "\\b") {
                  result0 = "\\b";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\\b\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) { return "\b"; })(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  if (input.substr(pos, 2) === "\\f") {
                    result0 = "\\f";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\\f\"");
                    }
                  }
                  if (result0 !== null) {
                    result0 = (function(offset) { return "\f"; })(pos0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                  if (result0 === null) {
                    pos0 = pos;
                    if (input.substr(pos, 2) === "\\n") {
                      result0 = "\\n";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\\n\"");
                      }
                    }
                    if (result0 !== null) {
                      result0 = (function(offset) { return "\n"; })(pos0);
                    }
                    if (result0 === null) {
                      pos = pos0;
                    }
                    if (result0 === null) {
                      pos0 = pos;
                      if (input.substr(pos, 2) === "\\r") {
                        result0 = "\\r";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\\r\"");
                        }
                      }
                      if (result0 !== null) {
                        result0 = (function(offset) { return "\r"; })(pos0);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                      if (result0 === null) {
                        pos0 = pos;
                        if (input.substr(pos, 2) === "\\t") {
                          result0 = "\\t";
                          pos += 2;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\t\"");
                          }
                        }
                        if (result0 !== null) {
                          result0 = (function(offset) { return "\t"; })(pos0);
                        }
                        if (result0 === null) {
                          pos = pos0;
                        }
                        if (result0 === null) {
                          pos0 = pos;
                          pos1 = pos;
                          if (input.substr(pos, 2) === "\\u") {
                            result0 = "\\u";
                            pos += 2;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\\u\"");
                            }
                          }
                          if (result0 !== null) {
                            result1 = parse_hexDigit();
                            if (result1 !== null) {
                              result2 = parse_hexDigit();
                              if (result2 !== null) {
                                result3 = parse_hexDigit();
                                if (result3 !== null) {
                                  result4 = parse_hexDigit();
                                  if (result4 !== null) {
                                    result0 = [result0, result1, result2, result3, result4];
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                          if (result0 !== null) {
                            result0 = (function(offset, h1, h2, h3, h4) {
                                return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                              })(pos0, result0[1], result0[2], result0[3], result0[4]);
                          }
                          if (result0 === null) {
                            pos = pos0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_hexDigit() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[_a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[_a-zA-Z]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[_a-zA-Z0-9]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[_a-zA-Z0-9]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) { return head + tail.join(''); })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return 0; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, head, tail) { return parseInt(head + tail.join('')); })(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_size() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_number();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, num) { return num; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result0 = ":";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_identifier();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, id) { return id; })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_specifierList() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_specifier();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_specifierTail();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_specifierTail();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_specifierTail() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_specifier();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, spec) { return spec; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_specifier() {
        var result0;
        
        if (input.substr(pos, 6) === "little") {
          result0 = "little";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"little\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 3) === "big") {
            result0 = "big";
            pos += 3;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"big\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 6) === "signed") {
              result0 = "signed";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"signed\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 8) === "unsigned") {
                result0 = "unsigned";
                pos += 8;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"unsigned\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 7) === "integer") {
                  result0 = "integer";
                  pos += 7;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"integer\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 6) === "binary") {
                    result0 = "binary";
                    pos += 6;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"binary\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 5) === "float") {
                      result0 = "float";
                      pos += 5;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"float\"");
                      }
                    }
                    if (result0 === null) {
                      result0 = parse_unit();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_unit() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5) === "unit:") {
          result0 = "unit:";
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"unit:\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_number();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, num) { return 'unit:' + num; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ws() {
        var result0, result1;
        
        result0 = [];
        if (/^[ \t\n]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[ \\t\\n]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[ \t\n]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[ \\t\\n]");
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/pattern.js":
/*!**********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/pattern.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
// -*- js-indent-level: 2 -*-
// Constructing patterns



function set(values) {
  var s = {};
  for (var i in values) {
    if (!Object.prototype.hasOwnProperty.call(values, i)) continue;
    s[values[i]] = 1;
  }
  return s;
}

// Construct a segment bound to a variable, e.g., from a segment like
// "Len:32/unsigned-big". `specifiers0` is an array.
function variable(name, size, specifiers0) {
  var specifiers = set(specifiers0);
  var segment = {name: name};
  segment.type = type_in(specifiers);
  specs(segment, segment.type, specifiers);
  segment.size = size_of(segment, segment.type, size, segment.unit);
  return segment;
}

module.exports.variable = variable;
module.exports.rest = function() {
  return variable('_', true, ['binary']);
}

// Construct a segment with a literal value, e.g., from a segment like
// "206". `specifiers0` is an array.

function value(val, size, specifiers0) {
  var specifiers = set(specifiers0);
  var segment = {value: val};
  segment.type = type_in(specifiers);
  // TODO check type v. value ..
  specs(segment, segment.type, specifiers);
  segment.size = size_of(segment, segment.type, size, segment.unit);
  return segment;
}

module.exports.value = value;

// A string can appear as a literal, but it must appear without
// specifiers.
function string(val) {
  return {value: val, type: 'string'};
}
module.exports.string = string;

var TYPES = {'integer': 1, 'binary': 1, 'float': 1};
function type_in(specifiers) {
  for (var t in specifiers) {
    if (!Object.prototype.hasOwnProperty.call(specifiers, t)) continue;
    if (TYPES[t]) { return t; }
  }
  return 'integer';
}

function specs(segment, type, specifiers) {
  switch (type) {
  case 'integer':
    segment.signed = signed_in(specifiers);
    // fall through
  case 'float':
    segment.bigendian = endian_in(specifiers);
    // fall through
  default:
    segment.unit = unit_in(specifiers, segment.type);
  }
  return segment;
}

function endian_in(specifiers) {
  // default is big, but I have chosen true = bigendian
  return !specifiers['little'];
}

function signed_in(specifiers) {
  // this time I got it right; default is unsigned
  return specifiers['signed'];
}

function unit_in(specifiers, type) {
  for (var s in specifiers) {
    if (!Object.prototype.hasOwnProperty.call(specifiers, s)) continue;
    if (s.substr(0, 5) == 'unit:') {
      var unit = parseInt(s.substr(5));
      // TODO check sane for type
      return unit;
    }
  }
  // OK defaults then
  switch (type) {
  case 'binary':
    return 8;
  case 'integer':
  case 'float':
    return 1;
  }
}

function size_of(segment, type, size, unit) {
  if (size !== undefined && size !== '') {
    return size;
  }
  else {
    switch (type) {
    case 'integer':
      return 8;
    case 'float':
      return 64;
    case 'binary':
      return true;
    }
  }
}


/***/ }),

/***/ "./node_modules/@octokit/auth-token/dist-web/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@octokit/auth-token/dist-web/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTokenAuth": () => (/* binding */ createTokenAuth)
/* harmony export */ });
const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) ||
        REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp
        ? "app"
        : isInstallation
            ? "installation"
            : isUserToServer
                ? "user-to-server"
                : "oauth";
    return {
        type: "token",
        token: token,
        tokenType,
    };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
    }
    return `token ${token}`;
}

async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
    if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token),
    });
};


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/core/dist-web/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@octokit/core/dist-web/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Octokit": () => (/* binding */ Octokit)
/* harmony export */ });
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");
/* harmony import */ var before_after_hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! before-after-hook */ "./node_modules/before-after-hook/index.js");
/* harmony import */ var before_after_hook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(before_after_hook__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _octokit_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @octokit/request */ "./node_modules/@octokit/request/dist-web/index.js");
/* harmony import */ var _octokit_graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/graphql */ "./node_modules/@octokit/graphql/dist-web/index.js");
/* harmony import */ var _octokit_auth_token__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @octokit/auth-token */ "./node_modules/@octokit/auth-token/dist-web/index.js");






const VERSION = "3.6.0";

class Octokit {
    constructor(options = {}) {
        const hook = new before_after_hook__WEBPACK_IMPORTED_MODULE_0__.Collection();
        const requestDefaults = {
            baseUrl: _octokit_request__WEBPACK_IMPORTED_MODULE_1__.request.endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
                // @ts-ignore internal usage only, no need to type
                hook: hook.bind(null, "request"),
            }),
            mediaType: {
                previews: [],
                format: "",
            },
        };
        // prepend default user agent with `options.userAgent` if set
        requestDefaults.headers["user-agent"] = [
            options.userAgent,
            `octokit-core.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_2__.getUserAgent)()}`,
        ]
            .filter(Boolean)
            .join(" ");
        if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = _octokit_request__WEBPACK_IMPORTED_MODULE_1__.request.defaults(requestDefaults);
        this.graphql = (0,_octokit_graphql__WEBPACK_IMPORTED_MODULE_3__.withCustomRequest)(this.request).defaults(requestDefaults);
        this.log = Object.assign({
            debug: () => { },
            info: () => { },
            warn: console.warn.bind(console),
            error: console.error.bind(console),
        }, options.log);
        this.hook = hook;
        // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
        //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
        // (2) If only `options.auth` is set, use the default token authentication strategy.
        // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
        // TODO: type `options.auth` based on `options.authStrategy`.
        if (!options.authStrategy) {
            if (!options.auth) {
                // (1)
                this.auth = async () => ({
                    type: "unauthenticated",
                });
            }
            else {
                // (2)
                const auth = (0,_octokit_auth_token__WEBPACK_IMPORTED_MODULE_4__.createTokenAuth)(options.auth);
                // @ts-ignore  ¯\_(ツ)_/¯
                hook.wrap("request", auth.hook);
                this.auth = auth;
            }
        }
        else {
            const { authStrategy, ...otherOptions } = options;
            const auth = authStrategy(Object.assign({
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions,
            }, options.auth));
            // @ts-ignore  ¯\_(ツ)_/¯
            hook.wrap("request", auth.hook);
            this.auth = auth;
        }
        // apply plugins
        // https://stackoverflow.com/a/16345172
        const classConstructor = this.constructor;
        classConstructor.plugins.forEach((plugin) => {
            Object.assign(this, plugin(this, options));
        });
    }
    static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
            constructor(...args) {
                const options = args[0] || {};
                if (typeof defaults === "function") {
                    super(defaults(options));
                    return;
                }
                super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent
                    ? {
                        userAgent: `${options.userAgent} ${defaults.userAgent}`,
                    }
                    : null));
            }
        };
        return OctokitWithDefaults;
    }
    /**
     * Attach a plugin (or many) to your Octokit instance.
     *
     * @example
     * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
     */
    static plugin(...newPlugins) {
        var _a;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a = class extends this {
            },
            _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))),
            _a);
        return NewOctokit;
    }
}
Octokit.VERSION = VERSION;
Octokit.plugins = [];


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/endpoint/dist-web/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@octokit/endpoint/dist-web/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "endpoint": () => (/* binding */ endpoint)
/* harmony export */ });
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "./node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");



function lowercaseKeys(object) {
    if (!object) {
        return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
    }, {});
}

function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(options[key])) {
            if (!(key in defaults))
                Object.assign(result, { [key]: options[key] });
            else
                result[key] = mergeDeep(defaults[key], options[key]);
        }
        else {
            Object.assign(result, { [key]: options[key] });
        }
    });
    return result;
}

function removeUndefinedProperties(obj) {
    for (const key in obj) {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    }
    return obj;
}

function merge(defaults, route, options) {
    if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? { method, url } : { url: method }, options);
    }
    else {
        options = Object.assign({}, route);
    }
    // lowercase header names before merging with defaults to avoid duplicates
    options.headers = lowercaseKeys(options.headers);
    // remove properties with undefined values before merging
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    // mediaType.previews arrays are merged, instead of overwritten
    if (defaults && defaults.mediaType.previews.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews
            .filter((preview) => !mergedOptions.mediaType.previews.includes(preview))
            .concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
    return mergedOptions;
}

function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
        return url;
    }
    return (url +
        separator +
        names
            .map((name) => {
            if (name === "q") {
                return ("q=" + parameters.q.split("+").map(encodeURIComponent).join("+"));
            }
            return `${name}=${encodeURIComponent(parameters[name])}`;
        })
            .join("&"));
}

const urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
        return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
    return Object.keys(object)
        .filter((option) => !keysToOmit.includes(option))
        .reduce((obj, key) => {
        obj[key] = object[key];
        return obj;
    }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/* istanbul ignore file */
function encodeReserved(str) {
    return str
        .split(/(%[0-9A-Fa-f]{2})/g)
        .map(function (part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
    })
        .join("");
}
function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
function encodeValue(operator, value, key) {
    value =
        operator === "+" || operator === "#"
            ? encodeReserved(value)
            : encodeUnreserved(value);
    if (key) {
        return encodeUnreserved(key) + "=" + value;
    }
    else {
        return value;
    }
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
        if (typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
                value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        }
        else {
            if (modifier === "*") {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                    });
                }
                else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            }
            else {
                const tmp = [];
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        tmp.push(encodeValue(operator, value));
                    });
                }
                else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeUnreserved(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }
                if (isKeyOperator(operator)) {
                    result.push(encodeUnreserved(key) + "=" + tmp.join(","));
                }
                else if (tmp.length !== 0) {
                    result.push(tmp.join(","));
                }
            }
        }
    }
    else {
        if (operator === ";") {
            if (isDefined(value)) {
                result.push(encodeUnreserved(key));
            }
        }
        else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(encodeUnreserved(key) + "=");
        }
        else if (value === "") {
            result.push("");
        }
    }
    return result;
}
function parseUrl(template) {
    return {
        expand: expand.bind(null, template),
    };
}
function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
        if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function (variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
                var separator = ",";
                if (operator === "?") {
                    separator = "&";
                }
                else if (operator !== "#") {
                    separator = operator;
                }
                return (values.length !== 0 ? operator : "") + values.join(separator);
            }
            else {
                return values.join(",");
            }
        }
        else {
            return encodeReserved(literal);
        }
    });
}

function parse(options) {
    // https://fetch.spec.whatwg.org/#methods
    let method = options.method.toUpperCase();
    // replace :varname with {varname} to make it RFC 6570 compatible
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType",
    ]);
    // extract variable names from URL to calculate remaining variables later
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
        url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options)
        .filter((option) => urlVariableNames.includes(option))
        .concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
        if (options.mediaType.format) {
            // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
            headers.accept = headers.accept
                .split(/,/)
                .map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`))
                .join(",");
        }
        if (options.mediaType.previews.length) {
            const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
            headers.accept = previewsFromAcceptHeader
                .concat(options.mediaType.previews)
                .map((preview) => {
                const format = options.mediaType.format
                    ? `.${options.mediaType.format}`
                    : "+json";
                return `application/vnd.github.${preview}-preview${format}`;
            })
                .join(",");
        }
    }
    // for GET/HEAD requests, set URL query parameters from remaining parameters
    // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters
    if (["GET", "HEAD"].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
    }
    else {
        if ("data" in remainingParameters) {
            body = remainingParameters.data;
        }
        else {
            if (Object.keys(remainingParameters).length) {
                body = remainingParameters;
            }
            else {
                headers["content-length"] = 0;
            }
        }
    }
    // default content-type for JSON if body is set
    if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
    }
    // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
    // fetch does not allow to set `content-length` header, but we can set body to an empty string
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
    }
    // Only return body/request keys if present
    return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}

function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS = merge(oldDefaults, newDefaults);
    const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
    return Object.assign(endpoint, {
        DEFAULTS,
        defaults: withDefaults.bind(null, DEFAULTS),
        merge: merge.bind(null, DEFAULTS),
        parse,
    });
}

const VERSION = "6.0.12";

const userAgent = `octokit-endpoint.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_1__.getUserAgent)()}`;
// DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.
const DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent,
    },
    mediaType: {
        format: "",
        previews: [],
    },
};

const endpoint = withDefaults(null, DEFAULTS);


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/graphql/dist-web/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@octokit/graphql/dist-web/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphqlResponseError": () => (/* binding */ GraphqlResponseError),
/* harmony export */   "graphql": () => (/* binding */ graphql$1),
/* harmony export */   "withCustomRequest": () => (/* binding */ withCustomRequest)
/* harmony export */ });
/* harmony import */ var _octokit_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @octokit/request */ "./node_modules/@octokit/request/dist-web/index.js");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");



const VERSION = "4.8.0";

function _buildMessageForResponseErrors(data) {
    return (`Request failed due to following response errors:\n` +
        data.errors.map((e) => ` - ${e.message}`).join("\n"));
}
class GraphqlResponseError extends Error {
    constructor(request, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        // Expose the errors and response data in their shorthand properties.
        this.errors = response.errors;
        this.data = response.data;
        // Maintains proper stack trace (only available on V8)
        /* istanbul ignore next */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}

const NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType",
];
const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
    if (options) {
        if (typeof query === "string" && "query" in options) {
            return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for (const key in options) {
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
                continue;
            return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
        }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS.includes(key)) {
            result[key] = parsedOptions[key];
            return result;
        }
        if (!result.variables) {
            result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
    }, {});
    // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
    // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451
    const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request(requestOptions).then((response) => {
        if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)) {
                headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(requestOptions, headers, response.data);
        }
        return response.data.data;
    });
}

function withDefaults(request$1, newDefaults) {
    const newRequest = request$1.defaults(newDefaults);
    const newApi = (query, options) => {
        return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: _octokit_request__WEBPACK_IMPORTED_MODULE_0__.request.endpoint,
    });
}

const graphql$1 = withDefaults(_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request, {
    headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_1__.getUserAgent)()}`,
    },
    method: "POST",
    url: "/graphql",
});
function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql",
    });
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "composePaginateRest": () => (/* binding */ composePaginateRest),
/* harmony export */   "isPaginatingEndpoint": () => (/* binding */ isPaginatingEndpoint),
/* harmony export */   "paginateRest": () => (/* binding */ paginateRest),
/* harmony export */   "paginatingEndpoints": () => (/* binding */ paginatingEndpoints)
/* harmony export */ });
const VERSION = "2.21.3";

/**
 * Some “list” response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
    // endpoints can respond with 204 if repository is empty
    if (!response.data) {
        return {
            ...response,
            data: [],
        };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization)
        return response;
    // keep the additional properties intact as there is currently no other way
    // to retrieve the same information.
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
}

function iterator(octokit, route, parameters) {
    const options = typeof route === "function"
        ? route.endpoint(parameters)
        : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
        [Symbol.asyncIterator]: () => ({
            async next() {
                if (!url)
                    return { done: true };
                try {
                    const response = await requestMethod({ method, url, headers });
                    const normalizedResponse = normalizePaginatedListResponse(response);
                    // `response.headers.link` format:
                    // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
                    // sets `url` to undefined if "next" URL is not present or `link` header is not set
                    url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
                    return { value: normalizedResponse };
                }
                catch (error) {
                    if (error.status !== 409)
                        throw error;
                    url = "";
                    return {
                        value: {
                            status: 200,
                            headers: {},
                            data: [],
                        },
                    };
                }
            },
        }),
    };
}

function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = undefined;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator, mapFn) {
    return iterator.next().then((result) => {
        if (result.done) {
            return results;
        }
        let earlyExit = false;
        function done() {
            earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
            return results;
        }
        return gather(octokit, results, iterator, mapFn);
    });
}

const composePaginateRest = Object.assign(paginate, {
    iterator,
});

const paginatingEndpoints = [
    "GET /app/hook/deliveries",
    "GET /app/installations",
    "GET /applications/grants",
    "GET /authorizations",
    "GET /enterprises/{enterprise}/actions/permissions/organizations",
    "GET /enterprises/{enterprise}/actions/runner-groups",
    "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations",
    "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners",
    "GET /enterprises/{enterprise}/actions/runners",
    "GET /enterprises/{enterprise}/audit-log",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /enterprises/{enterprise}/settings/billing/advanced-security",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runner-groups",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/audit-log",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/credential-authorizations",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/external-groups",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/settings/billing/advanced-security",
    "GET /orgs/{org}/team-sync/groups",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/git/matching-refs/{ref}",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions",
];

function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
    }
    else {
        return false;
    }
}

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */
function paginateRest(octokit) {
    return {
        paginate: Object.assign(paginate.bind(null, octokit), {
            iterator: iterator.bind(null, octokit),
        }),
    };
}
paginateRest.VERSION = VERSION;


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "legacyRestEndpointMethods": () => (/* binding */ legacyRestEndpointMethods),
/* harmony export */   "restEndpointMethods": () => (/* binding */ restEndpointMethods)
/* harmony export */ });
const Endpoints = {
    actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
        ],
        approveWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve",
        ],
        cancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel",
        ],
        createOrUpdateEnvironmentSecret: [
            "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}",
        ],
        createRegistrationTokenForOrg: [
            "POST /orgs/{org}/actions/runners/registration-token",
        ],
        createRegistrationTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/registration-token",
        ],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/remove-token",
        ],
        createWorkflowDispatch: [
            "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
        ],
        deleteActionsCacheById: [
            "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}",
        ],
        deleteActionsCacheByKey: [
            "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}",
        ],
        deleteArtifact: [
            "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
        ],
        deleteEnvironmentSecret: [
            "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}",
        ],
        deleteSelfHostedRunnerFromOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}",
        ],
        deleteSelfHostedRunnerFromRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}",
        ],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
            "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}",
        ],
        disableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable",
        ],
        downloadArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}",
        ],
        downloadJobLogsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs",
        ],
        downloadWorkflowRunAttemptLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs",
        ],
        downloadWorkflowRunLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}",
        ],
        enableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable",
        ],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: [
            "GET /orgs/{org}/actions/cache/usage-by-repository",
        ],
        getActionsCacheUsageForEnterprise: [
            "GET /enterprises/{enterprise}/actions/cache/usage",
        ],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/selected-actions",
        ],
        getAllowedActionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/selected-actions",
        ],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getEnvironmentPublicKey: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key",
        ],
        getEnvironmentSecret: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        getGithubActionsDefaultWorkflowPermissionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions/workflow",
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions/workflow",
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/workflow",
        ],
        getGithubActionsPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions",
        ],
        getGithubActionsPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions",
        ],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getPendingDeploymentsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
        ],
        getRepoPermissions: [
            "GET /repos/{owner}/{repo}/actions/permissions",
            {},
            { renamed: ["actions", "getGithubActionsPermissionsRepository"] },
        ],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getReviewsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals",
        ],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}",
        ],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/access",
        ],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}",
        ],
        getWorkflowRunUsage: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing",
        ],
        getWorkflowUsage: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing",
        ],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
        ],
        listJobsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
        ],
        listJobsForWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
        ],
        listLabelsForSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        listLabelsForSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/downloads",
        ],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/repositories",
        ],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
        ],
        listWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
        ],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun",
        ],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}",
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
        ],
        reviewPendingDeploymentsForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
        ],
        setAllowedActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/selected-actions",
        ],
        setAllowedActionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions",
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
            "PUT /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
            "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        setGithubActionsDefaultWorkflowPermissionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/workflow",
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/workflow",
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/workflow",
        ],
        setGithubActionsPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions",
        ],
        setGithubActionsPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories",
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories",
        ],
        setWorkflowAccessToRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/access",
        ],
    },
    activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: [
            "DELETE /notifications/threads/{thread_id}/subscription",
        ],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: [
            "GET /notifications/threads/{thread_id}/subscription",
        ],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: [
            "GET /users/{username}/events/orgs/{org}",
        ],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: [
            "GET /users/{username}/received_events/public",
        ],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/notifications",
        ],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: [
            "PUT /notifications/threads/{thread_id}/subscription",
        ],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"],
    },
    apps: {
        addRepoToInstallation: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
        ],
        addRepoToInstallationForAuthenticatedUser: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        ],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: [
            "POST /app/installations/{installation_id}/access_tokens",
        ],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: [
            "GET /marketplace_listing/accounts/{account_id}",
        ],
        getSubscriptionPlanForAccountStubbed: [
            "GET /marketplace_listing/stubbed/accounts/{account_id}",
        ],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: [
            "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
        ],
        listInstallationReposForAuthenticatedUser: [
            "GET /user/installations/{installation_id}/repositories",
        ],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: [
            "GET /user/marketplace_purchases/stubbed",
        ],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: [
            "POST /app/hook/deliveries/{delivery_id}/attempts",
        ],
        removeRepoFromInstallation: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] },
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        ],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: [
            "DELETE /app/installations/{installation_id}/suspended",
        ],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"],
    },
    billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: [
            "GET /users/{username}/settings/billing/actions",
        ],
        getGithubAdvancedSecurityBillingGhe: [
            "GET /enterprises/{enterprise}/settings/billing/advanced-security",
        ],
        getGithubAdvancedSecurityBillingOrg: [
            "GET /orgs/{org}/settings/billing/advanced-security",
        ],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: [
            "GET /users/{username}/settings/billing/packages",
        ],
        getSharedStorageBillingOrg: [
            "GET /orgs/{org}/settings/billing/shared-storage",
        ],
        getSharedStorageBillingUser: [
            "GET /users/{username}/settings/billing/shared-storage",
        ],
    },
    checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
        ],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
        ],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: [
            "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest",
        ],
        rerequestSuite: [
            "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest",
        ],
        setSuitesPreferences: [
            "PATCH /repos/{owner}/{repo}/check-suites/preferences",
        ],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    },
    codeScanning: {
        deleteAnalysis: [
            "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}",
        ],
        getAlert: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
            {},
            { renamedParameters: { alert_id: "alert_number" } },
        ],
        getAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}",
        ],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
            {},
            { renamed: ["codeScanning", "listAlertInstances"] },
        ],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        ],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
    },
    codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"],
    },
    codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        codespaceMachinesForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/machines",
        ],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        createOrUpdateSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}",
        ],
        createWithPrForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces",
        ],
        createWithRepoForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/codespaces",
        ],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: [
            "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}",
        ],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        deleteSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}",
        ],
        exportForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/exports",
        ],
        getExportDetailsForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/exports/{export_id}",
        ],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getPublicKeyForAuthenticatedUser: [
            "GET /user/codespaces/secrets/public-key",
        ],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/public-key",
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        getSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}",
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/devcontainers",
        ],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: [
            "GET /orgs/{org}/codespaces",
            {},
            { renamedParameters: { org_id: "org" } },
        ],
        listInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces",
        ],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}/repositories",
        ],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        removeRepositoryForSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        repoMachinesForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/machines",
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories",
        ],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: [
            "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop",
        ],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"],
    },
    dependabot: {
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
        ],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}",
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/public-key",
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        ],
    },
    dependencyGraph: {
        createRepositorySnapshot: [
            "POST /repos/{owner}/{repo}/dependency-graph/snapshots",
        ],
        diffRange: [
            "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}",
        ],
    },
    emojis: { get: ["GET /emojis"] },
    enterpriseAdmin: {
        addCustomLabelsToSelfHostedRunnerForEnterprise: [
            "POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        disableSelectedOrganizationGithubActionsEnterprise: [
            "DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
        ],
        enableSelectedOrganizationGithubActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
        ],
        getAllowedActionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions/selected-actions",
        ],
        getGithubActionsPermissionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions",
        ],
        getServerStatistics: [
            "GET /enterprise-installation/{enterprise_or_org}/server-statistics",
        ],
        listLabelsForSelfHostedRunnerForEnterprise: [
            "GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        listSelectedOrganizationsEnabledGithubActionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions/organizations",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: [
            "DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        removeCustomLabelFromSelfHostedRunnerForEnterprise: [
            "DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}",
        ],
        setAllowedActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/selected-actions",
        ],
        setCustomLabelsForSelfHostedRunnerForEnterprise: [
            "PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        setGithubActionsPermissionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions",
        ],
        setSelectedOrganizationsEnabledGithubActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/organizations",
        ],
    },
    gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
    },
    git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
    },
    gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"],
    },
    interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: [
            "GET /user/interaction-limits",
            {},
            { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] },
        ],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: [
            "DELETE /repos/{owner}/{repo}/interaction-limits",
        ],
        removeRestrictionsForYourPublicRepos: [
            "DELETE /user/interaction-limits",
            {},
            { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] },
        ],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: [
            "PUT /user/interaction-limits",
            {},
            { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] },
        ],
    },
    issues: {
        addAssignees: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees",
        ],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
        ],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}",
        ],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: [
            "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}",
        ],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
        ],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
        ],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
        ],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels",
        ],
        removeAssignees: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees",
        ],
        removeLabel: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
        ],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: [
            "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}",
        ],
    },
    licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"],
    },
    markdown: {
        render: ["POST /markdown"],
        renderRaw: [
            "POST /markdown/raw",
            { headers: { "content-type": "text/plain; charset=utf-8" } },
        ],
    },
    meta: {
        get: ["GET /meta"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"],
    },
    migrations: {
        cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
        deleteArchiveForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/archive",
        ],
        deleteArchiveForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/archive",
        ],
        downloadArchiveForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/archive",
        ],
        getArchiveForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/archive",
        ],
        getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
        getImportStatus: ["GET /repos/{owner}/{repo}/import"],
        getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/repositories",
        ],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: [
            "GET /user/migrations/{migration_id}/repositories",
            {},
            { renamed: ["migrations", "listReposForAuthenticatedUser"] },
        ],
        mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
        setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: ["PUT /repos/{owner}/{repo}/import"],
        unlockRepoForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock",
        ],
        unlockRepoForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock",
        ],
        updateImport: ["PATCH /repos/{owner}/{repo}/import"],
    },
    orgs: {
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: [
            "PUT /orgs/{org}/outside_collaborators/{username}",
        ],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        get: ["GET /orgs/{org}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}",
        ],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomRoles: ["GET /organizations/{organization_id}/custom_roles"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
            "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
        ],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: [
            "DELETE /orgs/{org}/outside_collaborators/{username}",
        ],
        removePublicMembershipForAuthenticatedUser: [
            "DELETE /orgs/{org}/public_members/{username}",
        ],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: [
            "PUT /orgs/{org}/public_members/{username}",
        ],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: [
            "PATCH /user/memberships/orgs/{org}",
        ],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"],
    },
    packages: {
        deletePackageForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}",
        ],
        deletePackageForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}",
        ],
        deletePackageForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}",
        ],
        deletePackageVersionForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        deletePackageVersionForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        deletePackageVersionForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
            {},
            { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] },
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
            {},
            {
                renamed: [
                    "packages",
                    "getAllPackageVersionsForPackageOwnedByAuthenticatedUser",
                ],
            },
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions",
        ],
        getPackageForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}",
        ],
        getPackageForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}",
        ],
        getPackageForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}",
        ],
        getPackageVersionForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getPackageVersionForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getPackageVersionForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageVersionForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
        restorePackageVersionForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
        restorePackageVersionForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
    },
    projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: [
            "GET /projects/{project_id}/collaborators/{username}/permission",
        ],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: [
            "DELETE /projects/{project_id}/collaborators/{username}",
        ],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"],
    },
    pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
        ],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        ],
        deletePendingReview: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        deleteReviewComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}",
        ],
        dismissReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals",
        ],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
        ],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        listReviewComments: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        ],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        requestReviewers: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        submitReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events",
        ],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch",
        ],
        updateReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        updateReviewComment: [
            "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}",
        ],
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
        createForCommitComment: [
            "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        ],
        createForIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions",
        ],
        createForIssueComment: [
            "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        ],
        createForPullRequestReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        ],
        createForRelease: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/reactions",
        ],
        createForTeamDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        ],
        createForTeamDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        ],
        deleteForCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}",
        ],
        deleteForIssueComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForPullRequestComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}",
        ],
        deleteForTeamDiscussion: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}",
        ],
        deleteForTeamDiscussionComment: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
        ],
        listForCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        ],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        ],
        listForPullRequestReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        ],
        listForRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
        ],
        listForTeamDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        ],
        listForTeamDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        ],
    },
    repos: {
        acceptInvitation: [
            "PATCH /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] },
        ],
        acceptInvitationForAuthenticatedUser: [
            "PATCH /user/repository_invitations/{invitation_id}",
        ],
        addAppAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        addTeamAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        addUserAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: [
            "GET /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: [
            "GET /repos/{owner}/{repo}/compare/{basehead}",
        ],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: [
            "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        ],
        createCommitSignatureProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentStatus: [
            "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        ],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateEnvironment: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: [
            "POST /repos/{template_owner}/{template_repo}/generate",
        ],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: [
            "DELETE /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "declineInvitationForAuthenticatedUser"] },
        ],
        declineInvitationForAuthenticatedUser: [
            "DELETE /user/repository_invitations/{invitation_id}",
        ],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
        ],
        deleteAdminBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        deleteAnEnvironment: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: [
            "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}",
        ],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: [
            "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}",
        ],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: [
            "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}",
        ],
        deleteTagProtection: [
            "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}",
        ],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: [
            "DELETE /repos/{owner}/{repo}/automated-security-fixes",
        ],
        disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
        disableVulnerabilityAlerts: [
            "DELETE /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        downloadArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}",
            {},
            { renamed: ["repos", "downloadZipballArchive"] },
        ],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: [
            "PUT /repos/{owner}/{repo}/automated-security-fixes",
        ],
        enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
        enableVulnerabilityAlerts: [
            "PUT /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        generateReleaseNotes: [
            "POST /repos/{owner}/{repo}/releases/generate-notes",
        ],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
        ],
        getAdminBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        ],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        ],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: [
            "GET /repos/{owner}/{repo}/collaborators/{username}/permission",
        ],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentStatus: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}",
        ],
        getEnvironment: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getStatusChecksProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        getTeamsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        ],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        ],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/config",
        ],
        getWebhookDelivery: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}",
        ],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
        ],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        ],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
        ],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentStatuses: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        ],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
        ],
        listReleaseAssets: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
        ],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
        ],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
        ],
        removeAppAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        removeCollaborator: [
            "DELETE /repos/{owner}/{repo}/collaborators/{username}",
        ],
        removeStatusCheckContexts: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        removeStatusCheckProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        removeTeamAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        removeUserAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        setAppAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        setStatusCheckContexts: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        setTeamAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        setUserAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: [
            "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}",
        ],
        updatePullRequestReviewProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: [
            "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}",
        ],
        updateStatusCheckPotection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
            {},
            { renamed: ["repos", "updateStatusCheckProtection"] },
        ],
        updateStatusCheckProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config",
        ],
        uploadReleaseAsset: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
            { baseUrl: "https://uploads.github.com" },
        ],
    },
    search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"],
    },
    secretScanning: {
        getAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
        ],
        listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/secret-scanning/alerts",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
        ],
    },
    teams: {
        addOrUpdateMembershipForUserInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        addOrUpdateProjectPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        addOrUpdateRepoPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        checkPermissionsForProjectInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        checkPermissionsForRepoInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        ],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        deleteDiscussionInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        getDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        getMembershipForUserInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        ],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/invitations",
        ],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        removeProjectInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        removeRepoInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        updateDiscussionCommentInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        updateDiscussionInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
    },
    users: {
        addEmailForAuthenticated: [
            "POST /user/emails",
            {},
            { renamed: ["users", "addEmailForAuthenticatedUser"] },
        ],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: [
            "POST /user/gpg_keys",
            {},
            { renamed: ["users", "createGpgKeyForAuthenticatedUser"] },
        ],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: [
            "POST /user/keys",
            {},
            { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] },
        ],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        deleteEmailForAuthenticated: [
            "DELETE /user/emails",
            {},
            { renamed: ["users", "deleteEmailForAuthenticatedUser"] },
        ],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] },
        ],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: [
            "DELETE /user/keys/{key_id}",
            {},
            { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] },
        ],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: [
            "GET /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "getGpgKeyForAuthenticatedUser"] },
        ],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: [
            "GET /user/keys/{key_id}",
            {},
            { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] },
        ],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        list: ["GET /users"],
        listBlockedByAuthenticated: [
            "GET /user/blocks",
            {},
            { renamed: ["users", "listBlockedByAuthenticatedUser"] },
        ],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: [
            "GET /user/emails",
            {},
            { renamed: ["users", "listEmailsForAuthenticatedUser"] },
        ],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: [
            "GET /user/following",
            {},
            { renamed: ["users", "listFollowedByAuthenticatedUser"] },
        ],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: [
            "GET /user/gpg_keys",
            {},
            { renamed: ["users", "listGpgKeysForAuthenticatedUser"] },
        ],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: [
            "GET /user/public_emails",
            {},
            { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] },
        ],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: [
            "GET /user/keys",
            {},
            { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] },
        ],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
            "PATCH /user/email/visibility",
            {},
            { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] },
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
            "PATCH /user/email/visibility",
        ],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"],
    },
};

const VERSION = "5.16.2";

function endpointsToMethods(octokit, endpointsMap) {
    const newMethods = {};
    for (const [scope, endpoints] of Object.entries(endpointsMap)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
            const [route, defaults, decorations] = endpoint;
            const [method, url] = route.split(/ /);
            const endpointDefaults = Object.assign({ method, url }, defaults);
            if (!newMethods[scope]) {
                newMethods[scope] = {};
            }
            const scopeMethods = newMethods[scope];
            if (decorations) {
                scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
                continue;
            }
            scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
        }
    }
    return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    /* istanbul ignore next */
    function withDecorations(...args) {
        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
        let options = requestWithDefaults.endpoint.merge(...args);
        // There are currently no other decorations than `.mapToData`
        if (decorations.mapToData) {
            options = Object.assign({}, options, {
                data: options[decorations.mapToData],
                [decorations.mapToData]: undefined,
            });
            return requestWithDefaults(options);
        }
        if (decorations.renamed) {
            const [newScope, newMethodName] = decorations.renamed;
            octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
        }
        if (decorations.deprecated) {
            octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
            // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
            const options = requestWithDefaults.endpoint.merge(...args);
            for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
                if (name in options) {
                    octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
                    if (!(alias in options)) {
                        options[alias] = options[name];
                    }
                    delete options[name];
                }
            }
            return requestWithDefaults(options);
        }
        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
        return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit, Endpoints);
    return {
        rest: api,
    };
}
restEndpointMethods.VERSION = VERSION;
function legacyRestEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit, Endpoints);
    return {
        ...api,
        rest: api,
    };
}
legacyRestEndpointMethods.VERSION = VERSION;


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/request-error/dist-web/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@octokit/request-error/dist-web/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestError": () => (/* binding */ RequestError)
/* harmony export */ });
/* harmony import */ var deprecation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deprecation */ "./node_modules/deprecation/dist-web/index.js");
/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! once */ "./node_modules/once/once.js");
/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_0__);



const logOnceCode = once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation) => console.warn(deprecation));
const logOnceHeaders = once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation) => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */
class RequestError extends Error {
    constructor(message, statusCode, options) {
        super(message);
        // Maintains proper stack trace (only available on V8)
        /* istanbul ignore next */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
            headers = options.headers;
        }
        if ("response" in options) {
            this.response = options.response;
            headers = options.response.headers;
        }
        // redact request credentials without mutating original request options
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
                authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]"),
            });
        }
        requestCopy.url = requestCopy.url
            // client_id & client_secret can be passed as URL query parameters to increase rate limit
            // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
            .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
            // OAuth tokens can be passed as URL query parameters, although it is not recommended
            // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
            .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        // deprecations
        Object.defineProperty(this, "code", {
            get() {
                logOnceCode(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
                return statusCode;
            },
        });
        Object.defineProperty(this, "headers", {
            get() {
                logOnceHeaders(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
                return headers || {};
            },
        });
    }
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/request/dist-web/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@octokit/request/dist-web/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "request": () => (/* binding */ request)
/* harmony export */ });
/* harmony import */ var _octokit_endpoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/endpoint */ "./node_modules/@octokit/endpoint/dist-web/index.js");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "./node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @octokit/request-error */ "./node_modules/@octokit/request-error/dist-web/index.js");






const VERSION = "5.6.3";

function getBufferResponse(response) {
    return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
    const log = requestOptions.request && requestOptions.request.log
        ? requestOptions.request.log
        : console;
    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(requestOptions.body) ||
        Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    const fetch = (requestOptions.request && requestOptions.request.fetch) || (node_fetch__WEBPACK_IMPORTED_MODULE_1___default());
    return fetch(requestOptions.url, Object.assign({
        method: requestOptions.method,
        body: requestOptions.body,
        headers: requestOptions.headers,
        redirect: requestOptions.redirect,
    }, 
    // `requestOptions.request.agent` type is incompatible
    // see https://github.com/octokit/types.ts/pull/264
    requestOptions.request))
        .then(async (response) => {
        url = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
            headers[keyAndValue[0]] = keyAndValue[1];
        }
        if ("deprecation" in headers) {
            const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
            const deprecationLink = matches && matches.pop();
            log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
        }
        if (status === 204 || status === 205) {
            return;
        }
        // GitHub API returns 200 for HEAD requests
        if (requestOptions.method === "HEAD") {
            if (status < 400) {
                return;
            }
            throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(response.statusText, status, {
                response: {
                    url,
                    status,
                    headers,
                    data: undefined,
                },
                request: requestOptions,
            });
        }
        if (status === 304) {
            throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError("Not modified", status, {
                response: {
                    url,
                    status,
                    headers,
                    data: await getResponseData(response),
                },
                request: requestOptions,
            });
        }
        if (status >= 400) {
            const data = await getResponseData(response);
            const error = new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(toErrorMessage(data), status, {
                response: {
                    url,
                    status,
                    headers,
                    data,
                },
                request: requestOptions,
            });
            throw error;
        }
        return getResponseData(response);
    })
        .then((data) => {
        return {
            status,
            url,
            headers,
            data,
        };
    })
        .catch((error) => {
        if (error instanceof _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError)
            throw error;
        throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(error.message, 500, {
            request: requestOptions,
        });
    });
}
async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
        return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
    }
    return getBufferResponse(response);
}
function toErrorMessage(data) {
    if (typeof data === "string")
        return data;
    // istanbul ignore else - just in case
    if ("message" in data) {
        if (Array.isArray(data.errors)) {
            return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
        }
        return data.message;
    }
    // istanbul ignore next - just in case
    return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults(oldEndpoint, newDefaults) {
    const endpoint = oldEndpoint.defaults(newDefaults);
    const newApi = function (route, parameters) {
        const endpointOptions = endpoint.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
            return fetchWrapper(endpoint.parse(endpointOptions));
        }
        const request = (route, parameters) => {
            return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
        };
        Object.assign(request, {
            endpoint,
            defaults: withDefaults.bind(null, endpoint),
        });
        return endpointOptions.request.hook(request, endpointOptions);
    };
    return Object.assign(newApi, {
        endpoint,
        defaults: withDefaults.bind(null, endpoint),
    });
}

const request = withDefaults(_octokit_endpoint__WEBPACK_IMPORTED_MODULE_3__.endpoint, {
    headers: {
        "user-agent": `octokit-request.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_4__.getUserAgent)()}`,
    },
});


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/amqplib/channel_api.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/channel_api.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var raw_connect = (__webpack_require__(/*! ./lib/connect */ "./node_modules/amqplib/lib/connect.js").connect);
var ChannelModel = (__webpack_require__(/*! ./lib/channel_model */ "./node_modules/amqplib/lib/channel_model.js").ChannelModel);
var promisify = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

function connect(url, connOptions) {
  return promisify(function(cb) {
    return raw_connect(url, connOptions, cb);
  })()
  .then(function(conn) {
    return new ChannelModel(conn);
  });
};

module.exports.connect = connect;
module.exports.credentials = __webpack_require__(/*! ./lib/credentials */ "./node_modules/amqplib/lib/credentials.js");
module.exports.IllegalOperationError = __webpack_require__(/*! ./lib/error */ "./node_modules/amqplib/lib/error.js").IllegalOperationError;


/***/ }),

/***/ "./node_modules/amqplib/lib/api_args.js":
/*!**********************************************!*\
  !*** ./node_modules/amqplib/lib/api_args.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
//
//
//



/*
The channel (promise) and callback APIs have similar signatures, and
in particular, both need AMQP fields prepared from the same arguments
and options. The arguments marshalling is done here. Each of the
procedures below takes arguments and options (the latter in an object)
particular to the operation it represents, and returns an object with
fields for handing to the encoder.
*/

// A number of AMQP methods have a table-typed field called
// `arguments`, that is intended to carry extension-specific
// values. RabbitMQ uses this in a number of places; e.g., to specify
// an 'alternate exchange'.
//
// Many of the methods in this API have an `options` argument, from
// which I take both values that have a default in AMQP (e.g.,
// autoDelete in QueueDeclare) *and* values that are specific to
// RabbitMQ (e.g., 'alternate-exchange'), which would normally be
// supplied in `arguments`. So that extensions I don't support yet can
// be used, I include `arguments` itself among the options.
//
// The upshot of this is that I often need to prepare an `arguments`
// value that has any values passed in `options.arguments` as well as
// any I've promoted to being options themselves. Since I don't want
// to mutate anything passed in, the general pattern is to create a
// fresh object with the `arguments` value given as its prototype; all
// fields in the supplied value will be serialised, as well as any I
// set on the fresh object. What I don't want to do, however, is set a
// field to undefined by copying possibly missing field values,
// because that will mask a value in the prototype.
//
// NB the `arguments` field already has a default value of `{}`, so
// there's no need to explicitly default it unless I'm setting values.
function setIfDefined(obj, prop, value) {
  if (value != undefined) obj[prop] = value;
}

var EMPTY_OPTIONS = Object.freeze({});

var Args = {};

Args.assertQueue = function(queue, options) {
  queue = queue || '';
  options = options || EMPTY_OPTIONS;

  var argt = Object.create(options.arguments || null);
  setIfDefined(argt, 'x-expires', options.expires);
  setIfDefined(argt, 'x-message-ttl', options.messageTtl);
  setIfDefined(argt, 'x-dead-letter-exchange',
               options.deadLetterExchange);
  setIfDefined(argt, 'x-dead-letter-routing-key',
               options.deadLetterRoutingKey);
  setIfDefined(argt, 'x-max-length', options.maxLength);
  setIfDefined(argt, 'x-max-priority', options.maxPriority);
  setIfDefined(argt, 'x-overflow', options.overflow);
  setIfDefined(argt, 'x-queue-mode', options.queueMode);

  return {
    queue: queue,
    exclusive: !!options.exclusive,
    durable: (options.durable === undefined) ? true : options.durable,
    autoDelete: !!options.autoDelete,
    arguments: argt,
    passive: false,
    // deprecated but we have to include it
    ticket: 0,
    nowait: false
  };
};

Args.checkQueue = function(queue) {
  return {
    queue: queue,
    passive: true, // switch to "completely different" mode
    nowait: false,
    durable: true, autoDelete: false, exclusive: false, // ignored
    ticket: 0,
  };
};

Args.deleteQueue = function(queue, options) {
  options = options || EMPTY_OPTIONS;
  return {
    queue: queue,
    ifUnused: !!options.ifUnused,
    ifEmpty: !!options.ifEmpty,
    ticket: 0, nowait: false
  };
};

Args.purgeQueue = function(queue) {
  return {
    queue: queue,
    ticket: 0, nowait: false
  };
};

Args.bindQueue = function(queue, source, pattern, argt) {
  return {
    queue: queue,
    exchange: source,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

Args.unbindQueue = function(queue, source, pattern, argt) {
  return {
    queue: queue,
    exchange: source,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

Args.assertExchange = function(exchange, type, options) {
  options = options || EMPTY_OPTIONS;
  var argt = Object.create(options.arguments || null);
  setIfDefined(argt, 'alternate-exchange', options.alternateExchange);
  return {
    exchange: exchange,
    ticket: 0,
    type: type,
    passive: false,
    durable: (options.durable === undefined) ? true : options.durable,
    autoDelete: !!options.autoDelete,
    internal: !!options.internal,
    nowait: false,
    arguments: argt
  };
};

Args.checkExchange = function(exchange) {
  return {
    exchange: exchange,
    passive: true, // switch to 'may as well be another method' mode
    nowait: false,
    // ff are ignored
    durable: true, internal: false,  type: '',  autoDelete: false,
    ticket: 0
  };
};

Args.deleteExchange = function(exchange, options) {
  options = options || EMPTY_OPTIONS;
  return {
    exchange: exchange,
    ifUnused: !!options.ifUnused,
    ticket: 0, nowait: false
  };
};

Args.bindExchange = function(dest, source, pattern, argt) {
  return {
    source: source,
    destination: dest,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

Args.unbindExchange = function(dest, source, pattern, argt) {
  return {
    source: source,
    destination: dest,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

// It's convenient to construct the properties and the method fields
// at the same time, since in the APIs, values for both can appear in
// `options`. Since the property or mthod field names don't overlap, I
// just return one big object that can be used for both purposes, and
// the encoder will pick out what it wants.
Args.publish = function(exchange, routingKey, options) {
  options = options || EMPTY_OPTIONS;

  // The CC and BCC fields expect an array of "longstr", which would
  // normally be buffer values in JavaScript; however, since a field
  // array (or table) cannot have shortstr values, the codec will
  // encode all strings as longstrs anyway.
  function convertCC(cc) {
    if (cc === undefined) {
      return undefined;
    }
    else if (Array.isArray(cc)) {
      return cc.map(String);
    }
    else return [String(cc)];
  }

  var headers = Object.create(options.headers || null);
  setIfDefined(headers, 'CC', convertCC(options.CC));
  setIfDefined(headers, 'BCC', convertCC(options.BCC));

  var deliveryMode; // undefined will default to 1 (non-persistent)

  // Previously I overloaded deliveryMode be a boolean meaning
  // 'persistent or not'; better is to name this option for what it
  // is, but I need to have backwards compatibility for applications
  // that either supply a numeric or boolean value.
  if (options.persistent !== undefined)
    deliveryMode = (options.persistent) ? 2 : 1;
  else if (typeof options.deliveryMode === 'number')
    deliveryMode = options.deliveryMode;
  else if (options.deliveryMode) // is supplied and truthy
    deliveryMode = 2;

  var expiration = options.expiration;
  if (expiration !== undefined) expiration = expiration.toString();

  return {
    // method fields
    exchange: exchange,
    routingKey: routingKey,
    mandatory: !!options.mandatory,
    immediate: false, // RabbitMQ doesn't implement this any more
    ticket: undefined,
    // properties
    contentType: options.contentType,
    contentEncoding: options.contentEncoding,
    headers: headers,
    deliveryMode: deliveryMode,
    priority: options.priority,
    correlationId: options.correlationId,
    replyTo: options.replyTo,
    expiration: expiration,
    messageId: options.messageId,
    timestamp: options.timestamp,
    type: options.type,
    userId: options.userId,
    appId: options.appId,
    clusterId: undefined
  };
};

Args.consume = function(queue, options) {
  options = options || EMPTY_OPTIONS;
  var argt = Object.create(options.arguments || null);
  setIfDefined(argt, 'x-priority', options.priority);
  return {
    ticket: 0,
    queue: queue,
    consumerTag: options.consumerTag || '',
    noLocal: !!options.noLocal,
    noAck: !!options.noAck,
    exclusive: !!options.exclusive,
    nowait: false,
    arguments: argt
  };
};

Args.cancel = function(consumerTag) {
  return {
    consumerTag: consumerTag,
    nowait: false
  };
};

Args.get = function(queue, options) {
  options = options || EMPTY_OPTIONS;
  return {
    ticket: 0,
    queue: queue,
    noAck: !!options.noAck
  };
};

Args.ack = function(tag, allUpTo) {
  return {
    deliveryTag: tag,
    multiple: !!allUpTo
  };
};

Args.nack = function(tag, allUpTo, requeue) {
  return {
    deliveryTag: tag,
    multiple: !!allUpTo,
    requeue: (requeue === undefined) ? true : requeue
  };
};

Args.reject = function(tag, requeue) {
  return {
    deliveryTag: tag,
    requeue: (requeue === undefined) ? true : requeue
  };
};

Args.prefetch = function(count, global) {
  return {
    prefetchCount: count || 0,
    prefetchSize: 0,
    global: !!global
  };
};

Args.recover = function() {
  return {requeue: true};
};

module.exports = Object.freeze(Args);


/***/ }),

/***/ "./node_modules/amqplib/lib/bitset.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/bitset.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
//
//
//



/**
 * A bitset implementation, after that in java.util.  Yes there
 * already exist such things, but none implement next{Clear|Set}Bit or
 * equivalent, and none involved me tooling about for an evening.
 */
class BitSet {
  /**
   * @param {number} [size]
   */
  constructor(size) {
    if (size) {
      const numWords = Math.ceil(size / 32);
      this.words = new Array(numWords);
    }
    else {
      this.words = [];
    }
    this.wordsInUse = 0; // = number, not index
  }

  /**
   * @param {number} numWords
   */
  ensureSize(numWords) {
    const wordsPresent = this.words.length;
    if (wordsPresent < numWords) {
      this.words = this.words.concat(new Array(numWords - wordsPresent));
    }
  }

  /**
   * @param {number} bitIndex
   */
  set(bitIndex) {
    const w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) {
      this.ensureSize(w + 1);
      this.wordsInUse = w + 1;
    }
    const bit = 1 << bitIndex;
    this.words[w] |= bit;
  }

  /**
   * @param {number} bitIndex
   */
  clear(bitIndex) {
    const w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) return;
    const mask = ~(1 << bitIndex);
    this.words[w] &= mask;
  }

  /**
   * @param {number} bitIndex
   */
  get(bitIndex) {
    const w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) return false; // >= since index vs size
    const bit = 1 << bitIndex;
    return !!(this.words[w] & bit);
  }

  /**
   * Give the next bit that is set on or after fromIndex, or -1 if no such bit
   *
   * @param {number} fromIndex
   */
  nextSetBit(fromIndex) {
    let w = wordIndex(fromIndex);
    if (w >= this.wordsInUse) return -1;

    // the right-hand side is shifted to only test the bits of the first
    // word that are > fromIndex
    let word = this.words[w] & (0xffffffff << fromIndex);
    while (true) {
      if (word) return (w * 32) + trailingZeros(word);
      w++;
      if (w === this.wordsInUse) return -1;
      word = this.words[w];
    }
  }

  /**
   * @param {number} fromIndex
   */
  nextClearBit(fromIndex) {
    let w = wordIndex(fromIndex);
    if (w >= this.wordsInUse) return fromIndex;

    let word = ~(this.words[w]) & (0xffffffff << fromIndex);
    while (true) {
      if (word) return (w * 32) + trailingZeros(word);
      w++;
      if (w == this.wordsInUse) return w * 32;
      word = ~(this.words[w]);
    }
  }
}

/**
 * @param {number} bitIndex
 */
function wordIndex(bitIndex) {
  return Math.floor(bitIndex / 32);
}

/**
 * @param {number} i
 */
function trailingZeros(i) {
  // From Hacker's Delight, via JDK. Probably far less effective here,
  // since bit ops are not necessarily the quick way to do things in
  // JS.
  if (i === 0) return 32;
  let y, n = 31;
  y = i << 16; if (y != 0) { n = n -16; i = y; }
  y = i << 8;  if (y != 0) { n = n - 8; i = y; }
  y = i << 4;  if (y != 0) { n = n - 4; i = y; }
  y = i << 2;  if (y != 0) { n = n - 2; i = y; }
  return n - ((i << 1) >>> 31);
}

module.exports.BitSet = BitSet;


/***/ }),

/***/ "./node_modules/amqplib/lib/channel.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/channel.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// Channel machinery.



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var closeMsg = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").closeMessage);
var inspect = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").inspect);
var methodName = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").methodName);
var assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'assert'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);
var fmt = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var IllegalOperationError = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").IllegalOperationError);
var stackCapture = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").stackCapture);
function Channel(connection) {
  EventEmitter.call( this );
  this.connection = connection;
  // for the presently outstanding RPC
  this.reply = null;
  // for the RPCs awaiting action
  this.pending = [];
  // for unconfirmed messages
  this.lwm = 1; // the least, unconfirmed deliveryTag
  this.unconfirmed = []; // rolling window of delivery callbacks
  this.on('ack', this.handleConfirm.bind(this, function(cb) {
    if (cb) cb(null);
  }));
  this.on('nack', this.handleConfirm.bind(this, function(cb) {
    if (cb) cb(new Error('message nacked'));
  }));
  this.on('close', function () {
    var cb;
    while (cb = this.unconfirmed.shift()) {
      if (cb) cb(new Error('channel closed'));
    }
  })
  // message frame state machine
  this.handleMessage = acceptDeliveryOrReturn;
}
inherits(Channel, EventEmitter);

module.exports.Channel = Channel;
module.exports.acceptMessage = acceptMessage;

var C = Channel.prototype;

C.allocate = function() {
  this.ch = this.connection.freshChannel(this);
  return this;
}

// Incoming frames are either notifications of e.g., message delivery,
// or replies to something we've sent. In general I deal with the
// former by emitting an event, and with the latter by keeping a track
// of what's expecting a reply.
//
// The AMQP specification implies that RPCs can't be pipelined; that
// is, you can have only one outstanding RPC on a channel at a
// time. Certainly that's what RabbitMQ and its clients assume. For
// this reason, I buffer RPCs if the channel is already waiting for a
// reply.

// Just send the damn frame.
C.sendImmediately = function(method, fields) {
  return this.connection.sendMethod(this.ch, method, fields);
};

// Invariant: !this.reply -> pending.length == 0. That is, whenever we
// clear a reply, we must send another RPC (and thereby fill
// this.reply) if there is one waiting. The invariant relevant here
// and in `accept`.
C.sendOrEnqueue = function(method, fields, reply) {
  if (!this.reply) { // if no reply waiting, we can go
    assert(this.pending.length === 0);
    this.reply = reply;
    this.sendImmediately(method, fields);
  }
  else {
    this.pending.push({method: method,
                       fields: fields,
                       reply: reply});
  }
};

C.sendMessage = function(fields, properties, content) {
  return this.connection.sendMessage(
    this.ch,
    defs.BasicPublish, fields,
    defs.BasicProperties, properties,
    content);
};

// Internal, synchronously resolved RPC; the return value is resolved
// with the whole frame.
C._rpc = function(method, fields, expect, cb) {
  var self = this;

  function reply(err, f) {
    if (err === null) {
      if (f.id === expect) {
        return cb(null, f);
      }
      else {
        // We have detected a problem, so it's up to us to close the
        // channel
        var expectedName = methodName(expect);

        var e = new Error(fmt("Expected %s; got %s",
                              expectedName, inspect(f, false)));
        self.closeWithError(f.id, fmt('Expected %s; got %s',
                                expectedName, methodName(f.id)),
                            defs.constants.UNEXPECTED_FRAME, e);
        return cb(e);
      }
    }
    // An error will be given if, for example, this is waiting to be
    // sent and the connection closes
    else if (err instanceof Error) return cb(err);
    // A close frame will be given if this is the RPC awaiting reply
    // and the channel is closed by the server
    else {
      // otherwise, it's a close frame
      var closeReason =
        (err.fields.classId << 16) + err.fields.methodId;
      var e = (method === closeReason)
        ? fmt("Operation failed: %s; %s",
              methodName(method), closeMsg(err))
        : fmt("Channel closed by server: %s", closeMsg(err));
      var closeFrameError = new Error(e);
      closeFrameError.code = err.fields.replyCode;
      closeFrameError.classId = err.fields.classId;
      closeFrameError.methodId = err.fields.methodId;
      return cb(closeFrameError);
    }
  }

  this.sendOrEnqueue(method, fields, reply);
};

// Shutdown protocol. There's three scenarios:
//
// 1. The application decides to shut the channel
// 2. The server decides to shut the channel, possibly because of
// something the application did
// 3. The connection is closing, so there won't be any more frames
// going back and forth.
//
// 1 and 2 involve an exchange of method frames (Close and CloseOk),
// while 3 doesn't; the connection simply says "shutdown" to the
// channel, which then acts as if it's closing, without going through
// the exchange.

function invalidOp(msg, stack) {
  return function() {
    throw new IllegalOperationError(msg, stack);
  };
}

function invalidateSend(ch, msg, stack) {
  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage =
    invalidOp(msg, stack);
}

// Move to entirely closed state.
C.toClosed = function(capturedStack) {
  this._rejectPending();
  invalidateSend(this, 'Channel closed', capturedStack);
  this.accept = invalidOp('Channel closed', capturedStack);
  this.connection.releaseChannel(this.ch);
  this.emit('close');
};

// Stop being able to send and receive methods and content. Used when
// we close the channel. Invokes the continuation once the server has
// acknowledged the close, but before the channel is moved to the
// closed state.
C.toClosing = function(capturedStack, k) {
  var send = this.sendImmediately.bind(this);
  invalidateSend(this, 'Channel closing', capturedStack);

  this.accept = function(f) {
    if (f.id === defs.ChannelCloseOk) {
      if (k) k();
      var s = stackCapture('ChannelCloseOk frame received');
      this.toClosed(s);
    }
    else if (f.id === defs.ChannelClose) {
      send(defs.ChannelCloseOk, {});
    }
    // else ignore frame
  };
};

C._rejectPending = function() {
  function rej(r) {
    r(new Error("Channel ended, no reply will be forthcoming"));
  }
  if (this.reply !== null) rej(this.reply);
  this.reply = null;

  var discard;
  while (discard = this.pending.shift()) rej(discard.reply);
  this.pending = null; // so pushes will break
};

C.closeBecause = function(reason, code, k) {
  this.sendImmediately(defs.ChannelClose, {
    replyText: reason,
    replyCode: code,
    methodId:0, classId: 0
  });
  var s = stackCapture('closeBecause called: ' + reason);
  this.toClosing(s, k);
};

// If we close because there's been an error, we need to distinguish
// between what we tell the server (`reason`) and what we report as
// the cause in the client (`error`).
C.closeWithError = function(id, reason, code, error) {
  var self = this;
  this.closeBecause(reason, code, function() {
    error.code = code;
    // content frames and consumer errors do not provide a method a class/method ID
    if (id) {
      error.classId = defs.info(id).classId;
      error.methodId = defs.info(id).methodId;
    }
    self.emit('error', error);
  });
};

// A trampolining state machine for message frames on a channel. A
// message arrives in at least two frames: first, a method announcing
// the message (either a BasicDeliver or BasicGetOk); then, a message
// header with the message properties; then, zero or more content
// frames.

// Keep the try/catch localised, in an attempt to avoid disabling
// optimisation
C.acceptMessageFrame = function(f) {
  try {
    this.handleMessage = this.handleMessage(f);
  }
  catch (msg) {
    if (typeof msg === 'string') {
      this.closeWithError(f.id, msg, defs.constants.UNEXPECTED_FRAME,
                          new Error(msg));
    }
    else if (msg instanceof Error) {
      this.closeWithError(f.id, 'Error while processing message',
                          defs.constants.INTERNAL_ERROR, msg);
    }
    else {
      this.closeWithError(f.id, 'Internal error while processing message',
                          defs.constants.INTERNAL_ERROR,
                          new Error(msg.toString()));
    }
  }
};

// Kick off a message delivery given a BasicDeliver or BasicReturn
// frame (BasicGet uses the RPC mechanism)
function acceptDeliveryOrReturn(f) {
  var event;
  if (f.id === defs.BasicDeliver) event = 'delivery';
  else if (f.id === defs.BasicReturn) event = 'return';
  else throw fmt("Expected BasicDeliver or BasicReturn; got %s",
                 inspect(f));

  var self = this;
  var fields = f.fields;
  return acceptMessage(function(message) {
    message.fields = fields;
    self.emit(event, message);
  });
}

// Move to the state of waiting for message frames (headers, then
// one or more content frames)
function acceptMessage(continuation) {
  var totalSize = 0, remaining = 0;
  var buffers = null;

  var message = {
    fields: null,
    properties: null,
    content: null
  };

  return headers;

  // expect a headers frame
  function headers(f) {
    if (f.id === defs.BasicProperties) {
      message.properties = f.fields;
      totalSize = remaining = f.size;

      // for zero-length messages, content frames aren't required.
      if (totalSize === 0) {
        message.content = Buffer.alloc(0);
        continuation(message);
        return acceptDeliveryOrReturn;
      }
      else {
        return content;
      }
    }
    else {
      throw "Expected headers frame after delivery";
    }
  }

  // expect a content frame
  // %%% TODO cancelled messages (sent as zero-length content frame)
  function content(f) {
    if (f.content) {
      var size = f.content.length;
      remaining -= size;
      if (remaining === 0) {
        if (buffers !== null) {
          buffers.push(f.content);
          message.content = Buffer.concat(buffers);
        }
        else {
          message.content = f.content;
        }
        continuation(message);
        return acceptDeliveryOrReturn;
      }
      else if (remaining < 0) {
        throw fmt("Too much content sent! Expected %d bytes",
                  totalSize);
      }
      else {
        if (buffers !== null)
          buffers.push(f.content);
        else
          buffers = [f.content];
        return content;
      }
    }
    else throw "Expected content frame after headers"
  }
}

C.handleConfirm = function(handle, f) {
  var tag = f.deliveryTag;
  var multi = f.multiple;

  if (multi) {
    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);
    this.lwm = tag + 1;
    confirmed.forEach(handle);
  }
  else {
    var c;
    if (tag === this.lwm) {
      c = this.unconfirmed.shift();
      this.lwm++;
      // Advance the LWM and the window to the next non-gap, or
      // possibly to the end
      while (this.unconfirmed[0] === null) {
        this.unconfirmed.shift();
        this.lwm++;
      }
    }
    else {
      c = this.unconfirmed[tag - this.lwm];
      this.unconfirmed[tag - this.lwm] = null;
    }
    // Technically, in the single-deliveryTag case, I should report a
    // protocol breach if it's already been confirmed.
    handle(c);
  }
};

C.pushConfirmCallback = function(cb) {
  // `null` is used specifically for marking already confirmed slots,
  // so I coerce `undefined` and `null` to false; functions are never
  // falsey.
  this.unconfirmed.push(cb || false);
};

// Interface for connection to use

C.accept = function(f) {

  switch (f.id) {

    // Message frames
  case undefined: // content frame!
  case defs.BasicDeliver:
  case defs.BasicReturn:
  case defs.BasicProperties:
    return this.acceptMessageFrame(f);

    // confirmations, need to do confirm.select first
  case defs.BasicAck:
    return this.emit('ack', f.fields);
  case defs.BasicNack:
    return this.emit('nack', f.fields);
  case defs.BasicCancel:
    // The broker can send this if e.g., the queue is deleted.
    return this.emit('cancel', f.fields);

  case defs.ChannelClose:
    // Any remote closure is an error to us. Reject the pending reply
    // with the close frame, so it can see whether it was that
    // operation that caused it to close.
    if (this.reply) {
      var reply = this.reply; this.reply = null;
      reply(f);
    }
    var emsg = "Channel closed by server: " + closeMsg(f);
    this.sendImmediately(defs.ChannelCloseOk, {});

    var error = new Error(emsg);
    error.code = f.fields.replyCode;
    error.classId = f.fields.classId;
    error.methodId = f.fields.methodId;
    this.emit('error', error);

    var s = stackCapture(emsg);
    this.toClosed(s);
    return;

  case defs.BasicFlow:
    // RabbitMQ doesn't send this, it just blocks the TCP socket
    return this.closeWithError(f.id, "Flow not implemented",
                               defs.constants.NOT_IMPLEMENTED,
                               new Error('Flow not implemented'));

  default: // assume all other things are replies
    // Resolving the reply may lead to another RPC; to make sure we
    // don't hold that up, clear this.reply
    var reply = this.reply; this.reply = null;
    // however, maybe there's an RPC waiting to go? If so, that'll
    // fill this.reply again, restoring the invariant. This does rely
    // on any response being recv'ed after resolving the promise,
    // below; hence, I use synchronous defer.
    if (this.pending.length > 0) {
      var send = this.pending.shift();
      this.reply = send.reply;
      this.sendImmediately(send.method, send.fields);
    }
    return reply(null, f);
  }
};

C.onBufferDrain = function() {
  this.emit('drain');
};


// This adds just a bit more stuff useful for the APIs, but not
// low-level machinery.
function BaseChannel(connection) {
  Channel.call(this, connection);
  this.consumers = new Map();
}
inherits(BaseChannel, Channel);

module.exports.BaseChannel = BaseChannel;

// Not sure I like the ff, it's going to be changing hidden classes
// all over the place. On the other hand, whaddya do.
BaseChannel.prototype.registerConsumer = function(tag, callback) {
  this.consumers.set(tag, callback);
};

BaseChannel.prototype.unregisterConsumer = function(tag) {
  this.consumers.delete(tag);
};

BaseChannel.prototype.dispatchMessage = function(fields, message) {
  var consumerTag = fields.consumerTag;
  var consumer = this.consumers.get(consumerTag);
  if (consumer) {
    return consumer(message);
  }
  else {
    // %%% Surely a race here
    throw new Error("Unknown consumer: " + consumerTag);
  }
};

BaseChannel.prototype.handleDelivery = function(message) {
  return this.dispatchMessage(message.fields, message);
};

BaseChannel.prototype.handleCancel = function(fields) {
  var result = this.dispatchMessage(fields, null);
  this.unregisterConsumer(fields.consumerTag);
  return result;
};


/***/ }),

/***/ "./node_modules/amqplib/lib/channel_model.js":
/*!***************************************************!*\
  !*** ./node_modules/amqplib/lib/channel_model.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//



const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const promisify = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
const defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
const {BaseChannel} = __webpack_require__(/*! ./channel */ "./node_modules/amqplib/lib/channel.js");
const {acceptMessage} = __webpack_require__(/*! ./channel */ "./node_modules/amqplib/lib/channel.js");
const Args = __webpack_require__(/*! ./api_args */ "./node_modules/amqplib/lib/api_args.js");
const {inspect} = __webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js");

class ChannelModel extends EventEmitter {
  constructor(connection) {
    super();
    this.connection = connection;

    ['error', 'close', 'blocked', 'unblocked'].forEach(ev => {
      connection.on(ev, this.emit.bind(this, ev));
    });
  }

  close() {
    return promisify(this.connection.close.bind(this.connection))();
  }

  async createChannel() {
    const channel = new Channel(this.connection);
    await channel.open();
    return channel;
  }

  async createConfirmChannel() {
    const channel = new ConfirmChannel(this.connection);
    await channel.open();
    await channel.rpc(defs.ConfirmSelect, {nowait: false}, defs.ConfirmSelectOk);
    return channel;
  }
}

// Channels

class Channel extends BaseChannel {
  constructor(connection) {
    super(connection);
    this.on('delivery', this.handleDelivery.bind(this));
    this.on('cancel', this.handleCancel.bind(this));
  }

  // An RPC that returns a 'proper' promise, which resolves to just the
  // response's fields; this is intended to be suitable for implementing
  // API procedures.
  async rpc(method, fields, expect) {
    const f = await promisify(cb => {
      return this._rpc(method, fields, expect, cb);
    })();

    return f.fields;
  }

  // Do the remarkably simple channel open handshake
  async open() {
    const ch = await this.allocate.bind(this)();
    return ch.rpc(defs.ChannelOpen, {outOfBand: ""},
                  defs.ChannelOpenOk);
  }

  close() {
    return promisify(cb => {
      return this.closeBecause("Goodbye", defs.constants.REPLY_SUCCESS,
                      cb);
    })();
  }

  // === Public API, declaring queues and stuff ===

  assertQueue(queue, options) {
    return this.rpc(defs.QueueDeclare,
                    Args.assertQueue(queue, options),
                    defs.QueueDeclareOk);
  }

  checkQueue(queue) {
    return this.rpc(defs.QueueDeclare,
                    Args.checkQueue(queue),
                    defs.QueueDeclareOk);
  }

  deleteQueue(queue, options) {
    return this.rpc(defs.QueueDelete,
                    Args.deleteQueue(queue, options),
                    defs.QueueDeleteOk);
  }

  purgeQueue(queue) {
    return this.rpc(defs.QueuePurge,
                    Args.purgeQueue(queue),
                    defs.QueuePurgeOk);
  }

  bindQueue(queue, source, pattern, argt) {
    return this.rpc(defs.QueueBind,
                    Args.bindQueue(queue, source, pattern, argt),
                    defs.QueueBindOk);
  }

  unbindQueue(queue, source, pattern, argt) {
    return this.rpc(defs.QueueUnbind,
                    Args.unbindQueue(queue, source, pattern, argt),
                    defs.QueueUnbindOk);
  }

  assertExchange(exchange, type, options) {
    // The server reply is an empty set of fields, but it's convenient
    // to have the exchange name handed to the continuation.
    return this.rpc(defs.ExchangeDeclare,
                    Args.assertExchange(exchange, type, options),
                    defs.ExchangeDeclareOk)
      .then(_ok => { return { exchange }; });
  }

  checkExchange(exchange) {
    return this.rpc(defs.ExchangeDeclare,
                    Args.checkExchange(exchange),
                    defs.ExchangeDeclareOk);
  }

  deleteExchange(name, options) {
    return this.rpc(defs.ExchangeDelete,
                    Args.deleteExchange(name, options),
                    defs.ExchangeDeleteOk);
  }

  bindExchange(dest, source, pattern, argt) {
    return this.rpc(defs.ExchangeBind,
                    Args.bindExchange(dest, source, pattern, argt),
                    defs.ExchangeBindOk);
  }

  unbindExchange(dest, source, pattern, argt) {
    return this.rpc(defs.ExchangeUnbind,
                    Args.unbindExchange(dest, source, pattern, argt),
                    defs.ExchangeUnbindOk);
  }

  // Working with messages

  publish(exchange, routingKey, content, options) {
    const fieldsAndProps = Args.publish(exchange, routingKey, options);
    return this.sendMessage(fieldsAndProps, fieldsAndProps, content);
  }

  sendToQueue(queue, content, options) {
    return this.publish('', queue, content, options);
  }

  consume(queue, callback, options) {
    // NB we want the callback to be run synchronously, so that we've
    // registered the consumerTag before any messages can arrive.
    const fields = Args.consume(queue, options);
    return new Promise((resolve, reject) => {
      this._rpc(defs.BasicConsume, fields, defs.BasicConsumeOk, (err, ok) => {
        if (err) return reject(err);
        this.registerConsumer(ok.fields.consumerTag, callback);
        resolve(ok.fields);
      });
    });
  }

  async cancel(consumerTag) {
    const ok = await promisify(cb => {
      this._rpc(defs.BasicCancel, Args.cancel(consumerTag),
            defs.BasicCancelOk,
            cb);
    })()
    .then(ok => {
      this.unregisterConsumer(consumerTag);
      return ok.fields;
    });
  }

  get(queue, options) {
    const fields = Args.get(queue, options);
    return new Promise((resolve, reject) => {
      this.sendOrEnqueue(defs.BasicGet, fields, (err, f) => {
        if (err) return reject(err);
        if (f.id === defs.BasicGetEmpty) {
          return resolve(false);
        }
        else if (f.id === defs.BasicGetOk) {
          const fields = f.fields;
          this.handleMessage = acceptMessage(m => {
            m.fields = fields;
            resolve(m);
          });
        }
        else {
          reject(new Error(`Unexpected response to BasicGet: ${inspect(f)}`));
        }
      });
    });
  }

  ack(message, allUpTo) {
    this.sendImmediately(
      defs.BasicAck,
      Args.ack(message.fields.deliveryTag, allUpTo));
  }

  ackAll() {
    this.sendImmediately(defs.BasicAck, Args.ack(0, true));
  }

  nack(message, allUpTo, requeue) {
    this.sendImmediately(
      defs.BasicNack,
      Args.nack(message.fields.deliveryTag, allUpTo, requeue));
  }

  nackAll(requeue) {
    this.sendImmediately(defs.BasicNack,
                         Args.nack(0, true, requeue));
  }

  // `Basic.Nack` is not available in older RabbitMQ versions (or in the
  // AMQP specification), so you have to use the one-at-a-time
  // `Basic.Reject`. This is otherwise synonymous with
  // `#nack(message, false, requeue)`.
  reject(message, requeue) {
    this.sendImmediately(
      defs.BasicReject,
      Args.reject(message.fields.deliveryTag, requeue));
  }

  recover() {
    return this.rpc(defs.BasicRecover,
                    Args.recover(),
                    defs.BasicRecoverOk);
  }

  qos(count, global) {
    return this.rpc(defs.BasicQos,
                    Args.prefetch(count, global),
                    defs.BasicQosOk);
  }
}

// There are more options in AMQP than exposed here; RabbitMQ only
// implements prefetch based on message count, and only for individual
// channels or consumers. RabbitMQ v3.3.0 and after treat prefetch
// (without `global` set) as per-consumer (for consumers following),
// and prefetch with `global` set as per-channel.
Channel.prototype.prefetch = Channel.prototype.qos

// Confirm channel. This is a channel with confirms 'switched on',
// meaning sent messages will provoke a responding 'ack' or 'nack'
// from the server. The upshot of this is that `publish` and
// `sendToQueue` both take a callback, which will be called either
// with `null` as its argument to signify 'ack', or an exception as
// its argument to signify 'nack'.

class ConfirmChannel extends Channel {
  publish(exchange, routingKey, content, options, cb) {
    this.pushConfirmCallback(cb);
    return Channel.prototype.publish.call(this, exchange, routingKey, content, options);
  }

  sendToQueue(queue, content, options, cb) {
    return this.publish('', queue, content, options, cb);
  }

  waitForConfirms() {
    const awaiting = [];
    const unconfirmed = this.unconfirmed;
    unconfirmed.forEach((val, index) => {
      if (val !== null) {
        const confirmed = new Promise((resolve, reject) => {
          unconfirmed[index] = err => {
            if (val) val(err);
            if (err === null) resolve();
            else reject(err);
          };
        });
        awaiting.push(confirmed);
      }
    });
    // Channel closed
    if (!this.pending) {
      var cb;
      while (cb = this.unconfirmed.shift()) {
        if (cb) cb(new Error('channel closed'));
      }
    }
    return Promise.all(awaiting);
  }
}

module.exports.ConfirmChannel = ConfirmChannel;
module.exports.Channel = Channel;
module.exports.ChannelModel = ChannelModel;


/***/ }),

/***/ "./node_modules/amqplib/lib/codec.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/codec.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

/*

The AMQP 0-9-1 is a mess when it comes to the types that can be
encoded on the wire.

There are four encoding schemes, and three overlapping sets of types:
frames, methods, (field-)tables, and properties.

Each *frame type* has a set layout in which values of given types are
concatenated along with sections of "raw binary" data.

In frames there are `shortstr`s, that is length-prefixed strings of
UTF8 chars, 8 bit unsigned integers (called `octet`), unsigned 16 bit
integers (called `short` or `short-uint`), unsigned 32 bit integers
(called `long` or `long-uint`), unsigned 64 bit integers (called
`longlong` or `longlong-uint`), and flags (called `bit`).

Methods are encoded as a frame giving a method ID and a sequence of
arguments of known types. The encoded method argument values are
concatenated (with some fun complications around "packing" consecutive
bit values into bytes).

Along with the types given in frames, method arguments may be long
byte strings (`longstr`, not required to be UTF8) or 64 bit unsigned
integers to be interpreted as timestamps (yeah I don't know why
either), or arbitrary sets of key-value pairs (called `field-table`).

Inside a field table the keys are `shortstr` and the values are
prefixed with a byte tag giving the type. The types are any of the
above except for bits (which are replaced by byte-wide `bool`), along
with a NULL value `void`, a special fixed-precision number encoding
(`decimal`), IEEE754 `float`s and `double`s, signed integers,
`field-array` (a sequence of tagged values), and nested field-tables.

RabbitMQ and QPid use a subset of the field-table types, and different
value tags, established before the AMQP 0-9-1 specification was
published. So far as I know, no-one uses the types and tags as
published. http://www.rabbitmq.com/amqp-0-9-1-errata.html gives the
list of field-table types.

Lastly, there are (sets of) properties, only one of which is given in
AMQP 0-9-1: `BasicProperties`. These are almost the same as methods,
except that they appear in content header frames, which include a
content size, and they carry a set of flags indicating which
properties are present. This scheme can save ones of bytes per message
(messages which take a minimum of three frames each to send).

*/



var ints = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js");

// JavaScript uses only doubles so what I'm testing for is whether
// it's *better* to encode a number as a float or double. This really
// just amounts to testing whether there's a fractional part to the
// number, except that see below. NB I don't use bitwise operations to
// do this 'efficiently' -- it would mask the number to 32 bits.
//
// At 2^50, doubles don't have sufficient precision to distinguish
// between floating point and integer numbers (`Math.pow(2, 50) + 0.1
// === Math.pow(2, 50)` (and, above 2^53, doubles cannot represent all
// integers (`Math.pow(2, 53) + 1 === Math.pow(2, 53)`)). Hence
// anything with a magnitude at or above 2^50 may as well be encoded
// as a 64-bit integer. Except that only signed integers are supported
// by RabbitMQ, so anything above 2^63 - 1 must be a double.
function isFloatingPoint(n) {
    return n >= 0x8000000000000000 ||
        (Math.abs(n) < 0x4000000000000
         && Math.floor(n) !== n);
}

function encodeTable(buffer, val, offset) {
    var start = offset;
    offset += 4; // leave room for the table length
    for (var key in val) {
        if (val[key] !== undefined) {
          var len = Buffer.byteLength(key);
          buffer.writeUInt8(len, offset); offset++;
          buffer.write(key, offset, 'utf8'); offset += len;
          offset += encodeFieldValue(buffer, val[key], offset);
        }
    }
    var size = offset - start;
    buffer.writeUInt32BE(size - 4, start);
    return size;
}

function encodeArray(buffer, val, offset) {
    var start = offset;
    offset += 4;
    for (var i=0, num=val.length; i < num; i++) {
        offset += encodeFieldValue(buffer, val[i], offset);
    }
    var size = offset - start;
    buffer.writeUInt32BE(size - 4, start);
    return size;
}

function encodeFieldValue(buffer, value, offset) {
    var start = offset;
    var type = typeof value, val = value;
    // A trapdoor for specifying a type, e.g., timestamp
    if (value && type === 'object' && value.hasOwnProperty('!')) {
        val = value.value;
        type = value['!'];
    }

    // If it's a JS number, we'll have to guess what type to encode it
    // as.
    if (type == 'number') {
        // Making assumptions about the kind of number (floating point
        // v integer, signed, unsigned, size) desired is dangerous in
        // general; however, in practice RabbitMQ uses only
        // longstrings and unsigned integers in its arguments, and
        // other clients generally conflate number types anyway. So
        // the only distinction we care about is floating point vs
        // integers, preferring integers since those can be promoted
        // if necessary. If floating point is required, we may as well
        // use double precision.
        if (isFloatingPoint(val)) {
            type = 'double';
        }
        else { // only signed values are used in tables by
               // RabbitMQ. It *used* to (< v3.3.0) treat the byte 'b'
               // type as unsigned, but most clients (and the spec)
               // think it's signed, and now RabbitMQ does too.
            if (val < 128 && val >= -128) {
                type = 'byte';
            }
            else if (val >= -0x8000 && val < 0x8000) {
                type = 'short'
            }
            else if (val >= -0x80000000 && val < 0x80000000) {
                type = 'int';
            }
            else {
                type = 'long';
            }
        }
    }

    function tag(t) { buffer.write(t, offset); offset++; }

    switch (type) {
    case 'string': // no shortstr in field tables
        var len = Buffer.byteLength(val, 'utf8');
        tag('S');
        buffer.writeUInt32BE(len, offset); offset += 4;
        buffer.write(val, offset, 'utf8'); offset += len;
        break;
    case 'object':
        if (val === null) {
            tag('V');
        }
        else if (Array.isArray(val)) {
            tag('A');
            offset += encodeArray(buffer, val, offset);
        }
        else if (Buffer.isBuffer(val)) {
            tag('x');
            buffer.writeUInt32BE(val.length, offset); offset += 4;
            val.copy(buffer, offset); offset += val.length;
        }
        else {
            tag('F');
            offset += encodeTable(buffer, val, offset);
        }
        break;
    case 'boolean':
        tag('t');
        buffer.writeUInt8((val) ? 1 : 0, offset); offset++;
        break;
    // These are the types that are either guessed above, or
    // explicitly given using the {'!': type} notation.
    case 'double':
    case 'float64':
        tag('d');
        buffer.writeDoubleBE(val, offset);
        offset += 8;
        break;
    case 'byte':
    case 'int8':
        tag('b');
        buffer.writeInt8(val, offset); offset++;
        break;
    case 'short':
    case 'int16':
        tag('s');
        buffer.writeInt16BE(val, offset); offset += 2;
        break;
    case 'int':
    case 'int32':
        tag('I');
        buffer.writeInt32BE(val, offset); offset += 4;
        break;
    case 'long':
    case 'int64':
        tag('l');
        ints.writeInt64BE(buffer, val, offset); offset += 8;
        break;

    // Now for exotic types, those can _only_ be denoted by using
    // `{'!': type, value: val}
    case 'timestamp':
        tag('T');
        ints.writeUInt64BE(buffer, val, offset); offset += 8;
        break;
    case 'float':
        tag('f');
        buffer.writeFloatBE(val, offset); offset += 4;
        break;
    case 'decimal':
        tag('D');
        if (val.hasOwnProperty('places') && val.hasOwnProperty('digits')
            && val.places >= 0 && val.places < 256) {
            buffer[offset] = val.places; offset++;
            buffer.writeUInt32BE(val.digits, offset); offset += 4;
        }
        else throw new TypeError(
            "Decimal value must be {'places': 0..255, 'digits': uint32}, " +
                "got " + JSON.stringify(val));
        break;
    default:
        throw new TypeError('Unknown type to encode: ' + type);
    }
    return offset - start;
}

// Assume we're given a slice of the buffer that contains just the
// fields.
function decodeFields(slice) {
    var fields = {}, offset = 0, size = slice.length;
    var len, key, val;

    function decodeFieldValue() {
        var tag = String.fromCharCode(slice[offset]); offset++;
        switch (tag) {
        case 'b':
            val = slice.readInt8(offset); offset++;
            break;
        case 'S':
            len = slice.readUInt32BE(offset); offset += 4;
            val = slice.toString('utf8', offset, offset + len);
            offset += len;
            break;
        case 'I':
            val = slice.readInt32BE(offset); offset += 4;
            break;
        case 'D': // only positive decimals, apparently.
            var places = slice[offset]; offset++;
            var digits = slice.readUInt32BE(offset); offset += 4;
            val = {'!': 'decimal', value: {places: places, digits: digits}};
            break;
        case 'T':
            val = ints.readUInt64BE(slice, offset); offset += 8;
            val = {'!': 'timestamp', value: val};
            break;
        case 'F':
            len = slice.readUInt32BE(offset); offset += 4;
            val = decodeFields(slice.slice(offset, offset + len));
            offset += len;
            break;
        case 'A':
            len = slice.readUInt32BE(offset); offset += 4;
            decodeArray(offset + len);
            // NB decodeArray will itself update offset and val
            break;
        case 'd':
            val = slice.readDoubleBE(offset); offset += 8;
            break;
        case 'f':
            val = slice.readFloatBE(offset); offset += 4;
            break;
        case 'l':
            val = ints.readInt64BE(slice, offset); offset += 8;
            break;
        case 's':
            val = slice.readInt16BE(offset); offset += 2;
            break;
        case 't':
            val = slice[offset] != 0; offset++;
            break;
        case 'V':
            val = null;
            break;
        case 'x':
            len = slice.readUInt32BE(offset); offset += 4;
            val = slice.slice(offset, offset + len);
            offset += len;
            break;
        default:
            throw new TypeError('Unexpected type tag "' + tag +'"');
        }
    }

    function decodeArray(until) {
        var vals = [];
        while (offset < until) {
            decodeFieldValue();
            vals.push(val);
        }
        val = vals;
    }

    while (offset < size) {
        len = slice.readUInt8(offset); offset++;
        key = slice.toString('utf8', offset, offset + len);
        offset += len;
        decodeFieldValue();
        fields[key] = val;
    }
    return fields;
}

module.exports.encodeTable = encodeTable;
module.exports.decodeFields = decodeFields;


/***/ }),

/***/ "./node_modules/amqplib/lib/connect.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/connect.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// General-purpose API for glueing everything together.



var URL = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");
var QS = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'querystring'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var Connection = (__webpack_require__(/*! ./connection */ "./node_modules/amqplib/lib/connection.js").Connection);
var fmt = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var credentials = __webpack_require__(/*! ./credentials */ "./node_modules/amqplib/lib/credentials.js");

function copyInto(obj, target) {
  var keys = Object.keys(obj);
  var i = keys.length;
  while (i--) {
    var k = keys[i];
    target[k] = obj[k];
  }
  return target;
}

// Adapted from util._extend, which is too fringe to use.
function clone(obj) {
  return copyInto(obj, {});
}

var CLIENT_PROPERTIES = {
  "product": "amqplib",
  "version": (__webpack_require__(/*! ../package.json */ "./node_modules/amqplib/package.json").version),
  "platform": fmt('Node.JS %s', process.version),
  "information": "http://squaremo.github.io/amqp.node",
  "capabilities": {
    "publisher_confirms": true,
    "exchange_exchange_bindings": true,
    "basic.nack": true,
    "consumer_cancel_notify": true,
    "connection.blocked": true,
    "authentication_failure_close": true
  }
};

// Construct the main frames used in the opening handshake
function openFrames(vhost, query, credentials, extraClientProperties) {
  if (!vhost)
    vhost = '/';
  else
    vhost = QS.unescape(vhost);

  var query = query || {};

  function intOrDefault(val, def) {
    return (val === undefined) ? def : parseInt(val);
  }

  var clientProperties = Object.create(CLIENT_PROPERTIES);

  return {
    // start-ok
    'clientProperties': copyInto(extraClientProperties, clientProperties),
    'mechanism': credentials.mechanism,
    'response': credentials.response(),
    'locale': query.locale || 'en_US',

    // tune-ok
    'channelMax': intOrDefault(query.channelMax, 0),
    'frameMax': intOrDefault(query.frameMax, 0x1000),
    'heartbeat': intOrDefault(query.heartbeat, 0),

    // open
    'virtualHost': vhost,
    'capabilities': '',
    'insist': 0
  };
}

// Decide on credentials based on what we're supplied.
function credentialsFromUrl(parts) {
  var user = 'guest', passwd = 'guest';
  if (parts.username != '' || parts.password != '') {
    user = (parts.username) ? unescape(parts.username) : '';
    passwd = (parts.password) ? unescape(parts.password) : '';
  }
  return credentials.plain(user, passwd);
}

function connect(url, socketOptions, openCallback) {
  // tls.connect uses `util._extend()` on the options given it, which
  // copies only properties mentioned in `Object.keys()`, when
  // processing the options. So I have to make copies too, rather
  // than using `Object.create()`.
  var sockopts = clone(socketOptions || {});
  url = url || 'amqp://localhost';

  var noDelay = !!sockopts.noDelay;
  var timeout = sockopts.timeout;
  var keepAlive = !!sockopts.keepAlive;
  // 0 is default for node
  var keepAliveDelay = sockopts.keepAliveDelay || 0;

  var extraClientProperties = sockopts.clientProperties || {};

  var protocol, fields;
  if (typeof url === 'object') {
    protocol = (url.protocol || 'amqp') + ':';
    sockopts.host = url.hostname;
    sockopts.servername = sockopts.servername || url.hostname;
    sockopts.port = url.port || ((protocol === 'amqp:') ? 5672 : 5671);

    var user, pass;
    // Only default if both are missing, to have the same behaviour as
    // the stringly URL.
    if (url.username == undefined && url.password == undefined) {
      user = 'guest'; pass = 'guest';
    } else {
      user = url.username || '';
      pass = url.password || '';
    }

    var config = {
      locale: url.locale,
      channelMax: url.channelMax,
      frameMax: url.frameMax,
      heartbeat: url.heartbeat,
    };

    fields = openFrames(url.vhost, config, sockopts.credentials || credentials.plain(user, pass), extraClientProperties);
  } else {
    var parts = URL(url, true); // yes, parse the query string
    protocol = parts.protocol;
    sockopts.host = parts.hostname;
    sockopts.servername = sockopts.servername || parts.hostname;
    sockopts.port = parseInt(parts.port) || ((protocol === 'amqp:') ? 5672 : 5671);
    var vhost = parts.pathname ? parts.pathname.substr(1) : null;
    fields = openFrames(vhost, parts.query, sockopts.credentials || credentialsFromUrl(parts), extraClientProperties);
  }

  var sockok = false;
  var sock;

  function onConnect() {
    sockok = true;
    sock.setNoDelay(noDelay);
    if (keepAlive) sock.setKeepAlive(keepAlive, keepAliveDelay);

    var c = new Connection(sock);
    c.open(fields, function(err, ok) {
      // disable timeout once the connection is open, we don't want
      // it fouling things
      if (timeout) sock.setTimeout(0);
      if (err === null) {
        openCallback(null, c);
      } else {
        // The connection isn't closed by the server on e.g. wrong password
        sock.end();
        sock.destroy();
        openCallback(err);
      }
    });
  }

  if (protocol === 'amqp:') {
    sock = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(sockopts, onConnect);
  }
  else if (protocol === 'amqps:') {
    sock = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(sockopts, onConnect);
  }
  else {
    throw new Error("Expected amqp: or amqps: as the protocol; got " + protocol);
  }

  if (timeout) {
    sock.setTimeout(timeout, function() {
      sock.end();
      sock.destroy();
      openCallback(new Error('connect ETIMEDOUT'));
    });
  }

  sock.once('error', function(err) {
    if (!sockok) openCallback(err);
  });

}

module.exports.connect = connect;
module.exports.credentialsFromUrl = credentialsFromUrl;


/***/ }),

/***/ "./node_modules/amqplib/lib/connection.js":
/*!************************************************!*\
  !*** ./node_modules/amqplib/lib/connection.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var constants = defs.constants;
var frame = __webpack_require__(/*! ./frame */ "./node_modules/amqplib/lib/frame.js");
var HEARTBEAT = frame.HEARTBEAT;
var Mux = (__webpack_require__(/*! ./mux */ "./node_modules/amqplib/lib/mux.js").Mux);

var Duplex =
  Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) ||
  __webpack_require__(/*! readable-stream/duplex */ "./node_modules/readable-stream/duplex.js");
var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);
var Heart = (__webpack_require__(/*! ./heartbeat */ "./node_modules/amqplib/lib/heartbeat.js").Heart);

var methodName = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").methodName);
var closeMsg = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").closeMessage);
var inspect = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").inspect);

var BitSet = (__webpack_require__(/*! ./bitset */ "./node_modules/amqplib/lib/bitset.js").BitSet);
var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var fmt = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var PassThrough = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) ||
  __webpack_require__(/*! readable-stream/passthrough */ "./node_modules/readable-stream/passthrough.js");
var IllegalOperationError = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").IllegalOperationError);
var stackCapture = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").stackCapture);

// High-water mark for channel write buffers, in 'objects' (which are
// encoded frames as buffers).
var DEFAULT_WRITE_HWM = 1024;
// If all the frames of a message (method, properties, content) total
// to less than this, copy them into a single buffer and write it all
// at once. Note that this is less than the minimum frame size: if it
// was greater, we might have to fragment the content.
var SINGLE_CHUNK_THRESHOLD = 2048;

function Connection(underlying) {
  EventEmitter.call( this );
  var stream = this.stream = wrapStream(underlying);
  this.muxer = new Mux(stream);

  // frames
  this.rest = Buffer.alloc(0);
  this.frameMax = constants.FRAME_MIN_SIZE;
  this.sentSinceLastCheck = false;
  this.recvSinceLastCheck = false;

  this.expectSocketClose = false;
  this.freeChannels = new BitSet();
  this.channels = [{channel: {accept: channel0(this)},
                    buffer: underlying}];
}
inherits(Connection, EventEmitter);

var C = Connection.prototype;

// Usual frame accept mode
function mainAccept(frame) {
  var rec = this.channels[frame.channel];
  if (rec) { return rec.channel.accept(frame); }
  // NB CHANNEL_ERROR may not be right, but I don't know what is ..
  else
    this.closeWithError(
      fmt('Frame on unknown channel %d', frame.channel),
      constants.CHANNEL_ERROR,
      new Error(fmt("Frame on unknown channel: %s",
                    inspect(frame, false))));
}

// Handle anything that comes through on channel 0, that's the
// connection control channel. This is only used once mainAccept is
// installed as the frame handler, after the opening handshake.
function channel0(connection) {
  return function(f) {
    // Once we get a 'close', we know 1. we'll get no more frames, and
    // 2. anything we send except close, or close-ok, will be
    // ignored. If we already sent 'close', this won't be invoked since
    // we're already in closing mode; if we didn't well we're not going
    // to send it now are we.
    if (f === HEARTBEAT); // ignore; it's already counted as activity
                          // on the socket, which is its purpose
    else if (f.id === defs.ConnectionClose) {
      // Oh. OK. I guess we're done here then.
      connection.sendMethod(0, defs.ConnectionCloseOk, {});
      var emsg = fmt('Connection closed: %s', closeMsg(f));
      var s = stackCapture(emsg);
      var e = new Error(emsg);
      e.code = f.fields.replyCode;
      if (isFatalError(e)) {
        connection.emit('error', e);
      }
      connection.toClosed(s, e);
    }
    else if (f.id === defs.ConnectionBlocked) {
      connection.emit('blocked', f.fields.reason);
    }
    else if (f.id === defs.ConnectionUnblocked) {
      connection.emit('unblocked');
    }
    else {
      connection.closeWithError(
        fmt("Unexpected frame on channel 0"),
        constants.UNEXPECTED_FRAME,
        new Error(fmt("Unexpected frame on channel 0: %s",
                      inspect(f, false))));
    }
  };
}

// This changed between versions, as did the codec, methods, etc. AMQP
// 0-9-1 is fairly similar to 0.8, but better, and nothing implements
// 0.8 that doesn't implement 0-9-1. In other words, it doesn't make
// much sense to generalise here.
C.sendProtocolHeader = function() {
  this.sendBytes(frame.PROTOCOL_HEADER);
};

/*
  The frighteningly complicated opening protocol (spec section 2.2.4):

     Client -> Server

       protocol header ->
         <- start
       start-ok ->
     .. next two zero or more times ..
         <- secure
       secure-ok ->
         <- tune
       tune-ok ->
       open ->
         <- open-ok

If I'm only supporting SASL's PLAIN mechanism (which I am for the time
being), it gets a bit easier since the server won't in general send
back a `secure`, it'll just send `tune` after the `start-ok`.
(SASL PLAIN: http://tools.ietf.org/html/rfc4616)

*/

C.open = function(allFields, openCallback0) {
  var self = this;
  var openCallback = openCallback0 || function() {};

  // This is where we'll put our negotiated values
  var tunedOptions = Object.create(allFields);

  function wait(k) {
    self.step(function(err, frame) {
      if (err !== null) bail(err);
      else if (frame.channel !== 0) {
        bail(new Error(
          fmt("Frame on channel != 0 during handshake: %s",
              inspect(frame, false))));
      }
      else k(frame);
    });
  }

  function expect(Method, k) {
    wait(function(frame) {
      if (frame.id === Method) k(frame);
      else {
        bail(new Error(
          fmt("Expected %s; got %s",
              methodName(Method), inspect(frame, false))));
      }
    });
  }

  function bail(err) {
    openCallback(err);
  }

  function send(Method) {
    // This can throw an exception if there's some problem with the
    // options; e.g., something is a string instead of a number.
    self.sendMethod(0, Method, tunedOptions);
  }

  function negotiate(server, desired) {
    // We get sent values for channelMax, frameMax and heartbeat,
    // which we may accept or lower (subject to a minimum for
    // frameMax, but we'll leave that to the server to enforce). In
    // all cases, `0` really means "no limit", or rather the highest
    // value in the encoding, e.g., unsigned short for channelMax.
    if (server === 0 || desired === 0) {
      // i.e., whichever places a limit, if either
      return Math.max(server, desired);
    }
    else {
      return Math.min(server, desired);
    }
  }

  function onStart(start) {
    var mechanisms = start.fields.mechanisms.toString().split(' ');
    if (mechanisms.indexOf(allFields.mechanism) < 0) {
      bail(new Error(fmt('SASL mechanism %s is not provided by the server',
                         allFields.mechanism)));
      return;
    }
    self.serverProperties = start.fields.serverProperties;
    try {
      send(defs.ConnectionStartOk);
    } catch (err) {
      bail(err);
      return;
    }
    wait(afterStartOk);
  }

  function afterStartOk(reply) {
    switch (reply.id) {
    case defs.ConnectionSecure:
      bail(new Error(
        "Wasn't expecting to have to go through secure"));
      break;
    case defs.ConnectionClose:
      bail(new Error(fmt("Handshake terminated by server: %s",
                         closeMsg(reply))));
      break;
    case defs.ConnectionTune:
      var fields = reply.fields;
      tunedOptions.frameMax =
        negotiate(fields.frameMax, allFields.frameMax);
      tunedOptions.channelMax =
        negotiate(fields.channelMax, allFields.channelMax);
      tunedOptions.heartbeat =
        negotiate(fields.heartbeat, allFields.heartbeat);
      try {
        send(defs.ConnectionTuneOk);
        send(defs.ConnectionOpen);
      } catch (err) {
        bail(err);
        return;
      }
      expect(defs.ConnectionOpenOk, onOpenOk);
      break;
    default:
      bail(new Error(
        fmt("Expected connection.secure, connection.close, " +
            "or connection.tune during handshake; got %s",
            inspect(reply, false))));
      break;
    }
  }

  function onOpenOk(openOk) {
    // Impose the maximum of the encoded value, if the negotiated
    // value is zero, meaning "no, no limits"
    self.channelMax = tunedOptions.channelMax || 0xffff;
    self.frameMax = tunedOptions.frameMax || 0xffffffff;
    // 0 means "no heartbeat", rather than "maximum period of
    // heartbeating"
    self.heartbeat = tunedOptions.heartbeat;
    self.heartbeater = self.startHeartbeater();
    self.accept = mainAccept;
    succeed(openOk);
  }

  // If the server closes the connection, it's probably because of
  // something we did
  function endWhileOpening(err) {
    bail(err || new Error('Socket closed abruptly ' +
                          'during opening handshake'));
  }

  this.stream.on('end', endWhileOpening);
  this.stream.on('error', endWhileOpening);

  function succeed(ok) {
    self.stream.removeListener('end', endWhileOpening);
    self.stream.removeListener('error', endWhileOpening);
    self.stream.on('error', self.onSocketError.bind(self));
    self.stream.on('end', self.onSocketError.bind(
      self, new Error('Unexpected close')));
    self.on('frameError', self.onSocketError.bind(self));
    self.acceptLoop();
    openCallback(null, ok);
  }

  // Now kick off the handshake by prompting the server
  this.sendProtocolHeader();
  expect(defs.ConnectionStart, onStart);
};

// Closing things: AMQP has a closing handshake that applies to
// closing both connects and channels. As the initiating party, I send
// Close, then ignore all frames until I see either CloseOK --
// which signifies that the other party has seen the Close and shut
// the connection or channel down, so it's fine to free resources; or
// Close, which means the other party also wanted to close the
// whatever, and I should send CloseOk so it can free resources,
// then go back to waiting for the CloseOk. If I receive a Close
// out of the blue, I should throw away any unsent frames (they will
// be ignored anyway) and send CloseOk, then clean up resources. In
// general, Close out of the blue signals an error (or a forced
// closure, which may as well be an error).
//
//  RUNNING [1] --- send Close ---> Closing [2] ---> recv Close --+
//     |                               |                         [3]
//     |                               +------ send CloseOk ------+
//  recv Close                   recv CloseOk
//     |                               |
//     V                               V
//  Ended [4] ---- send CloseOk ---> Closed [5]
//
// [1] All frames accepted; getting a Close frame from the server
// moves to Ended; client may initiate a close by sending Close
// itself.
// [2] Client has initiated a close; only CloseOk or (simulataneously
// sent) Close is accepted.
// [3] Simultaneous close
// [4] Server won't send any more frames; accept no more frames, send
// CloseOk.
// [5] Fully closed, client will send no more, server will send no
// more. Signal 'close' or 'error'.
//
// There are two signalling mechanisms used in the API. The first is
// that calling `close` will return a promise, that will either
// resolve once the connection or channel is cleanly shut down, or
// will reject if the shutdown times out.
//
// The second is the 'close' and 'error' events. These are
// emitted as above. The events will fire *before* promises are
// resolved.

// Close the connection without even giving a reason. Typical.
C.close = function(closeCallback) {
  var k = closeCallback && function() { closeCallback(null); };
  this.closeBecause("Cheers, thanks", constants.REPLY_SUCCESS, k);
};

// Close with a reason and a 'code'. I'm pretty sure RabbitMQ totally
// ignores these; maybe it logs them. The continuation will be invoked
// when the CloseOk has been received, and before the 'close' event.
C.closeBecause = function(reason, code, k) {
  this.sendMethod(0, defs.ConnectionClose, {
    replyText: reason,
    replyCode: code,
    methodId: 0, classId: 0
  });
  var s = stackCapture('closeBecause called: ' + reason);
  this.toClosing(s, k);
};

C.closeWithError = function(reason, code, error) {
  this.emit('error', error);
  this.closeBecause(reason, code);
};

C.onSocketError = function(err) {
  if (!this.expectSocketClose) {
    // forestall any more calls to onSocketError, since we're signed
    // up for `'error'` *and* `'end'`
    this.expectSocketClose = true;
    this.emit('error', err);
    var s = stackCapture('Socket error');
    this.toClosed(s, err);
  }
};

function invalidOp(msg, stack) {
  return function() {
    throw new IllegalOperationError(msg, stack);
  };
}

function invalidateSend(conn, msg, stack) {
  conn.sendMethod = conn.sendContent = conn.sendMessage =
    invalidOp(msg, stack);
}

// A close has been initiated. Repeat: a close has been initiated.
// This means we should not send more frames, anyway they will be
// ignored. We also have to shut down all the channels.
C.toClosing = function(capturedStack, k) {
  var send = this.sendMethod.bind(this);

  this.accept = function(f) {
    if (f.id === defs.ConnectionCloseOk) {
      if (k) k();
      var s = stackCapture('ConnectionCloseOk received');
      this.toClosed(s, undefined);
    }
    else if (f.id === defs.ConnectionClose) {
      send(0, defs.ConnectionCloseOk, {});
    }
    // else ignore frame
  };
  invalidateSend(this, 'Connection closing', capturedStack);
};

C._closeChannels = function(capturedStack) {
  for (var i = 1; i < this.channels.length; i++) {
    var ch = this.channels[i];
    if (ch !== null) {
      ch.channel.toClosed(capturedStack); // %%% or with an error? not clear
    }
  }
};

// A close has been confirmed. Cease all communication.
C.toClosed = function(capturedStack, maybeErr) {
  this._closeChannels(capturedStack);
  var info = fmt('Connection closed (%s)',
                 (maybeErr) ? maybeErr.toString() : 'by client');
  // Tidy up, invalidate enverything, dynamite the bridges.
  invalidateSend(this, info, capturedStack);
  this.accept = invalidOp(info, capturedStack);
  this.close = function(cb) {
    cb && cb(new IllegalOperationError(info, capturedStack));
  };
  if (this.heartbeater) this.heartbeater.clear();
  // This is certainly true now, if it wasn't before
  this.expectSocketClose = true;
  this.stream.end();
  this.emit('close', maybeErr);
};

// ===

C.startHeartbeater = function() {
  if (this.heartbeat === 0) return null;
  else {
    var self = this;
    var hb = new Heart(this.heartbeat,
                       this.checkSend.bind(this),
                       this.checkRecv.bind(this));
    hb.on('timeout', function() {
      var hberr = new Error("Heartbeat timeout");
      self.emit('error', hberr);
      var s = stackCapture('Heartbeat timeout');
      self.toClosed(s, hberr);
    });
    hb.on('beat', function() {
      self.sendHeartbeat();
    });
    return hb;
  }
};

// I use an array to keep track of the channels, rather than an
// object. The channel identifiers are numbers, and allocated by the
// connection. If I try to allocate low numbers when they are
// available (which I do, by looking from the start of the bitset),
// this ought to keep the array small, and out of 'sparse array
// storage'. I also set entries to null, rather than deleting them, in
// the expectation that the next channel allocation will fill the slot
// again rather than growing the array. See
// http://www.html5rocks.com/en/tutorials/speed/v8/
C.freshChannel = function(channel, options) {
  var next = this.freeChannels.nextClearBit(1);
  if (next < 0 || next > this.channelMax)
    throw new Error("No channels left to allocate");
  this.freeChannels.set(next);

  var hwm = (options && options.highWaterMark) || DEFAULT_WRITE_HWM;
  var writeBuffer = new PassThrough({
    objectMode: true, highWaterMark: hwm
  });
  this.channels[next] = {channel: channel, buffer: writeBuffer};
  writeBuffer.on('drain', function() {
    channel.onBufferDrain();
  });
  this.muxer.pipeFrom(writeBuffer);
  return next;
};

C.releaseChannel = function(channel) {
  this.freeChannels.clear(channel);
  var buffer = this.channels[channel].buffer;
  buffer.end(); // will also cause it to be unpiped
  this.channels[channel] = null;
};

C.acceptLoop = function() {
  var self = this;

  function go() {
    try {
      var f; while (f = self.recvFrame()) self.accept(f);
    }
    catch (e) {
      self.emit('frameError', e);
    }
  }
  self.stream.on('readable', go);
  go();
};

C.step = function(cb) {
  var self = this;
  function recv() {
    var f;
    try {
      f = self.recvFrame();
    }
    catch (e) {
      cb(e, null);
      return;
    }
    if (f) cb(null, f);
    else self.stream.once('readable', recv);
  }
  recv();
};

C.checkSend = function() {
  var check = this.sentSinceLastCheck;
  this.sentSinceLastCheck = false;
  return check;
}

C.checkRecv = function() {
  var check = this.recvSinceLastCheck;
  this.recvSinceLastCheck = false;
  return check;
}

C.sendBytes = function(bytes) {
  this.sentSinceLastCheck = true;
  this.stream.write(bytes);
};

C.sendHeartbeat = function() {
  return this.sendBytes(frame.HEARTBEAT_BUF);
};

var encodeMethod = defs.encodeMethod;
var encodeProperties = defs.encodeProperties;

C.sendMethod = function(channel, Method, fields) {
  var frame = encodeMethod(Method, channel, fields);
  this.sentSinceLastCheck = true;
  var buffer = this.channels[channel].buffer;
  return buffer.write(frame);
};

C.sendMessage = function(channel,
                         Method, fields,
                         Properties, props,
                         content) {
  if (!Buffer.isBuffer(content))
    throw new TypeError('content is not a buffer');

  var mframe = encodeMethod(Method, channel, fields);
  var pframe = encodeProperties(Properties, channel,
                                content.length, props);
  var buffer = this.channels[channel].buffer;
  this.sentSinceLastCheck = true;

  var methodHeaderLen = mframe.length + pframe.length;
  var bodyLen = (content.length > 0) ?
    content.length + FRAME_OVERHEAD : 0;
  var allLen = methodHeaderLen + bodyLen;

  if (allLen < SINGLE_CHUNK_THRESHOLD) {
    // Use `allocUnsafe` to avoid excessive allocations and CPU usage
    // from zeroing. The returned Buffer is not zeroed and so must be
    // completely filled to be used safely.
    // See https://github.com/amqp-node/amqplib/pull/695
    var all = Buffer.allocUnsafe(allLen);
    var offset = mframe.copy(all, 0);
    offset += pframe.copy(all, offset);

    if (bodyLen > 0)
      makeBodyFrame(channel, content).copy(all, offset);
    return buffer.write(all);
  }
  else {
    if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {
      // Use `allocUnsafe` to avoid excessive allocations and CPU usage
      // from zeroing. The returned Buffer is not zeroed and so must be
      // completely filled to be used safely.
      // See https://github.com/amqp-node/amqplib/pull/695
      var both = Buffer.allocUnsafe(methodHeaderLen);
      var offset = mframe.copy(both, 0);
      pframe.copy(both, offset);
      buffer.write(both);
    }
    else {
      buffer.write(mframe);
      buffer.write(pframe);
    }
    return this.sendContent(channel, content);
  }
};

var FRAME_OVERHEAD = defs.FRAME_OVERHEAD;
var makeBodyFrame = frame.makeBodyFrame;

C.sendContent = function(channel, body) {
  if (!Buffer.isBuffer(body)) {
    throw new TypeError(fmt("Expected buffer; got %s", body));
  }
  var writeResult = true;
  var buffer = this.channels[channel].buffer;

  var maxBody = this.frameMax - FRAME_OVERHEAD;

  for (var offset = 0; offset < body.length; offset += maxBody) {
    var end = offset + maxBody;
    var slice = (end > body.length) ? body.slice(offset) : body.slice(offset, end);
    var bodyFrame = makeBodyFrame(channel, slice);
    writeResult = buffer.write(bodyFrame);
  }
  this.sentSinceLastCheck = true;
  return writeResult;
};

var parseFrame = frame.parseFrame;
var decodeFrame = frame.decodeFrame;

C.recvFrame = function() {
  // %%% identifying invariants might help here?
  var frame = parseFrame(this.rest, this.frameMax);

  if (!frame) {
    var incoming = this.stream.read();
    if (incoming === null) {
      return false;
    }
    else {
      this.recvSinceLastCheck = true;
      this.rest = Buffer.concat([this.rest, incoming]);
      return this.recvFrame();
    }
  }
  else {
    this.rest = frame.rest;
    return decodeFrame(frame);
  }
};

function wrapStream(s) {
  if (s instanceof Duplex) return s;
  else {
    var ws = new Duplex();
    ws.wrap(s); //wraps the readable side of things
    ws._write = function(chunk, encoding, callback) {
      return s.write(chunk, encoding, callback);
    };
    return ws;
  }
}

function isFatalError(error) {
  switch (error && error.code) {
  case defs.constants.CONNECTION_FORCED:
  case defs.constants.REPLY_SUCCESS:
    return false;
  default:
    return true;
  }
}

module.exports.Connection = Connection;
module.exports.isFatalError = isFatalError;


/***/ }),

/***/ "./node_modules/amqplib/lib/credentials.js":
/*!*************************************************!*\
  !*** ./node_modules/amqplib/lib/credentials.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
//
//

// Different kind of credentials that can be supplied when opening a
// connection, corresponding to SASL mechanisms There's only two
// useful mechanisms that RabbitMQ implements:
//  * PLAIN (send username and password in the plain)
//  * EXTERNAL (assume the server will figure out who you are from
//    context, i.e., your SSL certificate)
var codec = __webpack_require__(/*! ./codec */ "./node_modules/amqplib/lib/codec.js")

module.exports.plain = function(user, passwd) {
  return {
    mechanism: 'PLAIN',
    response: function() {
      return Buffer.from(['', user, passwd].join(String.fromCharCode(0)))
    },
    username: user,
    password: passwd
  }
}

module.exports.amqplain = function(user, passwd) {
  return {
    mechanism: 'AMQPLAIN',
    response: function() {
      const buffer = Buffer.alloc(16384);
      const size = codec.encodeTable(buffer, { LOGIN: user, PASSWORD: passwd}, 0);
      return buffer.slice(4, size);
    },
    username: user,
    password: passwd
  }
}

module.exports.external = function() {
  return {
    mechanism: 'EXTERNAL',
    response: function() { return Buffer.from(''); }
  }
}


/***/ }),

/***/ "./node_modules/amqplib/lib/defs.js":
/*!******************************************!*\
  !*** ./node_modules/amqplib/lib/defs.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** @preserve This file is generated by the script
 * ../bin/generate-defs.js, which is not in general included in a
 * distribution, but is available in the source repository e.g. at
 * https://github.com/squaremo/amqp.node/
 */


function decodeConnectionStart(buffer) {
  var val, len, offset = 0, fields = {
    versionMajor: void 0,
    versionMinor: void 0,
    serverProperties: void 0,
    mechanisms: void 0,
    locales: void 0
  };
  val = buffer[offset];
  offset++;
  fields.versionMajor = val;
  val = buffer[offset];
  offset++;
  fields.versionMinor = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.serverProperties = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.mechanisms = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.locales = val;
  return fields;
}

function encodeConnectionStart(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
  val = fields.serverProperties;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'serverProperties'");
  if ("object" != typeof val) throw new TypeError("Field 'serverProperties' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var serverProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += serverProperties_encoded.length;
  val = fields.mechanisms;
  if (void 0 === val) val = Buffer.from("PLAIN"); else if (!Buffer.isBuffer(val)) throw new TypeError("Field 'mechanisms' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  val = fields.locales;
  if (void 0 === val) val = Buffer.from("en_US"); else if (!Buffer.isBuffer(val)) throw new TypeError("Field 'locales' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(22 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655370, 7);
  offset = 11;
  val = fields.versionMajor;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'versionMajor' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt8(val, offset);
  offset++;
  val = fields.versionMinor;
  if (void 0 === val) val = 9; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'versionMinor' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt8(val, offset);
  offset++;
  offset += serverProperties_encoded.copy(buffer, offset);
  val = fields.mechanisms;
  void 0 === val && (val = Buffer.from("PLAIN"));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  val = fields.locales;
  void 0 === val && (val = Buffer.from("en_US"));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionStartOk(buffer) {
  var val, len, offset = 0, fields = {
    clientProperties: void 0,
    mechanism: void 0,
    response: void 0,
    locale: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.clientProperties = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.mechanism = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.response = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.locale = val;
  return fields;
}

function encodeConnectionStartOk(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
  val = fields.clientProperties;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'clientProperties'");
  if ("object" != typeof val) throw new TypeError("Field 'clientProperties' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var clientProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += clientProperties_encoded.length;
  val = fields.mechanism;
  if (void 0 === val) val = "PLAIN"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'mechanism' is the wrong type; must be a string (up to 255 chars)");
  var mechanism_len = Buffer.byteLength(val, "utf8");
  varyingSize += mechanism_len;
  val = fields.response;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'response'");
  if (!Buffer.isBuffer(val)) throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  val = fields.locale;
  if (void 0 === val) val = "en_US"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'locale' is the wrong type; must be a string (up to 255 chars)");
  var locale_len = Buffer.byteLength(val, "utf8");
  varyingSize += locale_len;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655371, 7);
  offset = 11;
  offset += clientProperties_encoded.copy(buffer, offset);
  val = fields.mechanism;
  void 0 === val && (val = "PLAIN");
  buffer[offset] = mechanism_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += mechanism_len;
  val = fields.response;
  void 0 === val && (val = Buffer.from(void 0));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  val = fields.locale;
  void 0 === val && (val = "en_US");
  buffer[offset] = locale_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += locale_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionSecure(buffer) {
  var val, len, offset = 0, fields = {
    challenge: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.challenge = val;
  return fields;
}

function encodeConnectionSecure(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0;
  val = fields.challenge;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'challenge'");
  if (!Buffer.isBuffer(val)) throw new TypeError("Field 'challenge' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655380, 7);
  offset = 11;
  val = fields.challenge;
  void 0 === val && (val = Buffer.from(void 0));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionSecureOk(buffer) {
  var val, len, offset = 0, fields = {
    response: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.response = val;
  return fields;
}

function encodeConnectionSecureOk(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0;
  val = fields.response;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'response'");
  if (!Buffer.isBuffer(val)) throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655381, 7);
  offset = 11;
  val = fields.response;
  void 0 === val && (val = Buffer.from(void 0));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionTune(buffer) {
  var val, offset = 0, fields = {
    channelMax: void 0,
    frameMax: void 0,
    heartbeat: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.channelMax = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.frameMax = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.heartbeat = val;
  return fields;
}

function encodeConnectionTune(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(20);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655390, 7);
  offset = 11;
  val = fields.channelMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.frameMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.heartbeat;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionTuneOk(buffer) {
  var val, offset = 0, fields = {
    channelMax: void 0,
    frameMax: void 0,
    heartbeat: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.channelMax = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.frameMax = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.heartbeat = val;
  return fields;
}

function encodeConnectionTuneOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(20);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655391, 7);
  offset = 11;
  val = fields.channelMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.frameMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.heartbeat;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionOpen(buffer) {
  var val, len, offset = 0, fields = {
    virtualHost: void 0,
    capabilities: void 0,
    insist: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.virtualHost = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.capabilities = val;
  val = !!(1 & buffer[offset]);
  fields.insist = val;
  return fields;
}

function encodeConnectionOpen(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.virtualHost;
  if (void 0 === val) val = "/"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'virtualHost' is the wrong type; must be a string (up to 255 chars)");
  var virtualHost_len = Buffer.byteLength(val, "utf8");
  varyingSize += virtualHost_len;
  val = fields.capabilities;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'capabilities' is the wrong type; must be a string (up to 255 chars)");
  var capabilities_len = Buffer.byteLength(val, "utf8");
  varyingSize += capabilities_len;
  var buffer = Buffer.alloc(15 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655400, 7);
  offset = 11;
  val = fields.virtualHost;
  void 0 === val && (val = "/");
  buffer[offset] = virtualHost_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += virtualHost_len;
  val = fields.capabilities;
  void 0 === val && (val = "");
  buffer[offset] = capabilities_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += capabilities_len;
  val = fields.insist;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionOpenOk(buffer) {
  var val, len, offset = 0, fields = {
    knownHosts: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.knownHosts = val;
  return fields;
}

function encodeConnectionOpenOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.knownHosts;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'knownHosts' is the wrong type; must be a string (up to 255 chars)");
  var knownHosts_len = Buffer.byteLength(val, "utf8");
  varyingSize += knownHosts_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655401, 7);
  offset = 11;
  val = fields.knownHosts;
  void 0 === val && (val = "");
  buffer[offset] = knownHosts_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += knownHosts_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionClose(buffer) {
  var val, len, offset = 0, fields = {
    replyCode: void 0,
    replyText: void 0,
    classId: void 0,
    methodId: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.replyCode = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.replyText = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.classId = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.methodId = val;
  return fields;
}

function encodeConnectionClose(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.replyText;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
  var replyText_len = Buffer.byteLength(val, "utf8");
  varyingSize += replyText_len;
  var buffer = Buffer.alloc(19 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655410, 7);
  offset = 11;
  val = fields.replyCode;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'replyCode'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.replyText;
  void 0 === val && (val = "");
  buffer[offset] = replyText_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += replyText_len;
  val = fields.classId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'classId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.methodId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'methodId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionCloseOk(buffer) {
  return {};
}

function encodeConnectionCloseOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655411, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionBlocked(buffer) {
  var val, len, offset = 0, fields = {
    reason: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.reason = val;
  return fields;
}

function encodeConnectionBlocked(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.reason;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'reason' is the wrong type; must be a string (up to 255 chars)");
  var reason_len = Buffer.byteLength(val, "utf8");
  varyingSize += reason_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655420, 7);
  offset = 11;
  val = fields.reason;
  void 0 === val && (val = "");
  buffer[offset] = reason_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += reason_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionUnblocked(buffer) {
  return {};
}

function encodeConnectionUnblocked(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655421, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelOpen(buffer) {
  var val, len, offset = 0, fields = {
    outOfBand: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.outOfBand = val;
  return fields;
}

function encodeChannelOpen(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.outOfBand;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'outOfBand' is the wrong type; must be a string (up to 255 chars)");
  var outOfBand_len = Buffer.byteLength(val, "utf8");
  varyingSize += outOfBand_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310730, 7);
  offset = 11;
  val = fields.outOfBand;
  void 0 === val && (val = "");
  buffer[offset] = outOfBand_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += outOfBand_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelOpenOk(buffer) {
  var val, len, offset = 0, fields = {
    channelId: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.channelId = val;
  return fields;
}

function encodeChannelOpenOk(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0;
  val = fields.channelId;
  if (void 0 === val) val = Buffer.from(""); else if (!Buffer.isBuffer(val)) throw new TypeError("Field 'channelId' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310731, 7);
  offset = 11;
  val = fields.channelId;
  void 0 === val && (val = Buffer.from(""));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelFlow(buffer) {
  var val, fields = {
    active: void 0
  };
  val = !!(1 & buffer[0]);
  fields.active = val;
  return fields;
}

function encodeChannelFlow(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310740, 7);
  offset = 11;
  val = fields.active;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'active'");
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelFlowOk(buffer) {
  var val, fields = {
    active: void 0
  };
  val = !!(1 & buffer[0]);
  fields.active = val;
  return fields;
}

function encodeChannelFlowOk(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310741, 7);
  offset = 11;
  val = fields.active;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'active'");
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelClose(buffer) {
  var val, len, offset = 0, fields = {
    replyCode: void 0,
    replyText: void 0,
    classId: void 0,
    methodId: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.replyCode = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.replyText = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.classId = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.methodId = val;
  return fields;
}

function encodeChannelClose(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.replyText;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
  var replyText_len = Buffer.byteLength(val, "utf8");
  varyingSize += replyText_len;
  var buffer = Buffer.alloc(19 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310760, 7);
  offset = 11;
  val = fields.replyCode;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'replyCode'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.replyText;
  void 0 === val && (val = "");
  buffer[offset] = replyText_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += replyText_len;
  val = fields.classId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'classId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.methodId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'methodId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelCloseOk(buffer) {
  return {};
}

function encodeChannelCloseOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310761, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeAccessRequest(buffer) {
  var val, len, offset = 0, fields = {
    realm: void 0,
    exclusive: void 0,
    passive: void 0,
    active: void 0,
    write: void 0,
    read: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.realm = val;
  val = !!(1 & buffer[offset]);
  fields.exclusive = val;
  val = !!(2 & buffer[offset]);
  fields.passive = val;
  val = !!(4 & buffer[offset]);
  fields.active = val;
  val = !!(8 & buffer[offset]);
  fields.write = val;
  val = !!(16 & buffer[offset]);
  fields.read = val;
  return fields;
}

function encodeAccessRequest(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.realm;
  if (void 0 === val) val = "/data"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'realm' is the wrong type; must be a string (up to 255 chars)");
  var realm_len = Buffer.byteLength(val, "utf8");
  varyingSize += realm_len;
  var buffer = Buffer.alloc(14 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1966090, 7);
  offset = 11;
  val = fields.realm;
  void 0 === val && (val = "/data");
  buffer[offset] = realm_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += realm_len;
  val = fields.exclusive;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.passive;
  void 0 === val && (val = !0);
  val && (bits += 2);
  val = fields.active;
  void 0 === val && (val = !0);
  val && (bits += 4);
  val = fields.write;
  void 0 === val && (val = !0);
  val && (bits += 8);
  val = fields.read;
  void 0 === val && (val = !0);
  val && (bits += 16);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeAccessRequestOk(buffer) {
  var val, offset = 0, fields = {
    ticket: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  return fields;
}

function encodeAccessRequestOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(14);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1966091, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 1; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDeclare(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    exchange: void 0,
    type: void 0,
    passive: void 0,
    durable: void 0,
    autoDelete: void 0,
    internal: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.type = val;
  val = !!(1 & buffer[offset]);
  fields.passive = val;
  val = !!(2 & buffer[offset]);
  fields.durable = val;
  val = !!(4 & buffer[offset]);
  fields.autoDelete = val;
  val = !!(8 & buffer[offset]);
  fields.internal = val;
  val = !!(16 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeExchangeDeclare(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.type;
  if (void 0 === val) val = "direct"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
  var type_len = Buffer.byteLength(val, "utf8");
  varyingSize += type_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621450, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.type;
  void 0 === val && (val = "direct");
  buffer[offset] = type_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += type_len;
  val = fields.passive;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.durable;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.autoDelete;
  void 0 === val && (val = !1);
  val && (bits += 4);
  val = fields.internal;
  void 0 === val && (val = !1);
  val && (bits += 8);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 16);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDeclareOk(buffer) {
  return {};
}

function encodeExchangeDeclareOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621451, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDelete(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    exchange: void 0,
    ifUnused: void 0,
    nowait: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  val = !!(1 & buffer[offset]);
  fields.ifUnused = val;
  val = !!(2 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeExchangeDelete(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621460, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.ifUnused;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 2);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDeleteOk(buffer) {
  return {};
}

function encodeExchangeDeleteOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621461, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeBind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    destination: void 0,
    source: void 0,
    routingKey: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.destination = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.source = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeExchangeBind(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.destination;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'destination'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
  var destination_len = Buffer.byteLength(val, "utf8");
  varyingSize += destination_len;
  val = fields.source;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'source'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
  var source_len = Buffer.byteLength(val, "utf8");
  varyingSize += source_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621470, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.destination;
  void 0 === val && (val = void 0);
  buffer[offset] = destination_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += destination_len;
  val = fields.source;
  void 0 === val && (val = void 0);
  buffer[offset] = source_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += source_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeBindOk(buffer) {
  return {};
}

function encodeExchangeBindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621471, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeUnbind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    destination: void 0,
    source: void 0,
    routingKey: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.destination = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.source = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeExchangeUnbind(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.destination;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'destination'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
  var destination_len = Buffer.byteLength(val, "utf8");
  varyingSize += destination_len;
  val = fields.source;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'source'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
  var source_len = Buffer.byteLength(val, "utf8");
  varyingSize += source_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621480, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.destination;
  void 0 === val && (val = void 0);
  buffer[offset] = destination_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += destination_len;
  val = fields.source;
  void 0 === val && (val = void 0);
  buffer[offset] = source_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += source_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeUnbindOk(buffer) {
  return {};
}

function encodeExchangeUnbindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621491, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDeclare(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    passive: void 0,
    durable: void 0,
    exclusive: void 0,
    autoDelete: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.passive = val;
  val = !!(2 & buffer[offset]);
  fields.durable = val;
  val = !!(4 & buffer[offset]);
  fields.exclusive = val;
  val = !!(8 & buffer[offset]);
  fields.autoDelete = val;
  val = !!(16 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeQueueDeclare(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276810, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.passive;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.durable;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.exclusive;
  void 0 === val && (val = !1);
  val && (bits += 4);
  val = fields.autoDelete;
  void 0 === val && (val = !1);
  val && (bits += 8);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 16);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDeclareOk(buffer) {
  var val, len, offset = 0, fields = {
    queue: void 0,
    messageCount: void 0,
    consumerCount: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.consumerCount = val;
  return fields;
}

function encodeQueueDeclareOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'queue'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(21 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276811, 7);
  offset = 11;
  val = fields.queue;
  void 0 === val && (val = void 0);
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.consumerCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'consumerCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueBind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    exchange: void 0,
    routingKey: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeQueueBind(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276820, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueBindOk(buffer) {
  return {};
}

function encodeQueueBindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276821, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueuePurge(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    nowait: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeQueuePurge(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276830, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueuePurgeOk(buffer) {
  var val, offset = 0, fields = {
    messageCount: void 0
  };
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  return fields;
}

function encodeQueuePurgeOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(16);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276831, 7);
  offset = 11;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDelete(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    ifUnused: void 0,
    ifEmpty: void 0,
    nowait: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.ifUnused = val;
  val = !!(2 & buffer[offset]);
  fields.ifEmpty = val;
  val = !!(4 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeQueueDelete(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276840, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.ifUnused;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.ifEmpty;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 4);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDeleteOk(buffer) {
  var val, offset = 0, fields = {
    messageCount: void 0
  };
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  return fields;
}

function encodeQueueDeleteOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(16);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276841, 7);
  offset = 11;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueUnbind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    exchange: void 0,
    routingKey: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeQueueUnbind(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276850, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueUnbindOk(buffer) {
  return {};
}

function encodeQueueUnbindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276851, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicQos(buffer) {
  var val, offset = 0, fields = {
    prefetchSize: void 0,
    prefetchCount: void 0,
    global: void 0
  };
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.prefetchSize = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.prefetchCount = val;
  val = !!(1 & buffer[offset]);
  fields.global = val;
  return fields;
}

function encodeBasicQos(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(19);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932170, 7);
  offset = 11;
  val = fields.prefetchSize;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'prefetchSize' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.prefetchCount;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'prefetchCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.global;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicQosOk(buffer) {
  return {};
}

function encodeBasicQosOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932171, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicConsume(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    consumerTag: void 0,
    noLocal: void 0,
    noAck: void 0,
    exclusive: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  val = !!(1 & buffer[offset]);
  fields.noLocal = val;
  val = !!(2 & buffer[offset]);
  fields.noAck = val;
  val = !!(4 & buffer[offset]);
  fields.exclusive = val;
  val = !!(8 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeBasicConsume(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.consumerTag;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932180, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.consumerTag;
  void 0 === val && (val = "");
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  val = fields.noLocal;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.noAck;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.exclusive;
  void 0 === val && (val = !1);
  val && (bits += 4);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 8);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicConsumeOk(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  return fields;
}

function encodeBasicConsumeOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932181, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicCancel(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0,
    nowait: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeBasicCancel(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  var buffer = Buffer.alloc(14 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932190, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicCancelOk(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  return fields;
}

function encodeBasicCancelOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932191, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicPublish(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    exchange: void 0,
    routingKey: void 0,
    mandatory: void 0,
    immediate: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.mandatory = val;
  val = !!(2 & buffer[offset]);
  fields.immediate = val;
  return fields;
}

function encodeBasicPublish(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.exchange;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932200, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.exchange;
  void 0 === val && (val = "");
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.mandatory;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.immediate;
  void 0 === val && (val = !1);
  val && (bits += 2);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicReturn(buffer) {
  var val, len, offset = 0, fields = {
    replyCode: void 0,
    replyText: void 0,
    exchange: void 0,
    routingKey: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.replyCode = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.replyText = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  return fields;
}

function encodeBasicReturn(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.replyText;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
  var replyText_len = Buffer.byteLength(val, "utf8");
  varyingSize += replyText_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'routingKey'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932210, 7);
  offset = 11;
  val = fields.replyCode;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'replyCode'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.replyText;
  void 0 === val && (val = "");
  buffer[offset] = replyText_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += replyText_len;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = void 0);
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicDeliver(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0,
    deliveryTag: void 0,
    redelivered: void 0,
    exchange: void 0,
    routingKey: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.redelivered = val;
  offset++;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  return fields;
}

function encodeBasicDeliver(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'routingKey'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(24 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932220, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  val = fields.deliveryTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'deliveryTag'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.redelivered;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = void 0);
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicGet(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    noAck: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.noAck = val;
  return fields;
}

function encodeBasicGet(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932230, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.noAck;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicGetOk(buffer) {
  var val, len, offset = 0, fields = {
    deliveryTag: void 0,
    redelivered: void 0,
    exchange: void 0,
    routingKey: void 0,
    messageCount: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.redelivered = val;
  offset++;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  return fields;
}

function encodeBasicGetOk(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'routingKey'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(27 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932231, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'deliveryTag'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.redelivered;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = void 0);
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicGetEmpty(buffer) {
  var val, len, offset = 0, fields = {
    clusterId: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.clusterId = val;
  return fields;
}

function encodeBasicGetEmpty(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.clusterId;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
  var clusterId_len = Buffer.byteLength(val, "utf8");
  varyingSize += clusterId_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932232, 7);
  offset = 11;
  val = fields.clusterId;
  void 0 === val && (val = "");
  buffer[offset] = clusterId_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += clusterId_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicAck(buffer) {
  var val, offset = 0, fields = {
    deliveryTag: void 0,
    multiple: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.multiple = val;
  return fields;
}

function encodeBasicAck(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932240, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.multiple;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicReject(buffer) {
  var val, offset = 0, fields = {
    deliveryTag: void 0,
    requeue: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.requeue = val;
  return fields;
}

function encodeBasicReject(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932250, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'deliveryTag'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.requeue;
  void 0 === val && (val = !0);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicRecoverAsync(buffer) {
  var val, fields = {
    requeue: void 0
  };
  val = !!(1 & buffer[0]);
  fields.requeue = val;
  return fields;
}

function encodeBasicRecoverAsync(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932260, 7);
  offset = 11;
  val = fields.requeue;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicRecover(buffer) {
  var val, fields = {
    requeue: void 0
  };
  val = !!(1 & buffer[0]);
  fields.requeue = val;
  return fields;
}

function encodeBasicRecover(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932270, 7);
  offset = 11;
  val = fields.requeue;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicRecoverOk(buffer) {
  return {};
}

function encodeBasicRecoverOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932271, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicNack(buffer) {
  var val, offset = 0, fields = {
    deliveryTag: void 0,
    multiple: void 0,
    requeue: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.multiple = val;
  val = !!(2 & buffer[offset]);
  fields.requeue = val;
  return fields;
}

function encodeBasicNack(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932280, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.multiple;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.requeue;
  void 0 === val && (val = !0);
  val && (bits += 2);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxSelect(buffer) {
  return {};
}

function encodeTxSelect(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898250, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxSelectOk(buffer) {
  return {};
}

function encodeTxSelectOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898251, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxCommit(buffer) {
  return {};
}

function encodeTxCommit(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898260, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxCommitOk(buffer) {
  return {};
}

function encodeTxCommitOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898261, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxRollback(buffer) {
  return {};
}

function encodeTxRollback(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898270, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxRollbackOk(buffer) {
  return {};
}

function encodeTxRollbackOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898271, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConfirmSelect(buffer) {
  var val, fields = {
    nowait: void 0
  };
  val = !!(1 & buffer[0]);
  fields.nowait = val;
  return fields;
}

function encodeConfirmSelect(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5570570, 7);
  offset = 11;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConfirmSelectOk(buffer) {
  return {};
}

function encodeConfirmSelectOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5570571, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function encodeBasicProperties(channel, size, fields) {
  var val, len, offset = 0, flags = 0, scratchOffset = 0, varyingSize = 0;
  val = fields.contentType;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'contentType' is the wrong type; must be a string (up to 255 chars)");
    var contentType_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += contentType_len;
  }
  val = fields.contentEncoding;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'contentEncoding' is the wrong type; must be a string (up to 255 chars)");
    var contentEncoding_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += contentEncoding_len;
  }
  val = fields.headers;
  if (void 0 != val) {
    if ("object" != typeof val) throw new TypeError("Field 'headers' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var headers_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += headers_encoded.length;
  }
  val = fields.deliveryMode;
  if (void 0 != val) {
    if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryMode' is the wrong type; must be a number (but not NaN)");
    varyingSize += 1;
  }
  val = fields.priority;
  if (void 0 != val) {
    if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'priority' is the wrong type; must be a number (but not NaN)");
    varyingSize += 1;
  }
  val = fields.correlationId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'correlationId' is the wrong type; must be a string (up to 255 chars)");
    var correlationId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += correlationId_len;
  }
  val = fields.replyTo;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyTo' is the wrong type; must be a string (up to 255 chars)");
    var replyTo_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += replyTo_len;
  }
  val = fields.expiration;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'expiration' is the wrong type; must be a string (up to 255 chars)");
    var expiration_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += expiration_len;
  }
  val = fields.messageId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'messageId' is the wrong type; must be a string (up to 255 chars)");
    var messageId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += messageId_len;
  }
  val = fields.timestamp;
  if (void 0 != val) {
    if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'timestamp' is the wrong type; must be a number (but not NaN)");
    varyingSize += 8;
  }
  val = fields.type;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
    var type_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += type_len;
  }
  val = fields.userId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'userId' is the wrong type; must be a string (up to 255 chars)");
    var userId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += userId_len;
  }
  val = fields.appId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'appId' is the wrong type; must be a string (up to 255 chars)");
    var appId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += appId_len;
  }
  val = fields.clusterId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
    var clusterId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += clusterId_len;
  }
  var buffer = Buffer.alloc(22 + varyingSize);
  buffer[0] = 2;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932160, 7);
  ints.writeUInt64BE(buffer, size, 11);
  flags = 0;
  offset = 21;
  val = fields.contentType;
  if (void 0 != val) {
    flags += 32768;
    buffer[offset] = contentType_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += contentType_len;
  }
  val = fields.contentEncoding;
  if (void 0 != val) {
    flags += 16384;
    buffer[offset] = contentEncoding_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += contentEncoding_len;
  }
  val = fields.headers;
  if (void 0 != val) {
    flags += 8192;
    offset += headers_encoded.copy(buffer, offset);
  }
  val = fields.deliveryMode;
  if (void 0 != val) {
    flags += 4096;
    buffer.writeUInt8(val, offset);
    offset++;
  }
  val = fields.priority;
  if (void 0 != val) {
    flags += 2048;
    buffer.writeUInt8(val, offset);
    offset++;
  }
  val = fields.correlationId;
  if (void 0 != val) {
    flags += 1024;
    buffer[offset] = correlationId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += correlationId_len;
  }
  val = fields.replyTo;
  if (void 0 != val) {
    flags += 512;
    buffer[offset] = replyTo_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += replyTo_len;
  }
  val = fields.expiration;
  if (void 0 != val) {
    flags += 256;
    buffer[offset] = expiration_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += expiration_len;
  }
  val = fields.messageId;
  if (void 0 != val) {
    flags += 128;
    buffer[offset] = messageId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += messageId_len;
  }
  val = fields.timestamp;
  if (void 0 != val) {
    flags += 64;
    ints.writeUInt64BE(buffer, val, offset);
    offset += 8;
  }
  val = fields.type;
  if (void 0 != val) {
    flags += 32;
    buffer[offset] = type_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += type_len;
  }
  val = fields.userId;
  if (void 0 != val) {
    flags += 16;
    buffer[offset] = userId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += userId_len;
  }
  val = fields.appId;
  if (void 0 != val) {
    flags += 8;
    buffer[offset] = appId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += appId_len;
  }
  val = fields.clusterId;
  if (void 0 != val) {
    flags += 4;
    buffer[offset] = clusterId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += clusterId_len;
  }
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  buffer.writeUInt16BE(flags, 19);
  return buffer.slice(0, offset + 1);
}

function decodeBasicProperties(buffer) {
  var flags, val, len, offset = 2;
  flags = buffer.readUInt16BE(0);
  if (0 === flags) return {};
  var fields = {
    contentType: void 0,
    contentEncoding: void 0,
    headers: void 0,
    deliveryMode: void 0,
    priority: void 0,
    correlationId: void 0,
    replyTo: void 0,
    expiration: void 0,
    messageId: void 0,
    timestamp: void 0,
    type: void 0,
    userId: void 0,
    appId: void 0,
    clusterId: void 0
  };
  if (32768 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.contentType = val;
  }
  if (16384 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.contentEncoding = val;
  }
  if (8192 & flags) {
    len = buffer.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer.slice(offset, offset + len));
    offset += len;
    fields.headers = val;
  }
  if (4096 & flags) {
    val = buffer[offset];
    offset++;
    fields.deliveryMode = val;
  }
  if (2048 & flags) {
    val = buffer[offset];
    offset++;
    fields.priority = val;
  }
  if (1024 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.correlationId = val;
  }
  if (512 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.replyTo = val;
  }
  if (256 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.expiration = val;
  }
  if (128 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.messageId = val;
  }
  if (64 & flags) {
    val = ints.readUInt64BE(buffer, offset);
    offset += 8;
    fields.timestamp = val;
  }
  if (32 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.type = val;
  }
  if (16 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.userId = val;
  }
  if (8 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.appId = val;
  }
  if (4 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.clusterId = val;
  }
  return fields;
}

var codec = __webpack_require__(/*! ./codec */ "./node_modules/amqplib/lib/codec.js"), ints = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js"), encodeTable = codec.encodeTable, decodeFields = codec.decodeFields, SCRATCH = Buffer.alloc(65536), EMPTY_OBJECT = Object.freeze({});

module.exports.constants = {
  FRAME_METHOD: 1,
  FRAME_HEADER: 2,
  FRAME_BODY: 3,
  FRAME_HEARTBEAT: 8,
  FRAME_MIN_SIZE: 4096,
  FRAME_END: 206,
  REPLY_SUCCESS: 200,
  CONTENT_TOO_LARGE: 311,
  NO_ROUTE: 312,
  NO_CONSUMERS: 313,
  ACCESS_REFUSED: 403,
  NOT_FOUND: 404,
  RESOURCE_LOCKED: 405,
  PRECONDITION_FAILED: 406,
  CONNECTION_FORCED: 320,
  INVALID_PATH: 402,
  FRAME_ERROR: 501,
  SYNTAX_ERROR: 502,
  COMMAND_INVALID: 503,
  CHANNEL_ERROR: 504,
  UNEXPECTED_FRAME: 505,
  RESOURCE_ERROR: 506,
  NOT_ALLOWED: 530,
  NOT_IMPLEMENTED: 540,
  INTERNAL_ERROR: 541
};

module.exports.constant_strs = {
  "1": "FRAME-METHOD",
  "2": "FRAME-HEADER",
  "3": "FRAME-BODY",
  "8": "FRAME-HEARTBEAT",
  "200": "REPLY-SUCCESS",
  "206": "FRAME-END",
  "311": "CONTENT-TOO-LARGE",
  "312": "NO-ROUTE",
  "313": "NO-CONSUMERS",
  "320": "CONNECTION-FORCED",
  "402": "INVALID-PATH",
  "403": "ACCESS-REFUSED",
  "404": "NOT-FOUND",
  "405": "RESOURCE-LOCKED",
  "406": "PRECONDITION-FAILED",
  "501": "FRAME-ERROR",
  "502": "SYNTAX-ERROR",
  "503": "COMMAND-INVALID",
  "504": "CHANNEL-ERROR",
  "505": "UNEXPECTED-FRAME",
  "506": "RESOURCE-ERROR",
  "530": "NOT-ALLOWED",
  "540": "NOT-IMPLEMENTED",
  "541": "INTERNAL-ERROR",
  "4096": "FRAME-MIN-SIZE"
};

module.exports.FRAME_OVERHEAD = 8;

module.exports.decode = function(id, buf) {
  switch (id) {
   case 655370:
    return decodeConnectionStart(buf);

   case 655371:
    return decodeConnectionStartOk(buf);

   case 655380:
    return decodeConnectionSecure(buf);

   case 655381:
    return decodeConnectionSecureOk(buf);

   case 655390:
    return decodeConnectionTune(buf);

   case 655391:
    return decodeConnectionTuneOk(buf);

   case 655400:
    return decodeConnectionOpen(buf);

   case 655401:
    return decodeConnectionOpenOk(buf);

   case 655410:
    return decodeConnectionClose(buf);

   case 655411:
    return decodeConnectionCloseOk(buf);

   case 655420:
    return decodeConnectionBlocked(buf);

   case 655421:
    return decodeConnectionUnblocked(buf);

   case 1310730:
    return decodeChannelOpen(buf);

   case 1310731:
    return decodeChannelOpenOk(buf);

   case 1310740:
    return decodeChannelFlow(buf);

   case 1310741:
    return decodeChannelFlowOk(buf);

   case 1310760:
    return decodeChannelClose(buf);

   case 1310761:
    return decodeChannelCloseOk(buf);

   case 1966090:
    return decodeAccessRequest(buf);

   case 1966091:
    return decodeAccessRequestOk(buf);

   case 2621450:
    return decodeExchangeDeclare(buf);

   case 2621451:
    return decodeExchangeDeclareOk(buf);

   case 2621460:
    return decodeExchangeDelete(buf);

   case 2621461:
    return decodeExchangeDeleteOk(buf);

   case 2621470:
    return decodeExchangeBind(buf);

   case 2621471:
    return decodeExchangeBindOk(buf);

   case 2621480:
    return decodeExchangeUnbind(buf);

   case 2621491:
    return decodeExchangeUnbindOk(buf);

   case 3276810:
    return decodeQueueDeclare(buf);

   case 3276811:
    return decodeQueueDeclareOk(buf);

   case 3276820:
    return decodeQueueBind(buf);

   case 3276821:
    return decodeQueueBindOk(buf);

   case 3276830:
    return decodeQueuePurge(buf);

   case 3276831:
    return decodeQueuePurgeOk(buf);

   case 3276840:
    return decodeQueueDelete(buf);

   case 3276841:
    return decodeQueueDeleteOk(buf);

   case 3276850:
    return decodeQueueUnbind(buf);

   case 3276851:
    return decodeQueueUnbindOk(buf);

   case 3932170:
    return decodeBasicQos(buf);

   case 3932171:
    return decodeBasicQosOk(buf);

   case 3932180:
    return decodeBasicConsume(buf);

   case 3932181:
    return decodeBasicConsumeOk(buf);

   case 3932190:
    return decodeBasicCancel(buf);

   case 3932191:
    return decodeBasicCancelOk(buf);

   case 3932200:
    return decodeBasicPublish(buf);

   case 3932210:
    return decodeBasicReturn(buf);

   case 3932220:
    return decodeBasicDeliver(buf);

   case 3932230:
    return decodeBasicGet(buf);

   case 3932231:
    return decodeBasicGetOk(buf);

   case 3932232:
    return decodeBasicGetEmpty(buf);

   case 3932240:
    return decodeBasicAck(buf);

   case 3932250:
    return decodeBasicReject(buf);

   case 3932260:
    return decodeBasicRecoverAsync(buf);

   case 3932270:
    return decodeBasicRecover(buf);

   case 3932271:
    return decodeBasicRecoverOk(buf);

   case 3932280:
    return decodeBasicNack(buf);

   case 5898250:
    return decodeTxSelect(buf);

   case 5898251:
    return decodeTxSelectOk(buf);

   case 5898260:
    return decodeTxCommit(buf);

   case 5898261:
    return decodeTxCommitOk(buf);

   case 5898270:
    return decodeTxRollback(buf);

   case 5898271:
    return decodeTxRollbackOk(buf);

   case 5570570:
    return decodeConfirmSelect(buf);

   case 5570571:
    return decodeConfirmSelectOk(buf);

   case 60:
    return decodeBasicProperties(buf);

   default:
    throw new Error("Unknown class/method ID");
  }
};

module.exports.encodeMethod = function(id, channel, fields) {
  switch (id) {
   case 655370:
    return encodeConnectionStart(channel, fields);

   case 655371:
    return encodeConnectionStartOk(channel, fields);

   case 655380:
    return encodeConnectionSecure(channel, fields);

   case 655381:
    return encodeConnectionSecureOk(channel, fields);

   case 655390:
    return encodeConnectionTune(channel, fields);

   case 655391:
    return encodeConnectionTuneOk(channel, fields);

   case 655400:
    return encodeConnectionOpen(channel, fields);

   case 655401:
    return encodeConnectionOpenOk(channel, fields);

   case 655410:
    return encodeConnectionClose(channel, fields);

   case 655411:
    return encodeConnectionCloseOk(channel, fields);

   case 655420:
    return encodeConnectionBlocked(channel, fields);

   case 655421:
    return encodeConnectionUnblocked(channel, fields);

   case 1310730:
    return encodeChannelOpen(channel, fields);

   case 1310731:
    return encodeChannelOpenOk(channel, fields);

   case 1310740:
    return encodeChannelFlow(channel, fields);

   case 1310741:
    return encodeChannelFlowOk(channel, fields);

   case 1310760:
    return encodeChannelClose(channel, fields);

   case 1310761:
    return encodeChannelCloseOk(channel, fields);

   case 1966090:
    return encodeAccessRequest(channel, fields);

   case 1966091:
    return encodeAccessRequestOk(channel, fields);

   case 2621450:
    return encodeExchangeDeclare(channel, fields);

   case 2621451:
    return encodeExchangeDeclareOk(channel, fields);

   case 2621460:
    return encodeExchangeDelete(channel, fields);

   case 2621461:
    return encodeExchangeDeleteOk(channel, fields);

   case 2621470:
    return encodeExchangeBind(channel, fields);

   case 2621471:
    return encodeExchangeBindOk(channel, fields);

   case 2621480:
    return encodeExchangeUnbind(channel, fields);

   case 2621491:
    return encodeExchangeUnbindOk(channel, fields);

   case 3276810:
    return encodeQueueDeclare(channel, fields);

   case 3276811:
    return encodeQueueDeclareOk(channel, fields);

   case 3276820:
    return encodeQueueBind(channel, fields);

   case 3276821:
    return encodeQueueBindOk(channel, fields);

   case 3276830:
    return encodeQueuePurge(channel, fields);

   case 3276831:
    return encodeQueuePurgeOk(channel, fields);

   case 3276840:
    return encodeQueueDelete(channel, fields);

   case 3276841:
    return encodeQueueDeleteOk(channel, fields);

   case 3276850:
    return encodeQueueUnbind(channel, fields);

   case 3276851:
    return encodeQueueUnbindOk(channel, fields);

   case 3932170:
    return encodeBasicQos(channel, fields);

   case 3932171:
    return encodeBasicQosOk(channel, fields);

   case 3932180:
    return encodeBasicConsume(channel, fields);

   case 3932181:
    return encodeBasicConsumeOk(channel, fields);

   case 3932190:
    return encodeBasicCancel(channel, fields);

   case 3932191:
    return encodeBasicCancelOk(channel, fields);

   case 3932200:
    return encodeBasicPublish(channel, fields);

   case 3932210:
    return encodeBasicReturn(channel, fields);

   case 3932220:
    return encodeBasicDeliver(channel, fields);

   case 3932230:
    return encodeBasicGet(channel, fields);

   case 3932231:
    return encodeBasicGetOk(channel, fields);

   case 3932232:
    return encodeBasicGetEmpty(channel, fields);

   case 3932240:
    return encodeBasicAck(channel, fields);

   case 3932250:
    return encodeBasicReject(channel, fields);

   case 3932260:
    return encodeBasicRecoverAsync(channel, fields);

   case 3932270:
    return encodeBasicRecover(channel, fields);

   case 3932271:
    return encodeBasicRecoverOk(channel, fields);

   case 3932280:
    return encodeBasicNack(channel, fields);

   case 5898250:
    return encodeTxSelect(channel, fields);

   case 5898251:
    return encodeTxSelectOk(channel, fields);

   case 5898260:
    return encodeTxCommit(channel, fields);

   case 5898261:
    return encodeTxCommitOk(channel, fields);

   case 5898270:
    return encodeTxRollback(channel, fields);

   case 5898271:
    return encodeTxRollbackOk(channel, fields);

   case 5570570:
    return encodeConfirmSelect(channel, fields);

   case 5570571:
    return encodeConfirmSelectOk(channel, fields);

   default:
    throw new Error("Unknown class/method ID");
  }
};

module.exports.encodeProperties = function(id, channel, size, fields) {
  switch (id) {
   case 60:
    return encodeBasicProperties(channel, size, fields);

   default:
    throw new Error("Unknown class/properties ID");
  }
};

module.exports.info = function(id) {
  switch (id) {
   case 655370:
    return methodInfoConnectionStart;

   case 655371:
    return methodInfoConnectionStartOk;

   case 655380:
    return methodInfoConnectionSecure;

   case 655381:
    return methodInfoConnectionSecureOk;

   case 655390:
    return methodInfoConnectionTune;

   case 655391:
    return methodInfoConnectionTuneOk;

   case 655400:
    return methodInfoConnectionOpen;

   case 655401:
    return methodInfoConnectionOpenOk;

   case 655410:
    return methodInfoConnectionClose;

   case 655411:
    return methodInfoConnectionCloseOk;

   case 655420:
    return methodInfoConnectionBlocked;

   case 655421:
    return methodInfoConnectionUnblocked;

   case 1310730:
    return methodInfoChannelOpen;

   case 1310731:
    return methodInfoChannelOpenOk;

   case 1310740:
    return methodInfoChannelFlow;

   case 1310741:
    return methodInfoChannelFlowOk;

   case 1310760:
    return methodInfoChannelClose;

   case 1310761:
    return methodInfoChannelCloseOk;

   case 1966090:
    return methodInfoAccessRequest;

   case 1966091:
    return methodInfoAccessRequestOk;

   case 2621450:
    return methodInfoExchangeDeclare;

   case 2621451:
    return methodInfoExchangeDeclareOk;

   case 2621460:
    return methodInfoExchangeDelete;

   case 2621461:
    return methodInfoExchangeDeleteOk;

   case 2621470:
    return methodInfoExchangeBind;

   case 2621471:
    return methodInfoExchangeBindOk;

   case 2621480:
    return methodInfoExchangeUnbind;

   case 2621491:
    return methodInfoExchangeUnbindOk;

   case 3276810:
    return methodInfoQueueDeclare;

   case 3276811:
    return methodInfoQueueDeclareOk;

   case 3276820:
    return methodInfoQueueBind;

   case 3276821:
    return methodInfoQueueBindOk;

   case 3276830:
    return methodInfoQueuePurge;

   case 3276831:
    return methodInfoQueuePurgeOk;

   case 3276840:
    return methodInfoQueueDelete;

   case 3276841:
    return methodInfoQueueDeleteOk;

   case 3276850:
    return methodInfoQueueUnbind;

   case 3276851:
    return methodInfoQueueUnbindOk;

   case 3932170:
    return methodInfoBasicQos;

   case 3932171:
    return methodInfoBasicQosOk;

   case 3932180:
    return methodInfoBasicConsume;

   case 3932181:
    return methodInfoBasicConsumeOk;

   case 3932190:
    return methodInfoBasicCancel;

   case 3932191:
    return methodInfoBasicCancelOk;

   case 3932200:
    return methodInfoBasicPublish;

   case 3932210:
    return methodInfoBasicReturn;

   case 3932220:
    return methodInfoBasicDeliver;

   case 3932230:
    return methodInfoBasicGet;

   case 3932231:
    return methodInfoBasicGetOk;

   case 3932232:
    return methodInfoBasicGetEmpty;

   case 3932240:
    return methodInfoBasicAck;

   case 3932250:
    return methodInfoBasicReject;

   case 3932260:
    return methodInfoBasicRecoverAsync;

   case 3932270:
    return methodInfoBasicRecover;

   case 3932271:
    return methodInfoBasicRecoverOk;

   case 3932280:
    return methodInfoBasicNack;

   case 5898250:
    return methodInfoTxSelect;

   case 5898251:
    return methodInfoTxSelectOk;

   case 5898260:
    return methodInfoTxCommit;

   case 5898261:
    return methodInfoTxCommitOk;

   case 5898270:
    return methodInfoTxRollback;

   case 5898271:
    return methodInfoTxRollbackOk;

   case 5570570:
    return methodInfoConfirmSelect;

   case 5570571:
    return methodInfoConfirmSelectOk;

   case 60:
    return propertiesInfoBasicProperties;

   default:
    throw new Error("Unknown class/method ID");
  }
};

module.exports.ConnectionStart = 655370;

var methodInfoConnectionStart = module.exports.methodInfoConnectionStart = {
  id: 655370,
  classId: 10,
  methodId: 10,
  name: "ConnectionStart",
  args: [ {
    type: "octet",
    name: "versionMajor",
    default: 0
  }, {
    type: "octet",
    name: "versionMinor",
    default: 9
  }, {
    type: "table",
    name: "serverProperties"
  }, {
    type: "longstr",
    name: "mechanisms",
    default: "PLAIN"
  }, {
    type: "longstr",
    name: "locales",
    default: "en_US"
  } ]
};

module.exports.ConnectionStartOk = 655371;

var methodInfoConnectionStartOk = module.exports.methodInfoConnectionStartOk = {
  id: 655371,
  classId: 10,
  methodId: 11,
  name: "ConnectionStartOk",
  args: [ {
    type: "table",
    name: "clientProperties"
  }, {
    type: "shortstr",
    name: "mechanism",
    default: "PLAIN"
  }, {
    type: "longstr",
    name: "response"
  }, {
    type: "shortstr",
    name: "locale",
    default: "en_US"
  } ]
};

module.exports.ConnectionSecure = 655380;

var methodInfoConnectionSecure = module.exports.methodInfoConnectionSecure = {
  id: 655380,
  classId: 10,
  methodId: 20,
  name: "ConnectionSecure",
  args: [ {
    type: "longstr",
    name: "challenge"
  } ]
};

module.exports.ConnectionSecureOk = 655381;

var methodInfoConnectionSecureOk = module.exports.methodInfoConnectionSecureOk = {
  id: 655381,
  classId: 10,
  methodId: 21,
  name: "ConnectionSecureOk",
  args: [ {
    type: "longstr",
    name: "response"
  } ]
};

module.exports.ConnectionTune = 655390;

var methodInfoConnectionTune = module.exports.methodInfoConnectionTune = {
  id: 655390,
  classId: 10,
  methodId: 30,
  name: "ConnectionTune",
  args: [ {
    type: "short",
    name: "channelMax",
    default: 0
  }, {
    type: "long",
    name: "frameMax",
    default: 0
  }, {
    type: "short",
    name: "heartbeat",
    default: 0
  } ]
};

module.exports.ConnectionTuneOk = 655391;

var methodInfoConnectionTuneOk = module.exports.methodInfoConnectionTuneOk = {
  id: 655391,
  classId: 10,
  methodId: 31,
  name: "ConnectionTuneOk",
  args: [ {
    type: "short",
    name: "channelMax",
    default: 0
  }, {
    type: "long",
    name: "frameMax",
    default: 0
  }, {
    type: "short",
    name: "heartbeat",
    default: 0
  } ]
};

module.exports.ConnectionOpen = 655400;

var methodInfoConnectionOpen = module.exports.methodInfoConnectionOpen = {
  id: 655400,
  classId: 10,
  methodId: 40,
  name: "ConnectionOpen",
  args: [ {
    type: "shortstr",
    name: "virtualHost",
    default: "/"
  }, {
    type: "shortstr",
    name: "capabilities",
    default: ""
  }, {
    type: "bit",
    name: "insist",
    default: !1
  } ]
};

module.exports.ConnectionOpenOk = 655401;

var methodInfoConnectionOpenOk = module.exports.methodInfoConnectionOpenOk = {
  id: 655401,
  classId: 10,
  methodId: 41,
  name: "ConnectionOpenOk",
  args: [ {
    type: "shortstr",
    name: "knownHosts",
    default: ""
  } ]
};

module.exports.ConnectionClose = 655410;

var methodInfoConnectionClose = module.exports.methodInfoConnectionClose = {
  id: 655410,
  classId: 10,
  methodId: 50,
  name: "ConnectionClose",
  args: [ {
    type: "short",
    name: "replyCode"
  }, {
    type: "shortstr",
    name: "replyText",
    default: ""
  }, {
    type: "short",
    name: "classId"
  }, {
    type: "short",
    name: "methodId"
  } ]
};

module.exports.ConnectionCloseOk = 655411;

var methodInfoConnectionCloseOk = module.exports.methodInfoConnectionCloseOk = {
  id: 655411,
  classId: 10,
  methodId: 51,
  name: "ConnectionCloseOk",
  args: []
};

module.exports.ConnectionBlocked = 655420;

var methodInfoConnectionBlocked = module.exports.methodInfoConnectionBlocked = {
  id: 655420,
  classId: 10,
  methodId: 60,
  name: "ConnectionBlocked",
  args: [ {
    type: "shortstr",
    name: "reason",
    default: ""
  } ]
};

module.exports.ConnectionUnblocked = 655421;

var methodInfoConnectionUnblocked = module.exports.methodInfoConnectionUnblocked = {
  id: 655421,
  classId: 10,
  methodId: 61,
  name: "ConnectionUnblocked",
  args: []
};

module.exports.ChannelOpen = 1310730;

var methodInfoChannelOpen = module.exports.methodInfoChannelOpen = {
  id: 1310730,
  classId: 20,
  methodId: 10,
  name: "ChannelOpen",
  args: [ {
    type: "shortstr",
    name: "outOfBand",
    default: ""
  } ]
};

module.exports.ChannelOpenOk = 1310731;

var methodInfoChannelOpenOk = module.exports.methodInfoChannelOpenOk = {
  id: 1310731,
  classId: 20,
  methodId: 11,
  name: "ChannelOpenOk",
  args: [ {
    type: "longstr",
    name: "channelId",
    default: ""
  } ]
};

module.exports.ChannelFlow = 1310740;

var methodInfoChannelFlow = module.exports.methodInfoChannelFlow = {
  id: 1310740,
  classId: 20,
  methodId: 20,
  name: "ChannelFlow",
  args: [ {
    type: "bit",
    name: "active"
  } ]
};

module.exports.ChannelFlowOk = 1310741;

var methodInfoChannelFlowOk = module.exports.methodInfoChannelFlowOk = {
  id: 1310741,
  classId: 20,
  methodId: 21,
  name: "ChannelFlowOk",
  args: [ {
    type: "bit",
    name: "active"
  } ]
};

module.exports.ChannelClose = 1310760;

var methodInfoChannelClose = module.exports.methodInfoChannelClose = {
  id: 1310760,
  classId: 20,
  methodId: 40,
  name: "ChannelClose",
  args: [ {
    type: "short",
    name: "replyCode"
  }, {
    type: "shortstr",
    name: "replyText",
    default: ""
  }, {
    type: "short",
    name: "classId"
  }, {
    type: "short",
    name: "methodId"
  } ]
};

module.exports.ChannelCloseOk = 1310761;

var methodInfoChannelCloseOk = module.exports.methodInfoChannelCloseOk = {
  id: 1310761,
  classId: 20,
  methodId: 41,
  name: "ChannelCloseOk",
  args: []
};

module.exports.AccessRequest = 1966090;

var methodInfoAccessRequest = module.exports.methodInfoAccessRequest = {
  id: 1966090,
  classId: 30,
  methodId: 10,
  name: "AccessRequest",
  args: [ {
    type: "shortstr",
    name: "realm",
    default: "/data"
  }, {
    type: "bit",
    name: "exclusive",
    default: !1
  }, {
    type: "bit",
    name: "passive",
    default: !0
  }, {
    type: "bit",
    name: "active",
    default: !0
  }, {
    type: "bit",
    name: "write",
    default: !0
  }, {
    type: "bit",
    name: "read",
    default: !0
  } ]
};

module.exports.AccessRequestOk = 1966091;

var methodInfoAccessRequestOk = module.exports.methodInfoAccessRequestOk = {
  id: 1966091,
  classId: 30,
  methodId: 11,
  name: "AccessRequestOk",
  args: [ {
    type: "short",
    name: "ticket",
    default: 1
  } ]
};

module.exports.ExchangeDeclare = 2621450;

var methodInfoExchangeDeclare = module.exports.methodInfoExchangeDeclare = {
  id: 2621450,
  classId: 40,
  methodId: 10,
  name: "ExchangeDeclare",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "type",
    default: "direct"
  }, {
    type: "bit",
    name: "passive",
    default: !1
  }, {
    type: "bit",
    name: "durable",
    default: !1
  }, {
    type: "bit",
    name: "autoDelete",
    default: !1
  }, {
    type: "bit",
    name: "internal",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.ExchangeDeclareOk = 2621451;

var methodInfoExchangeDeclareOk = module.exports.methodInfoExchangeDeclareOk = {
  id: 2621451,
  classId: 40,
  methodId: 11,
  name: "ExchangeDeclareOk",
  args: []
};

module.exports.ExchangeDelete = 2621460;

var methodInfoExchangeDelete = module.exports.methodInfoExchangeDelete = {
  id: 2621460,
  classId: 40,
  methodId: 20,
  name: "ExchangeDelete",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "bit",
    name: "ifUnused",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.ExchangeDeleteOk = 2621461;

var methodInfoExchangeDeleteOk = module.exports.methodInfoExchangeDeleteOk = {
  id: 2621461,
  classId: 40,
  methodId: 21,
  name: "ExchangeDeleteOk",
  args: []
};

module.exports.ExchangeBind = 2621470;

var methodInfoExchangeBind = module.exports.methodInfoExchangeBind = {
  id: 2621470,
  classId: 40,
  methodId: 30,
  name: "ExchangeBind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "destination"
  }, {
    type: "shortstr",
    name: "source"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.ExchangeBindOk = 2621471;

var methodInfoExchangeBindOk = module.exports.methodInfoExchangeBindOk = {
  id: 2621471,
  classId: 40,
  methodId: 31,
  name: "ExchangeBindOk",
  args: []
};

module.exports.ExchangeUnbind = 2621480;

var methodInfoExchangeUnbind = module.exports.methodInfoExchangeUnbind = {
  id: 2621480,
  classId: 40,
  methodId: 40,
  name: "ExchangeUnbind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "destination"
  }, {
    type: "shortstr",
    name: "source"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.ExchangeUnbindOk = 2621491;

var methodInfoExchangeUnbindOk = module.exports.methodInfoExchangeUnbindOk = {
  id: 2621491,
  classId: 40,
  methodId: 51,
  name: "ExchangeUnbindOk",
  args: []
};

module.exports.QueueDeclare = 3276810;

var methodInfoQueueDeclare = module.exports.methodInfoQueueDeclare = {
  id: 3276810,
  classId: 50,
  methodId: 10,
  name: "QueueDeclare",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "passive",
    default: !1
  }, {
    type: "bit",
    name: "durable",
    default: !1
  }, {
    type: "bit",
    name: "exclusive",
    default: !1
  }, {
    type: "bit",
    name: "autoDelete",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.QueueDeclareOk = 3276811;

var methodInfoQueueDeclareOk = module.exports.methodInfoQueueDeclareOk = {
  id: 3276811,
  classId: 50,
  methodId: 11,
  name: "QueueDeclareOk",
  args: [ {
    type: "shortstr",
    name: "queue"
  }, {
    type: "long",
    name: "messageCount"
  }, {
    type: "long",
    name: "consumerCount"
  } ]
};

module.exports.QueueBind = 3276820;

var methodInfoQueueBind = module.exports.methodInfoQueueBind = {
  id: 3276820,
  classId: 50,
  methodId: 20,
  name: "QueueBind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.QueueBindOk = 3276821;

var methodInfoQueueBindOk = module.exports.methodInfoQueueBindOk = {
  id: 3276821,
  classId: 50,
  methodId: 21,
  name: "QueueBindOk",
  args: []
};

module.exports.QueuePurge = 3276830;

var methodInfoQueuePurge = module.exports.methodInfoQueuePurge = {
  id: 3276830,
  classId: 50,
  methodId: 30,
  name: "QueuePurge",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.QueuePurgeOk = 3276831;

var methodInfoQueuePurgeOk = module.exports.methodInfoQueuePurgeOk = {
  id: 3276831,
  classId: 50,
  methodId: 31,
  name: "QueuePurgeOk",
  args: [ {
    type: "long",
    name: "messageCount"
  } ]
};

module.exports.QueueDelete = 3276840;

var methodInfoQueueDelete = module.exports.methodInfoQueueDelete = {
  id: 3276840,
  classId: 50,
  methodId: 40,
  name: "QueueDelete",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "ifUnused",
    default: !1
  }, {
    type: "bit",
    name: "ifEmpty",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.QueueDeleteOk = 3276841;

var methodInfoQueueDeleteOk = module.exports.methodInfoQueueDeleteOk = {
  id: 3276841,
  classId: 50,
  methodId: 41,
  name: "QueueDeleteOk",
  args: [ {
    type: "long",
    name: "messageCount"
  } ]
};

module.exports.QueueUnbind = 3276850;

var methodInfoQueueUnbind = module.exports.methodInfoQueueUnbind = {
  id: 3276850,
  classId: 50,
  methodId: 50,
  name: "QueueUnbind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.QueueUnbindOk = 3276851;

var methodInfoQueueUnbindOk = module.exports.methodInfoQueueUnbindOk = {
  id: 3276851,
  classId: 50,
  methodId: 51,
  name: "QueueUnbindOk",
  args: []
};

module.exports.BasicQos = 3932170;

var methodInfoBasicQos = module.exports.methodInfoBasicQos = {
  id: 3932170,
  classId: 60,
  methodId: 10,
  name: "BasicQos",
  args: [ {
    type: "long",
    name: "prefetchSize",
    default: 0
  }, {
    type: "short",
    name: "prefetchCount",
    default: 0
  }, {
    type: "bit",
    name: "global",
    default: !1
  } ]
};

module.exports.BasicQosOk = 3932171;

var methodInfoBasicQosOk = module.exports.methodInfoBasicQosOk = {
  id: 3932171,
  classId: 60,
  methodId: 11,
  name: "BasicQosOk",
  args: []
};

module.exports.BasicConsume = 3932180;

var methodInfoBasicConsume = module.exports.methodInfoBasicConsume = {
  id: 3932180,
  classId: 60,
  methodId: 20,
  name: "BasicConsume",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "shortstr",
    name: "consumerTag",
    default: ""
  }, {
    type: "bit",
    name: "noLocal",
    default: !1
  }, {
    type: "bit",
    name: "noAck",
    default: !1
  }, {
    type: "bit",
    name: "exclusive",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.BasicConsumeOk = 3932181;

var methodInfoBasicConsumeOk = module.exports.methodInfoBasicConsumeOk = {
  id: 3932181,
  classId: 60,
  methodId: 21,
  name: "BasicConsumeOk",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  } ]
};

module.exports.BasicCancel = 3932190;

var methodInfoBasicCancel = module.exports.methodInfoBasicCancel = {
  id: 3932190,
  classId: 60,
  methodId: 30,
  name: "BasicCancel",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.BasicCancelOk = 3932191;

var methodInfoBasicCancelOk = module.exports.methodInfoBasicCancelOk = {
  id: 3932191,
  classId: 60,
  methodId: 31,
  name: "BasicCancelOk",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  } ]
};

module.exports.BasicPublish = 3932200;

var methodInfoBasicPublish = module.exports.methodInfoBasicPublish = {
  id: 3932200,
  classId: 60,
  methodId: 40,
  name: "BasicPublish",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "exchange",
    default: ""
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "mandatory",
    default: !1
  }, {
    type: "bit",
    name: "immediate",
    default: !1
  } ]
};

module.exports.BasicReturn = 3932210;

var methodInfoBasicReturn = module.exports.methodInfoBasicReturn = {
  id: 3932210,
  classId: 60,
  methodId: 50,
  name: "BasicReturn",
  args: [ {
    type: "short",
    name: "replyCode"
  }, {
    type: "shortstr",
    name: "replyText",
    default: ""
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey"
  } ]
};

module.exports.BasicDeliver = 3932220;

var methodInfoBasicDeliver = module.exports.methodInfoBasicDeliver = {
  id: 3932220,
  classId: 60,
  methodId: 60,
  name: "BasicDeliver",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  }, {
    type: "longlong",
    name: "deliveryTag"
  }, {
    type: "bit",
    name: "redelivered",
    default: !1
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey"
  } ]
};

module.exports.BasicGet = 3932230;

var methodInfoBasicGet = module.exports.methodInfoBasicGet = {
  id: 3932230,
  classId: 60,
  methodId: 70,
  name: "BasicGet",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "noAck",
    default: !1
  } ]
};

module.exports.BasicGetOk = 3932231;

var methodInfoBasicGetOk = module.exports.methodInfoBasicGetOk = {
  id: 3932231,
  classId: 60,
  methodId: 71,
  name: "BasicGetOk",
  args: [ {
    type: "longlong",
    name: "deliveryTag"
  }, {
    type: "bit",
    name: "redelivered",
    default: !1
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey"
  }, {
    type: "long",
    name: "messageCount"
  } ]
};

module.exports.BasicGetEmpty = 3932232;

var methodInfoBasicGetEmpty = module.exports.methodInfoBasicGetEmpty = {
  id: 3932232,
  classId: 60,
  methodId: 72,
  name: "BasicGetEmpty",
  args: [ {
    type: "shortstr",
    name: "clusterId",
    default: ""
  } ]
};

module.exports.BasicAck = 3932240;

var methodInfoBasicAck = module.exports.methodInfoBasicAck = {
  id: 3932240,
  classId: 60,
  methodId: 80,
  name: "BasicAck",
  args: [ {
    type: "longlong",
    name: "deliveryTag",
    default: 0
  }, {
    type: "bit",
    name: "multiple",
    default: !1
  } ]
};

module.exports.BasicReject = 3932250;

var methodInfoBasicReject = module.exports.methodInfoBasicReject = {
  id: 3932250,
  classId: 60,
  methodId: 90,
  name: "BasicReject",
  args: [ {
    type: "longlong",
    name: "deliveryTag"
  }, {
    type: "bit",
    name: "requeue",
    default: !0
  } ]
};

module.exports.BasicRecoverAsync = 3932260;

var methodInfoBasicRecoverAsync = module.exports.methodInfoBasicRecoverAsync = {
  id: 3932260,
  classId: 60,
  methodId: 100,
  name: "BasicRecoverAsync",
  args: [ {
    type: "bit",
    name: "requeue",
    default: !1
  } ]
};

module.exports.BasicRecover = 3932270;

var methodInfoBasicRecover = module.exports.methodInfoBasicRecover = {
  id: 3932270,
  classId: 60,
  methodId: 110,
  name: "BasicRecover",
  args: [ {
    type: "bit",
    name: "requeue",
    default: !1
  } ]
};

module.exports.BasicRecoverOk = 3932271;

var methodInfoBasicRecoverOk = module.exports.methodInfoBasicRecoverOk = {
  id: 3932271,
  classId: 60,
  methodId: 111,
  name: "BasicRecoverOk",
  args: []
};

module.exports.BasicNack = 3932280;

var methodInfoBasicNack = module.exports.methodInfoBasicNack = {
  id: 3932280,
  classId: 60,
  methodId: 120,
  name: "BasicNack",
  args: [ {
    type: "longlong",
    name: "deliveryTag",
    default: 0
  }, {
    type: "bit",
    name: "multiple",
    default: !1
  }, {
    type: "bit",
    name: "requeue",
    default: !0
  } ]
};

module.exports.TxSelect = 5898250;

var methodInfoTxSelect = module.exports.methodInfoTxSelect = {
  id: 5898250,
  classId: 90,
  methodId: 10,
  name: "TxSelect",
  args: []
};

module.exports.TxSelectOk = 5898251;

var methodInfoTxSelectOk = module.exports.methodInfoTxSelectOk = {
  id: 5898251,
  classId: 90,
  methodId: 11,
  name: "TxSelectOk",
  args: []
};

module.exports.TxCommit = 5898260;

var methodInfoTxCommit = module.exports.methodInfoTxCommit = {
  id: 5898260,
  classId: 90,
  methodId: 20,
  name: "TxCommit",
  args: []
};

module.exports.TxCommitOk = 5898261;

var methodInfoTxCommitOk = module.exports.methodInfoTxCommitOk = {
  id: 5898261,
  classId: 90,
  methodId: 21,
  name: "TxCommitOk",
  args: []
};

module.exports.TxRollback = 5898270;

var methodInfoTxRollback = module.exports.methodInfoTxRollback = {
  id: 5898270,
  classId: 90,
  methodId: 30,
  name: "TxRollback",
  args: []
};

module.exports.TxRollbackOk = 5898271;

var methodInfoTxRollbackOk = module.exports.methodInfoTxRollbackOk = {
  id: 5898271,
  classId: 90,
  methodId: 31,
  name: "TxRollbackOk",
  args: []
};

module.exports.ConfirmSelect = 5570570;

var methodInfoConfirmSelect = module.exports.methodInfoConfirmSelect = {
  id: 5570570,
  classId: 85,
  methodId: 10,
  name: "ConfirmSelect",
  args: [ {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.ConfirmSelectOk = 5570571;

var methodInfoConfirmSelectOk = module.exports.methodInfoConfirmSelectOk = {
  id: 5570571,
  classId: 85,
  methodId: 11,
  name: "ConfirmSelectOk",
  args: []
};

module.exports.BasicProperties = 60;

var propertiesInfoBasicProperties = module.exports.propertiesInfoBasicProperties = {
  id: 60,
  name: "BasicProperties",
  args: [ {
    type: "shortstr",
    name: "contentType"
  }, {
    type: "shortstr",
    name: "contentEncoding"
  }, {
    type: "table",
    name: "headers"
  }, {
    type: "octet",
    name: "deliveryMode"
  }, {
    type: "octet",
    name: "priority"
  }, {
    type: "shortstr",
    name: "correlationId"
  }, {
    type: "shortstr",
    name: "replyTo"
  }, {
    type: "shortstr",
    name: "expiration"
  }, {
    type: "shortstr",
    name: "messageId"
  }, {
    type: "timestamp",
    name: "timestamp"
  }, {
    type: "shortstr",
    name: "type"
  }, {
    type: "shortstr",
    name: "userId"
  }, {
    type: "shortstr",
    name: "appId"
  }, {
    type: "shortstr",
    name: "clusterId"
  } ]
};

/***/ }),

/***/ "./node_modules/amqplib/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/error.js ***!
  \*******************************************/
/***/ ((module) => {

var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

function trimStack(stack, num) {
  return stack && stack.split('\n').slice(num).join('\n');
}

function IllegalOperationError(msg, stack) {
  var tmp = new Error();
  this.message = msg;
  this.stack = this.toString() + '\n' + trimStack(tmp.stack, 2);
  this.stackAtStateChange = stack;
}
inherits(IllegalOperationError, Error);

IllegalOperationError.prototype.name = 'IllegalOperationError';

function stackCapture(reason) {
  var e = new Error();
  return 'Stack capture: ' + reason + '\n' +
    trimStack(e.stack, 2);
}

module.exports.IllegalOperationError = IllegalOperationError;
module.exports.stackCapture = stackCapture;


/***/ }),

/***/ "./node_modules/amqplib/lib/format.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/format.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// Stringifying various things



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var format = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var HEARTBEAT = (__webpack_require__(/*! ./frame */ "./node_modules/amqplib/lib/frame.js").HEARTBEAT);

module.exports.closeMessage = function(close) {
  var code = close.fields.replyCode;
  return format('%d (%s) with message "%s"',
                code, defs.constant_strs[code],
                close.fields.replyText);
}

module.exports.methodName = function(id) {
  return defs.info(id).name;
};

module.exports.inspect = function(frame, showFields) {
  if (frame === HEARTBEAT) {
    return '<Heartbeat>';
  }
  else if (!frame.id) {
    return format('<Content channel:%d size:%d>',
                  frame.channel, frame.size);
  }
  else {
    var info = defs.info(frame.id);
    return format('<%s channel:%d%s>', info.name, frame.channel,
                  (showFields)
                  ? ' ' + JSON.stringify(frame.fields, undefined, 2)
                  : '');
  }
}


/***/ }),

/***/ "./node_modules/amqplib/lib/frame.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/frame.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// The river sweeps through
// Silt and twigs, gravel and leaves
// Driving the wheel on



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var constants = defs.constants;
var decode = defs.decode;

var Bits = __webpack_require__(/*! @acuminous/bitsyntax */ "./node_modules/@acuminous/bitsyntax/index.js");

module.exports.PROTOCOL_HEADER = "AMQP" + String.fromCharCode(0, 0, 9, 1);

/*
  Frame format:

  0      1         3             7                size+7 size+8
  +------+---------+-------------+ +------------+ +-----------+
  | type | channel | size        | | payload    | | frame-end |
  +------+---------+-------------+ +------------+ +-----------+
  octet   short     long            size octets    octet

  In general I want to know those first three things straight away, so I
  can discard frames early.

*/

// framing constants
var FRAME_METHOD = constants.FRAME_METHOD,
FRAME_HEARTBEAT = constants.FRAME_HEARTBEAT,
FRAME_HEADER = constants.FRAME_HEADER,
FRAME_BODY = constants.FRAME_BODY,
FRAME_END = constants.FRAME_END;

var bodyCons =
  Bits.builder(FRAME_BODY,
               'channel:16, size:32, payload:size/binary',
               FRAME_END);

// %%% TESTME possibly better to cons the first bit and write the
// second directly, in the absence of IO lists
module.exports.makeBodyFrame = function(channel, payload) {
  return bodyCons({channel: channel, size: payload.length, payload: payload});
};

var frameHeaderPattern = Bits.matcher('type:8', 'channel:16',
                                      'size:32', 'rest/binary');

function parseFrame(bin, max) {
  var fh = frameHeaderPattern(bin);
  if (fh) {
    var size = fh.size, rest = fh.rest;
    if (size > max) {
      throw new Error('Frame size exceeds frame max');
    }
    else if (rest.length > size) {
      if (rest[size] !== FRAME_END)
        throw new Error('Invalid frame');

      return {
        type: fh.type,
        channel: fh.channel,
        size: size,
        payload: rest.slice(0, size),
        rest: rest.slice(size + 1)
      };
    }
  }
  return false;
}

module.exports.parseFrame = parseFrame;

var headerPattern = Bits.matcher('class:16',
                                 '_weight:16',
                                 'size:64',
                                 'flagsAndfields/binary');

var methodPattern = Bits.matcher('id:32, args/binary');

var HEARTBEAT = {channel: 0};

module.exports.decodeFrame = function(frame) {
  var payload = frame.payload;
  switch (frame.type) {
  case FRAME_METHOD:
    var idAndArgs = methodPattern(payload);
    var id = idAndArgs.id;
    var fields = decode(id, idAndArgs.args);
    return {id: id, channel: frame.channel, fields: fields};
  case FRAME_HEADER:
    var parts = headerPattern(payload);
    var id = parts['class'];
    var fields = decode(id, parts.flagsAndfields);
    return {id: id, channel: frame.channel,
            size: parts.size, fields: fields};
  case FRAME_BODY:
    return {channel: frame.channel, content: frame.payload};
  case FRAME_HEARTBEAT:
    return HEARTBEAT;
  default:
    throw new Error('Unknown frame type ' + frame.type);
  }
}

// encoded heartbeat
module.exports.HEARTBEAT_BUF = Buffer.from([constants.FRAME_HEARTBEAT,
                                           0, 0, 0, 0, // size = 0
                                           0, 0, // channel = 0
                                           constants.FRAME_END]);

module.exports.HEARTBEAT = HEARTBEAT;


/***/ }),

/***/ "./node_modules/amqplib/lib/heartbeat.js":
/*!***********************************************!*\
  !*** ./node_modules/amqplib/lib/heartbeat.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// Heartbeats. In AMQP both clients and servers may expect a heartbeat
// frame if there is no activity on the connection for a negotiated
// period of time. If there's no activity for two such intervals, the
// server or client is allowed to close the connection on the
// presumption that the other party is dead.
//
// The client has two jobs here: the first is to send a heartbeat
// frame if it's not sent any frames for a while, so that the server
// doesn't think it's dead; the second is to check periodically that
// it's seen activity from the server, and to advise if there doesn't
// appear to have been any for over two intervals.
//
// Node.JS timers are a bit unreliable, in that they endeavour only to
// fire at some indeterminate point *after* the given time (rather
// gives the lie to 'realtime', dunnit). Because the scheduler is just
// an event loop, it's quite easy to delay timers indefinitely by
// reacting to some I/O with a lot of computation.
//
// To mitigate this I need a bit of creative interpretation:
//
//  - I'll schedule a server activity check for every `interval`, and
//    check just how much time has passed. It will overshoot by at
//    least a small margin; modulo missing timer deadlines, it'll
//    notice between two and three intervals after activity actually
//    stops (otherwise, at some point after two intervals).
//
//  - Every `interval / 2` I'll check that we've sent something since
//    the last check, and if not, send a heartbeat frame. If we're
//    really too busy to even run the check for two whole heartbeat
//    intervals, there must be a lot of I (but not O, at least not on
//    the connection), or computation, in which case perhaps it's best
//    the server cuts us off anyway. Why `interval / 2`? Because the
//    edge case is that the client sent a frame just after a
//    heartbeat, which would mean I only send one after almost two
//    intervals. (NB a heartbeat counts as a send, so it'll be checked
//    at least twice before sending another)
//
// This design is based largely on RabbitMQ's heartbeating:
// https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_heartbeat.erl

// %% Yes, I could apply the same 'actually passage of time' thing to
// %% send as well as to recv.



var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

// Exported so that we can mess with it in tests
module.exports.UNITS_TO_MS = 1000;

function Heart(interval, checkSend, checkRecv) {
  EventEmitter.call(this);
  this.interval = interval;

  var intervalMs = interval * module.exports.UNITS_TO_MS;
  // Function#bind is my new best friend
  var beat = this.emit.bind(this, 'beat');
  var timeout = this.emit.bind(this, 'timeout');

  this.sendTimer = setInterval(
    this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);

  // A timeout occurs if I see nothing for *two consecutive* intervals
  var recvMissed = 0;
  function missedTwo() {
    if (!checkRecv()) return (++recvMissed < 2);
    else { recvMissed = 0; return true; }
  }
  this.recvTimer = setInterval(
    this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);
}
inherits(Heart, EventEmitter);

module.exports.Heart = Heart;

Heart.prototype.clear = function() {
  clearInterval(this.sendTimer);
  clearInterval(this.recvTimer);
};

Heart.prototype.runHeartbeat = function(check, fail) {
  // Have we seen activity?
  if (!check()) fail();
};


/***/ }),

/***/ "./node_modules/amqplib/lib/mux.js":
/*!*****************************************!*\
  !*** ./node_modules/amqplib/lib/mux.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//



// A Mux is an object into which other readable streams may be piped;
// it then writes 'packets' from the upstreams to the given
// downstream.

var assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'assert'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var schedule = (typeof setImmediate === 'function') ?
  setImmediate : process.nextTick;

function Mux(downstream) {
  this.newStreams = [];
  this.oldStreams = [];
  this.blocked = false;
  this.scheduledRead = false;

  this.out = downstream;
  var self = this;
  downstream.on('drain', function() {
    self.blocked = false;
    self._readIncoming();
  });
}

// There are 2 states we can be in:

// - waiting for outbound capacity, which will be signalled by a
// - 'drain' event on the downstream; or,

// - no packets to send, waiting for an inbound buffer to have
//   packets, which will be signalled by a 'readable' event

// If we write all packets available whenever there is outbound
// capacity, we will either run out of outbound capacity (`#write`
// returns false), or run out of packets (all calls to an
// `inbound.read()` have returned null).

Mux.prototype._readIncoming = function() {

  // We may be sent here speculatively, if an incoming stream has
  // become readable
  if (this.blocked) return;

  var accepting = true;
  var out = this.out;

  // Try to read a chunk from each stream in turn, until all streams
  // are empty, or we exhaust our ability to accept chunks.
  function roundrobin(streams) {
    var s;
    while (accepting && (s = streams.shift())) {
      var chunk = s.read();
      if (chunk !== null) {
        accepting = out.write(chunk);
        streams.push(s);
      }
    }
  }

  roundrobin(this.newStreams);

  // Either we exhausted the new queues, or we ran out of capacity. If
  // we ran out of capacity, all the remaining new streams (i.e.,
  // those with packets left) become old streams. This effectively
  // prioritises streams that keep their buffers close to empty over
  // those that are constantly near full.

  if (accepting) { // all new queues are exhausted, write as many as
                   // we can from the old streams
    assert.equal(0, this.newStreams.length);
    roundrobin(this.oldStreams);
  }
  else { // ran out of room
    assert(this.newStreams.length > 0, "Expect some new streams to remain");
    Array.prototype.push.apply(this.oldStreams, this.newStreams);
    this.newStreams = [];
  }
  // We may have exhausted all the old queues, or run out of room;
  // either way, all we need to do is record whether we have capacity
  // or not, so any speculative reads will know
  this.blocked = !accepting;
};

Mux.prototype._scheduleRead = function() {
  var self = this;

  if (!self.scheduledRead) {
    schedule(function() {
      self.scheduledRead = false;
      self._readIncoming();
    });
    self.scheduledRead = true;
  }
};

Mux.prototype.pipeFrom = function(readable) {
  var self = this;

  function enqueue() {
    self.newStreams.push(readable);
    self._scheduleRead();
  }

  function cleanup() {
    readable.removeListener('readable', enqueue);
    readable.removeListener('error', cleanup);
    readable.removeListener('end', cleanup);
    readable.removeListener('unpipeFrom', cleanupIfMe);
  }
  function cleanupIfMe(dest) {
    if (dest === self) cleanup();
  }

  readable.on('unpipeFrom', cleanupIfMe);
  readable.on('end', cleanup);
  readable.on('error', cleanup);
  readable.on('readable', enqueue);
};

Mux.prototype.unpipeFrom = function(readable) {
  readable.emit('unpipeFrom', this);
};

module.exports.Mux = Mux;


/***/ }),

/***/ "./node_modules/before-after-hook/index.js":
/*!*************************************************!*\
  !*** ./node_modules/before-after-hook/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var register = __webpack_require__(/*! ./lib/register */ "./node_modules/before-after-hook/lib/register.js");
var addHook = __webpack_require__(/*! ./lib/add */ "./node_modules/before-after-hook/lib/add.js");
var removeHook = __webpack_require__(/*! ./lib/remove */ "./node_modules/before-after-hook/lib/remove.js");

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind;
var bindable = bind.bind(bind);

function bindApi(hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook.api = { remove: removeHookRef };
  hook.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind];
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
  });
}

function HookSingular() {
  var singularHookName = "h";
  var singularHookState = {
    registry: {},
  };
  var singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}

function HookCollection() {
  var state = {
    registry: {},
  };

  var hook = register.bind(null, state);
  bindApi(hook, state);

  return hook;
}

var collectionHookDeprecationMessageDisplayed = false;
function Hook() {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn(
      '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
    );
    collectionHookDeprecationMessageDisplayed = true;
  }
  return HookCollection();
}

Hook.Singular = HookSingular.bind();
Hook.Collection = HookCollection.bind();

module.exports = Hook;
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook;
module.exports.Singular = Hook.Singular;
module.exports.Collection = Hook.Collection;


/***/ }),

/***/ "./node_modules/before-after-hook/lib/add.js":
/*!***************************************************!*\
  !*** ./node_modules/before-after-hook/lib/add.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ "./node_modules/before-after-hook/lib/register.js":
/*!********************************************************!*\
  !*** ./node_modules/before-after-hook/lib/register.js ***!
  \********************************************************/
/***/ ((module) => {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ "./node_modules/before-after-hook/lib/remove.js":
/*!******************************************************!*\
  !*** ./node_modules/before-after-hook/lib/remove.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ "./node_modules/buffer-more-ints/buffer-more-ints.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer-more-ints/buffer-more-ints.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


// JavaScript is numerically challenged
var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

// The maximum contiguous integer that can be held in a IEEE754 double
var MAX_INT = 0x1fffffffffffff;

function isContiguousInt(val) {
    return val <= MAX_INT && val >= -MAX_INT;
}

function assertContiguousInt(val) {
    if (!isContiguousInt(val)) {
        throw new TypeError("number cannot be represented as a contiguous integer");
    }
}

module.exports.isContiguousInt = isContiguousInt;
module.exports.assertContiguousInt = assertContiguousInt;

// Fill in the regular procedures
['UInt', 'Int'].forEach(function (sign) {
  var suffix = sign + '8';
  module.exports['read' + suffix] =
    Buffer.prototype['read' + suffix].call;
  module.exports['write' + suffix] =
    Buffer.prototype['write' + suffix].call;

  ['16', '32'].forEach(function (size) {
    ['LE', 'BE'].forEach(function (endian) {
      var suffix = sign + size + endian;
      var read = Buffer.prototype['read' + suffix];
      module.exports['read' + suffix] =
        function (buf, offset) {
          return read.call(buf, offset);
        };
      var write = Buffer.prototype['write' + suffix];
      module.exports['write' + suffix] =
        function (buf, val, offset) {
          return write.call(buf, val, offset);
        };
    });
  });
});

// Check that a value is an integer within the given range
function check_value(val, min, max) {
    val = +val;
    if (typeof(val) != 'number' || val < min || val > max || Math.floor(val) !== val) {
        throw new TypeError("\"value\" argument is out of bounds");
    }
    return val;
}

// Check that something is within the Buffer bounds
function check_bounds(buf, offset, len) {
    if (offset < 0 || offset + len > buf.length) {
        throw new RangeError("Index out of range");
    }
}

function readUInt24BE(buf, offset) {
  return buf.readUInt8(offset) << 16 | buf.readUInt16BE(offset + 1);
}
module.exports.readUInt24BE = readUInt24BE;

function writeUInt24BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffff);
    check_bounds(buf, offset, 3);
    buf.writeUInt8(val >>> 16, offset);
    buf.writeUInt16BE(val & 0xffff, offset + 1);
}
module.exports.writeUInt24BE = writeUInt24BE;

function readUInt40BE(buf, offset) {
    return (buf.readUInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
}
module.exports.readUInt40BE = readUInt40BE;

function writeUInt40BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffff);
    check_bounds(buf, offset, 5);
    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 1);
}
module.exports.writeUInt40BE = writeUInt40BE;

function readUInt48BE(buf, offset) {
    return buf.readUInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
}
module.exports.readUInt48BE = readUInt48BE;

function writeUInt48BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 2);
}
module.exports.writeUInt48BE = writeUInt48BE;

function readUInt56BE(buf, offset) {
    return ((buf.readUInt8(offset) || 0) << 16 | buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
}
module.exports.readUInt56BE = readUInt56BE;

function writeUInt56BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x100000000000000) {
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt8(hi >>> 16, offset);
        buf.writeUInt16BE(hi & 0xffff, offset + 1);
        buf.writeInt32BE(val & -1, offset + 3);
    } else {
        // Special case because 2^56-1 gets rounded up to 2^56
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
    }
}
module.exports.writeUInt56BE = writeUInt56BE;

function readUInt64BE(buf, offset) {
    return buf.readUInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
}
module.exports.readUInt64BE = readUInt64BE;

function writeUInt64BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x10000000000000000) {
        buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
        buf.writeInt32BE(val & -1, offset + 4);
    } else {
        // Special case because 2^64-1 gets rounded up to 2^64
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0xff;
    }
}
module.exports.writeUInt64BE = writeUInt64BE;

function readUInt24LE(buf, offset) {
    return buf.readUInt8(offset + 2) << 16 | buf.readUInt16LE(offset);
}
module.exports.readUInt24LE = readUInt24LE;

function writeUInt24LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffff);
    check_bounds(buf, offset, 3);

    buf.writeUInt16LE(val & 0xffff, offset);
    buf.writeUInt8(val >>> 16, offset + 2);
}
module.exports.writeUInt24LE = writeUInt24LE;

function readUInt40LE(buf, offset) {
    return (buf.readUInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt40LE = readUInt40LE;

function writeUInt40LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffff);
    check_bounds(buf, offset, 5);
    buf.writeInt32LE(val & -1, offset);
    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeUInt40LE = writeUInt40LE;

function readUInt48LE(buf, offset) {
    return buf.readUInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt48LE = readUInt48LE;

function writeUInt48LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeInt32LE(val & -1, offset);
    buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeUInt48LE = writeUInt48LE;

function readUInt56LE(buf, offset) {
    return ((buf.readUInt8(offset + 6) || 0) << 16 | buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt56LE = readUInt56LE;

function writeUInt56LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x100000000000000) {
        buf.writeInt32LE(val & -1, offset);
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt16LE(hi & 0xffff, offset + 4);
        buf.writeUInt8(hi >>> 16, offset + 6);
    } else {
        // Special case because 2^56-1 gets rounded up to 2^56
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
    }
}
module.exports.writeUInt56LE = writeUInt56LE;

function readUInt64LE(buf, offset) {
    return buf.readUInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt64LE = readUInt64LE;

function writeUInt64LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x10000000000000000) {
        buf.writeInt32LE(val & -1, offset);
        buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    } else {
        // Special case because 2^64-1 gets rounded up to 2^64
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0xff;
    }
}
module.exports.writeUInt64LE = writeUInt64LE;


function readInt24BE(buf, offset) {
    return (buf.readInt8(offset) << 16) + buf.readUInt16BE(offset + 1);
}
module.exports.readInt24BE = readInt24BE;

function writeInt24BE(buf, val, offset) {
    val = check_value(val, -0x800000, 0x7fffff);
    check_bounds(buf, offset, 3);
    buf.writeInt8(val >> 16, offset);
    buf.writeUInt16BE(val & 0xffff, offset + 1);
}
module.exports.writeInt24BE = writeInt24BE;

function readInt40BE(buf, offset) {
    return (buf.readInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
}
module.exports.readInt40BE = readInt40BE;

function writeInt40BE(buf, val, offset) {
    val = check_value(val, -0x8000000000, 0x7fffffffff);
    check_bounds(buf, offset, 5);
    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 1);
}
module.exports.writeInt40BE = writeInt40BE;

function readInt48BE(buf, offset) {
    return buf.readInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
}
module.exports.readInt48BE = readInt48BE;

function writeInt48BE(buf, val, offset) {
    val = check_value(val, -0x800000000000, 0x7fffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 2);
}
module.exports.writeInt48BE = writeInt48BE;

function readInt56BE(buf, offset) {
    return (((buf.readInt8(offset) || 0) << 16) + buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
}
module.exports.readInt56BE = readInt56BE;

function writeInt56BE(buf, val, offset) {
    val = check_value(val, -0x800000000000000, 0x7fffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x80000000000000) {
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeInt8(hi >> 16, offset);
        buf.writeUInt16BE(hi & 0xffff, offset + 1);
        buf.writeInt32BE(val & -1, offset + 3);
    } else {
        // Special case because 2^55-1 gets rounded up to 2^55
        buf[offset] = 0x7f;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
    }
}
module.exports.writeInt56BE = writeInt56BE;

function readInt64BE(buf, offset) {
    return buf.readInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
}
module.exports.readInt64BE = readInt64BE;

function writeInt64BE(buf, val, offset) {
    val = check_value(val, -0x800000000000000000, 0x7fffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x8000000000000000) {
        buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
        buf.writeInt32BE(val & -1, offset + 4);
    } else {
        // Special case because 2^63-1 gets rounded up to 2^63
        buf[offset] = 0x7f;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0xff;
    }
}
module.exports.writeInt64BE = writeInt64BE;

function readInt24LE(buf, offset) {
    return (buf.readInt8(offset + 2) << 16) + buf.readUInt16LE(offset);
}
module.exports.readInt24LE = readInt24LE;

function writeInt24LE(buf, val, offset) {
    val = check_value(val, -0x800000, 0x7fffff);
    check_bounds(buf, offset, 3);
    buf.writeUInt16LE(val & 0xffff, offset);
    buf.writeInt8(val >> 16, offset + 2);
}
module.exports.writeInt24LE = writeInt24LE;

function readInt40LE(buf, offset) {
    return (buf.readInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt40LE = readInt40LE;

function writeInt40LE(buf, val, offset) {
    val = check_value(val, -0x8000000000, 0x7fffffffff);
    check_bounds(buf, offset, 5);
    buf.writeInt32LE(val & -1, offset);
    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeInt40LE = writeInt40LE;

function readInt48LE(buf, offset) {
    return buf.readInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt48LE = readInt48LE;

function writeInt48LE(buf, val, offset) {
    val = check_value(val, -0x800000000000, 0x7fffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeInt32LE(val & -1, offset);
    buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeInt48LE = writeInt48LE;

function readInt56LE(buf, offset) {
    return (((buf.readInt8(offset + 6) || 0) << 16) + buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt56LE = readInt56LE;

function writeInt56LE(buf, val, offset) {
    val = check_value(val, -0x80000000000000, 0x7fffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x80000000000000) {
        buf.writeInt32LE(val & -1, offset);
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt16LE(hi & 0xffff, offset + 4);
        buf.writeInt8(hi >> 16, offset + 6);
    } else {
        // Special case because 2^55-1 gets rounded up to 2^55
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0x7f;
    }
}
module.exports.writeInt56LE = writeInt56LE;

function readInt64LE(buf, offset) {
    return buf.readInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt64LE = readInt64LE;

function writeInt64LE(buf, val, offset) {
    val = check_value(val, -0x8000000000000000, 0x7fffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x8000000000000000) {
        buf.writeInt32LE(val & -1, offset);
        buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    } else {
        // Special case because 2^55-1 gets rounded up to 2^55
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0x7f;
    }
}
module.exports.writeInt64LE = writeInt64LE;


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/deprecation/dist-web/index.js":
/*!****************************************************!*\
  !*** ./node_modules/deprecation/dist-web/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deprecation": () => (/* binding */ Deprecation)
/* harmony export */ });
class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}




/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports["default"] = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;


/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/readable-stream/duplex.js":
/*!************************************************!*\
  !*** ./node_modules/readable-stream/duplex.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js")


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/


/*<replacement>*/
var Buffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = __webpack_require__(/*! util */ "?d17e");
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/index.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/index.js").StringDecoder);
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}


/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js")


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/string_decoder/index.js":
/*!**********************************************!*\
  !*** ./node_modules/string_decoder/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const amqplib_1 = __importDefault(__webpack_require__(/*! amqplib */ "./node_modules/amqplib/channel_api.js"));
const core_1 = __importDefault(__webpack_require__(/*! @actions/core */ "./node_modules/@actions/core/lib/core.js"));
const github_1 = __importDefault(__webpack_require__(/*! @actions/github */ "./node_modules/@actions/github/lib/github.js"));
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const branch = core_1.default.getInput("branch");
        const connection = yield amqplib_1.default.connect("amqp://localhost"); // Alterar para IP do servidor (laptop)
        const channel = yield connection.createChannel();
        const queue = "notify-discord";
        yield channel.assertQueue(queue, { durable: true });
        channel.sendToQueue(queue, Buffer.from(branch));
        console.log(`[x] Sent ${branch} to ${queue}`);
        yield channel.close();
        yield connection.close();
        const payload = JSON.stringify(github_1.default.context.payload, undefined, 2);
        console.log(`The event payload: ${payload}`);
    });
}
main().catch(error => {
    core_1.default.setFailed(error.message);
});


/***/ }),

/***/ "./node_modules/tunnel/index.js":
/*!**************************************!*\
  !*** ./node_modules/tunnel/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/tunnel */ "./node_modules/tunnel/lib/tunnel.js");


/***/ }),

/***/ "./node_modules/tunnel/lib/tunnel.js":
/*!*******************************************!*\
  !*** ./node_modules/tunnel/lib/tunnel.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'assert'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ "./node_modules/universal-user-agent/dist-web/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/universal-user-agent/dist-web/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUserAgent": () => (/* binding */ getUserAgent)
/* harmony export */ });
function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
    }
    if (typeof process === "object" && "version" in process) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "?d17e":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/is-plain-object/dist/is-plain-object.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/is-plain-object/dist/is-plain-object.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject)
/* harmony export */ });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}




/***/ }),

/***/ "./node_modules/amqplib/package.json":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/package.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"amqplib","homepage":"http://amqp-node.github.io/amqplib/","main":"./channel_api.js","version":"0.10.3","description":"An AMQP 0-9-1 (e.g., RabbitMQ) library and client.","repository":{"type":"git","url":"https://github.com/amqp-node/amqplib.git"},"engines":{"node":">=10"},"dependencies":{"@acuminous/bitsyntax":"^0.1.2","buffer-more-ints":"~1.0.0","readable-stream":"1.x >=1.1.9","url-parse":"~1.5.10"},"devDependencies":{"claire":"0.4.1","mocha":"^9.2.2","nyc":"^15.1.0","uglify-js":"2.8.x"},"scripts":{"test":"make test","prepare":"make"},"keywords":["AMQP","AMQP 0-9-1","RabbitMQ"],"author":"Michael Bridgen <mikeb@squaremobius.net>","license":"MIT"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5RUFBeUU7QUFDNUc7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxrQ0FBa0Msa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ3pFLGlCQUFpQixNQUFNLDhDQUE4QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsdUdBQXVHO0FBQ3ZHOzs7Ozs7Ozs7OztBQzVsQmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUIsR0FBRyxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7Ozs7Ozs7Ozs7QUM1RGE7O0FBRWIsdUhBQW1EO0FBQ25ELHlIQUFvRDtBQUNwRCxtSUFBeUQ7QUFDekQsbUlBQXlEOztBQUV6RCxzQkFBc0IsR0FBRywrSEFDUztBQUNsQyx1SUFBaUU7Ozs7Ozs7Ozs7OztBQ1RqRTs7QUFFYTs7QUFFYixtQkFBTyxDQUFDLDZFQUFrQjtBQUMxQixRQUFRLG1JQUFzQjs7QUFFOUIsWUFBWSw4RkFBd0I7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLG1FQUFVO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBZTtBQUN2QztBQUNBOztBQUVBLGFBQWEsc0ZBQTZCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUMsZUFBZTtBQUNoRCxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLG1DQUFtQyxlQUFlO0FBQ2xELGtCQUFrQjtBQUNsQixvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGlDQUFpQyxlQUFlO0FBQ2hELGdCQUFnQjtBQUNoQiw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Qsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RCxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsY0FBYztBQUNkO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxzQkFBc0I7QUFDdEIsMkNBQTJDO0FBQzNDLGtEQUFrRDtBQUNsRCxzQ0FBc0M7QUFDdEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLGlCQUFpQjtBQUNqQixrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVLElBQUk7QUFDZCwyQkFBMkI7QUFDM0IsVUFBVSxJQUFJOztBQUVkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDBDQUEwQztBQUMxQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQkFBc0I7QUFDdEI7QUFDQSw0Q0FBNEM7QUFDNUMsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CO0FBQ3BCLFVBQVUsSUFBSTs7QUFFZDtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOVNBOztBQUVBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDckMsYUFBYSxzRkFBNkI7O0FBRTFDO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSw4RkFBd0I7O0FBRXBDLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLDBCQUEwQjs7QUFFMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyxrREFBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0I7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QiwwQkFBMEI7Ozs7Ozs7Ozs7OztBQ3ZPMUI7QUFDQTs7QUFFYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscUVBQVc7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLG1FQUFVOztBQUUvQjtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQixjQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRLDBDQUEwQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFFBQVEsMkNBQTJDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3Q0FBd0M7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLDJCQUEyQjs7Ozs7Ozs7Ozs7O0FDN1MzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDhIQUE4SDtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EscUNBQXFDLDJIQUEySDtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhIQUE4SDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwSEFBMEg7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlIQUF5SDtBQUMvSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkZBQTJGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrSEFBK0g7QUFDL0o7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyRjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRHQUE0RztBQUMzSTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkdBQTZHO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwSEFBMEg7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdJQUFnSTtBQUNoSztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkZBQTJGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2SEFBNkg7QUFDN0o7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtIQUErSDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEhBQThIO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBIQUEwSDtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4SEFBOEg7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkdBQTJHO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJHQUEyRztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEg7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsb0RBQVMsVUFBVSxtQkFBTyxDQUFDLDZFQUFrQixxSUFBcUk7O0FBRXRNLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Ozs7QUM1RHpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQzdDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQzFCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xCYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOzs7Ozs7Ozs7OztBQy9hM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsd0pBQW9EOztBQUVwRDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvR0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFrQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNWRBLHFJQUF3RDs7Ozs7Ozs7Ozs7O0FDQTNDOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxxSUFBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFLGNBQWM7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEscUlBQXdCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVOYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCwrQkFBK0IsbUJBQU8sQ0FBQywrREFBZTtBQUN0RCxpQ0FBaUMsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBLGdDQUFnQyxRQUFRLEtBQUssTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNsQ0QsK0ZBQXdDOzs7Ozs7Ozs7Ozs7QUNBM0I7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLGtJQUFLO0FBQ3ZCLFVBQVUsbUJBQU8sQ0FBQyxrSUFBSztBQUN2QixXQUFXLG1CQUFPLENBQUMsbUlBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLG9JQUFPO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQywrQ0FBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMscUlBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLG1JQUFNOzs7QUFHekIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCOzs7QUFHdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsYUFBYSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7O0FDdlF2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQixHQUFHLG1CQUFtQixFQUFFLGFBQWE7QUFDMUY7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7Ozs7Ozs7Ozs7O0FDWGE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDREQUFlO0FBQ3RDLFNBQVMsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBTSw4QkFBOEIscUJBQU07QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJO0FBQ0osc0NBQXNDO0FBQ3RDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyx5QkFBeUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvY29yZS9saWIvY29tbWFuZC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9jb3JlL2xpYi9jb3JlLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2NvcmUvbGliL2ZpbGUtY29tbWFuZC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9jb3JlL2xpYi9vaWRjLXV0aWxzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2NvcmUvbGliL3BhdGgtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvY29yZS9saWIvc3VtbWFyeS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9jb3JlL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9naXRodWIvbGliL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvZ2l0aHViL2xpYi9naXRodWIuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvZ2l0aHViL2xpYi9pbnRlcm5hbC91dGlscy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9naXRodWIvbGliL3V0aWxzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2h0dHAtY2xpZW50L2xpYi9hdXRoLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2h0dHAtY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9odHRwLWNsaWVudC9saWIvcHJveHkuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2NvbXBpbGUuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2NvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3VtaW5vdXMvYml0c3ludGF4L2xpYi9pbnRlcnAuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhcnNlLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3VtaW5vdXMvYml0c3ludGF4L2xpYi9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvYXV0aC10b2tlbi9kaXN0LXdlYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9jb3JlL2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L2VuZHBvaW50L2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L2dyYXBocWwvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcGx1Z2luLXBhZ2luYXRlLXJlc3QvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcGx1Z2luLXJlc3QtZW5kcG9pbnQtbWV0aG9kcy9kaXN0LXdlYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0LWVycm9yL2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3JlcXVlc3QvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9jaGFubmVsX2FwaS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9hcGlfYXJncy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9iaXRzZXQuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jaGFubmVsX21vZGVsLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2NvZGVjLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9kZWZzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2Vycm9yLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9mcmFtZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9oZWFydGJlYXQuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvbXV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9hZGQuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlZ2lzdGVyLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYnVmZmVyLW1vcmUtaW50cy9idWZmZXItbW9yZS1pbnRzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2RlcHJlY2F0aW9uL2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdHVubmVsL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3R1bm5lbC9saWIvdHVubmVsLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbC11c2VyLWFnZW50L2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3VybC1wYXJzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL21kNS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL2lnbm9yZWR8L2hvbWUvcmFzdGVsaS93d3cvbm90aWZ5LWRpc2NvcmQvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWJ8dXRpbCIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9pcy1wbGFpbi1vYmplY3QvZGlzdC9pcy1wbGFpbi1vYmplY3QubWpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc3N1ZSA9IGV4cG9ydHMuaXNzdWVDb21tYW5kID0gdm9pZCAwO1xuY29uc3Qgb3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm9zXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQ29tbWFuZHNcbiAqXG4gKiBDb21tYW5kIEZvcm1hdDpcbiAqICAgOjpuYW1lIGtleT12YWx1ZSxrZXk9dmFsdWU6Om1lc3NhZ2VcbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgOjp3YXJuaW5nOjpUaGlzIGlzIHRoZSBtZXNzYWdlXG4gKiAgIDo6c2V0LWVudiBuYW1lPU1ZX1ZBUjo6c29tZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBpc3N1ZUNvbW1hbmQoY29tbWFuZCwgcHJvcGVydGllcywgbWVzc2FnZSkge1xuICAgIGNvbnN0IGNtZCA9IG5ldyBDb21tYW5kKGNvbW1hbmQsIHByb3BlcnRpZXMsIG1lc3NhZ2UpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNtZC50b1N0cmluZygpICsgb3MuRU9MKTtcbn1cbmV4cG9ydHMuaXNzdWVDb21tYW5kID0gaXNzdWVDb21tYW5kO1xuZnVuY3Rpb24gaXNzdWUobmFtZSwgbWVzc2FnZSA9ICcnKSB7XG4gICAgaXNzdWVDb21tYW5kKG5hbWUsIHt9LCBtZXNzYWdlKTtcbn1cbmV4cG9ydHMuaXNzdWUgPSBpc3N1ZTtcbmNvbnN0IENNRF9TVFJJTkcgPSAnOjonO1xuY2xhc3MgQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgcHJvcGVydGllcywgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSAnbWlzc2luZy5jb21tYW5kJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGNtZFN0ciA9IENNRF9TVFJJTkcgKyB0aGlzLmNvbW1hbmQ7XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMgJiYgT2JqZWN0LmtleXModGhpcy5wcm9wZXJ0aWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbWRTdHIgKz0gJyAnO1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZFN0ciArPSAnLCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWRTdHIgKz0gYCR7a2V5fT0ke2VzY2FwZVByb3BlcnR5KHZhbCl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbWRTdHIgKz0gYCR7Q01EX1NUUklOR30ke2VzY2FwZURhdGEodGhpcy5tZXNzYWdlKX1gO1xuICAgICAgICByZXR1cm4gY21kU3RyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZURhdGEocykge1xuICAgIHJldHVybiB1dGlsc18xLnRvQ29tbWFuZFZhbHVlKHMpXG4gICAgICAgIC5yZXBsYWNlKC8lL2csICclMjUnKVxuICAgICAgICAucmVwbGFjZSgvXFxyL2csICclMEQnKVxuICAgICAgICAucmVwbGFjZSgvXFxuL2csICclMEEnKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVByb3BlcnR5KHMpIHtcbiAgICByZXR1cm4gdXRpbHNfMS50b0NvbW1hbmRWYWx1ZShzKVxuICAgICAgICAucmVwbGFjZSgvJS9nLCAnJTI1JylcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnJTBEJylcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnJTBBJylcbiAgICAgICAgLnJlcGxhY2UoLzovZywgJyUzQScpXG4gICAgICAgIC5yZXBsYWNlKC8sL2csICclMkMnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1hbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldElEVG9rZW4gPSBleHBvcnRzLmdldFN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSBleHBvcnRzLmdyb3VwID0gZXhwb3J0cy5lbmRHcm91cCA9IGV4cG9ydHMuc3RhcnRHcm91cCA9IGV4cG9ydHMuaW5mbyA9IGV4cG9ydHMubm90aWNlID0gZXhwb3J0cy53YXJuaW5nID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMuZGVidWcgPSBleHBvcnRzLmlzRGVidWcgPSBleHBvcnRzLnNldEZhaWxlZCA9IGV4cG9ydHMuc2V0Q29tbWFuZEVjaG8gPSBleHBvcnRzLnNldE91dHB1dCA9IGV4cG9ydHMuZ2V0Qm9vbGVhbklucHV0ID0gZXhwb3J0cy5nZXRNdWx0aWxpbmVJbnB1dCA9IGV4cG9ydHMuZ2V0SW5wdXQgPSBleHBvcnRzLmFkZFBhdGggPSBleHBvcnRzLnNldFNlY3JldCA9IGV4cG9ydHMuZXhwb3J0VmFyaWFibGUgPSBleHBvcnRzLkV4aXRDb2RlID0gdm9pZCAwO1xuY29uc3QgY29tbWFuZF8xID0gcmVxdWlyZShcIi4vY29tbWFuZFwiKTtcbmNvbnN0IGZpbGVfY29tbWFuZF8xID0gcmVxdWlyZShcIi4vZmlsZS1jb21tYW5kXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgb3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm9zXCIpKTtcbmNvbnN0IHBhdGggPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3Qgb2lkY191dGlsc18xID0gcmVxdWlyZShcIi4vb2lkYy11dGlsc1wiKTtcbi8qKlxuICogVGhlIGNvZGUgdG8gZXhpdCBhbiBhY3Rpb25cbiAqL1xudmFyIEV4aXRDb2RlO1xuKGZ1bmN0aW9uIChFeGl0Q29kZSkge1xuICAgIC8qKlxuICAgICAqIEEgY29kZSBpbmRpY2F0aW5nIHRoYXQgdGhlIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqL1xuICAgIEV4aXRDb2RlW0V4aXRDb2RlW1wiU3VjY2Vzc1wiXSA9IDBdID0gXCJTdWNjZXNzXCI7XG4gICAgLyoqXG4gICAgICogQSBjb2RlIGluZGljYXRpbmcgdGhhdCB0aGUgYWN0aW9uIHdhcyBhIGZhaWx1cmVcbiAgICAgKi9cbiAgICBFeGl0Q29kZVtFeGl0Q29kZVtcIkZhaWx1cmVcIl0gPSAxXSA9IFwiRmFpbHVyZVwiO1xufSkoRXhpdENvZGUgPSBleHBvcnRzLkV4aXRDb2RlIHx8IChleHBvcnRzLkV4aXRDb2RlID0ge30pKTtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFZhcmlhYmxlc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTZXRzIGVudiB2YXJpYWJsZSBmb3IgdGhpcyBhY3Rpb24gYW5kIGZ1dHVyZSBhY3Rpb25zIGluIHRoZSBqb2JcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBzZXRcbiAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gTm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmlhIEpTT04uc3RyaW5naWZ5XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBleHBvcnRWYXJpYWJsZShuYW1lLCB2YWwpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWwgPSB1dGlsc18xLnRvQ29tbWFuZFZhbHVlKHZhbCk7XG4gICAgcHJvY2Vzcy5lbnZbbmFtZV0gPSBjb252ZXJ0ZWRWYWw7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwcm9jZXNzLmVudlsnR0lUSFVCX0VOViddIHx8ICcnO1xuICAgIGlmIChmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gZmlsZV9jb21tYW5kXzEuaXNzdWVGaWxlQ29tbWFuZCgnRU5WJywgZmlsZV9jb21tYW5kXzEucHJlcGFyZUtleVZhbHVlTWVzc2FnZShuYW1lLCB2YWwpKTtcbiAgICB9XG4gICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnc2V0LWVudicsIHsgbmFtZSB9LCBjb252ZXJ0ZWRWYWwpO1xufVxuZXhwb3J0cy5leHBvcnRWYXJpYWJsZSA9IGV4cG9ydFZhcmlhYmxlO1xuLyoqXG4gKiBSZWdpc3RlcnMgYSBzZWNyZXQgd2hpY2ggd2lsbCBnZXQgbWFza2VkIGZyb20gbG9nc1xuICogQHBhcmFtIHNlY3JldCB2YWx1ZSBvZiB0aGUgc2VjcmV0XG4gKi9cbmZ1bmN0aW9uIHNldFNlY3JldChzZWNyZXQpIHtcbiAgICBjb21tYW5kXzEuaXNzdWVDb21tYW5kKCdhZGQtbWFzaycsIHt9LCBzZWNyZXQpO1xufVxuZXhwb3J0cy5zZXRTZWNyZXQgPSBzZXRTZWNyZXQ7XG4vKipcbiAqIFByZXBlbmRzIGlucHV0UGF0aCB0byB0aGUgUEFUSCAoZm9yIHRoaXMgYWN0aW9uIGFuZCBmdXR1cmUgYWN0aW9ucylcbiAqIEBwYXJhbSBpbnB1dFBhdGhcbiAqL1xuZnVuY3Rpb24gYWRkUGF0aChpbnB1dFBhdGgpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHByb2Nlc3MuZW52WydHSVRIVUJfUEFUSCddIHx8ICcnO1xuICAgIGlmIChmaWxlUGF0aCkge1xuICAgICAgICBmaWxlX2NvbW1hbmRfMS5pc3N1ZUZpbGVDb21tYW5kKCdQQVRIJywgaW5wdXRQYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbW1hbmRfMS5pc3N1ZUNvbW1hbmQoJ2FkZC1wYXRoJywge30sIGlucHV0UGF0aCk7XG4gICAgfVxuICAgIHByb2Nlc3MuZW52WydQQVRIJ10gPSBgJHtpbnB1dFBhdGh9JHtwYXRoLmRlbGltaXRlcn0ke3Byb2Nlc3MuZW52WydQQVRIJ119YDtcbn1cbmV4cG9ydHMuYWRkUGF0aCA9IGFkZFBhdGg7XG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGFuIGlucHV0LlxuICogVW5sZXNzIHRyaW1XaGl0ZXNwYWNlIGlzIHNldCB0byBmYWxzZSBpbiBJbnB1dE9wdGlvbnMsIHRoZSB2YWx1ZSBpcyBhbHNvIHRyaW1tZWQuXG4gKiBSZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgdmFsdWUgaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtICAgICBuYW1lICAgICBuYW1lIG9mIHRoZSBpbnB1dCB0byBnZXRcbiAqIEBwYXJhbSAgICAgb3B0aW9ucyAgb3B0aW9uYWwuIFNlZSBJbnB1dE9wdGlvbnMuXG4gKiBAcmV0dXJucyAgIHN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRJbnB1dChuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsID0gcHJvY2Vzcy5lbnZbYElOUFVUXyR7bmFtZS5yZXBsYWNlKC8gL2csICdfJykudG9VcHBlckNhc2UoKX1gXSB8fCAnJztcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcXVpcmVkICYmICF2YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCByZXF1aXJlZCBhbmQgbm90IHN1cHBsaWVkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJpbVdoaXRlc3BhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWwudHJpbSgpO1xufVxuZXhwb3J0cy5nZXRJbnB1dCA9IGdldElucHV0O1xuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZXMgb2YgYW4gbXVsdGlsaW5lIGlucHV0LiAgRWFjaCB2YWx1ZSBpcyBhbHNvIHRyaW1tZWQuXG4gKlxuICogQHBhcmFtICAgICBuYW1lICAgICBuYW1lIG9mIHRoZSBpbnB1dCB0byBnZXRcbiAqIEBwYXJhbSAgICAgb3B0aW9ucyAgb3B0aW9uYWwuIFNlZSBJbnB1dE9wdGlvbnMuXG4gKiBAcmV0dXJucyAgIHN0cmluZ1tdXG4gKlxuICovXG5mdW5jdGlvbiBnZXRNdWx0aWxpbmVJbnB1dChuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXRzID0gZ2V0SW5wdXQobmFtZSwgb3B0aW9ucylcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAuZmlsdGVyKHggPT4geCAhPT0gJycpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJpbVdoaXRlc3BhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dHMubWFwKGlucHV0ID0+IGlucHV0LnRyaW0oKSk7XG59XG5leHBvcnRzLmdldE11bHRpbGluZUlucHV0ID0gZ2V0TXVsdGlsaW5lSW5wdXQ7XG4vKipcbiAqIEdldHMgdGhlIGlucHV0IHZhbHVlIG9mIHRoZSBib29sZWFuIHR5cGUgaW4gdGhlIFlBTUwgMS4yIFwiY29yZSBzY2hlbWFcIiBzcGVjaWZpY2F0aW9uLlxuICogU3VwcG9ydCBib29sZWFuIGlucHV0IGxpc3Q6IGB0cnVlIHwgVHJ1ZSB8IFRSVUUgfCBmYWxzZSB8IEZhbHNlIHwgRkFMU0VgIC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYWxzbyBpbiBib29sZWFuIHR5cGUuXG4gKiByZWY6IGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuICpcbiAqIEBwYXJhbSAgICAgbmFtZSAgICAgbmFtZSBvZiB0aGUgaW5wdXQgdG8gZ2V0XG4gKiBAcGFyYW0gICAgIG9wdGlvbnMgIG9wdGlvbmFsLiBTZWUgSW5wdXRPcHRpb25zLlxuICogQHJldHVybnMgICBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGdldEJvb2xlYW5JbnB1dChuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHJ1ZVZhbHVlID0gWyd0cnVlJywgJ1RydWUnLCAnVFJVRSddO1xuICAgIGNvbnN0IGZhbHNlVmFsdWUgPSBbJ2ZhbHNlJywgJ0ZhbHNlJywgJ0ZBTFNFJ107XG4gICAgY29uc3QgdmFsID0gZ2V0SW5wdXQobmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKHRydWVWYWx1ZS5pbmNsdWRlcyh2YWwpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZmFsc2VWYWx1ZS5pbmNsdWRlcyh2YWwpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW5wdXQgZG9lcyBub3QgbWVldCBZQU1MIDEuMiBcIkNvcmUgU2NoZW1hXCIgc3BlY2lmaWNhdGlvbjogJHtuYW1lfVxcbmAgK1xuICAgICAgICBgU3VwcG9ydCBib29sZWFuIGlucHV0IGxpc3Q6IFxcYHRydWUgfCBUcnVlIHwgVFJVRSB8IGZhbHNlIHwgRmFsc2UgfCBGQUxTRVxcYGApO1xufVxuZXhwb3J0cy5nZXRCb29sZWFuSW5wdXQgPSBnZXRCb29sZWFuSW5wdXQ7XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGFuIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gICAgIG5hbWUgICAgIG5hbWUgb2YgdGhlIG91dHB1dCB0byBzZXRcbiAqIEBwYXJhbSAgICAgdmFsdWUgICAgdmFsdWUgdG8gc3RvcmUuIE5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIHZpYSBKU09OLnN0cmluZ2lmeVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc2V0T3V0cHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwcm9jZXNzLmVudlsnR0lUSFVCX09VVFBVVCddIHx8ICcnO1xuICAgIGlmIChmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gZmlsZV9jb21tYW5kXzEuaXNzdWVGaWxlQ29tbWFuZCgnT1VUUFVUJywgZmlsZV9jb21tYW5kXzEucHJlcGFyZUtleVZhbHVlTWVzc2FnZShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShvcy5FT0wpO1xuICAgIGNvbW1hbmRfMS5pc3N1ZUNvbW1hbmQoJ3NldC1vdXRwdXQnLCB7IG5hbWUgfSwgdXRpbHNfMS50b0NvbW1hbmRWYWx1ZSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5zZXRPdXRwdXQgPSBzZXRPdXRwdXQ7XG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGVjaG9pbmcgb2YgY29tbWFuZHMgaW50byBzdGRvdXQgZm9yIHRoZSByZXN0IG9mIHRoZSBzdGVwLlxuICogRWNob2luZyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IGlmIEFDVElPTlNfU1RFUF9ERUJVRyBpcyBub3Qgc2V0LlxuICpcbiAqL1xuZnVuY3Rpb24gc2V0Q29tbWFuZEVjaG8oZW5hYmxlZCkge1xuICAgIGNvbW1hbmRfMS5pc3N1ZSgnZWNobycsIGVuYWJsZWQgPyAnb24nIDogJ29mZicpO1xufVxuZXhwb3J0cy5zZXRDb21tYW5kRWNobyA9IHNldENvbW1hbmRFY2hvO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVzdWx0c1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTZXRzIHRoZSBhY3Rpb24gc3RhdHVzIHRvIGZhaWxlZC5cbiAqIFdoZW4gdGhlIGFjdGlvbiBleGl0cyBpdCB3aWxsIGJlIHdpdGggYW4gZXhpdCBjb2RlIG9mIDFcbiAqIEBwYXJhbSBtZXNzYWdlIGFkZCBlcnJvciBpc3N1ZSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIHNldEZhaWxlZChtZXNzYWdlKSB7XG4gICAgcHJvY2Vzcy5leGl0Q29kZSA9IEV4aXRDb2RlLkZhaWx1cmU7XG4gICAgZXJyb3IobWVzc2FnZSk7XG59XG5leHBvcnRzLnNldEZhaWxlZCA9IHNldEZhaWxlZDtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExvZ2dpbmcgQ29tbWFuZHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogR2V0cyB3aGV0aGVyIEFjdGlvbnMgU3RlcCBEZWJ1ZyBpcyBvbiBvciBub3RcbiAqL1xuZnVuY3Rpb24gaXNEZWJ1ZygpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbJ1JVTk5FUl9ERUJVRyddID09PSAnMSc7XG59XG5leHBvcnRzLmlzRGVidWcgPSBpc0RlYnVnO1xuLyoqXG4gKiBXcml0ZXMgZGVidWcgbWVzc2FnZSB0byB1c2VyIGxvZ1xuICogQHBhcmFtIG1lc3NhZ2UgZGVidWcgbWVzc2FnZVxuICovXG5mdW5jdGlvbiBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnZGVidWcnLCB7fSwgbWVzc2FnZSk7XG59XG5leHBvcnRzLmRlYnVnID0gZGVidWc7XG4vKipcbiAqIEFkZHMgYW4gZXJyb3IgaXNzdWVcbiAqIEBwYXJhbSBtZXNzYWdlIGVycm9yIGlzc3VlIG1lc3NhZ2UuIEVycm9ycyB3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgdmlhIHRvU3RyaW5nKClcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBhbm5vdGF0aW9uLlxuICovXG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBjb21tYW5kXzEuaXNzdWVDb21tYW5kKCdlcnJvcicsIHV0aWxzXzEudG9Db21tYW5kUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgbWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yID8gbWVzc2FnZS50b1N0cmluZygpIDogbWVzc2FnZSk7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG4vKipcbiAqIEFkZHMgYSB3YXJuaW5nIGlzc3VlXG4gKiBAcGFyYW0gbWVzc2FnZSB3YXJuaW5nIGlzc3VlIG1lc3NhZ2UuIEVycm9ycyB3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgdmlhIHRvU3RyaW5nKClcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBhbm5vdGF0aW9uLlxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHByb3BlcnRpZXMgPSB7fSkge1xuICAgIGNvbW1hbmRfMS5pc3N1ZUNvbW1hbmQoJ3dhcm5pbmcnLCB1dGlsc18xLnRvQ29tbWFuZFByb3BlcnRpZXMocHJvcGVydGllcyksIG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvciA/IG1lc3NhZ2UudG9TdHJpbmcoKSA6IG1lc3NhZ2UpO1xufVxuZXhwb3J0cy53YXJuaW5nID0gd2FybmluZztcbi8qKlxuICogQWRkcyBhIG5vdGljZSBpc3N1ZVxuICogQHBhcmFtIG1lc3NhZ2Ugbm90aWNlIGlzc3VlIG1lc3NhZ2UuIEVycm9ycyB3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgdmlhIHRvU3RyaW5nKClcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBhbm5vdGF0aW9uLlxuICovXG5mdW5jdGlvbiBub3RpY2UobWVzc2FnZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnbm90aWNlJywgdXRpbHNfMS50b0NvbW1hbmRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IgPyBtZXNzYWdlLnRvU3RyaW5nKCkgOiBtZXNzYWdlKTtcbn1cbmV4cG9ydHMubm90aWNlID0gbm90aWNlO1xuLyoqXG4gKiBXcml0ZXMgaW5mbyB0byBsb2cgd2l0aCBjb25zb2xlLmxvZy5cbiAqIEBwYXJhbSBtZXNzYWdlIGluZm8gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBpbmZvKG1lc3NhZ2UpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShtZXNzYWdlICsgb3MuRU9MKTtcbn1cbmV4cG9ydHMuaW5mbyA9IGluZm87XG4vKipcbiAqIEJlZ2luIGFuIG91dHB1dCBncm91cC5cbiAqXG4gKiBPdXRwdXQgdW50aWwgdGhlIG5leHQgYGdyb3VwRW5kYCB3aWxsIGJlIGZvbGRhYmxlIGluIHRoaXMgZ3JvdXBcbiAqXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3V0cHV0IGdyb3VwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0R3JvdXAobmFtZSkge1xuICAgIGNvbW1hbmRfMS5pc3N1ZSgnZ3JvdXAnLCBuYW1lKTtcbn1cbmV4cG9ydHMuc3RhcnRHcm91cCA9IHN0YXJ0R3JvdXA7XG4vKipcbiAqIEVuZCBhbiBvdXRwdXQgZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIGVuZEdyb3VwKCkge1xuICAgIGNvbW1hbmRfMS5pc3N1ZSgnZW5kZ3JvdXAnKTtcbn1cbmV4cG9ydHMuZW5kR3JvdXAgPSBlbmRHcm91cDtcbi8qKlxuICogV3JhcCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gY2FsbCBpbiBhIGdyb3VwLlxuICpcbiAqIFJldHVybnMgdGhlIHNhbWUgdHlwZSBhcyB0aGUgZnVuY3Rpb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBncm91cFxuICogQHBhcmFtIGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwIGluIHRoZSBncm91cFxuICovXG5mdW5jdGlvbiBncm91cChuYW1lLCBmbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHN0YXJ0R3JvdXAobmFtZSk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZW5kR3JvdXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gV3JhcHBlciBhY3Rpb24gc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogU2F2ZXMgc3RhdGUgZm9yIGN1cnJlbnQgYWN0aW9uLCB0aGUgc3RhdGUgY2FuIG9ubHkgYmUgcmV0cmlldmVkIGJ5IHRoaXMgYWN0aW9uJ3MgcG9zdCBqb2IgZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSAgICAgbmFtZSAgICAgbmFtZSBvZiB0aGUgc3RhdGUgdG8gc3RvcmVcbiAqIEBwYXJhbSAgICAgdmFsdWUgICAgdmFsdWUgdG8gc3RvcmUuIE5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIHZpYSBKU09OLnN0cmluZ2lmeVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc2F2ZVN0YXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwcm9jZXNzLmVudlsnR0lUSFVCX1NUQVRFJ10gfHwgJyc7XG4gICAgaWYgKGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBmaWxlX2NvbW1hbmRfMS5pc3N1ZUZpbGVDb21tYW5kKCdTVEFURScsIGZpbGVfY29tbWFuZF8xLnByZXBhcmVLZXlWYWx1ZU1lc3NhZ2UobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnc2F2ZS1zdGF0ZScsIHsgbmFtZSB9LCB1dGlsc18xLnRvQ29tbWFuZFZhbHVlKHZhbHVlKSk7XG59XG5leHBvcnRzLnNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYW4gc3RhdGUgc2V0IGJ5IHRoaXMgYWN0aW9uJ3MgbWFpbiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtICAgICBuYW1lICAgICBuYW1lIG9mIHRoZSBzdGF0ZSB0byBnZXRcbiAqIEByZXR1cm5zICAgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlKG5hbWUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbYFNUQVRFXyR7bmFtZX1gXSB8fCAnJztcbn1cbmV4cG9ydHMuZ2V0U3RhdGUgPSBnZXRTdGF0ZTtcbmZ1bmN0aW9uIGdldElEVG9rZW4oYXVkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIG9pZGNfdXRpbHNfMS5PaWRjQ2xpZW50LmdldElEVG9rZW4oYXVkKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0SURUb2tlbiA9IGdldElEVG9rZW47XG4vKipcbiAqIFN1bW1hcnkgZXhwb3J0c1xuICovXG52YXIgc3VtbWFyeV8xID0gcmVxdWlyZShcIi4vc3VtbWFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN1bW1hcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1bW1hcnlfMS5zdW1tYXJ5OyB9IH0pO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgY29yZS5zdW1tYXJ5XG4gKi9cbnZhciBzdW1tYXJ5XzIgPSByZXF1aXJlKFwiLi9zdW1tYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFya2Rvd25TdW1tYXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdW1tYXJ5XzIubWFya2Rvd25TdW1tYXJ5OyB9IH0pO1xuLyoqXG4gKiBQYXRoIGV4cG9ydHNcbiAqL1xudmFyIHBhdGhfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3BhdGgtdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1Bvc2l4UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGF0aF91dGlsc18xLnRvUG9zaXhQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9XaW4zMlBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhdGhfdXRpbHNfMS50b1dpbjMyUGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvUGxhdGZvcm1QYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXRoX3V0aWxzXzEudG9QbGF0Zm9ybVBhdGg7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gRm9yIGludGVybmFsIHVzZSwgc3ViamVjdCB0byBjaGFuZ2UuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmVwYXJlS2V5VmFsdWVNZXNzYWdlID0gZXhwb3J0cy5pc3N1ZUZpbGVDb21tYW5kID0gdm9pZCAwO1xuLy8gV2UgdXNlIGFueSBhcyBhIHZhbGlkIGlucHV0IHR5cGVcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGZzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBvcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwib3NcIikpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBpc3N1ZUZpbGVDb21tYW5kKGNvbW1hbmQsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHByb2Nlc3MuZW52W2BHSVRIVUJfJHtjb21tYW5kfWBdO1xuICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgZmlsZSBjb21tYW5kICR7Y29tbWFuZH1gKTtcbiAgICB9XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZmlsZSBhdCBwYXRoOiAke2ZpbGVQYXRofWApO1xuICAgIH1cbiAgICBmcy5hcHBlbmRGaWxlU3luYyhmaWxlUGF0aCwgYCR7dXRpbHNfMS50b0NvbW1hbmRWYWx1ZShtZXNzYWdlKX0ke29zLkVPTH1gLCB7XG4gICAgICAgIGVuY29kaW5nOiAndXRmOCdcbiAgICB9KTtcbn1cbmV4cG9ydHMuaXNzdWVGaWxlQ29tbWFuZCA9IGlzc3VlRmlsZUNvbW1hbmQ7XG5mdW5jdGlvbiBwcmVwYXJlS2V5VmFsdWVNZXNzYWdlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBkZWxpbWl0ZXIgPSBgZ2hhZGVsaW1pdGVyXyR7dXVpZF8xLnY0KCl9YDtcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IHV0aWxzXzEudG9Db21tYW5kVmFsdWUodmFsdWUpO1xuICAgIC8vIFRoZXNlIHNob3VsZCByZWFsaXN0aWNhbGx5IG5ldmVyIGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZSBzb21lb25lIGZpbmRzIGFcbiAgICAvLyB3YXkgdG8gZXhwbG9pdCB1dWlkIGdlbmVyYXRpb24gbGV0J3Mgbm90IGFsbG93IGtleXMgb3IgdmFsdWVzIHRoYXQgY29udGFpblxuICAgIC8vIHRoZSBkZWxpbWl0ZXIuXG4gICAgaWYgKGtleS5pbmNsdWRlcyhkZWxpbWl0ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dDogbmFtZSBzaG91bGQgbm90IGNvbnRhaW4gdGhlIGRlbGltaXRlciBcIiR7ZGVsaW1pdGVyfVwiYCk7XG4gICAgfVxuICAgIGlmIChjb252ZXJ0ZWRWYWx1ZS5pbmNsdWRlcyhkZWxpbWl0ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dDogdmFsdWUgc2hvdWxkIG5vdCBjb250YWluIHRoZSBkZWxpbWl0ZXIgXCIke2RlbGltaXRlcn1cImApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fTw8JHtkZWxpbWl0ZXJ9JHtvcy5FT0x9JHtjb252ZXJ0ZWRWYWx1ZX0ke29zLkVPTH0ke2RlbGltaXRlcn1gO1xufVxuZXhwb3J0cy5wcmVwYXJlS2V5VmFsdWVNZXNzYWdlID0gcHJlcGFyZUtleVZhbHVlTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtY29tbWFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PaWRjQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgaHR0cF9jbGllbnRfMSA9IHJlcXVpcmUoXCJAYWN0aW9ucy9odHRwLWNsaWVudFwiKTtcbmNvbnN0IGF1dGhfMSA9IHJlcXVpcmUoXCJAYWN0aW9ucy9odHRwLWNsaWVudC9saWIvYXV0aFwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jbGFzcyBPaWRjQ2xpZW50IHtcbiAgICBzdGF0aWMgY3JlYXRlSHR0cENsaWVudChhbGxvd1JldHJ5ID0gdHJ1ZSwgbWF4UmV0cnkgPSAxMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsbG93UmV0cmllczogYWxsb3dSZXRyeSxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IG1heFJldHJ5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgaHR0cF9jbGllbnRfMS5IdHRwQ2xpZW50KCdhY3Rpb25zL29pZGMtY2xpZW50JywgW25ldyBhdXRoXzEuQmVhcmVyQ3JlZGVudGlhbEhhbmRsZXIoT2lkY0NsaWVudC5nZXRSZXF1ZXN0VG9rZW4oKSldLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRSZXF1ZXN0VG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcHJvY2Vzcy5lbnZbJ0FDVElPTlNfSURfVE9LRU5fUkVRVUVTVF9UT0tFTiddO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgQUNUSU9OU19JRF9UT0tFTl9SRVFVRVNUX1RPS0VOIGVudiB2YXJpYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgc3RhdGljIGdldElEVG9rZW5VcmwoKSB7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWVVcmwgPSBwcm9jZXNzLmVudlsnQUNUSU9OU19JRF9UT0tFTl9SRVFVRVNUX1VSTCddO1xuICAgICAgICBpZiAoIXJ1bnRpbWVVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBBQ1RJT05TX0lEX1RPS0VOX1JFUVVFU1RfVVJMIGVudiB2YXJpYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW50aW1lVXJsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2FsbChpZF90b2tlbl91cmwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaHR0cGNsaWVudCA9IE9pZGNDbGllbnQuY3JlYXRlSHR0cENsaWVudCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgaHR0cGNsaWVudFxuICAgICAgICAgICAgICAgIC5nZXRKc29uKGlkX3Rva2VuX3VybClcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBJRCBUb2tlbi4gXFxuIFxuICAgICAgICBFcnJvciBDb2RlIDogJHtlcnJvci5zdGF0dXNDb2RlfVxcbiBcbiAgICAgICAgRXJyb3IgTWVzc2FnZTogJHtlcnJvci5yZXN1bHQubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaWRfdG9rZW4gPSAoX2EgPSByZXMucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWU7XG4gICAgICAgICAgICBpZiAoIWlkX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBqc29uIGJvZHkgZG8gbm90IGhhdmUgSUQgVG9rZW4gZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZF90b2tlbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRJRFRva2VuKGF1ZGllbmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE5ldyBJRCBUb2tlbiBpcyByZXF1ZXN0ZWQgZnJvbSBhY3Rpb24gc2VydmljZVxuICAgICAgICAgICAgICAgIGxldCBpZF90b2tlbl91cmwgPSBPaWRjQ2xpZW50LmdldElEVG9rZW5VcmwoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaWVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZEF1ZGllbmNlID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1ZGllbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW5fdXJsID0gYCR7aWRfdG9rZW5fdXJsfSZhdWRpZW5jZT0ke2VuY29kZWRBdWRpZW5jZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3JlXzEuZGVidWcoYElEIHRva2VuIHVybCBpcyAke2lkX3Rva2VuX3VybH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpZF90b2tlbiA9IHlpZWxkIE9pZGNDbGllbnQuZ2V0Q2FsbChpZF90b2tlbl91cmwpO1xuICAgICAgICAgICAgICAgIGNvcmVfMS5zZXRTZWNyZXQoaWRfdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZF90b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk9pZGNDbGllbnQgPSBPaWRjQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2lkYy11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvUGxhdGZvcm1QYXRoID0gZXhwb3J0cy50b1dpbjMyUGF0aCA9IGV4cG9ydHMudG9Qb3NpeFBhdGggPSB2b2lkIDA7XG5jb25zdCBwYXRoID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJwYXRoXCIpKTtcbi8qKlxuICogdG9Qb3NpeFBhdGggY29udmVydHMgdGhlIGdpdmVuIHBhdGggdG8gdGhlIHBvc2l4IGZvcm0uIE9uIFdpbmRvd3MsIFxcXFwgd2lsbCBiZVxuICogcmVwbGFjZWQgd2l0aCAvLlxuICpcbiAqIEBwYXJhbSBwdGguIFBhdGggdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiBzdHJpbmcgUG9zaXggcGF0aC5cbiAqL1xuZnVuY3Rpb24gdG9Qb3NpeFBhdGgocHRoKSB7XG4gICAgcmV0dXJuIHB0aC5yZXBsYWNlKC9bXFxcXF0vZywgJy8nKTtcbn1cbmV4cG9ydHMudG9Qb3NpeFBhdGggPSB0b1Bvc2l4UGF0aDtcbi8qKlxuICogdG9XaW4zMlBhdGggY29udmVydHMgdGhlIGdpdmVuIHBhdGggdG8gdGhlIHdpbjMyIGZvcm0uIE9uIExpbnV4LCAvIHdpbGwgYmVcbiAqIHJlcGxhY2VkIHdpdGggXFxcXC5cbiAqXG4gKiBAcGFyYW0gcHRoLiBQYXRoIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4gc3RyaW5nIFdpbjMyIHBhdGguXG4gKi9cbmZ1bmN0aW9uIHRvV2luMzJQYXRoKHB0aCkge1xuICAgIHJldHVybiBwdGgucmVwbGFjZSgvWy9dL2csICdcXFxcJyk7XG59XG5leHBvcnRzLnRvV2luMzJQYXRoID0gdG9XaW4zMlBhdGg7XG4vKipcbiAqIHRvUGxhdGZvcm1QYXRoIGNvbnZlcnRzIHRoZSBnaXZlbiBwYXRoIHRvIGEgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aC4gSXQgZG9lc1xuICogdGhpcyBieSByZXBsYWNpbmcgaW5zdGFuY2VzIG9mIC8gYW5kIFxcIHdpdGggdGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGhcbiAqIHNlcGFyYXRvci5cbiAqXG4gKiBAcGFyYW0gcHRoIFRoZSBwYXRoIHRvIHBsYXRmb3JtaXplLlxuICogQHJldHVybiBzdHJpbmcgVGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGguXG4gKi9cbmZ1bmN0aW9uIHRvUGxhdGZvcm1QYXRoKHB0aCkge1xuICAgIHJldHVybiBwdGgucmVwbGFjZSgvWy9cXFxcXS9nLCBwYXRoLnNlcCk7XG59XG5leHBvcnRzLnRvUGxhdGZvcm1QYXRoID0gdG9QbGF0Zm9ybVBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN1bW1hcnkgPSBleHBvcnRzLm1hcmtkb3duU3VtbWFyeSA9IGV4cG9ydHMuU1VNTUFSWV9ET0NTX1VSTCA9IGV4cG9ydHMuU1VNTUFSWV9FTlZfVkFSID0gdm9pZCAwO1xuY29uc3Qgb3NfMSA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB7IGFjY2VzcywgYXBwZW5kRmlsZSwgd3JpdGVGaWxlIH0gPSBmc18xLnByb21pc2VzO1xuZXhwb3J0cy5TVU1NQVJZX0VOVl9WQVIgPSAnR0lUSFVCX1NURVBfU1VNTUFSWSc7XG5leHBvcnRzLlNVTU1BUllfRE9DU19VUkwgPSAnaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vYWN0aW9ucy91c2luZy13b3JrZmxvd3Mvd29ya2Zsb3ctY29tbWFuZHMtZm9yLWdpdGh1Yi1hY3Rpb25zI2FkZGluZy1hLWpvYi1zdW1tYXJ5JztcbmNsYXNzIFN1bW1hcnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHN1bW1hcnkgZmlsZSBwYXRoIGZyb20gdGhlIGVudmlyb25tZW50LCByZWplY3RzIGlmIGVudiB2YXIgaXMgbm90IGZvdW5kIG9yIGZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICAgKiBBbHNvIGNoZWNrcyByL3cgcGVybWlzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdGVwIHN1bW1hcnkgZmlsZSBwYXRoXG4gICAgICovXG4gICAgZmlsZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRoRnJvbUVudiA9IHByb2Nlc3MuZW52W2V4cG9ydHMuU1VNTUFSWV9FTlZfVkFSXTtcbiAgICAgICAgICAgIGlmICghcGF0aEZyb21FbnYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciAkJHtleHBvcnRzLlNVTU1BUllfRU5WX1ZBUn0uIENoZWNrIGlmIHlvdXIgcnVudGltZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBqb2Igc3VtbWFyaWVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBhY2Nlc3MocGF0aEZyb21FbnYsIGZzXzEuY29uc3RhbnRzLlJfT0sgfCBmc18xLmNvbnN0YW50cy5XX09LKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGFjY2VzcyBzdW1tYXJ5IGZpbGU6ICcke3BhdGhGcm9tRW52fScuIENoZWNrIGlmIHRoZSBmaWxlIGhhcyBjb3JyZWN0IHJlYWQvd3JpdGUgcGVybWlzc2lvbnMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9maWxlUGF0aCA9IHBhdGhGcm9tRW52O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVQYXRoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHMgY29udGVudCBpbiBhbiBIVE1MIHRhZywgYWRkaW5nIGFueSBIVE1MIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSFRNTCB0YWcgdG8gd3JhcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gY29udGVudCBjb250ZW50IHdpdGhpbiB0aGUgdGFnXG4gICAgICogQHBhcmFtIHtbYXR0cmlidXRlOiBzdHJpbmddOiBzdHJpbmd9IGF0dHJzIGtleS12YWx1ZSBsaXN0IG9mIEhUTUwgYXR0cmlidXRlcyB0byBhZGRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgd3JhcHBlZCBpbiBIVE1MIGVsZW1lbnRcbiAgICAgKi9cbiAgICB3cmFwKHRhZywgY29udGVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBjb25zdCBodG1sQXR0cnMgPSBPYmplY3QuZW50cmllcyhhdHRycylcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAke2tleX09XCIke3ZhbHVlfVwiYClcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYDwke3RhZ30ke2h0bWxBdHRyc30+YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDwke3RhZ30ke2h0bWxBdHRyc30+JHtjb250ZW50fTwvJHt0YWd9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0ZXh0IGluIHRoZSBidWZmZXIgdG8gdGhlIHN1bW1hcnkgYnVmZmVyIGZpbGUgYW5kIGVtcHRpZXMgYnVmZmVyLiBXaWxsIGFwcGVuZCBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdW1tYXJ5V3JpdGVPcHRpb25zfSBbb3B0aW9uc10gKG9wdGlvbmFsKSBvcHRpb25zIGZvciB3cml0ZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1bW1hcnk+fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgd3JpdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcndyaXRlID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm92ZXJ3cml0ZSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHlpZWxkIHRoaXMuZmlsZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlRnVuYyA9IG92ZXJ3cml0ZSA/IHdyaXRlRmlsZSA6IGFwcGVuZEZpbGU7XG4gICAgICAgICAgICB5aWVsZCB3cml0ZUZ1bmMoZmlsZVBhdGgsIHRoaXMuX2J1ZmZlciwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlCdWZmZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3VtbWFyeSBidWZmZXIgYW5kIHdpcGVzIHRoZSBzdW1tYXJ5IGZpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpLndyaXRlKHsgb3ZlcndyaXRlOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdW1tYXJ5IGJ1ZmZlciBhcyBhIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIG9mIHN1bW1hcnkgYnVmZmVyXG4gICAgICovXG4gICAgc3RyaW5naWZ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3VtbWFyeSBidWZmZXIgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZW59IHRydWUgaWYgdGhlIGJ1ZmZlciBpcyBlbXB0eVxuICAgICAqL1xuICAgIGlzRW1wdHlCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN1bW1hcnkgYnVmZmVyIHdpdGhvdXQgd3JpdGluZyB0byBzdW1tYXJ5IGZpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgZW1wdHlCdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9ICcnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyByYXcgdGV4dCB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGNvbnRlbnQgdG8gYWRkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWRkRU9MPWZhbHNlXSAob3B0aW9uYWwpIGFwcGVuZCBhbiBFT0wgdG8gdGhlIHJhdyB0ZXh0IChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkUmF3KHRleHQsIGFkZEVPTCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciArPSB0ZXh0O1xuICAgICAgICByZXR1cm4gYWRkRU9MID8gdGhpcy5hZGRFT0woKSA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIG9wZXJhdGluZyBzeXN0ZW0tc3BlY2lmaWMgZW5kLW9mLWxpbmUgbWFya2VyIHRvIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkRU9MKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcob3NfMS5FT0wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEhUTUwgY29kZWJsb2NrIHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgY29udGVudCB0byByZW5kZXIgd2l0aGluIGZlbmNlZCBjb2RlIGJsb2NrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgKG9wdGlvbmFsKSBsYW5ndWFnZSB0byBzeW50YXggaGlnaGxpZ2h0IGNvZGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkQ29kZUJsb2NrKGNvZGUsIGxhbmcpIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCAobGFuZyAmJiB7IGxhbmcgfSkpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwKCdwcmUnLCB0aGlzLndyYXAoJ2NvZGUnLCBjb2RlKSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gSFRNTCBsaXN0IHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaXRlbXMgbGlzdCBvZiBpdGVtcyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmRlcmVkPWZhbHNlXSAob3B0aW9uYWwpIGlmIHRoZSByZW5kZXJlZCBsaXN0IHNob3VsZCBiZSBvcmRlcmVkIG9yIG5vdCAoZGVmYXVsdDogZmFsc2UpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3VtbWFyeX0gc3VtbWFyeSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFkZExpc3QoaXRlbXMsIG9yZGVyZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB0YWcgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHRoaXMud3JhcCgnbGknLCBpdGVtKSkuam9pbignJyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAodGFnLCBsaXN0SXRlbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gSFRNTCB0YWJsZSB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3VtbWFyeVRhYmxlQ2VsbFtdfSByb3dzIHRhYmxlIHJvd3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkVGFibGUocm93cykge1xuICAgICAgICBjb25zdCB0YWJsZUJvZHkgPSByb3dzXG4gICAgICAgICAgICAubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IHJvd1xuICAgICAgICAgICAgICAgIC5tYXAoY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwKCd0ZCcsIGNlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWRlciwgZGF0YSwgY29sc3Bhbiwgcm93c3BhbiB9ID0gY2VsbDtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSBoZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGNvbHNwYW4gJiYgeyBjb2xzcGFuIH0pKSwgKHJvd3NwYW4gJiYgeyByb3dzcGFuIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwKHRhZywgZGF0YSwgYXR0cnMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwKCd0cicsIGNlbGxzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcCgndGFibGUnLCB0YWJsZUJvZHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb2xsYXBzYWJsZSBIVE1MIGRldGFpbHMgZWxlbWVudCB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCB0ZXh0IGZvciB0aGUgY2xvc2VkIHN0YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgY29sbGFwc2FibGUgY29udGVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGREZXRhaWxzKGxhYmVsLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoJ2RldGFpbHMnLCB0aGlzLndyYXAoJ3N1bW1hcnknLCBsYWJlbCkgKyBjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmF3KGVsZW1lbnQpLmFkZEVPTCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEhUTUwgaW1hZ2UgdGFnIHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBwYXRoIHRvIHRoZSBpbWFnZSB5b3UgdG8gZW1iZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWx0IHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtTdW1tYXJ5SW1hZ2VPcHRpb25zfSBvcHRpb25zIChvcHRpb25hbCkgYWRkaXRpb24gaW1hZ2UgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRJbWFnZShzcmMsIGFsdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAod2lkdGggJiYgeyB3aWR0aCB9KSksIChoZWlnaHQgJiYgeyBoZWlnaHQgfSkpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwKCdpbWcnLCBudWxsLCBPYmplY3QuYXNzaWduKHsgc3JjLCBhbHQgfSwgYXR0cnMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmF3KGVsZW1lbnQpLmFkZEVPTCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEhUTUwgc2VjdGlvbiBoZWFkaW5nIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGhlYWRpbmcgdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSBbbGV2ZWw9MV0gKG9wdGlvbmFsKSB0aGUgaGVhZGluZyBsZXZlbCwgZGVmYXVsdDogMVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRIZWFkaW5nKHRleHQsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGBoJHtsZXZlbH1gO1xuICAgICAgICBjb25zdCBhbGxvd2VkVGFnID0gWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddLmluY2x1ZGVzKHRhZylcbiAgICAgICAgICAgID8gdGFnXG4gICAgICAgICAgICA6ICdoMSc7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoYWxsb3dlZFRhZywgdGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBIVE1MIHRoZW1hdGljIGJyZWFrICg8aHI+KSB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkU2VwYXJhdG9yKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwKCdocicsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gSFRNTCBsaW5lIGJyZWFrICg8YnI+KSB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkQnJlYWsoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoJ2JyJywgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBIVE1MIGJsb2NrcXVvdGUgdG8gdGhlIHN1bW1hcnkgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBxdW90ZSB0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNpdGUgKG9wdGlvbmFsKSBjaXRhdGlvbiB1cmxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkUXVvdGUodGV4dCwgY2l0ZSkge1xuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oe30sIChjaXRlICYmIHsgY2l0ZSB9KSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoJ2Jsb2NrcXVvdGUnLCB0ZXh0LCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBIVE1MIGFuY2hvciB0YWcgdG8gdGhlIHN1bW1hcnkgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBsaW5rIHRleHQvY29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIGh5cGVybGlua1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRMaW5rKHRleHQsIGhyZWYpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcCgnYScsIHRleHQsIHsgaHJlZiB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmF3KGVsZW1lbnQpLmFkZEVPTCgpO1xuICAgIH1cbn1cbmNvbnN0IF9zdW1tYXJ5ID0gbmV3IFN1bW1hcnkoKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBjb3JlLnN1bW1hcnlgXG4gKi9cbmV4cG9ydHMubWFya2Rvd25TdW1tYXJ5ID0gX3N1bW1hcnk7XG5leHBvcnRzLnN1bW1hcnkgPSBfc3VtbWFyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1bW1hcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBXZSB1c2UgYW55IGFzIGEgdmFsaWQgaW5wdXQgdHlwZVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0NvbW1hbmRQcm9wZXJ0aWVzID0gZXhwb3J0cy50b0NvbW1hbmRWYWx1ZSA9IHZvaWQgMDtcbi8qKlxuICogU2FuaXRpemVzIGFuIGlucHV0IGludG8gYSBzdHJpbmcgc28gaXQgY2FuIGJlIHBhc3NlZCBpbnRvIGlzc3VlQ29tbWFuZCBzYWZlbHlcbiAqIEBwYXJhbSBpbnB1dCBpbnB1dCB0byBzYW5pdGl6ZSBpbnRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHRvQ29tbWFuZFZhbHVlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbn1cbmV4cG9ydHMudG9Db21tYW5kVmFsdWUgPSB0b0NvbW1hbmRWYWx1ZTtcbi8qKlxuICpcbiAqIEBwYXJhbSBhbm5vdGF0aW9uUHJvcGVydGllc1xuICogQHJldHVybnMgVGhlIGNvbW1hbmQgcHJvcGVydGllcyB0byBzZW5kIHdpdGggdGhlIGFjdHVhbCBhbm5vdGF0aW9uIGNvbW1hbmRcbiAqIFNlZSBJc3N1ZUNvbW1hbmRQcm9wZXJ0aWVzOiBodHRwczovL2dpdGh1Yi5jb20vYWN0aW9ucy9ydW5uZXIvYmxvYi9tYWluL3NyYy9SdW5uZXIuV29ya2VyL0FjdGlvbkNvbW1hbmRNYW5hZ2VyLmNzI0w2NDZcbiAqL1xuZnVuY3Rpb24gdG9Db21tYW5kUHJvcGVydGllcyhhbm5vdGF0aW9uUHJvcGVydGllcykge1xuICAgIGlmICghT2JqZWN0LmtleXMoYW5ub3RhdGlvblByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBhbm5vdGF0aW9uUHJvcGVydGllcy50aXRsZSxcbiAgICAgICAgZmlsZTogYW5ub3RhdGlvblByb3BlcnRpZXMuZmlsZSxcbiAgICAgICAgbGluZTogYW5ub3RhdGlvblByb3BlcnRpZXMuc3RhcnRMaW5lLFxuICAgICAgICBlbmRMaW5lOiBhbm5vdGF0aW9uUHJvcGVydGllcy5lbmRMaW5lLFxuICAgICAgICBjb2w6IGFubm90YXRpb25Qcm9wZXJ0aWVzLnN0YXJ0Q29sdW1uLFxuICAgICAgICBlbmRDb2x1bW46IGFubm90YXRpb25Qcm9wZXJ0aWVzLmVuZENvbHVtblxuICAgIH07XG59XG5leHBvcnRzLnRvQ29tbWFuZFByb3BlcnRpZXMgPSB0b0NvbW1hbmRQcm9wZXJ0aWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRleHQgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3Qgb3NfMSA9IHJlcXVpcmUoXCJvc1wiKTtcbmNsYXNzIENvbnRleHQge1xuICAgIC8qKlxuICAgICAqIEh5ZHJhdGUgdGhlIGNvbnRleHQgZnJvbSB0aGUgZW52aXJvbm1lbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuR0lUSFVCX0VWRU5UX1BBVEgpIHtcbiAgICAgICAgICAgIGlmIChmc18xLmV4aXN0c1N5bmMocHJvY2Vzcy5lbnYuR0lUSFVCX0VWRU5UX1BBVEgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXlsb2FkID0gSlNPTi5wYXJzZShmc18xLnJlYWRGaWxlU3luYyhwcm9jZXNzLmVudi5HSVRIVUJfRVZFTlRfUEFUSCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwcm9jZXNzLmVudi5HSVRIVUJfRVZFTlRfUEFUSDtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgR0lUSFVCX0VWRU5UX1BBVEggJHtwYXRofSBkb2VzIG5vdCBleGlzdCR7b3NfMS5FT0x9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBwcm9jZXNzLmVudi5HSVRIVUJfRVZFTlRfTkFNRTtcbiAgICAgICAgdGhpcy5zaGEgPSBwcm9jZXNzLmVudi5HSVRIVUJfU0hBO1xuICAgICAgICB0aGlzLnJlZiA9IHByb2Nlc3MuZW52LkdJVEhVQl9SRUY7XG4gICAgICAgIHRoaXMud29ya2Zsb3cgPSBwcm9jZXNzLmVudi5HSVRIVUJfV09SS0ZMT1c7XG4gICAgICAgIHRoaXMuYWN0aW9uID0gcHJvY2Vzcy5lbnYuR0lUSFVCX0FDVElPTjtcbiAgICAgICAgdGhpcy5hY3RvciA9IHByb2Nlc3MuZW52LkdJVEhVQl9BQ1RPUjtcbiAgICAgICAgdGhpcy5qb2IgPSBwcm9jZXNzLmVudi5HSVRIVUJfSk9CO1xuICAgICAgICB0aGlzLnJ1bk51bWJlciA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkdJVEhVQl9SVU5fTlVNQkVSLCAxMCk7XG4gICAgICAgIHRoaXMucnVuSWQgPSBwYXJzZUludChwcm9jZXNzLmVudi5HSVRIVUJfUlVOX0lELCAxMCk7XG4gICAgICAgIHRoaXMuYXBpVXJsID0gKF9hID0gcHJvY2Vzcy5lbnYuR0lUSFVCX0FQSV9VUkwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGBodHRwczovL2FwaS5naXRodWIuY29tYDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJVcmwgPSAoX2IgPSBwcm9jZXNzLmVudi5HSVRIVUJfU0VSVkVSX1VSTCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYGh0dHBzOi8vZ2l0aHViLmNvbWA7XG4gICAgICAgIHRoaXMuZ3JhcGhxbFVybCA9IChfYyA9IHByb2Nlc3MuZW52LkdJVEhVQl9HUkFQSFFMX1VSTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vZ3JhcGhxbGA7XG4gICAgfVxuICAgIGdldCBpc3N1ZSgpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMucGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZXBvKSwgeyBudW1iZXI6IChwYXlsb2FkLmlzc3VlIHx8IHBheWxvYWQucHVsbF9yZXF1ZXN0IHx8IHBheWxvYWQpLm51bWJlciB9KTtcbiAgICB9XG4gICAgZ2V0IHJlcG8oKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5HSVRIVUJfUkVQT1NJVE9SWSkge1xuICAgICAgICAgICAgY29uc3QgW293bmVyLCByZXBvXSA9IHByb2Nlc3MuZW52LkdJVEhVQl9SRVBPU0lUT1JZLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICByZXR1cm4geyBvd25lciwgcmVwbyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBheWxvYWQucmVwb3NpdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5wYXlsb2FkLnJlcG9zaXRvcnkub3duZXIubG9naW4sXG4gICAgICAgICAgICAgICAgcmVwbzogdGhpcy5wYXlsb2FkLnJlcG9zaXRvcnkubmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZXh0LnJlcG8gcmVxdWlyZXMgYSBHSVRIVUJfUkVQT1NJVE9SWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBsaWtlICdvd25lci9yZXBvJ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRleHQgPSBDb250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE9jdG9raXQgPSBleHBvcnRzLmNvbnRleHQgPSB2b2lkIDA7XG5jb25zdCBDb250ZXh0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRleHRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5jb250ZXh0ID0gbmV3IENvbnRleHQuQ29udGV4dCgpO1xuLyoqXG4gKiBSZXR1cm5zIGEgaHlkcmF0ZWQgb2N0b2tpdCByZWFkeSB0byB1c2UgZm9yIEdpdEh1YiBBY3Rpb25zXG4gKlxuICogQHBhcmFtICAgICB0b2tlbiAgICB0aGUgcmVwbyBQQVQgb3IgR0lUSFVCX1RPS0VOXG4gKiBAcGFyYW0gICAgIG9wdGlvbnMgIG90aGVyIG9wdGlvbnMgdG8gc2V0XG4gKi9cbmZ1bmN0aW9uIGdldE9jdG9raXQodG9rZW4sIG9wdGlvbnMsIC4uLmFkZGl0aW9uYWxQbHVnaW5zKSB7XG4gICAgY29uc3QgR2l0SHViV2l0aFBsdWdpbnMgPSB1dGlsc18xLkdpdEh1Yi5wbHVnaW4oLi4uYWRkaXRpb25hbFBsdWdpbnMpO1xuICAgIHJldHVybiBuZXcgR2l0SHViV2l0aFBsdWdpbnModXRpbHNfMS5nZXRPY3Rva2l0T3B0aW9ucyh0b2tlbiwgb3B0aW9ucykpO1xufVxuZXhwb3J0cy5nZXRPY3Rva2l0ID0gZ2V0T2N0b2tpdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdpdGh1Yi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFwaUJhc2VVcmwgPSBleHBvcnRzLmdldFByb3h5QWdlbnQgPSBleHBvcnRzLmdldEF1dGhTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBodHRwQ2xpZW50ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAYWN0aW9ucy9odHRwLWNsaWVudFwiKSk7XG5mdW5jdGlvbiBnZXRBdXRoU3RyaW5nKHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0b2tlbiAmJiAhb3B0aW9ucy5hdXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIHRva2VuIG9yIG9wdHMuYXV0aCBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2tlbiAmJiBvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIHRva2VuIGFuZCBvcHRzLmF1dGggbWF5IG5vdCBib3RoIGJlIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMuYXV0aCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmF1dGggOiBgdG9rZW4gJHt0b2tlbn1gO1xufVxuZXhwb3J0cy5nZXRBdXRoU3RyaW5nID0gZ2V0QXV0aFN0cmluZztcbmZ1bmN0aW9uIGdldFByb3h5QWdlbnQoZGVzdGluYXRpb25VcmwpIHtcbiAgICBjb25zdCBoYyA9IG5ldyBodHRwQ2xpZW50Lkh0dHBDbGllbnQoKTtcbiAgICByZXR1cm4gaGMuZ2V0QWdlbnQoZGVzdGluYXRpb25VcmwpO1xufVxuZXhwb3J0cy5nZXRQcm94eUFnZW50ID0gZ2V0UHJveHlBZ2VudDtcbmZ1bmN0aW9uIGdldEFwaUJhc2VVcmwoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52WydHSVRIVUJfQVBJX1VSTCddIHx8ICdodHRwczovL2FwaS5naXRodWIuY29tJztcbn1cbmV4cG9ydHMuZ2V0QXBpQmFzZVVybCA9IGdldEFwaUJhc2VVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE9jdG9raXRPcHRpb25zID0gZXhwb3J0cy5HaXRIdWIgPSBleHBvcnRzLmRlZmF1bHRzID0gZXhwb3J0cy5jb250ZXh0ID0gdm9pZCAwO1xuY29uc3QgQ29udGV4dCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb250ZXh0XCIpKTtcbmNvbnN0IFV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxzXCIpKTtcbi8vIG9jdG9raXQgKyBwbHVnaW5zXG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9jdG9raXQvY29yZVwiKTtcbmNvbnN0IHBsdWdpbl9yZXN0X2VuZHBvaW50X21ldGhvZHNfMSA9IHJlcXVpcmUoXCJAb2N0b2tpdC9wbHVnaW4tcmVzdC1lbmRwb2ludC1tZXRob2RzXCIpO1xuY29uc3QgcGx1Z2luX3BhZ2luYXRlX3Jlc3RfMSA9IHJlcXVpcmUoXCJAb2N0b2tpdC9wbHVnaW4tcGFnaW5hdGUtcmVzdFwiKTtcbmV4cG9ydHMuY29udGV4dCA9IG5ldyBDb250ZXh0LkNvbnRleHQoKTtcbmNvbnN0IGJhc2VVcmwgPSBVdGlscy5nZXRBcGlCYXNlVXJsKCk7XG5leHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIGJhc2VVcmwsXG4gICAgcmVxdWVzdDoge1xuICAgICAgICBhZ2VudDogVXRpbHMuZ2V0UHJveHlBZ2VudChiYXNlVXJsKVxuICAgIH1cbn07XG5leHBvcnRzLkdpdEh1YiA9IGNvcmVfMS5PY3Rva2l0LnBsdWdpbihwbHVnaW5fcmVzdF9lbmRwb2ludF9tZXRob2RzXzEucmVzdEVuZHBvaW50TWV0aG9kcywgcGx1Z2luX3BhZ2luYXRlX3Jlc3RfMS5wYWdpbmF0ZVJlc3QpLmRlZmF1bHRzKGV4cG9ydHMuZGVmYXVsdHMpO1xuLyoqXG4gKiBDb252aWVuY2UgZnVuY3Rpb24gdG8gY29ycmVjdGx5IGZvcm1hdCBPY3Rva2l0IE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0gICAgIHRva2VuICAgIHRoZSByZXBvIFBBVCBvciBHSVRIVUJfVE9LRU5cbiAqIEBwYXJhbSAgICAgb3B0aW9ucyAgb3RoZXIgb3B0aW9ucyB0byBzZXRcbiAqL1xuZnVuY3Rpb24gZ2V0T2N0b2tpdE9wdGlvbnModG9rZW4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyB8fCB7fSk7IC8vIFNoYWxsb3cgY2xvbmUgLSBkb24ndCBtdXRhdGUgdGhlIG9iamVjdCBwcm92aWRlZCBieSB0aGUgY2FsbGVyXG4gICAgLy8gQXV0aFxuICAgIGNvbnN0IGF1dGggPSBVdGlscy5nZXRBdXRoU3RyaW5nKHRva2VuLCBvcHRzKTtcbiAgICBpZiAoYXV0aCkge1xuICAgICAgICBvcHRzLmF1dGggPSBhdXRoO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cztcbn1cbmV4cG9ydHMuZ2V0T2N0b2tpdE9wdGlvbnMgPSBnZXRPY3Rva2l0T3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcnNvbmFsQWNjZXNzVG9rZW5DcmVkZW50aWFsSGFuZGxlciA9IGV4cG9ydHMuQmVhcmVyQ3JlZGVudGlhbEhhbmRsZXIgPSBleHBvcnRzLkJhc2ljQ3JlZGVudGlhbEhhbmRsZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNpY0NyZWRlbnRpYWxIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgICAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgfVxuICAgIHByZXBhcmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgcmVxdWVzdCBoYXMgbm8gaGVhZGVycycpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dGhpcy51c2VybmFtZX06JHt0aGlzLnBhc3N3b3JkfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgIH1cbiAgICAvLyBUaGlzIGhhbmRsZXIgY2Fubm90IGhhbmRsZSA0MDFcbiAgICBjYW5IYW5kbGVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNDcmVkZW50aWFsSGFuZGxlciA9IEJhc2ljQ3JlZGVudGlhbEhhbmRsZXI7XG5jbGFzcyBCZWFyZXJDcmVkZW50aWFsSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICAvLyBjdXJyZW50bHkgaW1wbGVtZW50cyBwcmUtYXV0aG9yaXphdGlvblxuICAgIC8vIFRPRE86IHN1cHBvcnQgcHJlQXV0aCA9IGZhbHNlIHdoZXJlIGl0IGhvb2tzIG9uIDQwMVxuICAgIHByZXBhcmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgcmVxdWVzdCBoYXMgbm8gaGVhZGVycycpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3RoaXMudG9rZW59YDtcbiAgICB9XG4gICAgLy8gVGhpcyBoYW5kbGVyIGNhbm5vdCBoYW5kbGUgNDAxXG4gICAgY2FuSGFuZGxlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJlYXJlckNyZWRlbnRpYWxIYW5kbGVyID0gQmVhcmVyQ3JlZGVudGlhbEhhbmRsZXI7XG5jbGFzcyBQZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9XG4gICAgLy8gY3VycmVudGx5IGltcGxlbWVudHMgcHJlLWF1dGhvcml6YXRpb25cbiAgICAvLyBUT0RPOiBzdXBwb3J0IHByZUF1dGggPSBmYWxzZSB3aGVyZSBpdCBob29rcyBvbiA0MDFcbiAgICBwcmVwYXJlUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHJlcXVlc3QgaGFzIG5vIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKGBQQVQ6JHt0aGlzLnRva2VufWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgIH1cbiAgICAvLyBUaGlzIGhhbmRsZXIgY2Fubm90IGhhbmRsZSA0MDFcbiAgICBjYW5IYW5kbGVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVyc29uYWxBY2Nlc3NUb2tlbkNyZWRlbnRpYWxIYW5kbGVyID0gUGVyc29uYWxBY2Nlc3NUb2tlbkNyZWRlbnRpYWxIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cENsaWVudCA9IGV4cG9ydHMuaXNIdHRwcyA9IGV4cG9ydHMuSHR0cENsaWVudFJlc3BvbnNlID0gZXhwb3J0cy5IdHRwQ2xpZW50RXJyb3IgPSBleHBvcnRzLmdldFByb3h5VXJsID0gZXhwb3J0cy5NZWRpYVR5cGVzID0gZXhwb3J0cy5IZWFkZXJzID0gZXhwb3J0cy5IdHRwQ29kZXMgPSB2b2lkIDA7XG5jb25zdCBodHRwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJodHRwXCIpKTtcbmNvbnN0IGh0dHBzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJodHRwc1wiKSk7XG5jb25zdCBwbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wcm94eVwiKSk7XG5jb25zdCB0dW5uZWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR1bm5lbFwiKSk7XG52YXIgSHR0cENvZGVzO1xuKGZ1bmN0aW9uIChIdHRwQ29kZXMpIHtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiT0tcIl0gPSAyMDBdID0gXCJPS1wiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJNdWx0aXBsZUNob2ljZXNcIl0gPSAzMDBdID0gXCJNdWx0aXBsZUNob2ljZXNcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiTW92ZWRQZXJtYW5lbnRseVwiXSA9IDMwMV0gPSBcIk1vdmVkUGVybWFuZW50bHlcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiUmVzb3VyY2VNb3ZlZFwiXSA9IDMwMl0gPSBcIlJlc291cmNlTW92ZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiU2VlT3RoZXJcIl0gPSAzMDNdID0gXCJTZWVPdGhlclwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJOb3RNb2RpZmllZFwiXSA9IDMwNF0gPSBcIk5vdE1vZGlmaWVkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlVzZVByb3h5XCJdID0gMzA1XSA9IFwiVXNlUHJveHlcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiU3dpdGNoUHJveHlcIl0gPSAzMDZdID0gXCJTd2l0Y2hQcm94eVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJUZW1wb3JhcnlSZWRpcmVjdFwiXSA9IDMwN10gPSBcIlRlbXBvcmFyeVJlZGlyZWN0XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlBlcm1hbmVudFJlZGlyZWN0XCJdID0gMzA4XSA9IFwiUGVybWFuZW50UmVkaXJlY3RcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiQmFkUmVxdWVzdFwiXSA9IDQwMF0gPSBcIkJhZFJlcXVlc3RcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiVW5hdXRob3JpemVkXCJdID0gNDAxXSA9IFwiVW5hdXRob3JpemVkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlBheW1lbnRSZXF1aXJlZFwiXSA9IDQwMl0gPSBcIlBheW1lbnRSZXF1aXJlZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJGb3JiaWRkZW5cIl0gPSA0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiTm90Rm91bmRcIl0gPSA0MDRdID0gXCJOb3RGb3VuZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJNZXRob2ROb3RBbGxvd2VkXCJdID0gNDA1XSA9IFwiTWV0aG9kTm90QWxsb3dlZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJOb3RBY2NlcHRhYmxlXCJdID0gNDA2XSA9IFwiTm90QWNjZXB0YWJsZVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWRcIl0gPSA0MDddID0gXCJQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiUmVxdWVzdFRpbWVvdXRcIl0gPSA0MDhdID0gXCJSZXF1ZXN0VGltZW91dFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJDb25mbGljdFwiXSA9IDQwOV0gPSBcIkNvbmZsaWN0XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkdvbmVcIl0gPSA0MTBdID0gXCJHb25lXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlRvb01hbnlSZXF1ZXN0c1wiXSA9IDQyOV0gPSBcIlRvb01hbnlSZXF1ZXN0c1wiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNTAwXSA9IFwiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJOb3RJbXBsZW1lbnRlZFwiXSA9IDUwMV0gPSBcIk5vdEltcGxlbWVudGVkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkJhZEdhdGV3YXlcIl0gPSA1MDJdID0gXCJCYWRHYXRld2F5XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlNlcnZpY2VVbmF2YWlsYWJsZVwiXSA9IDUwM10gPSBcIlNlcnZpY2VVbmF2YWlsYWJsZVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJHYXRld2F5VGltZW91dFwiXSA9IDUwNF0gPSBcIkdhdGV3YXlUaW1lb3V0XCI7XG59KShIdHRwQ29kZXMgPSBleHBvcnRzLkh0dHBDb2RlcyB8fCAoZXhwb3J0cy5IdHRwQ29kZXMgPSB7fSkpO1xudmFyIEhlYWRlcnM7XG4oZnVuY3Rpb24gKEhlYWRlcnMpIHtcbiAgICBIZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhY2NlcHRcIjtcbiAgICBIZWFkZXJzW1wiQ29udGVudFR5cGVcIl0gPSBcImNvbnRlbnQtdHlwZVwiO1xufSkoSGVhZGVycyA9IGV4cG9ydHMuSGVhZGVycyB8fCAoZXhwb3J0cy5IZWFkZXJzID0ge30pKTtcbnZhciBNZWRpYVR5cGVzO1xuKGZ1bmN0aW9uIChNZWRpYVR5cGVzKSB7XG4gICAgTWVkaWFUeXBlc1tcIkFwcGxpY2F0aW9uSnNvblwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xufSkoTWVkaWFUeXBlcyA9IGV4cG9ydHMuTWVkaWFUeXBlcyB8fCAoZXhwb3J0cy5NZWRpYVR5cGVzID0ge30pKTtcbi8qKlxuICogUmV0dXJucyB0aGUgcHJveHkgVVJMLCBkZXBlbmRpbmcgdXBvbiB0aGUgc3VwcGxpZWQgdXJsIGFuZCBwcm94eSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKiBAcGFyYW0gc2VydmVyVXJsICBUaGUgc2VydmVyIFVSTCB3aGVyZSB0aGUgcmVxdWVzdCB3aWxsIGJlIHNlbnQuIEZvciBleGFtcGxlLCBodHRwczovL2FwaS5naXRodWIuY29tXG4gKi9cbmZ1bmN0aW9uIGdldFByb3h5VXJsKHNlcnZlclVybCkge1xuICAgIGNvbnN0IHByb3h5VXJsID0gcG0uZ2V0UHJveHlVcmwobmV3IFVSTChzZXJ2ZXJVcmwpKTtcbiAgICByZXR1cm4gcHJveHlVcmwgPyBwcm94eVVybC5ocmVmIDogJyc7XG59XG5leHBvcnRzLmdldFByb3h5VXJsID0gZ2V0UHJveHlVcmw7XG5jb25zdCBIdHRwUmVkaXJlY3RDb2RlcyA9IFtcbiAgICBIdHRwQ29kZXMuTW92ZWRQZXJtYW5lbnRseSxcbiAgICBIdHRwQ29kZXMuUmVzb3VyY2VNb3ZlZCxcbiAgICBIdHRwQ29kZXMuU2VlT3RoZXIsXG4gICAgSHR0cENvZGVzLlRlbXBvcmFyeVJlZGlyZWN0LFxuICAgIEh0dHBDb2Rlcy5QZXJtYW5lbnRSZWRpcmVjdFxuXTtcbmNvbnN0IEh0dHBSZXNwb25zZVJldHJ5Q29kZXMgPSBbXG4gICAgSHR0cENvZGVzLkJhZEdhdGV3YXksXG4gICAgSHR0cENvZGVzLlNlcnZpY2VVbmF2YWlsYWJsZSxcbiAgICBIdHRwQ29kZXMuR2F0ZXdheVRpbWVvdXRcbl07XG5jb25zdCBSZXRyeWFibGVIdHRwVmVyYnMgPSBbJ09QVElPTlMnLCAnR0VUJywgJ0RFTEVURScsICdIRUFEJ107XG5jb25zdCBFeHBvbmVudGlhbEJhY2tvZmZDZWlsaW5nID0gMTA7XG5jb25zdCBFeHBvbmVudGlhbEJhY2tvZmZUaW1lU2xpY2UgPSA1O1xuY2xhc3MgSHR0cENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdIdHRwQ2xpZW50RXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSHR0cENsaWVudEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwQ2xpZW50RXJyb3IgPSBIdHRwQ2xpZW50RXJyb3I7XG5jbGFzcyBIdHRwQ2xpZW50UmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVhZEJvZHkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBCdWZmZXIuY29uY2F0KFtvdXRwdXQsIGNodW5rXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBDbGllbnRSZXNwb25zZSA9IEh0dHBDbGllbnRSZXNwb25zZTtcbmZ1bmN0aW9uIGlzSHR0cHMocmVxdWVzdFVybCkge1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocmVxdWVzdFVybCk7XG4gICAgcmV0dXJuIHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG59XG5leHBvcnRzLmlzSHR0cHMgPSBpc0h0dHBzO1xuY2xhc3MgSHR0cENsaWVudCB7XG4gICAgY29uc3RydWN0b3IodXNlckFnZW50LCBoYW5kbGVycywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faWdub3JlU3NsRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWxsb3dSZWRpcmVjdHMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hbGxvd1JlZGlyZWN0RG93bmdyYWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21heFJlZGlyZWN0cyA9IDUwO1xuICAgICAgICB0aGlzLl9hbGxvd1JldHJpZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWF4UmV0cmllcyA9IDE7XG4gICAgICAgIHRoaXMuX2tlZXBBbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gcmVxdWVzdE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLmlnbm9yZVNzbEVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZ25vcmVTc2xFcnJvciA9IHJlcXVlc3RPcHRpb25zLmlnbm9yZVNzbEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc29ja2V0VGltZW91dCA9IHJlcXVlc3RPcHRpb25zLnNvY2tldFRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMuYWxsb3dSZWRpcmVjdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93UmVkaXJlY3RzID0gcmVxdWVzdE9wdGlvbnMuYWxsb3dSZWRpcmVjdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMuYWxsb3dSZWRpcmVjdERvd25ncmFkZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dSZWRpcmVjdERvd25ncmFkZSA9IHJlcXVlc3RPcHRpb25zLmFsbG93UmVkaXJlY3REb3duZ3JhZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMubWF4UmVkaXJlY3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBNYXRoLm1heChyZXF1ZXN0T3B0aW9ucy5tYXhSZWRpcmVjdHMsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLmtlZXBBbGl2ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2VlcEFsaXZlID0gcmVxdWVzdE9wdGlvbnMua2VlcEFsaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLmFsbG93UmV0cmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dSZXRyaWVzID0gcmVxdWVzdE9wdGlvbnMuYWxsb3dSZXRyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLm1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21heFJldHJpZXMgPSByZXF1ZXN0T3B0aW9ucy5tYXhSZXRyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMocmVxdWVzdFVybCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ09QVElPTlMnLCByZXF1ZXN0VXJsLCBudWxsLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQocmVxdWVzdFVybCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0dFVCcsIHJlcXVlc3RVcmwsIG51bGwsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbChyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnREVMRVRFJywgcmVxdWVzdFVybCwgbnVsbCwgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zdChyZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnUE9TVCcsIHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdGNoKHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdQQVRDSCcsIHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1dChyZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnUFVUJywgcmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGVhZChyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnSEVBRCcsIHJlcXVlc3RVcmwsIG51bGwsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRTdHJlYW0odmVyYiwgcmVxdWVzdFVybCwgc3RyZWFtLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh2ZXJiLCByZXF1ZXN0VXJsLCBzdHJlYW0sIGFkZGl0aW9uYWxIZWFkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSB0eXBlZCBvYmplY3QgZnJvbSBhbiBlbmRwb2ludFxuICAgICAqIEJlIGF3YXJlIHRoYXQgbm90IGZvdW5kIHJldHVybnMgYSBudWxsLiAgT3RoZXIgZXJyb3JzICg0eHgsIDV4eCkgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICovXG4gICAgZ2V0SnNvbihyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVyc1tIZWFkZXJzLkFjY2VwdF0gPSB0aGlzLl9nZXRFeGlzdGluZ09yRGVmYXVsdEhlYWRlcihhZGRpdGlvbmFsSGVhZGVycywgSGVhZGVycy5BY2NlcHQsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuZ2V0KHJlcXVlc3RVcmwsIGFkZGl0aW9uYWxIZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUmVzcG9uc2UocmVzLCB0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc3RKc29uKHJlcXVlc3RVcmwsIG9iaiwgYWRkaXRpb25hbEhlYWRlcnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVyc1tIZWFkZXJzLkFjY2VwdF0gPSB0aGlzLl9nZXRFeGlzdGluZ09yRGVmYXVsdEhlYWRlcihhZGRpdGlvbmFsSGVhZGVycywgSGVhZGVycy5BY2NlcHQsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzW0hlYWRlcnMuQ29udGVudFR5cGVdID0gdGhpcy5fZ2V0RXhpc3RpbmdPckRlZmF1bHRIZWFkZXIoYWRkaXRpb25hbEhlYWRlcnMsIEhlYWRlcnMuQ29udGVudFR5cGUsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMucG9zdChyZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1Jlc3BvbnNlKHJlcywgdGhpcy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdXRKc29uKHJlcXVlc3RVcmwsIG9iaiwgYWRkaXRpb25hbEhlYWRlcnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVyc1tIZWFkZXJzLkFjY2VwdF0gPSB0aGlzLl9nZXRFeGlzdGluZ09yRGVmYXVsdEhlYWRlcihhZGRpdGlvbmFsSGVhZGVycywgSGVhZGVycy5BY2NlcHQsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzW0hlYWRlcnMuQ29udGVudFR5cGVdID0gdGhpcy5fZ2V0RXhpc3RpbmdPckRlZmF1bHRIZWFkZXIoYWRkaXRpb25hbEhlYWRlcnMsIEhlYWRlcnMuQ29udGVudFR5cGUsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMucHV0KHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUmVzcG9uc2UocmVzLCB0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdGNoSnNvbihyZXF1ZXN0VXJsLCBvYmosIGFkZGl0aW9uYWxIZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgICAgICAgICAgYWRkaXRpb25hbEhlYWRlcnNbSGVhZGVycy5BY2NlcHRdID0gdGhpcy5fZ2V0RXhpc3RpbmdPckRlZmF1bHRIZWFkZXIoYWRkaXRpb25hbEhlYWRlcnMsIEhlYWRlcnMuQWNjZXB0LCBNZWRpYVR5cGVzLkFwcGxpY2F0aW9uSnNvbik7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVyc1tIZWFkZXJzLkNvbnRlbnRUeXBlXSA9IHRoaXMuX2dldEV4aXN0aW5nT3JEZWZhdWx0SGVhZGVyKGFkZGl0aW9uYWxIZWFkZXJzLCBIZWFkZXJzLkNvbnRlbnRUeXBlLCBNZWRpYVR5cGVzLkFwcGxpY2F0aW9uSnNvbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLnBhdGNoKHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUmVzcG9uc2UocmVzLCB0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgcmF3IGh0dHAgcmVxdWVzdC5cbiAgICAgKiBBbGwgb3RoZXIgbWV0aG9kcyBzdWNoIGFzIGdldCwgcG9zdCwgcGF0Y2gsIGFuZCByZXF1ZXN0IHVsdGltYXRlbHkgY2FsbCB0aGlzLlxuICAgICAqIFByZWZlciBnZXQsIGRlbCwgcG9zdCBhbmQgcGF0Y2hcbiAgICAgKi9cbiAgICByZXF1ZXN0KHZlcmIsIHJlcXVlc3RVcmwsIGRhdGEsIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJlcXVlc3RVcmwpO1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLl9wcmVwYXJlUmVxdWVzdCh2ZXJiLCBwYXJzZWRVcmwsIGhlYWRlcnMpO1xuICAgICAgICAgICAgLy8gT25seSBwZXJmb3JtIHJldHJpZXMgb24gcmVhZHMgc2luY2Ugd3JpdGVzIG1heSBub3QgYmUgaWRlbXBvdGVudC5cbiAgICAgICAgICAgIGNvbnN0IG1heFRyaWVzID0gdGhpcy5fYWxsb3dSZXRyaWVzICYmIFJldHJ5YWJsZUh0dHBWZXJicy5pbmNsdWRlcyh2ZXJiKVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbWF4UmV0cmllcyArIDFcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBsZXQgbnVtVHJpZXMgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0UmF3KGluZm8sIGRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gYXV0aGVudGljYXRpb24gY2hhbGxlbmdlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlID09PSBIdHRwQ29kZXMuVW5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdXRoZW50aWNhdGlvbkhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGVBdXRoZW50aWNhdGlvbihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbkhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRoZW50aWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoZW50aWNhdGlvbkhhbmRsZXIuaGFuZGxlQXV0aGVudGljYXRpb24odGhpcywgaW5mbywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGFuIHVuYXV0aG9yaXplZCByZXNwb25zZSBidXQgaGF2ZSBubyBoYW5kbGVycyB0byBoYW5kbGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQgdGhlIHJlc3BvbnNlIHJldHVybiB0byB0aGUgY2FsbGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWRpcmVjdHNSZW1haW5pbmcgPSB0aGlzLl9tYXhSZWRpcmVjdHM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSAmJlxuICAgICAgICAgICAgICAgICAgICBIdHRwUmVkaXJlY3RDb2Rlcy5pbmNsdWRlcyhyZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93UmVkaXJlY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0c1JlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSByZXNwb25zZS5tZXNzYWdlLmhlYWRlcnNbJ2xvY2F0aW9uJ107XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXJlY3RVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbG9jYXRpb24gdG8gcmVkaXJlY3QgdG8sIHdlIHdvbid0XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZWRpcmVjdFVybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkVXJsLnByb3RvY29sICE9PSBwYXJzZWRSZWRpcmVjdFVybC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2FsbG93UmVkaXJlY3REb3duZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkaXJlY3QgZnJvbSBIVFRQUyB0byBIVFRQIHByb3RvY29sLiBUaGlzIGRvd25ncmFkZSBpcyBub3QgYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucy4gSWYgeW91IHdhbnQgdG8gYWxsb3cgdGhpcyBiZWhhdmlvciwgc2V0IHRoZSBhbGxvd1JlZGlyZWN0RG93bmdyYWRlIG9wdGlvbiB0byB0cnVlLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZmluaXNoIHJlYWRpbmcgdGhlIHJlc3BvbnNlIGJlZm9yZSByZWFzc2lnbmluZyByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIGxlYWsgdGhlIG9wZW4gc29ja2V0LlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXNwb25zZS5yZWFkQm9keSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBhdXRob3JpemF0aW9uIGhlYWRlciBpZiByZWRpcmVjdGVkIHRvIGEgZGlmZmVyZW50IGhvc3RuYW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZWRpcmVjdFVybC5ob3N0bmFtZSAhPT0gcGFyc2VkVXJsLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVyIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlci50b0xvd2VyQ2FzZSgpID09PSAnYXV0aG9yaXphdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgbWFrZSB0aGUgcmVxdWVzdCB3aXRoIHRoZSBuZXcgcmVkaXJlY3RVcmxcbiAgICAgICAgICAgICAgICAgICAgaW5mbyA9IHRoaXMuX3ByZXBhcmVSZXF1ZXN0KHZlcmIsIHBhcnNlZFJlZGlyZWN0VXJsLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3RSYXcoaW5mbywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0c1JlbWFpbmluZy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSB8fFxuICAgICAgICAgICAgICAgICAgICAhSHR0cFJlc3BvbnNlUmV0cnlDb2Rlcy5pbmNsdWRlcyhyZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBhIHJldHJ5IGNvZGUsIHJldHVybiBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHJldHJ5aW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVtVHJpZXMgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAobnVtVHJpZXMgPCBtYXhUcmllcykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXNwb25zZS5yZWFkQm9keSgpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9wZXJmb3JtRXhwb25lbnRpYWxCYWNrb2ZmKG51bVRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChudW1UcmllcyA8IG1heFRyaWVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZWRzIHRvIGJlIGNhbGxlZCBpZiBrZWVwQWxpdmUgaXMgc2V0IHRvIHRydWUgaW4gcmVxdWVzdCBvcHRpb25zLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hZ2VudCkge1xuICAgICAgICAgICAgdGhpcy5fYWdlbnQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGluZm9cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHJlcXVlc3RSYXcoaW5mbywgZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFja0ZvclJlc3VsdChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBgZXJyYCBpcyBub3QgcGFzc2VkLCB0aGVuIGByZXNgIG11c3QgYmUgcGFzc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RSYXdXaXRoQ2FsbGJhY2soaW5mbywgZGF0YSwgY2FsbGJhY2tGb3JSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYXcgcmVxdWVzdCB3aXRoIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSBpbmZvXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb25SZXN1bHRcbiAgICAgKi9cbiAgICByZXF1ZXN0UmF3V2l0aENhbGxiYWNrKGluZm8sIGRhdGEsIG9uUmVzdWx0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghaW5mby5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpbmZvLm9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mby5vcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhLCAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxsYmFja0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2tDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25SZXN1bHQoZXJyLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcSA9IGluZm8uaHR0cE1vZHVsZS5yZXF1ZXN0KGluZm8ub3B0aW9ucywgKG1zZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IEh0dHBDbGllbnRSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgaGFuZGxlUmVzdWx0KHVuZGVmaW5lZCwgcmVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgIHJlcS5vbignc29ja2V0Jywgc29jayA9PiB7XG4gICAgICAgICAgICBzb2NrZXQgPSBzb2NrO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgd2UgZXZlciBnZXQgZGlzY29ubmVjdGVkLCB3ZSB3YW50IHRoZSBzb2NrZXQgdG8gdGltZW91dCBldmVudHVhbGx5XG4gICAgICAgIHJlcS5zZXRUaW1lb3V0KHRoaXMuX3NvY2tldFRpbWVvdXQgfHwgMyAqIDYwMDAwLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlUmVzdWx0KG5ldyBFcnJvcihgUmVxdWVzdCB0aW1lb3V0OiAke2luZm8ub3B0aW9ucy5wYXRofWApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBlcnIgaGFzIHN0YXR1c0NvZGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHJlcyBzaG91bGQgaGF2ZSBoZWFkZXJzXG4gICAgICAgICAgICBoYW5kbGVSZXN1bHQoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVxLndyaXRlKGRhdGEsICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXEuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEucGlwZShyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gaHR0cCBhZ2VudC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhbiBodHRwIGFnZW50IHRoYXQgaGFuZGxlc1xuICAgICAqIHJvdXRpbmcgdGhyb3VnaCBhIHByb3h5IHNlcnZlciAtIGRlcGVuZGluZyB1cG9uIHRoZSB1cmwgYW5kIHByb3h5IGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0gc2VydmVyVXJsICBUaGUgc2VydmVyIFVSTCB3aGVyZSB0aGUgcmVxdWVzdCB3aWxsIGJlIHNlbnQuIEZvciBleGFtcGxlLCBodHRwczovL2FwaS5naXRodWIuY29tXG4gICAgICovXG4gICAgZ2V0QWdlbnQoc2VydmVyVXJsKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwoc2VydmVyVXJsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFnZW50KHBhcnNlZFVybCk7XG4gICAgfVxuICAgIF9wcmVwYXJlUmVxdWVzdChtZXRob2QsIHJlcXVlc3RVcmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHt9O1xuICAgICAgICBpbmZvLnBhcnNlZFVybCA9IHJlcXVlc3RVcmw7XG4gICAgICAgIGNvbnN0IHVzaW5nU3NsID0gaW5mby5wYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICBpbmZvLmh0dHBNb2R1bGUgPSB1c2luZ1NzbCA/IGh0dHBzIDogaHR0cDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFBvcnQgPSB1c2luZ1NzbCA/IDQ0MyA6IDgwO1xuICAgICAgICBpbmZvLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgaW5mby5vcHRpb25zLmhvc3QgPSBpbmZvLnBhcnNlZFVybC5ob3N0bmFtZTtcbiAgICAgICAgaW5mby5vcHRpb25zLnBvcnQgPSBpbmZvLnBhcnNlZFVybC5wb3J0XG4gICAgICAgICAgICA/IHBhcnNlSW50KGluZm8ucGFyc2VkVXJsLnBvcnQpXG4gICAgICAgICAgICA6IGRlZmF1bHRQb3J0O1xuICAgICAgICBpbmZvLm9wdGlvbnMucGF0aCA9XG4gICAgICAgICAgICAoaW5mby5wYXJzZWRVcmwucGF0aG5hbWUgfHwgJycpICsgKGluZm8ucGFyc2VkVXJsLnNlYXJjaCB8fCAnJyk7XG4gICAgICAgIGluZm8ub3B0aW9ucy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIGluZm8ub3B0aW9ucy5oZWFkZXJzID0gdGhpcy5fbWVyZ2VIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy51c2VyQWdlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5mby5vcHRpb25zLmhlYWRlcnNbJ3VzZXItYWdlbnQnXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgIGluZm8ub3B0aW9ucy5hZ2VudCA9IHRoaXMuX2dldEFnZW50KGluZm8ucGFyc2VkVXJsKTtcbiAgICAgICAgLy8gZ2l2ZXMgaGFuZGxlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcGFydGljaXBhdGVcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5wcmVwYXJlUmVxdWVzdChpbmZvLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgICBfbWVyZ2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdE9wdGlvbnMgJiYgdGhpcy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbG93ZXJjYXNlS2V5cyh0aGlzLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLCBsb3dlcmNhc2VLZXlzKGhlYWRlcnMgfHwge30pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG93ZXJjYXNlS2V5cyhoZWFkZXJzIHx8IHt9KTtcbiAgICB9XG4gICAgX2dldEV4aXN0aW5nT3JEZWZhdWx0SGVhZGVyKGFkZGl0aW9uYWxIZWFkZXJzLCBoZWFkZXIsIF9kZWZhdWx0KSB7XG4gICAgICAgIGxldCBjbGllbnRIZWFkZXI7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RPcHRpb25zICYmIHRoaXMucmVxdWVzdE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgY2xpZW50SGVhZGVyID0gbG93ZXJjYXNlS2V5cyh0aGlzLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMpW2hlYWRlcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxIZWFkZXJzW2hlYWRlcl0gfHwgY2xpZW50SGVhZGVyIHx8IF9kZWZhdWx0O1xuICAgIH1cbiAgICBfZ2V0QWdlbnQocGFyc2VkVXJsKSB7XG4gICAgICAgIGxldCBhZ2VudDtcbiAgICAgICAgY29uc3QgcHJveHlVcmwgPSBwbS5nZXRQcm94eVVybChwYXJzZWRVcmwpO1xuICAgICAgICBjb25zdCB1c2VQcm94eSA9IHByb3h5VXJsICYmIHByb3h5VXJsLmhvc3RuYW1lO1xuICAgICAgICBpZiAodGhpcy5fa2VlcEFsaXZlICYmIHVzZVByb3h5KSB7XG4gICAgICAgICAgICBhZ2VudCA9IHRoaXMuX3Byb3h5QWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2tlZXBBbGl2ZSAmJiAhdXNlUHJveHkpIHtcbiAgICAgICAgICAgIGFnZW50ID0gdGhpcy5fYWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWdlbnQgaXMgYWxyZWFkeSBhc3NpZ25lZCB1c2UgdGhhdCBhZ2VudC5cbiAgICAgICAgaWYgKGFnZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNpbmdTc2wgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICBsZXQgbWF4U29ja2V0cyA9IDEwMDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG1heFNvY2tldHMgPSB0aGlzLnJlcXVlc3RPcHRpb25zLm1heFNvY2tldHMgfHwgaHR0cC5nbG9iYWxBZ2VudC5tYXhTb2NrZXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgYHVzZVByb3h5YCBhZ2FpbiwgYnV0IHdlIG5lZWQgdG8gY2hlY2sgYHByb3h5VVJsYCBkaXJlY3RseSBmb3IgVHlwZVNjcmlwdHMncyBmbG93IGFuYWx5c2lzLlxuICAgICAgICBpZiAocHJveHlVcmwgJiYgcHJveHlVcmwuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtYXhTb2NrZXRzLFxuICAgICAgICAgICAgICAgIGtlZXBBbGl2ZTogdGhpcy5fa2VlcEFsaXZlLFxuICAgICAgICAgICAgICAgIHByb3h5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgocHJveHlVcmwudXNlcm5hbWUgfHwgcHJveHlVcmwucGFzc3dvcmQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBdXRoOiBgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gXG4gICAgICAgICAgICAgICAgfSkpLCB7IGhvc3Q6IHByb3h5VXJsLmhvc3RuYW1lLCBwb3J0OiBwcm94eVVybC5wb3J0IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHR1bm5lbEFnZW50O1xuICAgICAgICAgICAgY29uc3Qgb3Zlckh0dHBzID0gcHJveHlVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICAgICAgaWYgKHVzaW5nU3NsKSB7XG4gICAgICAgICAgICAgICAgdHVubmVsQWdlbnQgPSBvdmVySHR0cHMgPyB0dW5uZWwuaHR0cHNPdmVySHR0cHMgOiB0dW5uZWwuaHR0cHNPdmVySHR0cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR1bm5lbEFnZW50ID0gb3Zlckh0dHBzID8gdHVubmVsLmh0dHBPdmVySHR0cHMgOiB0dW5uZWwuaHR0cE92ZXJIdHRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWdlbnQgPSB0dW5uZWxBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcHJveHlBZ2VudCA9IGFnZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJldXNpbmcgYWdlbnQgYWNyb3NzIHJlcXVlc3QgYW5kIHR1bm5lbGluZyBhZ2VudCBpc24ndCBhc3NpZ25lZCBjcmVhdGUgYSBuZXcgYWdlbnRcbiAgICAgICAgaWYgKHRoaXMuX2tlZXBBbGl2ZSAmJiAhYWdlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGtlZXBBbGl2ZTogdGhpcy5fa2VlcEFsaXZlLCBtYXhTb2NrZXRzIH07XG4gICAgICAgICAgICBhZ2VudCA9IHVzaW5nU3NsID8gbmV3IGh0dHBzLkFnZW50KG9wdGlvbnMpIDogbmV3IGh0dHAuQWdlbnQob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9hZ2VudCA9IGFnZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vdCB1c2luZyBwcml2YXRlIGFnZW50IGFuZCB0dW5uZWwgYWdlbnQgaXNuJ3Qgc2V0dXAgdGhlbiB1c2UgZ2xvYmFsIGFnZW50XG4gICAgICAgIGlmICghYWdlbnQpIHtcbiAgICAgICAgICAgIGFnZW50ID0gdXNpbmdTc2wgPyBodHRwcy5nbG9iYWxBZ2VudCA6IGh0dHAuZ2xvYmFsQWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzaW5nU3NsICYmIHRoaXMuX2lnbm9yZVNzbEVycm9yKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHNldCBOT0RFX1RMU19SRUpFQ1RfVU5BVVRIT1JJWkVEPTAgc2luY2UgdGhhdCB3aWxsIGFmZmVjdCByZXF1ZXN0IGZvciBlbnRpcmUgcHJvY2Vzc1xuICAgICAgICAgICAgLy8gaHR0cC5SZXF1ZXN0T3B0aW9ucyBkb2Vzbid0IGV4cG9zZSBhIHdheSB0byBtb2RpZnkgUmVxdWVzdE9wdGlvbnMuYWdlbnQub3B0aW9uc1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBjYXN0IGl0IHRvIGFueSBhbmQgY2hhbmdlIGl0IGRpcmVjdGx5XG4gICAgICAgICAgICBhZ2VudC5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihhZ2VudC5vcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFnZW50O1xuICAgIH1cbiAgICBfcGVyZm9ybUV4cG9uZW50aWFsQmFja29mZihyZXRyeU51bWJlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0cnlOdW1iZXIgPSBNYXRoLm1pbihFeHBvbmVudGlhbEJhY2tvZmZDZWlsaW5nLCByZXRyeU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCBtcyA9IEV4cG9uZW50aWFsQmFja29mZlRpbWVTbGljZSAqIE1hdGgucG93KDIsIHJldHJ5TnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCBtcykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NSZXNwb25zZShyZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5tZXNzYWdlLnN0YXR1c0NvZGUgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gbm90IGZvdW5kIGxlYWRzIHRvIG51bGwgb2JqIHJldHVybmVkXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IEh0dHBDb2Rlcy5Ob3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSByZXN1bHQgZnJvbSB0aGUgYm9keVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRhdGVUaW1lRGVzZXJpYWxpemVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGEudmFsdWVPZigpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9iajtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudHM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSB5aWVsZCByZXMucmVhZEJvZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzICYmIGNvbnRlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVzZXJpYWxpemVEYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IEpTT04ucGFyc2UoY29udGVudHMsIGRhdGVUaW1lRGVzZXJpYWxpemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IEpTT04ucGFyc2UoY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmVzdWx0ID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSByZXMubWVzc2FnZS5oZWFkZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgcmVzb3VyY2UgKGNvbnRlbnRzIG5vdCBqc29uKTsgIGxlYXZpbmcgcmVzdWx0IG9iaiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCAzeHggcmVkaXJlY3RzIGFyZSBoYW5kbGVkIGJ5IHRoZSBodHRwIGxheWVyLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID4gMjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtc2c7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGV4Y2VwdGlvbi9lcnJvciBpbiBib2R5LCBhdHRlbXB0IHRvIGdldCBiZXR0ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmoubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gb2JqLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudHMgJiYgY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgbWF5IGJlIHRoZSBjYXNlIHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyBpbiB0aGUgYm9keSBtZXNzYWdlIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gY29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBgRmFpbGVkIHJlcXVlc3Q6ICgke3N0YXR1c0NvZGV9KWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEh0dHBDbGllbnRFcnJvcihtc2csIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICBlcnIucmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwQ2xpZW50ID0gSHR0cENsaWVudDtcbmNvbnN0IGxvd2VyY2FzZUtleXMgPSAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYywgaykgPT4gKChjW2sudG9Mb3dlckNhc2UoKV0gPSBvYmpba10pLCBjKSwge30pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrQnlwYXNzID0gZXhwb3J0cy5nZXRQcm94eVVybCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldFByb3h5VXJsKHJlcVVybCkge1xuICAgIGNvbnN0IHVzaW5nU3NsID0gcmVxVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICBpZiAoY2hlY2tCeXBhc3MocmVxVXJsKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBwcm94eVZhciA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh1c2luZ1NzbCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52WydodHRwc19wcm94eSddIHx8IHByb2Nlc3MuZW52WydIVFRQU19QUk9YWSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52WydodHRwX3Byb3h5J10gfHwgcHJvY2Vzcy5lbnZbJ0hUVFBfUFJPWFknXTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgaWYgKHByb3h5VmFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKHByb3h5VmFyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRQcm94eVVybCA9IGdldFByb3h5VXJsO1xuZnVuY3Rpb24gY2hlY2tCeXBhc3MocmVxVXJsKSB7XG4gICAgaWYgKCFyZXFVcmwuaG9zdG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBub1Byb3h5ID0gcHJvY2Vzcy5lbnZbJ25vX3Byb3h5J10gfHwgcHJvY2Vzcy5lbnZbJ05PX1BST1hZJ10gfHwgJyc7XG4gICAgaWYgKCFub1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSByZXF1ZXN0IHBvcnRcbiAgICBsZXQgcmVxUG9ydDtcbiAgICBpZiAocmVxVXJsLnBvcnQpIHtcbiAgICAgICAgcmVxUG9ydCA9IE51bWJlcihyZXFVcmwucG9ydCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcVVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgICByZXFQb3J0ID0gODA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcVVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgcmVxUG9ydCA9IDQ0MztcbiAgICB9XG4gICAgLy8gRm9ybWF0IHRoZSByZXF1ZXN0IGhvc3RuYW1lIGFuZCBob3N0bmFtZSB3aXRoIHBvcnRcbiAgICBjb25zdCB1cHBlclJlcUhvc3RzID0gW3JlcVVybC5ob3N0bmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICBpZiAodHlwZW9mIHJlcVBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHVwcGVyUmVxSG9zdHMucHVzaChgJHt1cHBlclJlcUhvc3RzWzBdfToke3JlcVBvcnR9YCk7XG4gICAgfVxuICAgIC8vIENvbXBhcmUgcmVxdWVzdCBob3N0IGFnYWluc3Qgbm9wcm94eVxuICAgIGZvciAoY29uc3QgdXBwZXJOb1Byb3h5SXRlbSBvZiBub1Byb3h5XG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoeCA9PiB4LnRyaW0oKS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAuZmlsdGVyKHggPT4geCkpIHtcbiAgICAgICAgaWYgKHVwcGVyUmVxSG9zdHMuc29tZSh4ID0+IHggPT09IHVwcGVyTm9Qcm94eUl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmNoZWNrQnlwYXNzID0gY2hlY2tCeXBhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm94eS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKS5wYXJzZTtcbm1vZHVsZS5leHBvcnRzLm1hdGNoID0gcmVxdWlyZSgnLi9saWIvaW50ZXJwJykubWF0Y2g7XG5tb2R1bGUuZXhwb3J0cy5idWlsZCA9IHJlcXVpcmUoJy4vbGliL2NvbnN0cnVjdG9yJykuYnVpbGQ7XG5tb2R1bGUuZXhwb3J0cy53cml0ZSA9IHJlcXVpcmUoJy4vbGliL2NvbnN0cnVjdG9yJykud3JpdGU7XG5cbm1vZHVsZS5leHBvcnRzLm1hdGNoZXIgPSBtb2R1bGUuZXhwb3J0cy5jb21waWxlID1cbiAgcmVxdWlyZSgnLi9saWIvY29tcGlsZScpLmNvbXBpbGU7XG5tb2R1bGUuZXhwb3J0cy5idWlsZGVyID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZScpLmNvbXBpbGVfYnVpbGRlcjtcbiIsIi8vIENvbXBpbGUgcGF0dGVybnMgdG8gcmVjb2duaXNlcnMgYW5kIGNvbnN0cnVjdG9yc1xuXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJ2J1ZmZlci1tb3JlLWludHMnKTtcbnZhciAkID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpLnBhcnNlO1xudmFyIGludGVycCA9IHJlcXVpcmUoJy4vaW50ZXJwJyksXG4gIHBhcnNlX2ludCA9IGludGVycC5wYXJzZV9pbnQsXG4gIHBhcnNlX2Zsb2F0ID0gaW50ZXJwLnBhcnNlX2Zsb2F0O1xudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoJy4vY29uc3RydWN0b3InKSxcbiAgd3JpdGVfaW50ID0gY29uc3RydWN0LndyaXRlX2ludCxcbiAgd3JpdGVfZmxvYXQgPSBjb25zdHJ1Y3Qud3JpdGVfZmxvYXQ7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGxpbmVzID0gW107XG5mdW5jdGlvbiAkc3RhcnQoKSB7XG4gIGxpbmVzID0gW107XG59XG5mdW5jdGlvbiAkbGluZSgvKiBmb3JtYXQgLCBhcmdzICovKSB7XG4gIGxpbmVzLnB1c2goJC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbn1cbmZ1bmN0aW9uICRyZXN1bHQoKSB7XG4gIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gYml0c19leHByKHNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICQoJyVzICogJWQnLCB2YXJfbmFtZShzZWdtZW50LnNpemUpLCBzZWdtZW50LnVuaXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAoc2VnbWVudC5zaXplICogc2VnbWVudC51bml0KS50b1N0cmluZygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldF9udW1iZXIoc2VnbWVudCkge1xuICAkbGluZSgnYml0cyA9ICVzO1xcbicsIGJpdHNfZXhwcihzZWdtZW50KSk7XG4gIHZhciBwYXJzZXIgPSAoc2VnbWVudC50eXBlID09PSAnaW50ZWdlcicpID9cbiAgICAncGFyc2VfaW50JyA6ICdwYXJzZV9mbG9hdCc7XG4gIHZhciBiZSA9IHNlZ21lbnQuYmlnZW5kaWFuLCBzZyA9IHNlZ21lbnQuc2lnbmVkO1xuICAkbGluZShcImJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4OyBvZmZzZXQgKz0gYml0c1wiKTtcbiAgJGxpbmUoXCJpZiAob2Zmc2V0ID4gYmluc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cIik7XG4gICRsaW5lKFwiZWxzZSB7IHJlc3VsdCA9ICVzKGJpbiwgYnl0ZW9mZnNldCwgYml0cyAvIDgsICVzLCAlcyk7IH1cIixcbiAgICAgICAgcGFyc2VyLCBiZSwgc2cpO1xufVxuXG5mdW5jdGlvbiBnZXRfYmluYXJ5KHNlZ21lbnQpIHtcbiAgJGxpbmUoXCJieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODtcIik7XG4gIGlmIChzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAkbGluZShcIm9mZnNldCA9IGJpbnNpemU7XCIpO1xuICAgICRsaW5lKFwicmVzdWx0ID0gYmluLnNsaWNlKGJ5dGVvZmZzZXQpO1wiKTtcbiAgfVxuICBlbHNlIHtcbiAgICAkbGluZShcImJpdHMgPSAlcztcIiwgYml0c19leHByKHNlZ21lbnQpKTtcbiAgICAkbGluZShcIm9mZnNldCArPSBiaXRzO1wiKTtcbiAgICAkbGluZShcImlmIChvZmZzZXQgPiBiaW5zaXplKSB7IHJldHVybiBmYWxzZTsgfVwiKTtcbiAgICAkbGluZShcImVsc2UgeyByZXN1bHQgPSBiaW4uc2xpY2UoYnl0ZW9mZnNldCxcIixcbiAgICAgICAgICBcImJ5dGVvZmZzZXQgKyBiaXRzIC8gOCk7IH1cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3N0cmluZyhzZWdtZW50KSB7XG4gICRsaW5lKFwiYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7XCIpO1xuICB2YXIgc3RybGVuID0gc2VnbWVudC52YWx1ZS5sZW5ndGg7XG4gIHZhciBzdHJsZW5iaXRzID0gc3RybGVuICogODtcbiAgJGxpbmUoXCJvZmZzZXQgKz0gJWQ7XCIsIHN0cmxlbmJpdHMpO1xuICAkbGluZShcImlmIChvZmZzZXQgPiBiaW5zaXplKSB7IHJldHVybiBmYWxzZTsgfVwiKTtcbiAgJGxpbmUoXCJlbHNlIHsgcmVzdWx0ID0gYmluLnRvU3RyaW5nKGJ5dGVvZmZzZXQsXCIsXG4gICAgICAgICQoXCJieXRlb2Zmc2V0ICsgJWQpOyB9XCIsIHN0cmxlbikpO1xufVxuXG5mdW5jdGlvbiBza2lwX2JpdHMoc2VnbWVudCkge1xuICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBEYW1uLiBIYXZlIHRvIGxvb2sgdXAgdGhlIHNpemUuXG4gICAgJGxpbmUoXCJ2YXIgc2tpcGJpdHMgPSAlcyAqICVkO1wiLFxuICAgICAgICAgIHZhcl9uYW1lKHNlZ21lbnQuc2l6ZSksIHNlZ21lbnQudW5pdCk7XG4gICAgJGxpbmUoXCJpZiAob2Zmc2V0ICsgc2tpcGJpdHMgPiBiaW5zaXplKSB7IHJldHVybiBmYWxzZTsgfVwiKTtcbiAgICAkbGluZShcImVsc2UgeyBvZmZzZXQgKz0gc2tpcGJpdHM7IH1cIik7XG4gIH1cbiAgZWxzZSBpZiAoc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgJGxpbmUoXCJpZiAob2Zmc2V0ICUgOCA9PT0gMCkgeyBvZmZzZXQgPSBiaW5zaXplOyB9XCIpO1xuICAgICRsaW5lKFwiZWxzZSB7IHJldHVybiBmYWxzZTsgfVwiKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgYml0cyA9IHNlZ21lbnQudW5pdCAqIHNlZ21lbnQuc2l6ZTtcbiAgICAkbGluZShcImlmIChvZmZzZXQgKyAlZCA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIsIGJpdHMpO1xuICAgICRsaW5lKFwiZWxzZSB7IG9mZnNldCArPSAlZDsgfVwiLCBiaXRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaF9zZWcoc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5uYW1lID09PSAnXycpIHtcbiAgICBza2lwX2JpdHMoc2VnbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGFzc2lnbl9yZXN1bHQ7XG4gICAgc3dpdGNoIChzZWdtZW50LnR5cGUpIHtcbiAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICBjYXNlICdmbG9hdCc6XG4gICAgICBnZXRfbnVtYmVyKHNlZ21lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIGdldF9iaW5hcnkoc2VnbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgZ2V0X3N0cmluZyhzZWdtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAkbGluZShcImlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XCIpO1xuICAgIGlmIChzZWdtZW50Lm5hbWUpIHtcbiAgICAgIC8vIHZhcmlhYmxlIGlzIGdpdmVuIGEgdmFsdWUgaW4gdGhlIGVudmlyb25tZW50XG4gICAgICAkbGluZShcImVsc2UgaWYgKCVzICE9PSB1bmRlZmluZWQpIHtcIiwgdmFyX25hbWUoc2VnbWVudC5uYW1lKSk7XG4gICAgICAvLyAuLiBhbmQgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoYXQgbWF0Y2hlZFxuICAgICAgJGxpbmUoXCJpZiAoJXMgIT0gcmVzdWx0KSByZXR1cm4gZmFsc2U7XCIsXG4gICAgICAgICAgICB2YXJfbmFtZShzZWdtZW50Lm5hbWUpKTtcbiAgICAgICRsaW5lKFwifVwiKTtcbiAgICAgIC8vIHZhcmlhYmxlIGlzIGZyZWVcbiAgICAgICRsaW5lKCdlbHNlICVzID0gcmVzdWx0OycsIHZhcl9uYW1lKHNlZ21lbnQubmFtZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZXByID0gSlNPTi5zdHJpbmdpZnkoc2VnbWVudC52YWx1ZSk7XG4gICAgICAkbGluZShcImVsc2UgaWYgKHJlc3VsdCAhPSAlcykgcmV0dXJuIGZhbHNlO1wiLCByZXByKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFyX25hbWUobmFtZSkge1xuICByZXR1cm4gICd2YXJfJyArIG5hbWU7XG59XG5cbmZ1bmN0aW9uIHZhcmlhYmxlcyhzZWdtZW50cykge1xuICB2YXIgbmFtZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gc2VnbWVudHNbaV0ubmFtZTtcbiAgICBpZiAobmFtZSAmJiBuYW1lICE9PSAnXycpIHtcbiAgICAgIG5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgbmFtZSA9IHNlZ21lbnRzW2ldLnNpemU7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMobmFtZXMpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlX3BhdHRlcm4oc2VnbWVudHMpIHtcbiAgJHN0YXJ0KCk7XG4gICRsaW5lKFwicmV0dXJuIGZ1bmN0aW9uKGJpbmFyeSwgZW52KSB7XCIpO1xuICAkbGluZShcIid1c2Ugc3RyaWN0JztcIik7XG4gICRsaW5lKFwidmFyIGJpbiA9IGJpbmFyeSwgZW52ID0gZW52IHx8IHt9O1wiKTtcbiAgJGxpbmUoXCJ2YXIgb2Zmc2V0ID0gMCwgYmluc2l6ZSA9IGJpbi5sZW5ndGggKiA4O1wiKTtcbiAgJGxpbmUoXCJ2YXIgYml0cywgcmVzdWx0LCBieXRlb2Zmc2V0O1wiKTtcbiAgdmFyIHZhcm5hbWVzID0gdmFyaWFibGVzKHNlZ21lbnRzKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCB2YXJuYW1lcy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBuYW1lID0gdmFybmFtZXNbdl07XG4gICAgJGxpbmUoXCJ2YXIgJXMgPSBlbnZbJyVzJ107XCIsIHZhcl9uYW1lKG5hbWUpLCBuYW1lKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBzZWdtZW50cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICRsaW5lKFwiLy8gXCIgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSk7XG4gICAgbWF0Y2hfc2VnKHNlZ21lbnQpO1xuICB9XG5cbiAgJGxpbmUoXCJpZiAob2Zmc2V0ID09IGJpbnNpemUpIHtcIik7XG4gICRsaW5lKFwicmV0dXJuIHtcIik7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwgdmFybmFtZXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbmFtZSA9IHZhcm5hbWVzW3ZdO1xuICAgICRsaW5lKFwiJXM6ICVzLFwiLCBuYW1lLCB2YXJfbmFtZShuYW1lKSk7XG4gIH1cbiAgJGxpbmUoJ307Jyk7XG4gICRsaW5lKCd9Jyk7IC8vIGlmIG9mZnNldCA9PSBiaW5zaXplXG4gICRsaW5lKFwiZWxzZSByZXR1cm4gZmFsc2U7XCIpO1xuICAkbGluZShcIn1cIik7IC8vIGVuZCBmdW5jdGlvblxuXG4gIHZhciBmbiA9IG5ldyBGdW5jdGlvbigncGFyc2VfaW50JywgJ3BhcnNlX2Zsb2F0JywgJHJlc3VsdCgpKTtcbiAgcmV0dXJuIGZuKHBhcnNlX2ludCwgcGFyc2VfZmxvYXQpO1xufVxuXG5cbmZ1bmN0aW9uIHdyaXRlX3NlZyhzZWdtZW50KSB7XG4gIHN3aXRjaCAoc2VnbWVudC50eXBlKSB7XG4gIGNhc2UgJ3N0cmluZyc6XG4gICAgJGxpbmUoXCJvZmZzZXQgKz0gYnVmLndyaXRlKCVzLCBvZmZzZXQsICd1dGY4Jyk7XCIsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2VnbWVudC52YWx1ZSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICdiaW5hcnknOlxuICAgICRsaW5lKFwidmFsID0gYmluZGluZ3NbJyVzJ107XCIsIHNlZ21lbnQubmFtZSk7XG4gICAgaWYgKHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgJGxpbmUoJ3NpemUgPSB2YWwubGVuZ3RoOycpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgICAgJGxpbmUoXCJzaXplID0gKGJpbmRpbmdzWyclcyddICogJWQpIC8gODtcIixcbiAgICAgICAgICAgIHNlZ21lbnQuc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAkbGluZShcInNpemUgPSAlZDtcIiwgKHNlZ21lbnQuc2l6ZSAqIHNlZ21lbnQudW5pdCkgLyA4KTtcbiAgICB9XG4gICAgJGxpbmUoJ3ZhbC5jb3B5KGJ1Ziwgb2Zmc2V0LCAwLCBzaXplKTsnKTtcbiAgICAkbGluZSgnb2Zmc2V0ICs9IHNpemU7Jyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2ludGVnZXInOlxuICBjYXNlICdmbG9hdCc6XG4gICAgd3JpdGVfbnVtYmVyKHNlZ21lbnQpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlX251bWJlcihzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50Lm5hbWUpIHtcbiAgICAkbGluZShcInZhbCA9IGJpbmRpbmdzWyclcyddO1wiLCBzZWdtZW50Lm5hbWUpO1xuICB9XG4gIGVsc2Uge1xuICAgICRsaW5lKFwidmFsID0gJWRcIiwgc2VnbWVudC52YWx1ZSk7XG4gIH1cbiAgdmFyIHdyaXRlciA9IChzZWdtZW50LnR5cGUgPT09ICdpbnRlZ2VyJykgP1xuICAgICd3cml0ZV9pbnQnIDogJ3dyaXRlX2Zsb2F0JztcbiAgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgJGxpbmUoXCJzaXplID0gKGJpbmRpbmdzWyclcyddICogJWQpIC8gODtcIixcbiAgICAgICAgICBzZWdtZW50LnNpemUsIHNlZ21lbnQudW5pdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgJGxpbmUoJ3NpemUgPSAlZDsnLCAoc2VnbWVudC5zaXplICogc2VnbWVudC51bml0KSAvIDgpO1xuICB9XG4gICRsaW5lKCclcyhidWYsIHZhbCwgb2Zmc2V0LCBzaXplLCAlcyk7JyxcbiAgICAgICAgd3JpdGVyLCBzZWdtZW50LmJpZ2VuZGlhbik7XG4gICRsaW5lKCdvZmZzZXQgKz0gc2l6ZTsnKTtcbn1cblxuZnVuY3Rpb24gc2l6ZV9vZihzZWdtZW50cykge1xuICB2YXIgdmFyaWFibGUgPSBbXTtcbiAgdmFyIGZpeGVkID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgICB2YXJpYWJsZS5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWdtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaXhlZCArPSBCdWZmZXIuYnl0ZUxlbmd0aChzZWdtZW50LnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmaXhlZCArPSAoc2VnbWVudC5zaXplICogc2VnbWVudC51bml0KSAvIDg7XG4gICAgfVxuICB9XG5cbiAgJGxpbmUoJ3ZhciBidWZmZXJzaXplID0gJWQ7JywgZml4ZWQpO1xuXG4gIGlmICh2YXJpYWJsZS5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YXJpYWJsZS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSB2YXJpYWJsZVtqXTtcbiAgICAgIGlmIChzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAgICAgJGxpbmUoXCJidWZmZXJzaXplICs9IGJpbmRpbmdzWyclcyddLmxlbmd0aDtcIiwgc2VnbWVudC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkbGluZShcImJ1ZmZlcnNpemUgKz0gKGJpbmRpbmdzWyclcyddICogJWQpIC8gODtcIixcbiAgICAgICAgICAgICAgc2VnbWVudC5zaXplLCBzZWdtZW50LnVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0X3dyaXRlKHNlZ21lbnRzKSB7XG4gICRsaW5lKCd2YXIgdmFsLCBzaXplOycpO1xuXG4gIHZhciBsZW4gPSBzZWdtZW50cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICRsaW5lKCcvLyAlcycsIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpKTtcbiAgICB3cml0ZV9zZWcoc2VnbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZV9jdG9yKHNlZ21lbnRzKSB7XG4gICRzdGFydCgpO1xuICAkbGluZSgncmV0dXJuIGZ1bmN0aW9uKGJpbmRpbmdzKSB7Jyk7XG4gICRsaW5lKFwiJ3VzZSBzdHJpY3QnO1wiKTtcbiAgc2l6ZV9vZihzZWdtZW50cyk7XG4gICRsaW5lKCd2YXIgYnVmID0gQnVmZmVyLmFsbG9jKGJ1ZmZlcnNpemUpOycpO1xuICAkbGluZSgndmFyIG9mZnNldCA9IDA7Jyk7XG4gIGVtaXRfd3JpdGUoc2VnbWVudHMpO1xuICAkbGluZSgncmV0dXJuIGJ1ZjsnKTtcbiAgJGxpbmUoJ30nKTsgLy8gZW5kIGZ1bmN0aW9uXG5cbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignd3JpdGVfaW50JywgJ3dyaXRlX2Zsb2F0JywgJ0J1ZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgJHJlc3VsdCgpKSh3cml0ZV9pbnQsIHdyaXRlX2Zsb2F0LCBCdWZmZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlX3BhdHRlcm4gPSBjb21waWxlX3BhdHRlcm47XG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHIgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnLCcpO1xuICB2YXIgcCA9IHBhcnNlKHN0cik7XG4gIHJldHVybiBjb21waWxlX3BhdHRlcm4ocCk7XG59O1xubW9kdWxlLmV4cG9ydHMuY29tcGlsZV9idWlsZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHIgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnLCcpO1xuICB2YXIgcCA9IHBhcnNlKHN0cik7XG4gIHJldHVybiBjb21waWxlX2N0b3IocCk7XG59O1xuIiwiLy8gLSotIGpzLWluZGVudC1sZXZlbDogMiAtKi1cblxuLy8gQ29uc3RydWN0b3JzIGdpdmVuIHBhdHRlcm5zXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludHMgPSByZXF1aXJlKCdidWZmZXItbW9yZS1pbnRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbi8vIEludGVycHJldCB0aGUgcGF0dGVybiwgd3JpdGluZyB2YWx1ZXMgaW50byBhIGJ1ZmZlclxuZnVuY3Rpb24gd3JpdGUoYnVmLCBvZmZzZXQsIHBhdHRlcm4sIGJpbmRpbmdzKSB7XG4gIGZvciAodmFyIGk9MCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gcGF0dGVybltpXTtcbiAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBvZmZzZXQgKz0gYnVmLndyaXRlKHNlZ21lbnQudmFsdWUsIG9mZnNldCwgJ3V0ZjgnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICBvZmZzZXQgKz0gd3JpdGVCaW5hcnkoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgb2Zmc2V0ICs9IHdyaXRlSW50ZWdlcihzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgb2Zmc2V0ICs9IHdyaXRlRmxvYXQoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBidWlsZChwYXR0ZXJuLCBiaW5kaW5ncykge1xuICB2YXIgYnVmc2l6ZSA9IHNpemVfb2YocGF0dGVybiwgYmluZGluZ3MpO1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKGJ1ZnNpemUpO1xuICB3cml0ZShidWYsIDAsIHBhdHRlcm4sIGJpbmRpbmdzKTtcbiAgcmV0dXJuIGJ1Zjtcbn1cblxuLy8gSW4gYnl0ZXNcbmZ1bmN0aW9uIHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncykge1xuICAvLyBzaXplIHJlZmVycyB0byBhIHZhcmlhYmxlXG4gIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAoYmluZGluZ3Nbc2VnbWVudC5zaXplXSAqIHNlZ21lbnQudW5pdCkgLyA4O1xuICB9XG4gIGlmIChzZWdtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHNlZ21lbnQudmFsdWUsICd1dGY4Jyk7XG4gIH1cbiAgaWYgKHNlZ21lbnQudHlwZSA9PT0gJ2JpbmFyeScgJiYgc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgdmFyIHZhbCA9IGJpbmRpbmdzW3NlZ21lbnQubmFtZV07XG4gICAgcmV0dXJuIHZhbC5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gODtcbn1cblxuLy8gc2l6ZSBvZiB0aGUgdG8tYmUtY29uc3RydWN0ZWQgYmluYXJ5LCBpbiBieXRlc1xuZnVuY3Rpb24gc2l6ZV9vZihzZWdtZW50cywgYmluZGluZ3MpIHtcbiAgdmFyIHNpemUgPSAwO1xuICBmb3IgKHZhciBpPTAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2l6ZSArPSBzaXplX29mX3NlZ21lbnQoc2VnbWVudHNbaV0sIGJpbmRpbmdzKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCaW5hcnkoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKSB7XG4gIHZhciBiaW4gPSBiaW5kaW5nc1tzZWdtZW50Lm5hbWVdO1xuICB2YXIgc2l6ZSA9IHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncyk7XG4gIGJpbi5jb3B5KGJ1Ziwgb2Zmc2V0LCAwLCBzaXplKTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vIFRPRE8gaW4gZmYgbWlnaHQgdXNlIHRoZSBub0Fzc2VydCBhcmd1bWVudCB0byBCdWZmZXIud3JpdGUqKCkgYnV0XG4vLyBuZWVkIHRvIGNoZWNrIHRoYXQgaXQgZG9lcyB0aGUgcmlnaHQgdGhpbmcgd3J0IGxpdHRsZS1lbmRpYW5cblxuZnVuY3Rpb24gd3JpdGVJbnRlZ2VyKHNlZ21lbnQsIGJ1Ziwgb2Zmc2V0LCBiaW5kaW5ncykge1xuICB2YXIgdmFsdWUgPSAoc2VnbWVudC5uYW1lKSA/IGJpbmRpbmdzW3NlZ21lbnQubmFtZV0gOiBzZWdtZW50LnZhbHVlO1xuICB2YXIgc2l6ZSA9IHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncyk7XG4gIHJldHVybiB3cml0ZV9pbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBzaXplLCBzZWdtZW50LmJpZ2VuZGlhbik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlX2ludChidWYsIHZhbHVlLCBvZmZzZXQsIHNpemUsIGJpZ2VuZGlhbikge1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgY2FzZSAxOlxuICAgIGJ1Zi53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgYnVmLndyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNDpcbiAgICAoYmlnZW5kaWFuKSA/XG4gICAgICBidWYud3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSA6XG4gICAgICBidWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSA4OlxuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGludHMud3JpdGVVSW50NjRCRShidWYsIHZhbHVlLCBvZmZzZXQpIDpcbiAgICAgIGludHMud3JpdGVVSW50NjRMRShidWYsIHZhbHVlLCBvZmZzZXQpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcImludGVnZXIgc2l6ZSAqIHVuaXQgbXVzdCBiZSA4LCAxNiwgMzIgb3IgNjRcIik7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKSB7XG4gIHZhciB2YWx1ZSA9IChzZWdtZW50Lm5hbWUpID8gYmluZGluZ3Nbc2VnbWVudC5uYW1lXSA6IHNlZ21lbnQudmFsdWU7XG4gIHZhciBzaXplID0gc2l6ZV9vZl9zZWdtZW50KHNlZ21lbnQsIGJpbmRpbmdzKTtcbiAgcmV0dXJuIHdyaXRlX2Zsb2F0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgc2l6ZSwgc2VnbWVudC5iaWdlbmRpYW4pO1xufVxuXG5mdW5jdGlvbiB3cml0ZV9mbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIHNpemUsIGJpZ2VuZGlhbikge1xuICBpZiAoc2l6ZSA9PT0gNCkge1xuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGJ1Zi53cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlRmxvYXRMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgfVxuICBlbHNlIGlmIChzaXplID09PSA4KSB7XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgYnVmLndyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmxvYXQgc2l6ZSAqIHVuaXQgbXVzdCBiZSAzMiBvciA2NFwiKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpLnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cy53cml0ZSA9IHdyaXRlO1xubW9kdWxlLmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbm1vZHVsZS5leHBvcnRzLndyaXRlX2ludCA9IHdyaXRlX2ludDtcbm1vZHVsZS5leHBvcnRzLndyaXRlX2Zsb2F0ID0gd3JpdGVfZmxvYXQ7XG5cbm1vZHVsZS5leHBvcnRzLmJ1aWxkZXIgPSBmdW5jdGlvbihwc3RyKSB7XG4gIHBzdHIgPSAoYXJndW1lbnRzLmxlbmd0aCA+IDEpID8gW10uam9pbi5jYWxsKGFyZ3VtZW50cywgJywnKSA6IHBzdHI7XG4gIHZhciBwYXR0ZXJuID0gcGFyc2UocHN0cik7XG4gIHJldHVybiBmdW5jdGlvbih2YXJzKSB7XG4gICAgcmV0dXJuIGJ1aWxkKHBhdHRlcm4sIHZhcnMpO1xuICB9O1xufTtcbiIsIi8vIC0qLSBqcy1pbmRlbnQ6IDIgLSotXG4vLyBJbnRlcnByZXRlciBmb3IgYml0IHN5bnRheCBBU1QuXG4vLyBHcmFtbWFyOlxuLy9cbi8vIHBhdHRlcm4gICA6PSBzZWdtZW50IChcIixcIiBzZWdtZW50KSpcbi8vIHNlZ21lbnQgICA6PSAodmFsdWUgfCB2YXIpIChcIjpcIiBzaXplKT8gKFwiL1wiIHNwZWNpZmllciAoXCItXCIgc3BlY2lmaWVyKSopPyB8IHN0cmluZ1xuLy8gdmFyICAgICAgIDo9IFwiX1wiIHwgaWRlbnRpZmllclxuLy8gc2l6ZSAgICAgIDo9IGludGVnZXIgfCB2YXJcbi8vIHNwZWNpZmllciA6PSBcImxpdHRsZVwiIHwgXCJiaWdcIiB8IFwic2lnbmVkXCIgfCBcInVuc2lnbmVkXCIgfCBcInVuaXRcIiBcIjpcIiAwLi4yNTYgfCB0eXBlXG4vLyB0eXBlICAgICAgOj0gXCJpbnRlZ2VyXCIgfCBcImJpbmFyeVwiIHwgXCJmbG9hdFwiXG4vL1xuLy8gd2hlcmUgaW50ZWdlciBoYXMgdGhlIG9idmlvdXMgbWVhbmluZywgYW5kIGlkZW50aWZpZXIgaXMgYW55dGhpbmdcbi8vIG90aGVyIHRoYW4gXCJfXCIgdGhhdCBmaXRzIHRoZSBKYXZhU2NyaXB0IGlkZW50aWZpZXIgc3BlY2lmaWNhdGlvbi5cbi8vXG5cbi8vIFdlJ2xsIHVzZSBhbiBvYmplY3QgdG8gcmVwcmVzZW50IGVhY2ggc2VnbWVudCwgYW5kIGFuIGFycmF5IG9mXG4vLyBzZWdtZW50cyBmb3IgYSBwYXR0ZXJuLiBXZSB3b24ndCB0cnkgdG8gb3B0aW1pc2UgZm9yIGdyb3VwcyBvZlxuLy8gcGF0dGVybnM7IHdlJ2xsIGp1c3Qgc3RlcCB0aHJvdWdoIGVhY2ggdG8gc2VlIGlmIGl0IHdvcmtzLiBXZSByZWx5XG4vLyBhIGh5cG90aGV0aWNhbCBwcmlvciBzdGVwIHRvIGNoZWNrIHRoYXQgaXQncyBhIHZhbGlkIHBhdHRlcm4uXG5cbi8vID8gY29tcGlsZSB0byBpbnRlcm1lZGlhdGUgaW5zdHJ1Y3Rpb25zID9cblxuLy8gQSBzZWdtZW50IGxvb2tzIGxpa2Vcbi8vIHtcbi8vICAgIHR5cGU6IHN0cmluZywgLy8gJ3N0cmluZycgaXMgc3BlY2lhbCBjYXNlXG4vLyAgICBzaXplOiBpbnRlZ2VyIHwgdHJ1ZSwgLy8gdHJ1ZSBtZWFucyAnYWxsIHJlbWFpbmluZydcbi8vICAgIG5hbWU6IHN0cmluZyB8IG51bGwsIC8vIChtYXkgYmUgJ18nKVxuLy8gICAgdmFsdWU6IHZhbHVlIHwgbnVsbCwgLy8gZWl0aGVyIG5hbWUgT1IgdmFsdWVcbi8vICAgIHVuaXQ6IGludGVnZXIsXG4vLyAgICBzaWduZWQ6IGJvb2xlYW4sXG4vLyAgICBiaWdlbmRpYW46IGJvb2xlYW5cbi8vIH1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50cyAgICA9IHJlcXVpcmUoJ2J1ZmZlci1tb3JlLWludHMnKSxcbiAgICBkZWJ1ZyAgID0gcmVxdWlyZSgnZGVidWcnKSgnYml0c3ludGF4LUludGVycHJldGVyJyk7XG5cbmZ1bmN0aW9uIHBhcnNlX2ludChiaW4sIG9mZiwgc2l6ZUluQnl0ZXMsIGJpZ2VuZGlhbiwgc2lnbmVkKSB7XG4gIHN3aXRjaCAoc2l6ZUluQnl0ZXMpIHtcbiAgY2FzZSAxOlxuICAgIHJldHVybiAoc2lnbmVkKSA/IGJpbi5yZWFkSW50OChvZmYpIDogYmluLnJlYWRVSW50OChvZmYpO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIChiaWdlbmRpYW4pID9cbiAgICAgIChzaWduZWQpID8gYmluLnJlYWRJbnQxNkJFKG9mZikgOiBiaW4ucmVhZFVJbnQxNkJFKG9mZikgOlxuICAgICAgKHNpZ25lZCkgPyBiaW4ucmVhZEludDE2TEUob2ZmKSA6IGJpbi5yZWFkVUludDE2TEUob2ZmKTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiAoYmlnZW5kaWFuKSA/XG4gICAgICAoc2lnbmVkKSA/IGJpbi5yZWFkSW50MzJCRShvZmYpIDogYmluLnJlYWRVSW50MzJCRShvZmYpIDpcbiAgICAgIChzaWduZWQpID8gYmluLnJlYWRJbnQzMkxFKG9mZikgOiBiaW4ucmVhZFVJbnQzMkxFKG9mZik7XG4gIGNhc2UgODpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgP1xuICAgICAgKChzaWduZWQpID8gaW50cy5yZWFkSW50NjRCRSA6IGludHMucmVhZFVJbnQ2NEJFKShiaW4sIG9mZikgOlxuICAgICAgKChzaWduZWQpID8gaW50cy5yZWFkSW50NjRMRSA6IGludHMucmVhZFVJbnQ2NExFKShiaW4sIG9mZik7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgXCJJbnRlZ2VycyBtdXN0IGJlIDgtLCAxNi0sIDMyLSBvciA2NC1iaXRcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZV9mbG9hdChiaW4sIG9mZiwgc2l6ZUluQnl0ZXMsIGJpZ2VuZGlhbikge1xuICBzd2l0Y2ggKHNpemVJbkJ5dGVzKSB7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgPyBiaW4ucmVhZEZsb2F0QkUob2ZmKSA6IGJpbi5yZWFkRmxvYXRMRShvZmYpO1xuICBjYXNlIDg6XG4gICAgcmV0dXJuIChiaWdlbmRpYW4pID8gYmluLnJlYWREb3VibGVCRShvZmYpIDogYmluLnJlYWREb3VibGVMRShvZmYpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IFwiRmxvYXRzIG11c3QgYmUgMzItIG9yIDY0LWJpdFwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpemVfb2Yoc2VnbWVudCwgYm91bmQpIHtcbiAgdmFyIHNpemUgPSBzZWdtZW50LnNpemU7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYm91bmRbc2l6ZV07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV3X3Njb3BlKGVudikge1xuICBmdW5jdGlvbiBzY29wZSgpIHt9O1xuICBzY29wZS5wcm90b3R5cGUgPSBlbnY7XG4gIHJldHVybiBuZXcgc2NvcGUoKTtcbn1cblxuZnVuY3Rpb24gYmluZGluZ3Moc2NvcGUpIHtcbiAgdmFyIHMgPSB7fTtcbiAgZm9yICh2YXIgayBpbiBzY29wZSkge1xuICAgIGlmIChzY29wZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgc1trXSA9IHNjb3BlW2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gbWF0Y2gocGF0dGVybiwgYmluYXJ5LCBib3VuZHZhcnMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhcnMgPSBuZXdfc2NvcGUoYm91bmR2YXJzKTtcbiAgdmFyIGJpbnNpemUgPSBiaW5hcnkubGVuZ3RoICogODtcblxuICBmdW5jdGlvbiBza2lwX2JpdHMoc2VnbWVudCkge1xuICAgIGRlYnVnKFwic2tpcCBiaXRzXCIpOyBkZWJ1ZyhzZWdtZW50KTtcbiAgICB2YXIgc2l6ZSA9IHNpemVfb2Yoc2VnbWVudCwgdmFycyk7XG4gICAgaWYgKHNpemUgPT09IHRydWUpIHtcbiAgICAgIGlmIChvZmZzZXQgJSA4ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IGJpbnNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYml0cyA9IHNlZ21lbnQudW5pdCAqIHNpemU7XG4gICAgaWYgKG9mZnNldCArIGJpdHMgPiBiaW5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IGJpdHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X2ludGVnZXIoc2VnbWVudCkge1xuICAgIGRlYnVnKFwiZ2V0X2ludGVnZXJcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIC8vIGxldCdzIGRvIG9ubHkgbXVsdGlwbGVzIG9mIGVpZ2h0IGJpdHMgZm9yIG5vd1xuICAgIHZhciB1bml0ID0gc2VnbWVudC51bml0LCBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICB2YXIgYml0c2l6ZSA9IHNpemUgKiB1bml0O1xuICAgIHZhciBieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgLy8gTkIgYXNzdW1lcyBhbGlnbmVkXG4gICAgb2Zmc2V0ICs9IGJpdHNpemU7XG4gICAgaWYgKGJpdHNpemUgJSA4ID4gMCB8fCAob2Zmc2V0ID4gYmluc2l6ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VfaW50KGJpbmFyeSwgYnl0ZW9mZnNldCwgYml0c2l6ZSAvIDgsXG4gICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuYmlnZW5kaWFuLCBzZWdtZW50LnNpZ25lZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X2Zsb2F0KHNlZ21lbnQpIHtcbiAgICBkZWJ1ZyhcImdldF9mbG9hdFwiKTsgZGVidWcoc2VnbWVudCk7XG4gICAgdmFyIHVuaXQgPSBzZWdtZW50LnVuaXQ7IHZhciBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICB2YXIgYml0c2l6ZSA9IHNpemUgKiB1bml0O1xuICAgIHZhciBieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgLy8gYXNzdW1lIGFsaWduZWRcbiAgICBvZmZzZXQgKz0gYml0c2l6ZTtcbiAgICBpZiAob2Zmc2V0ID4gYmluc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZV9mbG9hdChiaW5hcnksIGJ5dGVvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYml0c2l6ZSAvIDgsIHNlZ21lbnQuYmlnZW5kaWFuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfYmluYXJ5KHNlZ21lbnQpIHtcbiAgICBkZWJ1ZyhcImdldF9iaW5hcnlcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIHZhciB1bml0ID0gc2VnbWVudC51bml0LCBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICB2YXIgYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7IC8vIE5CIGFsaWdubWVudFxuXG4gICAgaWYgKHNpemUgPT09IHRydWUpIHtcbiAgICAgIG9mZnNldCA9IGJpbnNpemU7XG4gICAgICByZXR1cm4gYmluYXJ5LnNsaWNlKGJ5dGVvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBiaXRzaXplID0gc2l6ZSAqIHVuaXQ7XG4gICAgICBpZiAoYml0c2l6ZSAlIDggPiAwIHx8IChvZmZzZXQgKyBiaXRzaXplKSA+IGJpbnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBiaXRzaXplO1xuICAgICAgICByZXR1cm4gYmluYXJ5LnNsaWNlKGJ5dGVvZmZzZXQsIGJ5dGVvZmZzZXQgKyBiaXRzaXplIC8gOCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X3N0cmluZyhzZWdtZW50KSB7XG4gICAgZGVidWcoXCJnZXRfc3RyaW5nXCIpOyBkZWJ1ZyhzZWdtZW50KTtcbiAgICB2YXIgbGVuID0gc2VnbWVudC52YWx1ZS5sZW5ndGg7XG4gICAgdmFyIGJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4O1xuXG4gICAgb2Zmc2V0ICs9IGxlbiAqIDg7XG4gICAgaWYgKG9mZnNldCA+IGJpbnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRklYTUUgYnl0ZXMgdnMgVVRGOCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGJpbmFyeS5zbGljZShieXRlb2Zmc2V0LCBieXRlb2Zmc2V0ICsgbGVuKS50b1N0cmluZygndXRmOCcpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm5sZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7ICBpIDwgcGF0dGVybmxlbjsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBwYXR0ZXJuW2ldO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAoc2VnbWVudC5uYW1lID09PSAnXycpIHtcbiAgICAgIHJlc3VsdCA9IHNraXBfYml0cyhzZWdtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmVzdWx0ID0gZ2V0X3N0cmluZyhzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgcmVzdWx0ID0gZ2V0X2ludGVnZXIoc2VnbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICByZXN1bHQgPSBnZXRfZmxvYXQoc2VnbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmVzdWx0ID0gZ2V0X2JpbmFyeShzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlZ21lbnQubmFtZSkge1xuICAgICAgICB2YXJzW3NlZ21lbnQubmFtZV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWdtZW50LnZhbHVlICE9IHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvZmZzZXQgPT0gYmluc2l6ZSkge1xuICAgIHJldHVybiBiaW5kaW5ncyh2YXJzKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbm1vZHVsZS5leHBvcnRzLnBhcnNlX2ludCA9IHBhcnNlX2ludDtcbm1vZHVsZS5leHBvcnRzLnBhcnNlX2Zsb2F0ID0gcGFyc2VfZmxvYXQ7XG4iLCIvLyBQYXJzZSBwYXR0ZXJucyBpbiBzdHJpbmcgZm9ybSBpbnRvIHRoZSBmb3JtIHdlIHVzZSBmb3IgaW50ZXJwcmV0aW5nXG4vLyAoYW5kIGxhdGVyLCBmb3IgY29tcGlsaW5nKS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXN0ID0gcmVxdWlyZSgnLi9wYXR0ZXJuJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcblxuZnVuY3Rpb24gcGFyc2VfcGF0dGVybihzdHJpbmcpIHtcbiAgdmFyIHNlZ21lbnRzID0gcGFyc2VyLnBhcnNlKHN0cmluZyk7XG4gIGZvciAodmFyIGk9MCwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcyA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzLnN0cmluZyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHNlZ21lbnRzW2ldID0gYXN0LnN0cmluZyhzLnN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHMudmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWdtZW50c1tpXSA9IGFzdC52YWx1ZShzLnZhbHVlLCBzLnNpemUsIHMuc3BlY2lmaWVycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHMubmFtZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHNlZ21lbnRzW2ldID0gYXN0LnZhcmlhYmxlKHMubmFtZSwgcy5zaXplLCBzLnNwZWNpZmllcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IFwiVW5rbm93biBzZWdtZW50IFwiICsgcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RyID0gW10uam9pbi5jYWxsKGFyZ3VtZW50cywgJywnKTtcbiAgcmV0dXJuIHBhcnNlX3BhdHRlcm4oc3RyKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpe1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuNy4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gcXVvdGUocykge1xuICAgIC8qXG4gICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhXG4gICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCxcbiAgICAgKiBjYXJyaWFnZSByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLlxuICAgICAqIEFueSBjaGFyYWN0ZXIgbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJXG4gICAgICogY2hhcmFjdGVycy4gTm90ZSB0aGF0IFwiXFwwXCIgYW5kIFwiXFx2XCIgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IHVzZWRcbiAgICAgKiBiZWNhdXNlIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC5cbiAgICAgKi9cbiAgICAgcmV0dXJuICdcIicgKyBzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAgLy8gYmFja3NsYXNoXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICAgIC8vIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyXG4gICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJykgLy8gYmFja3NwYWNlXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpICAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgICAvLyBsaW5lIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykgICAvLyBmb3JtIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFLVxceDFGXFx4ODAtXFx1RkZGRl0vZywgZXNjYXBlKVxuICAgICAgKyAnXCInO1xuICB9XG4gIFxuICB2YXIgcmVzdWx0ID0ge1xuICAgIC8qXG4gICAgICogUGFyc2VzIHRoZSBpbnB1dCB3aXRoIGEgZ2VuZXJhdGVkIHBhcnNlci4gSWYgdGhlIHBhcnNpbmcgaXMgc3VjY2Vzc2Z1bGwsXG4gICAgICogcmV0dXJucyBhIHZhbHVlIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBzcGVjaWZpZWQgYnkgdGhlIGdyYW1tYXIgZnJvbVxuICAgICAqIHdoaWNoIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCAoc2VlIHxQRUcuYnVpbGRQYXJzZXJ8KS4gSWYgdGhlIHBhcnNpbmcgaXNcbiAgICAgKiB1bnN1Y2Nlc3NmdWwsIHRocm93cyB8UEVHLnBhcnNlci5TeW50YXhFcnJvcnwgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBzdGFydFJ1bGUpIHtcbiAgICAgIHZhciBwYXJzZUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgXCJzdGFydFwiOiBwYXJzZV9zdGFydCxcbiAgICAgICAgXCJzZWdtZW50VGFpbFwiOiBwYXJzZV9zZWdtZW50VGFpbCxcbiAgICAgICAgXCJzZWdtZW50XCI6IHBhcnNlX3NlZ21lbnQsXG4gICAgICAgIFwic3RyaW5nXCI6IHBhcnNlX3N0cmluZyxcbiAgICAgICAgXCJjaGFyc1wiOiBwYXJzZV9jaGFycyxcbiAgICAgICAgXCJjaGFyXCI6IHBhcnNlX2NoYXIsXG4gICAgICAgIFwiaGV4RGlnaXRcIjogcGFyc2VfaGV4RGlnaXQsXG4gICAgICAgIFwiaWRlbnRpZmllclwiOiBwYXJzZV9pZGVudGlmaWVyLFxuICAgICAgICBcIm51bWJlclwiOiBwYXJzZV9udW1iZXIsXG4gICAgICAgIFwic2l6ZVwiOiBwYXJzZV9zaXplLFxuICAgICAgICBcInNwZWNpZmllckxpc3RcIjogcGFyc2Vfc3BlY2lmaWVyTGlzdCxcbiAgICAgICAgXCJzcGVjaWZpZXJUYWlsXCI6IHBhcnNlX3NwZWNpZmllclRhaWwsXG4gICAgICAgIFwic3BlY2lmaWVyXCI6IHBhcnNlX3NwZWNpZmllcixcbiAgICAgICAgXCJ1bml0XCI6IHBhcnNlX3VuaXQsXG4gICAgICAgIFwid3NcIjogcGFyc2Vfd3NcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGlmIChzdGFydFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBydWxlIG5hbWU6IFwiICsgcXVvdGUoc3RhcnRSdWxlKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRSdWxlID0gXCJzdGFydFwiO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciByZXBvcnRGYWlsdXJlcyA9IDA7XG4gICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSAwO1xuICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpbnB1dDtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBlc2NhcGUoY2gpIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgdmFyIGVzY2FwZUNoYXI7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhckNvZGUgPD0gMHhGRikge1xuICAgICAgICAgIGVzY2FwZUNoYXIgPSAneCc7XG4gICAgICAgICAgbGVuZ3RoID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlc2NhcGVDaGFyID0gJ3UnO1xuICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVDaGFyICsgcGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSwgJzAnLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBtYXRjaEZhaWxlZChmYWlsdXJlKSB7XG4gICAgICAgIGlmIChwb3MgPCByaWdodG1vc3RGYWlsdXJlc1Bvcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHBvcyA+IHJpZ2h0bW9zdEZhaWx1cmVzUG9zKSB7XG4gICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSBwb3M7XG4gICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkLnB1c2goZmFpbHVyZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0YXJ0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2Vfd3MoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc2VnbWVudCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gW107XG4gICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc2VnbWVudFRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NlZ21lbnRUYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7IHRhaWwudW5zaGlmdChoZWFkKTsgcmV0dXJuIHRhaWw7IH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2VnbWVudFRhaWwoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV93cygpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCIsXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLFxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfd3MoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zZWdtZW50KCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHNlZykgeyByZXR1cm4gc2VnOyB9KShwb3MwLCByZXN1bHQwWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NlZ21lbnQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgc3RyKSB7IHJldHVybiB7c3RyaW5nOiBzdHJ9OyB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2lkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NpemUoKTtcbiAgICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc3BlY2lmaWVyTGlzdCgpO1xuICAgICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiAhPT0gbnVsbCA/IHJlc3VsdDIgOiBcIlwiO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCB2LCBzaXplLCBzcGVjcykgeyByZXR1cm4ge25hbWU6IHYsIHNpemU6IHNpemUsIHNwZWNpZmllcnM6IHNwZWNzfTsgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc2l6ZSgpO1xuICAgICAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zcGVjaWZpZXJMaXN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIgIT09IG51bGwgPyByZXN1bHQyIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCB2LCBzaXplLCBzcGVjcykgeyByZXR1cm4ge3ZhbHVlOiB2LCBzaXplOiBzaXplLCBzcGVjaWZpZXJzOiBzcGVjc307IH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFwiXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcIjsgICAgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFwiXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NoYXJzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcnMpIHsgcmV0dXJuIGNoYXJzOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jaGFycygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NoYXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jaGFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NoYXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0O1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXlteXCJcXFxcXFwwLVxceDFGf10vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbXlxcXCJcXFxcXFxcXFxcXFwwLVxcXFx4MUZ/XVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcXFxcIlwiKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXFxcIlwiO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuICdcIic7ICB9KShwb3MwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcXFxcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFwvXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcL1wiO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFwvXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIvXCI7ICB9KShwb3MwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcYlwiKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcYlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXGJcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcZlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcZlwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXG5cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcblwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcclxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXHJcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcdFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcdFwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXHVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFx1XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHVcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoXCIweFwiICsgaDEgKyBoMiArIGgzICsgaDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0sIHJlc3VsdDBbM10sIHJlc3VsdDBbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaGV4RGlnaXQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05YS1mQS1GXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2lkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmICgvXltfYS16QS1aXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIltfYS16QS1aXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgaWYgKC9eW19hLXpBLVowLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW19hLXpBLVowLTldXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgaWYgKC9eW19hLXpBLVowLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW19hLXpBLVowLTldXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkgeyByZXR1cm4gaGVhZCArIHRhaWwuam9pbignJyk7IH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbnVtYmVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0OCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIjBcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjBcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiAwOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgaWYgKC9eWzEtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMS05XVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgIGlmICgvXlswLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzAtOV1cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgICAgaWYgKC9eWzAtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHsgcmV0dXJuIHBhcnNlSW50KGhlYWQgKyB0YWlsLmpvaW4oJycpKTsgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2l6ZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCI6XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI6XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfbnVtYmVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBudW0pIHsgcmV0dXJuIG51bTsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCI6XCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiOlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfaWRlbnRpZmllcigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaWQpIHsgcmV0dXJuIGlkOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zcGVjaWZpZXJMaXN0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Nykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi9cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi9cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zcGVjaWZpZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NwZWNpZmllclRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NwZWNpZmllclRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHsgdGFpbC51bnNoaWZ0KGhlYWQpOyByZXR1cm4gdGFpbDsgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zcGVjaWZpZXJUYWlsKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0NSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi1cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi1cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zcGVjaWZpZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHNwZWMpIHsgcmV0dXJuIHNwZWM7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3BlY2lmaWVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA2KSA9PT0gXCJsaXR0bGVcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcImxpdHRsZVwiO1xuICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwibGl0dGxlXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMykgPT09IFwiYmlnXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcImJpZ1wiO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImJpZ1xcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwic2lnbmVkXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFwic2lnbmVkXCI7XG4gICAgICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInNpZ25lZFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA4KSA9PT0gXCJ1bnNpZ25lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwidW5zaWduZWRcIjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInVuc2lnbmVkXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNykgPT09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgICAgICAgICAgICBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiaW50ZWdlclxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwiYmluYXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImJpbmFyeVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA1KSA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiZmxvYXRcIjtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImZsb2F0XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV91bml0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNSkgPT09IFwidW5pdDpcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcInVuaXQ6XCI7XG4gICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ1bml0OlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX251bWJlcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgbnVtKSB7IHJldHVybiAndW5pdDonICsgbnVtOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3dzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgaWYgKC9eWyBcXHRcXG5dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDEgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWyBcXFxcdFxcXFxuXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgaWYgKC9eWyBcXHRcXG5dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWyBcXFxcdFxcXFxuXVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICAgIGV4cGVjdGVkLnNvcnQoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsYXN0RXhwZWN0ZWQgPSBudWxsO1xuICAgICAgICB2YXIgY2xlYW5FeHBlY3RlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2ldICE9PSBsYXN0RXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGNsZWFuRXhwZWN0ZWQucHVzaChleHBlY3RlZFtpXSk7XG4gICAgICAgICAgICBsYXN0RXhwZWN0ZWQgPSBleHBlY3RlZFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsZWFuRXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVFcnJvclBvc2l0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgZmlyc3QgaWRlYSB3YXMgdG8gdXNlIHxTdHJpbmcuc3BsaXR8IHRvIGJyZWFrIHRoZSBpbnB1dCB1cCB0byB0aGVcbiAgICAgICAgICogZXJyb3IgcG9zaXRpb24gYWxvbmcgbmV3bGluZXMgYW5kIGRlcml2ZSB0aGUgbGluZSBhbmQgY29sdW1uIGZyb21cbiAgICAgICAgICogdGhlcmUuIEhvd2V2ZXIgSUUncyB8c3BsaXR8IGltcGxlbWVudGF0aW9uIGlzIHNvIGJyb2tlbiB0aGF0IGl0IHdhc1xuICAgICAgICAgKiBlbm91Z2ggdG8gcHJldmVudCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIFxuICAgICAgICB2YXIgbGluZSA9IDE7XG4gICAgICAgIHZhciBjb2x1bW4gPSAxO1xuICAgICAgICB2YXIgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5DUikgeyBsaW5lKys7IH1cbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBzZWVuQ1IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSgpO1xuICAgICAgXG4gICAgICAvKlxuICAgICAgICogVGhlIHBhcnNlciBpcyBub3cgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAgICAgICpcbiAgICAgICAqIDEuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgd2hvbGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICogICAgLSB8cG9zID09PSBpbnB1dC5sZW5ndGh8XG4gICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZ1xuICAgICAgICpcbiAgICAgICAqIDIuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBvbmx5IGEgcGFydCBvZiB0aGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICogICAgLSB8cG9zIDwgaW5wdXQubGVuZ3RofFxuICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmdcbiAgICAgICAqXG4gICAgICAgKiAzLiBUaGUgcGFyc2VyIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFueSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgIC0gfHJlc3VsdCA9PT0gbnVsbHxcbiAgICAgICAqICAgLSB8cG9zID09PSAwfFxuICAgICAgICogICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBjb250YWlucyBhdCBsZWFzdCBvbmUgZmFpbHVyZVxuICAgICAgICpcbiAgICAgICAqIEFsbCBjb2RlIGZvbGxvd2luZyB0aGlzIGNvbW1lbnQgKGluY2x1ZGluZyBjYWxsZWQgZnVuY3Rpb25zKSBtdXN0XG4gICAgICAgKiBoYW5kbGUgdGhlc2Ugc3RhdGVzLlxuICAgICAgICovXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHBvcyAhPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTtcbiAgICAgICAgdmFyIGZvdW5kID0gb2Zmc2V0IDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KG9mZnNldCkgOiBudWxsO1xuICAgICAgICB2YXIgZXJyb3JQb3NpdGlvbiA9IGNvbXB1dGVFcnJvclBvc2l0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICB0aHJvdyBuZXcgdGhpcy5TeW50YXhFcnJvcihcbiAgICAgICAgICBjbGVhbnVwRXhwZWN0ZWQocmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCksXG4gICAgICAgICAgZm91bmQsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGVycm9yUG9zaXRpb24ubGluZSxcbiAgICAgICAgICBlcnJvclBvc2l0aW9uLmNvbHVtblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgXG4gICAgLyogUmV0dXJucyB0aGUgcGFyc2VyIHNvdXJjZSBjb2RlLiAqL1xuICAgIHRvU291cmNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3NvdXJjZTsgfVxuICB9O1xuICBcbiAgLyogVGhyb3duIHdoZW4gYSBwYXJzZXIgZW5jb3VudGVycyBhIHN5bnRheCBlcnJvci4gKi9cbiAgXG4gIHJlc3VsdC5TeW50YXhFcnJvciA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRIdW1hbml6ZWQsIGZvdW5kSHVtYW5pemVkO1xuICAgICAgXG4gICAgICBzd2l0Y2ggKGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZFswXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkLnNsaWNlKDAsIGV4cGVjdGVkLmxlbmd0aCAtIDEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgKyBleHBlY3RlZFtleHBlY3RlZC5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm91bmRIdW1hbml6ZWQgPSBmb3VuZCA/IHF1b3RlKGZvdW5kKSA6IFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICBcbiAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWRIdW1hbml6ZWQgKyBcIiBidXQgXCIgKyBmb3VuZEh1bWFuaXplZCArIFwiIGZvdW5kLlwiO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgPSBmb3VuZDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB9O1xuICBcbiAgcmVzdWx0LlN5bnRheEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbiAgXG4gIHJldHVybiByZXN1bHQ7XG59KSgpO1xuIiwiLy8gLSotIGpzLWluZGVudC1sZXZlbDogMiAtKi1cbi8vIENvbnN0cnVjdGluZyBwYXR0ZXJuc1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcbiAgdmFyIHMgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiB2YWx1ZXMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZXMsIGkpKSBjb250aW51ZTtcbiAgICBzW3ZhbHVlc1tpXV0gPSAxO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vLyBDb25zdHJ1Y3QgYSBzZWdtZW50IGJvdW5kIHRvIGEgdmFyaWFibGUsIGUuZy4sIGZyb20gYSBzZWdtZW50IGxpa2Vcbi8vIFwiTGVuOjMyL3Vuc2lnbmVkLWJpZ1wiLiBgc3BlY2lmaWVyczBgIGlzIGFuIGFycmF5LlxuZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgc2l6ZSwgc3BlY2lmaWVyczApIHtcbiAgdmFyIHNwZWNpZmllcnMgPSBzZXQoc3BlY2lmaWVyczApO1xuICB2YXIgc2VnbWVudCA9IHtuYW1lOiBuYW1lfTtcbiAgc2VnbWVudC50eXBlID0gdHlwZV9pbihzcGVjaWZpZXJzKTtcbiAgc3BlY3Moc2VnbWVudCwgc2VnbWVudC50eXBlLCBzcGVjaWZpZXJzKTtcbiAgc2VnbWVudC5zaXplID0gc2l6ZV9vZihzZWdtZW50LCBzZWdtZW50LnR5cGUsIHNpemUsIHNlZ21lbnQudW5pdCk7XG4gIHJldHVybiBzZWdtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cy52YXJpYWJsZSA9IHZhcmlhYmxlO1xubW9kdWxlLmV4cG9ydHMucmVzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdmFyaWFibGUoJ18nLCB0cnVlLCBbJ2JpbmFyeSddKTtcbn1cblxuLy8gQ29uc3RydWN0IGEgc2VnbWVudCB3aXRoIGEgbGl0ZXJhbCB2YWx1ZSwgZS5nLiwgZnJvbSBhIHNlZ21lbnQgbGlrZVxuLy8gXCIyMDZcIi4gYHNwZWNpZmllcnMwYCBpcyBhbiBhcnJheS5cblxuZnVuY3Rpb24gdmFsdWUodmFsLCBzaXplLCBzcGVjaWZpZXJzMCkge1xuICB2YXIgc3BlY2lmaWVycyA9IHNldChzcGVjaWZpZXJzMCk7XG4gIHZhciBzZWdtZW50ID0ge3ZhbHVlOiB2YWx9O1xuICBzZWdtZW50LnR5cGUgPSB0eXBlX2luKHNwZWNpZmllcnMpO1xuICAvLyBUT0RPIGNoZWNrIHR5cGUgdi4gdmFsdWUgLi5cbiAgc3BlY3Moc2VnbWVudCwgc2VnbWVudC50eXBlLCBzcGVjaWZpZXJzKTtcbiAgc2VnbWVudC5zaXplID0gc2l6ZV9vZihzZWdtZW50LCBzZWdtZW50LnR5cGUsIHNpemUsIHNlZ21lbnQudW5pdCk7XG4gIHJldHVybiBzZWdtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cy52YWx1ZSA9IHZhbHVlO1xuXG4vLyBBIHN0cmluZyBjYW4gYXBwZWFyIGFzIGEgbGl0ZXJhbCwgYnV0IGl0IG11c3QgYXBwZWFyIHdpdGhvdXRcbi8vIHNwZWNpZmllcnMuXG5mdW5jdGlvbiBzdHJpbmcodmFsKSB7XG4gIHJldHVybiB7dmFsdWU6IHZhbCwgdHlwZTogJ3N0cmluZyd9O1xufVxubW9kdWxlLmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuXG52YXIgVFlQRVMgPSB7J2ludGVnZXInOiAxLCAnYmluYXJ5JzogMSwgJ2Zsb2F0JzogMX07XG5mdW5jdGlvbiB0eXBlX2luKHNwZWNpZmllcnMpIHtcbiAgZm9yICh2YXIgdCBpbiBzcGVjaWZpZXJzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3BlY2lmaWVycywgdCkpIGNvbnRpbnVlO1xuICAgIGlmIChUWVBFU1t0XSkgeyByZXR1cm4gdDsgfVxuICB9XG4gIHJldHVybiAnaW50ZWdlcic7XG59XG5cbmZ1bmN0aW9uIHNwZWNzKHNlZ21lbnQsIHR5cGUsIHNwZWNpZmllcnMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ2ludGVnZXInOlxuICAgIHNlZ21lbnQuc2lnbmVkID0gc2lnbmVkX2luKHNwZWNpZmllcnMpO1xuICAgIC8vIGZhbGwgdGhyb3VnaFxuICBjYXNlICdmbG9hdCc6XG4gICAgc2VnbWVudC5iaWdlbmRpYW4gPSBlbmRpYW5faW4oc3BlY2lmaWVycyk7XG4gICAgLy8gZmFsbCB0aHJvdWdoXG4gIGRlZmF1bHQ6XG4gICAgc2VnbWVudC51bml0ID0gdW5pdF9pbihzcGVjaWZpZXJzLCBzZWdtZW50LnR5cGUpO1xuICB9XG4gIHJldHVybiBzZWdtZW50O1xufVxuXG5mdW5jdGlvbiBlbmRpYW5faW4oc3BlY2lmaWVycykge1xuICAvLyBkZWZhdWx0IGlzIGJpZywgYnV0IEkgaGF2ZSBjaG9zZW4gdHJ1ZSA9IGJpZ2VuZGlhblxuICByZXR1cm4gIXNwZWNpZmllcnNbJ2xpdHRsZSddO1xufVxuXG5mdW5jdGlvbiBzaWduZWRfaW4oc3BlY2lmaWVycykge1xuICAvLyB0aGlzIHRpbWUgSSBnb3QgaXQgcmlnaHQ7IGRlZmF1bHQgaXMgdW5zaWduZWRcbiAgcmV0dXJuIHNwZWNpZmllcnNbJ3NpZ25lZCddO1xufVxuXG5mdW5jdGlvbiB1bml0X2luKHNwZWNpZmllcnMsIHR5cGUpIHtcbiAgZm9yICh2YXIgcyBpbiBzcGVjaWZpZXJzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3BlY2lmaWVycywgcykpIGNvbnRpbnVlO1xuICAgIGlmIChzLnN1YnN0cigwLCA1KSA9PSAndW5pdDonKSB7XG4gICAgICB2YXIgdW5pdCA9IHBhcnNlSW50KHMuc3Vic3RyKDUpKTtcbiAgICAgIC8vIFRPRE8gY2hlY2sgc2FuZSBmb3IgdHlwZVxuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gIC8vIE9LIGRlZmF1bHRzIHRoZW5cbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ2JpbmFyeSc6XG4gICAgcmV0dXJuIDg7XG4gIGNhc2UgJ2ludGVnZXInOlxuICBjYXNlICdmbG9hdCc6XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2l6ZV9vZihzZWdtZW50LCB0eXBlLCBzaXplLCB1bml0KSB7XG4gIGlmIChzaXplICE9PSB1bmRlZmluZWQgJiYgc2l6ZSAhPT0gJycpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIHJldHVybiA2NDtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZID0gL152MVxcLi87XG5jb25zdCBSRUdFWF9JU19JTlNUQUxMQVRJT04gPSAvXmdoc18vO1xuY29uc3QgUkVHRVhfSVNfVVNFUl9UT19TRVJWRVIgPSAvXmdodV8vO1xuYXN5bmMgZnVuY3Rpb24gYXV0aCh0b2tlbikge1xuICAgIGNvbnN0IGlzQXBwID0gdG9rZW4uc3BsaXQoL1xcLi8pLmxlbmd0aCA9PT0gMztcbiAgICBjb25zdCBpc0luc3RhbGxhdGlvbiA9IFJFR0VYX0lTX0lOU1RBTExBVElPTl9MRUdBQ1kudGVzdCh0b2tlbikgfHxcbiAgICAgICAgUkVHRVhfSVNfSU5TVEFMTEFUSU9OLnRlc3QodG9rZW4pO1xuICAgIGNvbnN0IGlzVXNlclRvU2VydmVyID0gUkVHRVhfSVNfVVNFUl9UT19TRVJWRVIudGVzdCh0b2tlbik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gaXNBcHBcbiAgICAgICAgPyBcImFwcFwiXG4gICAgICAgIDogaXNJbnN0YWxsYXRpb25cbiAgICAgICAgICAgID8gXCJpbnN0YWxsYXRpb25cIlxuICAgICAgICAgICAgOiBpc1VzZXJUb1NlcnZlclxuICAgICAgICAgICAgICAgID8gXCJ1c2VyLXRvLXNlcnZlclwiXG4gICAgICAgICAgICAgICAgOiBcIm9hdXRoXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0b2tlblwiLFxuICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgIHRva2VuVHlwZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFByZWZpeCB0b2tlbiBmb3IgdXNhZ2UgaW4gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gKlxuICogQHBhcmFtIHRva2VuIE9BdXRoIHRva2VuIG9yIEpTT04gV2ViIFRva2VuXG4gKi9cbmZ1bmN0aW9uIHdpdGhBdXRob3JpemF0aW9uUHJlZml4KHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnNwbGl0KC9cXC4vKS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGBiZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgICByZXR1cm4gYHRva2VuICR7dG9rZW59YDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaG9vayh0b2tlbiwgcmVxdWVzdCwgcm91dGUsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHJlcXVlc3QuZW5kcG9pbnQubWVyZ2Uocm91dGUsIHBhcmFtZXRlcnMpO1xuICAgIGVuZHBvaW50LmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IHdpdGhBdXRob3JpemF0aW9uUHJlZml4KHRva2VuKTtcbiAgICByZXR1cm4gcmVxdWVzdChlbmRwb2ludCk7XG59XG5cbmNvbnN0IGNyZWF0ZVRva2VuQXV0aCA9IGZ1bmN0aW9uIGNyZWF0ZVRva2VuQXV0aCh0b2tlbikge1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIE5vIHRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGhcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIFRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGggaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoL14odG9rZW58YmVhcmVyKSArL2ksIFwiXCIpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGF1dGguYmluZChudWxsLCB0b2tlbiksIHtcbiAgICAgICAgaG9vazogaG9vay5iaW5kKG51bGwsIHRva2VuKSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVRva2VuQXV0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJpbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tICd1bml2ZXJzYWwtdXNlci1hZ2VudCc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnYmVmb3JlLWFmdGVyLWhvb2snO1xuaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJ0BvY3Rva2l0L3JlcXVlc3QnO1xuaW1wb3J0IHsgd2l0aEN1c3RvbVJlcXVlc3QgfSBmcm9tICdAb2N0b2tpdC9ncmFwaHFsJztcbmltcG9ydCB7IGNyZWF0ZVRva2VuQXV0aCB9IGZyb20gJ0BvY3Rva2l0L2F1dGgtdG9rZW4nO1xuXG5jb25zdCBWRVJTSU9OID0gXCIzLjYuMFwiO1xuXG5jbGFzcyBPY3Rva2l0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgaG9vayA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGJhc2VVcmw6IHJlcXVlc3QuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgcmVxdWVzdDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB1c2FnZSBvbmx5LCBubyBuZWVkIHRvIHR5cGVcbiAgICAgICAgICAgICAgICBob29rOiBob29rLmJpbmQobnVsbCwgXCJyZXF1ZXN0XCIpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3czogW10sXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHJlcGVuZCBkZWZhdWx0IHVzZXIgYWdlbnQgd2l0aCBgb3B0aW9ucy51c2VyQWdlbnRgIGlmIHNldFxuICAgICAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInVzZXItYWdlbnRcIl0gPSBbXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIGBvY3Rva2l0LWNvcmUuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWAsXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmFzZVVybCkge1xuICAgICAgICAgICAgcmVxdWVzdERlZmF1bHRzLmJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucHJldmlld3MpIHtcbiAgICAgICAgICAgIHJlcXVlc3REZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MgPSBvcHRpb25zLnByZXZpZXdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInRpbWUtem9uZVwiXSA9IG9wdGlvbnMudGltZVpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdC5kZWZhdWx0cyhyZXF1ZXN0RGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmdyYXBocWwgPSB3aXRoQ3VzdG9tUmVxdWVzdCh0aGlzLnJlcXVlc3QpLmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgICAgIHRoaXMubG9nID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkZWJ1ZzogKCkgPT4geyB9LFxuICAgICAgICAgICAgaW5mbzogKCkgPT4geyB9LFxuICAgICAgICAgICAgd2FybjogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICBlcnJvcjogY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLFxuICAgICAgICB9LCBvcHRpb25zLmxvZyk7XG4gICAgICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgICAgIC8vICgxKSBJZiBuZWl0aGVyIGBvcHRpb25zLmF1dGhTdHJhdGVneWAgbm9yIGBvcHRpb25zLmF1dGhgIGFyZSBzZXQsIHRoZSBgb2N0b2tpdGAgaW5zdGFuY2VcbiAgICAgICAgLy8gICAgIGlzIHVuYXV0aGVudGljYXRlZC4gVGhlIGB0aGlzLmF1dGgoKWAgbWV0aG9kIGlzIGEgbm8tb3AgYW5kIG5vIHJlcXVlc3QgaG9vayBpcyByZWdpc3RlcmVkLlxuICAgICAgICAvLyAoMikgSWYgb25seSBgb3B0aW9ucy5hdXRoYCBpcyBzZXQsIHVzZSB0aGUgZGVmYXVsdCB0b2tlbiBhdXRoZW50aWNhdGlvbiBzdHJhdGVneS5cbiAgICAgICAgLy8gKDMpIElmIGBvcHRpb25zLmF1dGhTdHJhdGVneWAgaXMgc2V0IHRoZW4gdXNlIGl0IGFuZCBwYXNzIGluIGBvcHRpb25zLmF1dGhgLiBBbHdheXMgcGFzcyBvd24gcmVxdWVzdCBhcyBtYW55IHN0cmF0ZWdpZXMgYWNjZXB0IGEgY3VzdG9tIHJlcXVlc3QgaW5zdGFuY2UuXG4gICAgICAgIC8vIFRPRE86IHR5cGUgYG9wdGlvbnMuYXV0aGAgYmFzZWQgb24gYG9wdGlvbnMuYXV0aFN0cmF0ZWd5YC5cbiAgICAgICAgaWYgKCFvcHRpb25zLmF1dGhTdHJhdGVneSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgICAgICAvLyAoMSlcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGggPSBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInVuYXV0aGVudGljYXRlZFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gKDIpXG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aCA9IGNyZWF0ZVRva2VuQXV0aChvcHRpb25zLmF1dGgpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgIMKvXFxfKOODhClfL8KvXG4gICAgICAgICAgICAgICAgaG9vay53cmFwKFwicmVxdWVzdFwiLCBhdXRoLmhvb2spO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhTdHJhdGVneSwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYXV0aCA9IGF1dGhTdHJhdGVneShPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgbG9nOiB0aGlzLmxvZyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBwYXNzIHRoZSBjdXJyZW50IG9jdG9raXQgaW5zdGFuY2UgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHRvIGFsbG93IGZvciBhdXRoZW50aWNhdGlvbiBzdHJhdGVnaWVzIHRoYXQgcmV0dXJuIGEgbmV3IG9jdG9raXQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHNoYXJlcyB0aGUgc2FtZSBpbnRlcm5hbCBzdGF0ZSBhcyB0aGUgY3VycmVudCBvbmUuIFRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50IGZvciB0aGlzIHdhcyB0aGUgXCJldmVudC1vY3Rva2l0XCIgYXV0aGVudGljYXRpb24gc3RyYXRlZ3lcbiAgICAgICAgICAgICAgICAvLyBvZiBodHRwczovL2dpdGh1Yi5jb20vcHJvYm90L29jdG9raXQtYXV0aC1wcm9ib3QuXG4gICAgICAgICAgICAgICAgb2N0b2tpdDogdGhpcyxcbiAgICAgICAgICAgICAgICBvY3Rva2l0T3B0aW9uczogb3RoZXJPcHRpb25zLFxuICAgICAgICAgICAgfSwgb3B0aW9ucy5hdXRoKSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlICDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICAgICAgaG9vay53cmFwKFwicmVxdWVzdFwiLCBhdXRoLmhvb2spO1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBwbHVnaW5zXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjM0NTE3MlxuICAgICAgICBjb25zdCBjbGFzc0NvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY2xhc3NDb25zdHJ1Y3Rvci5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwbHVnaW4odGhpcywgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRzKGRlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IE9jdG9raXRXaXRoRGVmYXVsdHMgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzBdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihkZWZhdWx0cyhvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMsIG9wdGlvbnMudXNlckFnZW50ICYmIGRlZmF1bHRzLnVzZXJBZ2VudFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJBZ2VudDogYCR7b3B0aW9ucy51c2VyQWdlbnR9ICR7ZGVmYXVsdHMudXNlckFnZW50fWAsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPY3Rva2l0V2l0aERlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBwbHVnaW4gKG9yIG1hbnkpIHRvIHlvdXIgT2N0b2tpdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgQVBJID0gT2N0b2tpdC5wbHVnaW4ocGx1Z2luMSwgcGx1Z2luMiwgcGx1Z2luMywgLi4uKVxuICAgICAqL1xuICAgIHN0YXRpYyBwbHVnaW4oLi4ubmV3UGx1Z2lucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQbHVnaW5zID0gdGhpcy5wbHVnaW5zO1xuICAgICAgICBjb25zdCBOZXdPY3Rva2l0ID0gKF9hID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYS5wbHVnaW5zID0gY3VycmVudFBsdWdpbnMuY29uY2F0KG5ld1BsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+ICFjdXJyZW50UGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSksXG4gICAgICAgICAgICBfYSk7XG4gICAgICAgIHJldHVybiBOZXdPY3Rva2l0O1xuICAgIH1cbn1cbk9jdG9raXQuVkVSU0lPTiA9IFZFUlNJT047XG5PY3Rva2l0LnBsdWdpbnMgPSBbXTtcblxuZXhwb3J0IHsgT2N0b2tpdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gJ3VuaXZlcnNhbC11c2VyLWFnZW50JztcblxuZnVuY3Rpb24gbG93ZXJjYXNlS2V5cyhvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZSgobmV3T2JqLCBrZXkpID0+IHtcbiAgICAgICAgbmV3T2JqW2tleS50b0xvd2VyQ2FzZSgpXSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwKGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gZGVmYXVsdHMpKVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZURlZXAoZGVmYXVsdHNba2V5XSwgb3B0aW9uc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygcm91dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IFttZXRob2QsIHVybF0gPSByb3V0ZS5zcGxpdChcIiBcIik7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHVybCA/IHsgbWV0aG9kLCB1cmwgfSA6IHsgdXJsOiBtZXRob2QgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGUpO1xuICAgIH1cbiAgICAvLyBsb3dlcmNhc2UgaGVhZGVyIG5hbWVzIGJlZm9yZSBtZXJnaW5nIHdpdGggZGVmYXVsdHMgdG8gYXZvaWQgZHVwbGljYXRlc1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IGxvd2VyY2FzZUtleXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICAvLyByZW1vdmUgcHJvcGVydGllcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgYmVmb3JlIG1lcmdpbmdcbiAgICByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gbWVyZ2VEZWVwKGRlZmF1bHRzIHx8IHt9LCBvcHRpb25zKTtcbiAgICAvLyBtZWRpYVR5cGUucHJldmlld3MgYXJyYXlzIGFyZSBtZXJnZWQsIGluc3RlYWQgb2Ygb3ZlcndyaXR0ZW5cbiAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzLmxlbmd0aCkge1xuICAgICAgICBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyA9IGRlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3c1xuICAgICAgICAgICAgLmZpbHRlcigocHJldmlldykgPT4gIW1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzLmluY2x1ZGVzKHByZXZpZXcpKVxuICAgICAgICAgICAgLmNvbmNhdChtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyk7XG4gICAgfVxuICAgIG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzID0gbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MubWFwKChwcmV2aWV3KSA9PiBwcmV2aWV3LnJlcGxhY2UoLy1wcmV2aWV3LywgXCJcIikpO1xuICAgIHJldHVybiBtZXJnZWRPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIjtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcmV0dXJuICh1cmwgK1xuICAgICAgICBzZXBhcmF0b3IgK1xuICAgICAgICBuYW1lc1xuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcInE9XCIgKyBwYXJhbWV0ZXJzLnEuc3BsaXQoXCIrXCIpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIrXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJzW25hbWVdKX1gO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCImXCIpKTtcbn1cblxuY29uc3QgdXJsVmFyaWFibGVSZWdleCA9IC9cXHtbXn1dK1xcfS9nO1xuZnVuY3Rpb24gcmVtb3ZlTm9uQ2hhcnModmFyaWFibGVOYW1lKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlTmFtZS5yZXBsYWNlKC9eXFxXK3xcXFcrJC9nLCBcIlwiKS5zcGxpdCgvLC8pO1xufVxuZnVuY3Rpb24gZXh0cmFjdFVybFZhcmlhYmxlTmFtZXModXJsKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaCh1cmxWYXJpYWJsZVJlZ2V4KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAocmVtb3ZlTm9uQ2hhcnMpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbn1cblxuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXNUb09taXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+ICFrZXlzVG9PbWl0LmluY2x1ZGVzKG9wdGlvbikpXG4gICAgICAgIC5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgIG9ialtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3VybC10ZW1wbGF0ZSwgbGljZW5zZWQgdW5kZXIgQlNEXG4vLyBUT0RPOiBjcmVhdGUgc2VwYXJhdGUgcGFja2FnZS5cbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgQnJhbSBTdGVpblxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4vLyBhcmUgbWV0OlxuLy8gIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyAgMy4gVGhlIG5hbWUgb2YgdGhlIGF1dGhvciBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4vLyAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1IgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4vLyBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk9cbi8vIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbi8vIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxuLy8gQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbi8vIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4vLyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4vLyBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbmZ1bmN0aW9uIGVuY29kZVJlc2VydmVkKHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnNwbGl0KC8oJVswLTlBLUZhLWZdezJ9KS9nKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGlmICghLyVbMC05QS1GYS1mXS8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KS5yZXBsYWNlKC8lNUIvZywgXCJbXCIpLnJlcGxhY2UoLyU1RC9nLCBcIl1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBlbmNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG4gICAgdmFsdWUgPVxuICAgICAgICBvcGVyYXRvciA9PT0gXCIrXCIgfHwgb3BlcmF0b3IgPT09IFwiI1wiXG4gICAgICAgICAgICA/IGVuY29kZVJlc2VydmVkKHZhbHVlKVxuICAgICAgICAgICAgOiBlbmNvZGVVbnJlc2VydmVkKHZhbHVlKTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIiArIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNLZXlPcGVyYXRvcihvcGVyYXRvcikge1xuICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI7XCIgfHwgb3BlcmF0b3IgPT09IFwiJlwiIHx8IG9wZXJhdG9yID09PSBcIj9cIjtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwga2V5LCBtb2RpZmllcikge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHRba2V5XSwgcmVzdWx0ID0gW107XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgJiYgbW9kaWZpZXIgIT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgcGFyc2VJbnQobW9kaWZpZXIsIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXIoaXNEZWZpbmVkKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wID0gW107XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVbnJlc2VydmVkKGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiICsgdG1wLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIjtcIikge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcIlwiICYmIChvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VVcmwodGVtcGxhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleHBhbmQ6IGV4cGFuZC5iaW5kKG51bGwsIHRlbXBsYXRlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXhwYW5kKHRlbXBsYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG9wZXJhdG9ycyA9IFtcIitcIiwgXCIjXCIsIFwiLlwiLCBcIi9cIiwgXCI7XCIsIFwiP1wiLCBcIiZcIl07XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xceyhbXlxce1xcfV0rKVxcfXwoW15cXHtcXH1dKykvZywgZnVuY3Rpb24gKF8sIGV4cHJlc3Npb24sIGxpdGVyYWwpIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGxldCBvcGVyYXRvciA9IFwiXCI7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihleHByZXNzaW9uLmNoYXJBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBleHByZXNzaW9uLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IC8oW146XFwqXSopKD86OihcXGQrKXwoXFwqKSk/Ly5leGVjKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIHRtcFsxXSwgdG1wWzJdIHx8IHRtcFszXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3IgJiYgb3BlcmF0b3IgIT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gXCImXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yICE9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiBcIlwiKSArIHZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMpIHtcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jbWV0aG9kc1xuICAgIGxldCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIHJlcGxhY2UgOnZhcm5hbWUgd2l0aCB7dmFybmFtZX0gdG8gbWFrZSBpdCBSRkMgNjU3MCBjb21wYXRpYmxlXG4gICAgbGV0IHVybCA9IChvcHRpb25zLnVybCB8fCBcIi9cIikucmVwbGFjZSgvOihbYS16XVxcdyspL2csIFwieyQxfVwiKTtcbiAgICBsZXQgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgbGV0IGJvZHk7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSBvbWl0KG9wdGlvbnMsIFtcbiAgICAgICAgXCJtZXRob2RcIixcbiAgICAgICAgXCJiYXNlVXJsXCIsXG4gICAgICAgIFwidXJsXCIsXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBcInJlcXVlc3RcIixcbiAgICAgICAgXCJtZWRpYVR5cGVcIixcbiAgICBdKTtcbiAgICAvLyBleHRyYWN0IHZhcmlhYmxlIG5hbWVzIGZyb20gVVJMIHRvIGNhbGN1bGF0ZSByZW1haW5pbmcgdmFyaWFibGVzIGxhdGVyXG4gICAgY29uc3QgdXJsVmFyaWFibGVOYW1lcyA9IGV4dHJhY3RVcmxWYXJpYWJsZU5hbWVzKHVybCk7XG4gICAgdXJsID0gcGFyc2VVcmwodXJsKS5leHBhbmQocGFyYW1ldGVycyk7XG4gICAgaWYgKCEvXmh0dHAvLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgPSBvcHRpb25zLmJhc2VVcmwgKyB1cmw7XG4gICAgfVxuICAgIGNvbnN0IG9taXR0ZWRQYXJhbWV0ZXJzID0gT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiB1cmxWYXJpYWJsZU5hbWVzLmluY2x1ZGVzKG9wdGlvbikpXG4gICAgICAgIC5jb25jYXQoXCJiYXNlVXJsXCIpO1xuICAgIGNvbnN0IHJlbWFpbmluZ1BhcmFtZXRlcnMgPSBvbWl0KHBhcmFtZXRlcnMsIG9taXR0ZWRQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBpc0JpbmFyeVJlcXVlc3QgPSAvYXBwbGljYXRpb25cXC9vY3RldC1zdHJlYW0vaS50ZXN0KGhlYWRlcnMuYWNjZXB0KTtcbiAgICBpZiAoIWlzQmluYXJ5UmVxdWVzdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0KSB7XG4gICAgICAgICAgICAvLyBlLmcuIGFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvbiA9PiBhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzLnJhd1xuICAgICAgICAgICAgaGVhZGVycy5hY2NlcHQgPSBoZWFkZXJzLmFjY2VwdFxuICAgICAgICAgICAgICAgIC5zcGxpdCgvLC8pXG4gICAgICAgICAgICAgICAgLm1hcCgocHJldmlldykgPT4gcHJldmlldy5yZXBsYWNlKC9hcHBsaWNhdGlvblxcL3ZuZChcXC5cXHcrKShcXC52Myk/KFxcLlxcdyspPyhcXCtqc29uKT8kLywgYGFwcGxpY2F0aW9uL3ZuZCQxJDIuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlciA9IGhlYWRlcnMuYWNjZXB0Lm1hdGNoKC9bXFx3LV0rKD89LXByZXZpZXcpL2cpIHx8IFtdO1xuICAgICAgICAgICAgaGVhZGVycy5hY2NlcHQgPSBwcmV2aWV3c0Zyb21BY2NlcHRIZWFkZXJcbiAgICAgICAgICAgICAgICAuY29uY2F0KG9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzKVxuICAgICAgICAgICAgICAgIC5tYXAoKHByZXZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgPyBgLiR7b3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0fWBcbiAgICAgICAgICAgICAgICAgICAgOiBcIitqc29uXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBhcHBsaWNhdGlvbi92bmQuZ2l0aHViLiR7cHJldmlld30tcHJldmlldyR7Zm9ybWF0fWA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3IgR0VUL0hFQUQgcmVxdWVzdHMsIHNldCBVUkwgcXVlcnkgcGFyYW1ldGVycyBmcm9tIHJlbWFpbmluZyBwYXJhbWV0ZXJzXG4gICAgLy8gZm9yIFBBVENIL1BPU1QvUFVUL0RFTEVURSByZXF1ZXN0cywgc2V0IHJlcXVlc3QgYm9keSBmcm9tIHJlbWFpbmluZyBwYXJhbWV0ZXJzXG4gICAgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICB1cmwgPSBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCByZW1haW5pbmdQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChcImRhdGFcIiBpbiByZW1haW5pbmdQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBib2R5ID0gcmVtYWluaW5nUGFyYW1ldGVycy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbWFpbmluZ1BhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSByZW1haW5pbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWZhdWx0IGNvbnRlbnQtdHlwZSBmb3IgSlNPTiBpZiBib2R5IGlzIHNldFxuICAgIGlmICghaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSAmJiB0eXBlb2YgYm9keSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCI7XG4gICAgfVxuICAgIC8vIEdpdEh1YiBleHBlY3RzICdjb250ZW50LWxlbmd0aDogMCcgaGVhZGVyIGZvciBQVVQvUEFUQ0ggcmVxdWVzdHMgd2l0aG91dCBib2R5LlxuICAgIC8vIGZldGNoIGRvZXMgbm90IGFsbG93IHRvIHNldCBgY29udGVudC1sZW5ndGhgIGhlYWRlciwgYnV0IHdlIGNhbiBzZXQgYm9keSB0byBhbiBlbXB0eSBzdHJpbmdcbiAgICBpZiAoW1wiUEFUQ0hcIiwgXCJQVVRcIl0uaW5jbHVkZXMobWV0aG9kKSAmJiB0eXBlb2YgYm9keSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBib2R5ID0gXCJcIjtcbiAgICB9XG4gICAgLy8gT25seSByZXR1cm4gYm9keS9yZXF1ZXN0IGtleXMgaWYgcHJlc2VudFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgbWV0aG9kLCB1cmwsIGhlYWRlcnMgfSwgdHlwZW9mIGJvZHkgIT09IFwidW5kZWZpbmVkXCIgPyB7IGJvZHkgfSA6IG51bGwsIG9wdGlvbnMucmVxdWVzdCA/IHsgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0IH0gOiBudWxsKTtcbn1cblxuZnVuY3Rpb24gZW5kcG9pbnRXaXRoRGVmYXVsdHMoZGVmYXVsdHMsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBhcnNlKG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMob2xkRGVmYXVsdHMsIG5ld0RlZmF1bHRzKSB7XG4gICAgY29uc3QgREVGQVVMVFMgPSBtZXJnZShvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICAgIGNvbnN0IGVuZHBvaW50ID0gZW5kcG9pbnRXaXRoRGVmYXVsdHMuYmluZChudWxsLCBERUZBVUxUUyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZW5kcG9pbnQsIHtcbiAgICAgICAgREVGQVVMVFMsXG4gICAgICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBERUZBVUxUUyksXG4gICAgICAgIG1lcmdlOiBtZXJnZS5iaW5kKG51bGwsIERFRkFVTFRTKSxcbiAgICAgICAgcGFyc2UsXG4gICAgfSk7XG59XG5cbmNvbnN0IFZFUlNJT04gPSBcIjYuMC4xMlwiO1xuXG5jb25zdCB1c2VyQWdlbnQgPSBgb2N0b2tpdC1lbmRwb2ludC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YDtcbi8vIERFRkFVTFRTIGhhcyBhbGwgcHJvcGVydGllcyBzZXQgdGhhdCBFbmRwb2ludE9wdGlvbnMgaGFzLCBleGNlcHQgdXJsLlxuLy8gU28gd2UgdXNlIFJlcXVlc3RQYXJhbWV0ZXJzIGFuZCBhZGQgbWV0aG9kIGFzIGFkZGl0aW9uYWwgcmVxdWlyZWQgcHJvcGVydHkuXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYmFzZVVybDogXCJodHRwczovL2FwaS5naXRodWIuY29tXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uXCIsXG4gICAgICAgIFwidXNlci1hZ2VudFwiOiB1c2VyQWdlbnQsXG4gICAgfSxcbiAgICBtZWRpYVR5cGU6IHtcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBwcmV2aWV3czogW10sXG4gICAgfSxcbn07XG5cbmNvbnN0IGVuZHBvaW50ID0gd2l0aERlZmF1bHRzKG51bGwsIERFRkFVTFRTKTtcblxuZXhwb3J0IHsgZW5kcG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJ0BvY3Rva2l0L3JlcXVlc3QnO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSAndW5pdmVyc2FsLXVzZXItYWdlbnQnO1xuXG5jb25zdCBWRVJTSU9OID0gXCI0LjguMFwiO1xuXG5mdW5jdGlvbiBfYnVpbGRNZXNzYWdlRm9yUmVzcG9uc2VFcnJvcnMoZGF0YSkge1xuICAgIHJldHVybiAoYFJlcXVlc3QgZmFpbGVkIGR1ZSB0byBmb2xsb3dpbmcgcmVzcG9uc2UgZXJyb3JzOlxcbmAgK1xuICAgICAgICBkYXRhLmVycm9ycy5tYXAoKGUpID0+IGAgLSAke2UubWVzc2FnZX1gKS5qb2luKFwiXFxuXCIpKTtcbn1cbmNsYXNzIEdyYXBocWxSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QsIGhlYWRlcnMsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhyZXNwb25zZSkpO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiR3JhcGhxbFJlc3BvbnNlRXJyb3JcIjtcbiAgICAgICAgLy8gRXhwb3NlIHRoZSBlcnJvcnMgYW5kIHJlc3BvbnNlIGRhdGEgaW4gdGhlaXIgc2hvcnRoYW5kIHByb3BlcnRpZXMuXG4gICAgICAgIHRoaXMuZXJyb3JzID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgICAgICB0aGlzLmRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTk9OX1ZBUklBQkxFX09QVElPTlMgPSBbXG4gICAgXCJtZXRob2RcIixcbiAgICBcImJhc2VVcmxcIixcbiAgICBcInVybFwiLFxuICAgIFwiaGVhZGVyc1wiLFxuICAgIFwicmVxdWVzdFwiLFxuICAgIFwicXVlcnlcIixcbiAgICBcIm1lZGlhVHlwZVwiLFxuXTtcbmNvbnN0IEZPUkJJRERFTl9WQVJJQUJMRV9PUFRJT05TID0gW1wicXVlcnlcIiwgXCJtZXRob2RcIiwgXCJ1cmxcIl07XG5jb25zdCBHSEVTX1YzX1NVRkZJWF9SRUdFWCA9IC9cXC9hcGlcXC92M1xcLz8kLztcbmZ1bmN0aW9uIGdyYXBocWwocmVxdWVzdCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIFwicXVlcnlcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBbQG9jdG9raXQvZ3JhcGhxbF0gXCJxdWVyeVwiIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlIG5hbWVgKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFGT1JCSURERU5fVkFSSUFCTEVfT1BUSU9OUy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgW0BvY3Rva2l0L2dyYXBocWxdIFwiJHtrZXl9XCIgY2Fubm90IGJlIHVzZWQgYXMgdmFyaWFibGUgbmFtZWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJzZWRPcHRpb25zID0gdHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiID8gT2JqZWN0LmFzc2lnbih7IHF1ZXJ5IH0sIG9wdGlvbnMpIDogcXVlcnk7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3Qua2V5cyhwYXJzZWRPcHRpb25zKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgICAgIGlmIChOT05fVkFSSUFCTEVfT1BUSU9OUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHBhcnNlZE9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQudmFyaWFibGVzKSB7XG4gICAgICAgICAgICByZXN1bHQudmFyaWFibGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnZhcmlhYmxlc1trZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICAvLyB3b3JrYXJvdW5kIGZvciBHaXRIdWIgRW50ZXJwcmlzZSBiYXNlVXJsIHNldCB3aXRoIC9hcGkvdjMgc3VmZml4XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29jdG9raXQvYXV0aC1hcHAuanMvaXNzdWVzLzExMSNpc3N1ZWNvbW1lbnQtNjU3NjEwNDUxXG4gICAgY29uc3QgYmFzZVVybCA9IHBhcnNlZE9wdGlvbnMuYmFzZVVybCB8fCByZXF1ZXN0LmVuZHBvaW50LkRFRkFVTFRTLmJhc2VVcmw7XG4gICAgaWYgKEdIRVNfVjNfU1VGRklYX1JFR0VYLnRlc3QoYmFzZVVybCkpIHtcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMudXJsID0gYmFzZVVybC5yZXBsYWNlKEdIRVNfVjNfU1VGRklYX1JFR0VYLCBcIi9hcGkvZ3JhcGhxbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3QocmVxdWVzdE9wdGlvbnMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmVycm9ycykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSByZXNwb25zZS5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhxbFJlc3BvbnNlRXJyb3IocmVxdWVzdE9wdGlvbnMsIGhlYWRlcnMsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmRhdGE7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhyZXF1ZXN0JDEsIG5ld0RlZmF1bHRzKSB7XG4gICAgY29uc3QgbmV3UmVxdWVzdCA9IHJlcXVlc3QkMS5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gICAgY29uc3QgbmV3QXBpID0gKHF1ZXJ5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIHJldHVybiBncmFwaHFsKG5ld1JlcXVlc3QsIHF1ZXJ5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0FwaSwge1xuICAgICAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgbmV3UmVxdWVzdCksXG4gICAgICAgIGVuZHBvaW50OiByZXF1ZXN0LmVuZHBvaW50LFxuICAgIH0pO1xufVxuXG5jb25zdCBncmFwaHFsJDEgPSB3aXRoRGVmYXVsdHMocmVxdWVzdCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LWdyYXBocWwuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWAsXG4gICAgfSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogXCIvZ3JhcGhxbFwiLFxufSk7XG5mdW5jdGlvbiB3aXRoQ3VzdG9tUmVxdWVzdChjdXN0b21SZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHdpdGhEZWZhdWx0cyhjdXN0b21SZXF1ZXN0LCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHVybDogXCIvZ3JhcGhxbFwiLFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBHcmFwaHFsUmVzcG9uc2VFcnJvciwgZ3JhcGhxbCQxIGFzIGdyYXBocWwsIHdpdGhDdXN0b21SZXF1ZXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImNvbnN0IFZFUlNJT04gPSBcIjIuMjEuM1wiO1xuXG4vKipcbiAqIFNvbWUg4oCcbGlzdOKAnSByZXNwb25zZSB0aGF0IGNhbiBiZSBwYWdpbmF0ZWQgaGF2ZSBhIGRpZmZlcmVudCByZXNwb25zZSBzdHJ1Y3R1cmVcbiAqXG4gKiBUaGV5IGhhdmUgYSBgdG90YWxfY291bnRgIGtleSBpbiB0aGUgcmVzcG9uc2UgKHNlYXJjaCBhbHNvIGhhcyBgaW5jb21wbGV0ZV9yZXN1bHRzYCxcbiAqIC9pbnN0YWxsYXRpb24vcmVwb3NpdG9yaWVzIGFsc28gaGFzIGByZXBvc2l0b3J5X3NlbGVjdGlvbmApLCBhcyB3ZWxsIGFzIGEga2V5IHdpdGhcbiAqIHRoZSBsaXN0IG9mIHRoZSBpdGVtcyB3aGljaCBuYW1lIHZhcmllcyBmcm9tIGVuZHBvaW50IHRvIGVuZHBvaW50LlxuICpcbiAqIE9jdG9raXQgbm9ybWFsaXplcyB0aGVzZSByZXNwb25zZXMgc28gdGhhdCBwYWdpbmF0ZWQgcmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkIGZvbGxvd2luZ1xuICogdGhlIHNhbWUgc3RydWN0dXJlLiBPbmUgY2hhbGxlbmdlIGlzIHRoYXQgaWYgdGhlIGxpc3QgcmVzcG9uc2UgaGFzIG9ubHkgb25lIHBhZ2UsIG5vIExpbmtcbiAqIGhlYWRlciBpcyBwcm92aWRlZCwgc28gdGhpcyBoZWFkZXIgYWxvbmUgaXMgbm90IHN1ZmZpY2llbnQgdG8gY2hlY2sgd2V0aGVyIGEgcmVzcG9uc2UgaXNcbiAqIHBhZ2luYXRlZCBvciBub3QuXG4gKlxuICogV2UgY2hlY2sgaWYgYSBcInRvdGFsX2NvdW50XCIga2V5IGlzIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlIGRhdGEsIGJ1dCBhbHNvIG1ha2Ugc3VyZSB0aGF0XG4gKiBhIFwidXJsXCIgcHJvcGVydHkgaXMgbm90LCBhcyB0aGUgXCJHZXQgdGhlIGNvbWJpbmVkIHN0YXR1cyBmb3IgYSBzcGVjaWZpYyByZWZcIiBlbmRwb2ludCB3b3VsZFxuICogb3RoZXJ3aXNlIG1hdGNoOiBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzL3JlcG9zL3N0YXR1c2VzLyNnZXQtdGhlLWNvbWJpbmVkLXN0YXR1cy1mb3ItYS1zcGVjaWZpYy1yZWZcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUGFnaW5hdGVkTGlzdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgLy8gZW5kcG9pbnRzIGNhbiByZXNwb25kIHdpdGggMjA0IGlmIHJlcG9zaXRvcnkgaXMgZW1wdHlcbiAgICBpZiAoIXJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlTmVlZHNOb3JtYWxpemF0aW9uID0gXCJ0b3RhbF9jb3VudFwiIGluIHJlc3BvbnNlLmRhdGEgJiYgIShcInVybFwiIGluIHJlc3BvbnNlLmRhdGEpO1xuICAgIGlmICghcmVzcG9uc2VOZWVkc05vcm1hbGl6YXRpb24pXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAvLyBrZWVwIHRoZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW50YWN0IGFzIHRoZXJlIGlzIGN1cnJlbnRseSBubyBvdGhlciB3YXlcbiAgICAvLyB0byByZXRyaWV2ZSB0aGUgc2FtZSBpbmZvcm1hdGlvbi5cbiAgICBjb25zdCBpbmNvbXBsZXRlUmVzdWx0cyA9IHJlc3BvbnNlLmRhdGEuaW5jb21wbGV0ZV9yZXN1bHRzO1xuICAgIGNvbnN0IHJlcG9zaXRvcnlTZWxlY3Rpb24gPSByZXNwb25zZS5kYXRhLnJlcG9zaXRvcnlfc2VsZWN0aW9uO1xuICAgIGNvbnN0IHRvdGFsQ291bnQgPSByZXNwb25zZS5kYXRhLnRvdGFsX2NvdW50O1xuICAgIGRlbGV0ZSByZXNwb25zZS5kYXRhLmluY29tcGxldGVfcmVzdWx0cztcbiAgICBkZWxldGUgcmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5X3NlbGVjdGlvbjtcbiAgICBkZWxldGUgcmVzcG9uc2UuZGF0YS50b3RhbF9jb3VudDtcbiAgICBjb25zdCBuYW1lc3BhY2VLZXkgPSBPYmplY3Qua2V5cyhyZXNwb25zZS5kYXRhKVswXTtcbiAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YVtuYW1lc3BhY2VLZXldO1xuICAgIHJlc3BvbnNlLmRhdGEgPSBkYXRhO1xuICAgIGlmICh0eXBlb2YgaW5jb21wbGV0ZVJlc3VsdHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5pbmNvbXBsZXRlX3Jlc3VsdHMgPSBpbmNvbXBsZXRlUmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXBvc2l0b3J5U2VsZWN0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEucmVwb3NpdG9yeV9zZWxlY3Rpb24gPSByZXBvc2l0b3J5U2VsZWN0aW9uO1xuICAgIH1cbiAgICByZXNwb25zZS5kYXRhLnRvdGFsX2NvdW50ID0gdG90YWxDb3VudDtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yKG9jdG9raXQsIHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiByb3V0ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gcm91dGUuZW5kcG9pbnQocGFyYW1ldGVycylcbiAgICAgICAgOiBvY3Rva2l0LnJlcXVlc3QuZW5kcG9pbnQocm91dGUsIHBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSB0eXBlb2Ygcm91dGUgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlIDogb2N0b2tpdC5yZXF1ZXN0O1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgbGV0IHVybCA9IG9wdGlvbnMudXJsO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06ICgpID0+ICh7XG4gICAgICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdXJsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0TWV0aG9kKHsgbWV0aG9kLCB1cmwsIGhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXNwb25zZSA9IG5vcm1hbGl6ZVBhZ2luYXRlZExpc3RSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGByZXNwb25zZS5oZWFkZXJzLmxpbmtgIGZvcm1hdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gJzxodHRwczovL2FwaS5naXRodWIuY29tL3VzZXJzL2FzZWVtay9mb2xsb3dlcnM/cGFnZT0yPjsgcmVsPVwibmV4dFwiLCA8aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS91c2Vycy9hc2VlbWsvZm9sbG93ZXJzP3BhZ2U9Mj47IHJlbD1cImxhc3RcIidcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyBgdXJsYCB0byB1bmRlZmluZWQgaWYgXCJuZXh0XCIgVVJMIGlzIG5vdCBwcmVzZW50IG9yIGBsaW5rYCBoZWFkZXIgaXMgbm90IHNldFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoKG5vcm1hbGl6ZWRSZXNwb25zZS5oZWFkZXJzLmxpbmsgfHwgXCJcIikubWF0Y2goLzwoW14+XSspPjtcXHMqcmVsPVwibmV4dFwiLykgfHwgW10pWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbm9ybWFsaXplZFJlc3BvbnNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzICE9PSA0MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhZ2luYXRlKG9jdG9raXQsIHJvdXRlLCBwYXJhbWV0ZXJzLCBtYXBGbikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1hcEZuID0gcGFyYW1ldGVycztcbiAgICAgICAgcGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGdhdGhlcihvY3Rva2l0LCBbXSwgaXRlcmF0b3Iob2N0b2tpdCwgcm91dGUsIHBhcmFtZXRlcnMpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCBtYXBGbik7XG59XG5mdW5jdGlvbiBnYXRoZXIob2N0b2tpdCwgcmVzdWx0cywgaXRlcmF0b3IsIG1hcEZuKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWFybHlFeGl0ID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICBlYXJseUV4aXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChtYXBGbiA/IG1hcEZuKHJlc3VsdC52YWx1ZSwgZG9uZSkgOiByZXN1bHQudmFsdWUuZGF0YSk7XG4gICAgICAgIGlmIChlYXJseUV4aXQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXRoZXIob2N0b2tpdCwgcmVzdWx0cywgaXRlcmF0b3IsIG1hcEZuKTtcbiAgICB9KTtcbn1cblxuY29uc3QgY29tcG9zZVBhZ2luYXRlUmVzdCA9IE9iamVjdC5hc3NpZ24ocGFnaW5hdGUsIHtcbiAgICBpdGVyYXRvcixcbn0pO1xuXG5jb25zdCBwYWdpbmF0aW5nRW5kcG9pbnRzID0gW1xuICAgIFwiR0VUIC9hcHAvaG9vay9kZWxpdmVyaWVzXCIsXG4gICAgXCJHRVQgL2FwcC9pbnN0YWxsYXRpb25zXCIsXG4gICAgXCJHRVQgL2FwcGxpY2F0aW9ucy9ncmFudHNcIixcbiAgICBcIkdFVCAvYXV0aG9yaXphdGlvbnNcIixcbiAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnMvb3JnYW5pemF0aW9uc1wiLFxuICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9ydW5uZXItZ3JvdXBzXCIsXG4gICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3J1bm5lci1ncm91cHMve3J1bm5lcl9ncm91cF9pZH0vb3JnYW5pemF0aW9uc1wiLFxuICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L3J1bm5lcnNcIixcbiAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcnVubmVyc1wiLFxuICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYXVkaXQtbG9nXCIsXG4gICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzXCIsXG4gICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9zZXR0aW5ncy9iaWxsaW5nL2FkdmFuY2VkLXNlY3VyaXR5XCIsXG4gICAgXCJHRVQgL2V2ZW50c1wiLFxuICAgIFwiR0VUIC9naXN0c1wiLFxuICAgIFwiR0VUIC9naXN0cy9wdWJsaWNcIixcbiAgICBcIkdFVCAvZ2lzdHMvc3RhcnJlZFwiLFxuICAgIFwiR0VUIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHNcIixcbiAgICBcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1pdHNcIixcbiAgICBcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2ZvcmtzXCIsXG4gICAgXCJHRVQgL2luc3RhbGxhdGlvbi9yZXBvc2l0b3JpZXNcIixcbiAgICBcIkdFVCAvaXNzdWVzXCIsXG4gICAgXCJHRVQgL2xpY2Vuc2VzXCIsXG4gICAgXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnNcIixcbiAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9wbGFucy97cGxhbl9pZH0vYWNjb3VudHNcIixcbiAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9zdHViYmVkL3BsYW5zXCIsXG4gICAgXCJHRVQgL21hcmtldHBsYWNlX2xpc3Rpbmcvc3R1YmJlZC9wbGFucy97cGxhbl9pZH0vYWNjb3VudHNcIixcbiAgICBcIkdFVCAvbmV0d29ya3Mve293bmVyfS97cmVwb30vZXZlbnRzXCIsXG4gICAgXCJHRVQgL25vdGlmaWNhdGlvbnNcIixcbiAgICBcIkdFVCAvb3JnYW5pemF0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvY2FjaGUvdXNhZ2UtYnktcmVwb3NpdG9yeVwiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVyLWdyb3Vwcy97cnVubmVyX2dyb3VwX2lkfS9ydW5uZXJzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYXVkaXQtbG9nXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYmxvY2tzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vY29kZS1zY2FubmluZy9hbGVydHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9jb2Rlc3BhY2VzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vY3JlZGVudGlhbC1hdXRob3JpemF0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0c1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2V2ZW50c1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2V4dGVybmFsLWdyb3Vwc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2ZhaWxlZF9pbnZpdGF0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2hvb2tzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9pbnN0YWxsYXRpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vaW52aXRhdGlvbnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH0vdGVhbXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9pc3N1ZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9tZW1iZXJzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vbWlncmF0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vb3V0c2lkZV9jb2xsYWJvcmF0b3JzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3Byb2plY3RzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vcHVibGljX21lbWJlcnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9yZXBvc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9iaWxsaW5nL2FkdmFuY2VkLXNlY3VyaXR5XCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbS1zeW5jL2dyb3Vwc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vcmVhY3Rpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vaW52aXRhdGlvbnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9tZW1iZXJzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vcHJvamVjdHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3RlYW1zXCIsXG4gICAgXCJHRVQgL3Byb2plY3RzL2NvbHVtbnMve2NvbHVtbl9pZH0vY2FyZHNcIixcbiAgICBcIkdFVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbGxhYm9yYXRvcnNcIixcbiAgICBcIkdFVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbHVtbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9hcnRpZmFjdHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9jYWNoZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVuc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXJ0aWZhY3RzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hdHRlbXB0cy97YXR0ZW1wdF9udW1iZXJ9L2pvYnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2pvYnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9zZWNyZXRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzL3t3b3JrZmxvd19pZH0vcnVuc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hc3NpZ25lZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stcnVucy97Y2hlY2tfcnVuX2lkfS9hbm5vdGF0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1zdWl0ZXMve2NoZWNrX3N1aXRlX2lkfS9jaGVjay1ydW5zXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2luc3RhbmNlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FuYWx5c2VzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9kZXZjb250YWluZXJzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvc2VjcmV0c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9jb21tZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9wdWxsc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L2NoZWNrLXJ1bnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9jaGVjay1zdWl0ZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9zdGF0dXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9zdGF0dXNlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb250cmlidXRvcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kYWJvdC9zZWNyZXRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50X2lkfS9zdGF0dXNlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZXZlbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ZvcmtzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9tYXRjaGluZy1yZWZzL3tyZWZ9XCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ludml0YXRpb25zXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2V2ZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vY29tbWVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2V2ZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbGFiZWxzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3RpbWVsaW5lXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbGFiZWxzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lcy97bWlsZXN0b25lX251bWJlcn0vbGFiZWxzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L25vdGlmaWNhdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXMvYnVpbGRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Byb2plY3RzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21tZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2NvbW1pdHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9maWxlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3JlcXVlc3RlZF9yZXZpZXdlcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfS9jb21tZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vYXNzZXRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2xvY2F0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGFyZ2F6ZXJzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N1YnNjcmliZXJzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhZ3NcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdGVhbXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdG9waWNzXCIsXG4gICAgXCJHRVQgL3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vc2VjcmV0c1wiLFxuICAgIFwiR0VUIC9zZWFyY2gvY29kZVwiLFxuICAgIFwiR0VUIC9zZWFyY2gvY29tbWl0c1wiLFxuICAgIFwiR0VUIC9zZWFyY2gvaXNzdWVzXCIsXG4gICAgXCJHRVQgL3NlYXJjaC9sYWJlbHNcIixcbiAgICBcIkdFVCAvc2VhcmNoL3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC9zZWFyY2gvdG9waWNzXCIsXG4gICAgXCJHRVQgL3NlYXJjaC91c2Vyc1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vZGlzY3Vzc2lvbnNcIixcbiAgICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHNcIixcbiAgICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vcmVhY3Rpb25zXCIsXG4gICAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9pbnZpdGF0aW9uc1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vbWVtYmVyc1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vcHJvamVjdHNcIixcbiAgICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L3JlcG9zXCIsXG4gICAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS90ZWFtc1wiLFxuICAgIFwiR0VUIC91c2VyL2Jsb2Nrc1wiLFxuICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXNcIixcbiAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHNcIixcbiAgICBcIkdFVCAvdXNlci9lbWFpbHNcIixcbiAgICBcIkdFVCAvdXNlci9mb2xsb3dlcnNcIixcbiAgICBcIkdFVCAvdXNlci9mb2xsb3dpbmdcIixcbiAgICBcIkdFVCAvdXNlci9ncGdfa2V5c1wiLFxuICAgIFwiR0VUIC91c2VyL2luc3RhbGxhdGlvbnNcIixcbiAgICBcIkdFVCAvdXNlci9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC91c2VyL2lzc3Vlc1wiLFxuICAgIFwiR0VUIC91c2VyL2tleXNcIixcbiAgICBcIkdFVCAvdXNlci9tYXJrZXRwbGFjZV9wdXJjaGFzZXNcIixcbiAgICBcIkdFVCAvdXNlci9tYXJrZXRwbGFjZV9wdXJjaGFzZXMvc3R1YmJlZFwiLFxuICAgIFwiR0VUIC91c2VyL21lbWJlcnNoaXBzL29yZ3NcIixcbiAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zXCIsXG4gICAgXCJHRVQgL3VzZXIvbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgICBcIkdFVCAvdXNlci9vcmdzXCIsXG4gICAgXCJHRVQgL3VzZXIvcGFja2FnZXNcIixcbiAgICBcIkdFVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgIFwiR0VUIC91c2VyL3B1YmxpY19lbWFpbHNcIixcbiAgICBcIkdFVCAvdXNlci9yZXBvc1wiLFxuICAgIFwiR0VUIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnNcIixcbiAgICBcIkdFVCAvdXNlci9zdGFycmVkXCIsXG4gICAgXCJHRVQgL3VzZXIvc3Vic2NyaXB0aW9uc1wiLFxuICAgIFwiR0VUIC91c2VyL3RlYW1zXCIsXG4gICAgXCJHRVQgL3VzZXJzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZXZlbnRzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZXZlbnRzL29yZ3Mve29yZ31cIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHMvcHVibGljXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93ZXJzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93aW5nXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZ2lzdHNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ncGdfa2V5c1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2tleXNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9vcmdzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wcm9qZWN0c1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3JlY2VpdmVkX2V2ZW50c1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3JlY2VpdmVkX2V2ZW50cy9wdWJsaWNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZXBvc1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3N0YXJyZWRcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zdWJzY3JpcHRpb25zXCIsXG5dO1xuXG5mdW5jdGlvbiBpc1BhZ2luYXRpbmdFbmRwb2ludChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGFnaW5hdGluZ0VuZHBvaW50cy5pbmNsdWRlcyhhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gb2N0b2tpdCBPY3Rva2l0IGluc3RhbmNlXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHBhc3NlZCB0byBPY3Rva2l0IGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHBhZ2luYXRlUmVzdChvY3Rva2l0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFnaW5hdGU6IE9iamVjdC5hc3NpZ24ocGFnaW5hdGUuYmluZChudWxsLCBvY3Rva2l0KSwge1xuICAgICAgICAgICAgaXRlcmF0b3I6IGl0ZXJhdG9yLmJpbmQobnVsbCwgb2N0b2tpdCksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG5wYWdpbmF0ZVJlc3QuVkVSU0lPTiA9IFZFUlNJT047XG5cbmV4cG9ydCB7IGNvbXBvc2VQYWdpbmF0ZVJlc3QsIGlzUGFnaW5hdGluZ0VuZHBvaW50LCBwYWdpbmF0ZVJlc3QsIHBhZ2luYXRpbmdFbmRwb2ludHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiY29uc3QgRW5kcG9pbnRzID0ge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgICAgYWRkQ3VzdG9tTGFiZWxzVG9TZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBhZGRDdXN0b21MYWJlbHNUb1NlbGZIb3N0ZWRSdW5uZXJGb3JSZXBvOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgYWRkU2VsZWN0ZWRSZXBvVG9PcmdTZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgYXBwcm92ZVdvcmtmbG93UnVuOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hcHByb3ZlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNhbmNlbFdvcmtmbG93UnVuOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9jYW5jZWxcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVFbnZpcm9ubWVudFNlY3JldDogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH0vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVPcmdTZWNyZXQ6IFtcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVSZXBvU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlUmVnaXN0cmF0aW9uVG9rZW5Gb3JPcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMvcmVnaXN0cmF0aW9uLXRva2VuXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZVJlZ2lzdHJhdGlvblRva2VuRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMvcmVnaXN0cmF0aW9uLXRva2VuXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZVJlbW92ZVRva2VuRm9yT3JnOiBbXCJQT1NUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy9yZW1vdmUtdG9rZW5cIl0sXG4gICAgICAgIGNyZWF0ZVJlbW92ZVRva2VuRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMvcmVtb3ZlLXRva2VuXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZVdvcmtmbG93RGlzcGF0Y2g6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9kaXNwYXRjaGVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUFjdGlvbnNDYWNoZUJ5SWQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlcy97Y2FjaGVfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUFjdGlvbnNDYWNoZUJ5S2V5OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9jYWNoZXN7P2tleSxyZWZ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUFydGlmYWN0OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9hcnRpZmFjdHMve2FydGlmYWN0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVFbnZpcm9ubWVudFNlY3JldDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH0vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlT3JnU2VjcmV0OiBbXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgICAgIGRlbGV0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVTZWxmSG9zdGVkUnVubmVyRnJvbU9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVNlbGZIb3N0ZWRSdW5uZXJGcm9tUmVwbzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVXb3JrZmxvd1J1bjogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZVdvcmtmbG93UnVuTG9nczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9sb2dzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRpc2FibGVTZWxlY3RlZFJlcG9zaXRvcnlHaXRodWJBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGlzYWJsZVdvcmtmbG93OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9kaXNhYmxlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRvd25sb2FkQXJ0aWZhY3Q6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2FydGlmYWN0cy97YXJ0aWZhY3RfaWR9L3thcmNoaXZlX2Zvcm1hdH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZG93bmxvYWRKb2JMb2dzRm9yV29ya2Zsb3dSdW46IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2pvYnMve2pvYl9pZH0vbG9nc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkb3dubG9hZFdvcmtmbG93UnVuQXR0ZW1wdExvZ3M6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXR0ZW1wdHMve2F0dGVtcHRfbnVtYmVyfS9sb2dzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRvd25sb2FkV29ya2Zsb3dSdW5Mb2dzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2xvZ3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgZW5hYmxlU2VsZWN0ZWRSZXBvc2l0b3J5R2l0aHViQWN0aW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGVuYWJsZVdvcmtmbG93OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9lbmFibGVcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWN0aW9uc0NhY2hlTGlzdDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlc1wiXSxcbiAgICAgICAgZ2V0QWN0aW9uc0NhY2hlVXNhZ2U6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9jYWNoZS91c2FnZVwiXSxcbiAgICAgICAgZ2V0QWN0aW9uc0NhY2hlVXNhZ2VCeVJlcG9Gb3JPcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvY2FjaGUvdXNhZ2UtYnktcmVwb3NpdG9yeVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBY3Rpb25zQ2FjaGVVc2FnZUZvckVudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9jYWNoZS91c2FnZVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBY3Rpb25zQ2FjaGVVc2FnZUZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvY2FjaGUvdXNhZ2VcIl0sXG4gICAgICAgIGdldEFsbG93ZWRBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3NlbGVjdGVkLWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWxsb3dlZEFjdGlvbnNSZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy9zZWxlY3RlZC1hY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFydGlmYWN0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvYXJ0aWZhY3RzL3thcnRpZmFjdF9pZH1cIl0sXG4gICAgICAgIGdldEVudmlyb25tZW50UHVibGljS2V5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3NlY3JldHMvcHVibGljLWtleVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRFbnZpcm9ubWVudFNlY3JldDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH0vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0R2l0aHViQWN0aW9uc0RlZmF1bHRXb3JrZmxvd1Blcm1pc3Npb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL3dvcmtmbG93XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEdpdGh1YkFjdGlvbnNEZWZhdWx0V29ya2Zsb3dQZXJtaXNzaW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy93b3JrZmxvd1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBY3Rpb25zRGVmYXVsdFdvcmtmbG93UGVybWlzc2lvbnNSZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy93b3JrZmxvd1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0R2l0aHViQWN0aW9uc1Blcm1pc3Npb25zUmVwb3NpdG9yeTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0Sm9iRm9yV29ya2Zsb3dSdW46IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9qb2JzL3tqb2JfaWR9XCJdLFxuICAgICAgICBnZXRPcmdQdWJsaWNLZXk6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMvcHVibGljLWtleVwiXSxcbiAgICAgICAgZ2V0T3JnU2VjcmV0OiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgICAgIGdldFBlbmRpbmdEZXBsb3ltZW50c0ZvclJ1bjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9wZW5kaW5nX2RlcGxveW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFJlcG9QZXJtaXNzaW9uczogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJhY3Rpb25zXCIsIFwiZ2V0R2l0aHViQWN0aW9uc1Blcm1pc3Npb25zUmVwb3NpdG9yeVwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBnZXRSZXBvUHVibGljS2V5OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvc2VjcmV0cy9wdWJsaWMta2V5XCJdLFxuICAgICAgICBnZXRSZXBvU2VjcmV0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJdLFxuICAgICAgICBnZXRSZXZpZXdzRm9yUnVuOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2FwcHJvdmFsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRTZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9XCJdLFxuICAgICAgICBnZXRTZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRXb3JrZmxvdzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9XCJdLFxuICAgICAgICBnZXRXb3JrZmxvd0FjY2Vzc1RvUmVwb3NpdG9yeTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnMvYWNjZXNzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFdvcmtmbG93UnVuOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfVwiXSxcbiAgICAgICAgZ2V0V29ya2Zsb3dSdW5BdHRlbXB0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2F0dGVtcHRzL3thdHRlbXB0X251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0V29ya2Zsb3dSdW5Vc2FnZTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS90aW1pbmdcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0V29ya2Zsb3dVc2FnZTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzL3t3b3JrZmxvd19pZH0vdGltaW5nXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RBcnRpZmFjdHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvYXJ0aWZhY3RzXCJdLFxuICAgICAgICBsaXN0RW52aXJvbm1lbnRTZWNyZXRzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3NlY3JldHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEpvYnNGb3JXb3JrZmxvd1J1bjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9qb2JzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RKb2JzRm9yV29ya2Zsb3dSdW5BdHRlbXB0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2F0dGVtcHRzL3thdHRlbXB0X251bWJlcn0vam9ic1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0TGFiZWxzRm9yU2VsZkhvc3RlZFJ1bm5lckZvck9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0TGFiZWxzRm9yU2VsZkhvc3RlZFJ1bm5lckZvclJlcG86IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RPcmdTZWNyZXRzOiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzXCJdLFxuICAgICAgICBsaXN0UmVwb1NlY3JldHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9zZWNyZXRzXCJdLFxuICAgICAgICBsaXN0UmVwb1dvcmtmbG93czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93c1wiXSxcbiAgICAgICAgbGlzdFJ1bm5lckFwcGxpY2F0aW9uc0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy9kb3dubG9hZHNcIl0sXG4gICAgICAgIGxpc3RSdW5uZXJBcHBsaWNhdGlvbnNGb3JSZXBvOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL2Rvd25sb2Fkc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0U2VsZWN0ZWRSZXBvc0Zvck9yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RTZWxlY3RlZFJlcG9zaXRvcmllc0VuYWJsZWRHaXRodWJBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3JlcG9zaXRvcmllc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0U2VsZkhvc3RlZFJ1bm5lcnNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnNcIl0sXG4gICAgICAgIGxpc3RTZWxmSG9zdGVkUnVubmVyc0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzXCJdLFxuICAgICAgICBsaXN0V29ya2Zsb3dSdW5BcnRpZmFjdHM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXJ0aWZhY3RzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RXb3JrZmxvd1J1bnM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9L3J1bnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFdvcmtmbG93UnVuc0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zXCJdLFxuICAgICAgICByZVJ1bkpvYkZvcldvcmtmbG93UnVuOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvam9icy97am9iX2lkfS9yZXJ1blwiLFxuICAgICAgICBdLFxuICAgICAgICByZVJ1bldvcmtmbG93OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vcmVydW5cIl0sXG4gICAgICAgIHJlUnVuV29ya2Zsb3dGYWlsZWRKb2JzOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9yZXJ1bi1mYWlsZWQtam9ic1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVBbGxDdXN0b21MYWJlbHNGcm9tU2VsZkhvc3RlZFJ1bm5lckZvck9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVBbGxDdXN0b21MYWJlbHNGcm9tU2VsZkhvc3RlZFJ1bm5lckZvclJlcG86IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUN1c3RvbUxhYmVsRnJvbVNlbGZIb3N0ZWRSdW5uZXJGb3JPcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHMve25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUN1c3RvbUxhYmVsRnJvbVNlbGZIb3N0ZWRSdW5uZXJGb3JSZXBvOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVscy97bmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlU2VsZWN0ZWRSZXBvRnJvbU9yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICByZXZpZXdQZW5kaW5nRGVwbG95bWVudHNGb3JSdW46IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L3BlbmRpbmdfZGVwbG95bWVudHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0QWxsb3dlZEFjdGlvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvc2VsZWN0ZWQtYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRBbGxvd2VkQWN0aW9uc1JlcG9zaXRvcnk6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zL3NlbGVjdGVkLWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0Q3VzdG9tTGFiZWxzRm9yU2VsZkhvc3RlZFJ1bm5lckZvck9yZzogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRDdXN0b21MYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0R2l0aHViQWN0aW9uc0RlZmF1bHRXb3JrZmxvd1Blcm1pc3Npb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJQVVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL3dvcmtmbG93XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEdpdGh1YkFjdGlvbnNEZWZhdWx0V29ya2Zsb3dQZXJtaXNzaW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy93b3JrZmxvd1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRHaXRodWJBY3Rpb25zRGVmYXVsdFdvcmtmbG93UGVybWlzc2lvbnNSZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy93b3JrZmxvd1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0R2l0aHViQWN0aW9uc1Blcm1pc3Npb25zUmVwb3NpdG9yeTogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0U2VsZWN0ZWRSZXBvc0Zvck9yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldFNlbGVjdGVkUmVwb3NpdG9yaWVzRW5hYmxlZEdpdGh1YkFjdGlvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldFdvcmtmbG93QWNjZXNzVG9SZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy9hY2Nlc3NcIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGFjdGl2aXR5OiB7XG4gICAgICAgIGNoZWNrUmVwb0lzU3RhcnJlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9zdGFycmVkL3tvd25lcn0ve3JlcG99XCJdLFxuICAgICAgICBkZWxldGVSZXBvU3Vic2NyaXB0aW9uOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N1YnNjcmlwdGlvblwiXSxcbiAgICAgICAgZGVsZXRlVGhyZWFkU3Vic2NyaXB0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvbm90aWZpY2F0aW9ucy90aHJlYWRzL3t0aHJlYWRfaWR9L3N1YnNjcmlwdGlvblwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRGZWVkczogW1wiR0VUIC9mZWVkc1wiXSxcbiAgICAgICAgZ2V0UmVwb1N1YnNjcmlwdGlvbjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdWJzY3JpcHRpb25cIl0sXG4gICAgICAgIGdldFRocmVhZDogW1wiR0VUIC9ub3RpZmljYXRpb25zL3RocmVhZHMve3RocmVhZF9pZH1cIl0sXG4gICAgICAgIGdldFRocmVhZFN1YnNjcmlwdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvbm90aWZpY2F0aW9ucy90aHJlYWRzL3t0aHJlYWRfaWR9L3N1YnNjcmlwdGlvblwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0RXZlbnRzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHNcIl0sXG4gICAgICAgIGxpc3ROb3RpZmljYXRpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvbm90aWZpY2F0aW9uc1wiXSxcbiAgICAgICAgbGlzdE9yZ0V2ZW50c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHMvb3Jncy97b3JnfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UHVibGljRXZlbnRzOiBbXCJHRVQgL2V2ZW50c1wiXSxcbiAgICAgICAgbGlzdFB1YmxpY0V2ZW50c0ZvclJlcG9OZXR3b3JrOiBbXCJHRVQgL25ldHdvcmtzL3tvd25lcn0ve3JlcG99L2V2ZW50c1wiXSxcbiAgICAgICAgbGlzdFB1YmxpY0V2ZW50c0ZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHMvcHVibGljXCJdLFxuICAgICAgICBsaXN0UHVibGljT3JnRXZlbnRzOiBbXCJHRVQgL29yZ3Mve29yZ30vZXZlbnRzXCJdLFxuICAgICAgICBsaXN0UmVjZWl2ZWRFdmVudHNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcmVjZWl2ZWRfZXZlbnRzXCJdLFxuICAgICAgICBsaXN0UmVjZWl2ZWRQdWJsaWNFdmVudHNGb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZWNlaXZlZF9ldmVudHMvcHVibGljXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RSZXBvRXZlbnRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2V2ZW50c1wiXSxcbiAgICAgICAgbGlzdFJlcG9Ob3RpZmljYXRpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ub3RpZmljYXRpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RSZXBvc1N0YXJyZWRCeUF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvc3RhcnJlZFwiXSxcbiAgICAgICAgbGlzdFJlcG9zU3RhcnJlZEJ5VXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L3N0YXJyZWRcIl0sXG4gICAgICAgIGxpc3RSZXBvc1dhdGNoZWRCeVVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zdWJzY3JpcHRpb25zXCJdLFxuICAgICAgICBsaXN0U3RhcmdhemVyc0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3RhcmdhemVyc1wiXSxcbiAgICAgICAgbGlzdFdhdGNoZWRSZXBvc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvc3Vic2NyaXB0aW9uc1wiXSxcbiAgICAgICAgbGlzdFdhdGNoZXJzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdWJzY3JpYmVyc1wiXSxcbiAgICAgICAgbWFya05vdGlmaWNhdGlvbnNBc1JlYWQ6IFtcIlBVVCAvbm90aWZpY2F0aW9uc1wiXSxcbiAgICAgICAgbWFya1JlcG9Ob3RpZmljYXRpb25zQXNSZWFkOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L25vdGlmaWNhdGlvbnNcIl0sXG4gICAgICAgIG1hcmtUaHJlYWRBc1JlYWQ6IFtcIlBBVENIIC9ub3RpZmljYXRpb25zL3RocmVhZHMve3RocmVhZF9pZH1cIl0sXG4gICAgICAgIHNldFJlcG9TdWJzY3JpcHRpb246IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3Vic2NyaXB0aW9uXCJdLFxuICAgICAgICBzZXRUaHJlYWRTdWJzY3JpcHRpb246IFtcbiAgICAgICAgICAgIFwiUFVUIC9ub3RpZmljYXRpb25zL3RocmVhZHMve3RocmVhZF9pZH0vc3Vic2NyaXB0aW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXJSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBVVCAvdXNlci9zdGFycmVkL3tvd25lcn0ve3JlcG99XCJdLFxuICAgICAgICB1bnN0YXJSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9zdGFycmVkL3tvd25lcn0ve3JlcG99XCJdLFxuICAgIH0sXG4gICAgYXBwczoge1xuICAgICAgICBhZGRSZXBvVG9JbnN0YWxsYXRpb246IFtcbiAgICAgICAgICAgIFwiUFVUIC91c2VyL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcImFwcHNcIiwgXCJhZGRSZXBvVG9JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBhZGRSZXBvVG9JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQVVQgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNoZWNrVG9rZW46IFtcIlBPU1QgL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS90b2tlblwiXSxcbiAgICAgICAgY3JlYXRlRnJvbU1hbmlmZXN0OiBbXCJQT1NUIC9hcHAtbWFuaWZlc3RzL3tjb2RlfS9jb252ZXJzaW9uc1wiXSxcbiAgICAgICAgY3JlYXRlSW5zdGFsbGF0aW9uQWNjZXNzVG9rZW46IFtcbiAgICAgICAgICAgIFwiUE9TVCAvYXBwL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vYWNjZXNzX3Rva2Vuc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVBdXRob3JpemF0aW9uOiBbXCJERUxFVEUgL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS9ncmFudFwiXSxcbiAgICAgICAgZGVsZXRlSW5zdGFsbGF0aW9uOiBbXCJERUxFVEUgL2FwcC9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9XCJdLFxuICAgICAgICBkZWxldGVUb2tlbjogW1wiREVMRVRFIC9hcHBsaWNhdGlvbnMve2NsaWVudF9pZH0vdG9rZW5cIl0sXG4gICAgICAgIGdldEF1dGhlbnRpY2F0ZWQ6IFtcIkdFVCAvYXBwXCJdLFxuICAgICAgICBnZXRCeVNsdWc6IFtcIkdFVCAvYXBwcy97YXBwX3NsdWd9XCJdLFxuICAgICAgICBnZXRJbnN0YWxsYXRpb246IFtcIkdFVCAvYXBwL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH1cIl0sXG4gICAgICAgIGdldE9yZ0luc3RhbGxhdGlvbjogW1wiR0VUIC9vcmdzL3tvcmd9L2luc3RhbGxhdGlvblwiXSxcbiAgICAgICAgZ2V0UmVwb0luc3RhbGxhdGlvbjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnN0YWxsYXRpb25cIl0sXG4gICAgICAgIGdldFN1YnNjcmlwdGlvblBsYW5Gb3JBY2NvdW50OiBbXG4gICAgICAgICAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9hY2NvdW50cy97YWNjb3VudF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0U3Vic2NyaXB0aW9uUGxhbkZvckFjY291bnRTdHViYmVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9zdHViYmVkL2FjY291bnRzL3thY2NvdW50X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRVc2VySW5zdGFsbGF0aW9uOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vaW5zdGFsbGF0aW9uXCJdLFxuICAgICAgICBnZXRXZWJob29rQ29uZmlnRm9yQXBwOiBbXCJHRVQgL2FwcC9ob29rL2NvbmZpZ1wiXSxcbiAgICAgICAgZ2V0V2ViaG9va0RlbGl2ZXJ5OiBbXCJHRVQgL2FwcC9ob29rL2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfVwiXSxcbiAgICAgICAgbGlzdEFjY291bnRzRm9yUGxhbjogW1wiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3BsYW5zL3twbGFuX2lkfS9hY2NvdW50c1wiXSxcbiAgICAgICAgbGlzdEFjY291bnRzRm9yUGxhblN0dWJiZWQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3N0dWJiZWQvcGxhbnMve3BsYW5faWR9L2FjY291bnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RJbnN0YWxsYXRpb25SZXBvc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0SW5zdGFsbGF0aW9uczogW1wiR0VUIC9hcHAvaW5zdGFsbGF0aW9uc1wiXSxcbiAgICAgICAgbGlzdEluc3RhbGxhdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2luc3RhbGxhdGlvbnNcIl0sXG4gICAgICAgIGxpc3RQbGFuczogW1wiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3BsYW5zXCJdLFxuICAgICAgICBsaXN0UGxhbnNTdHViYmVkOiBbXCJHRVQgL21hcmtldHBsYWNlX2xpc3Rpbmcvc3R1YmJlZC9wbGFuc1wiXSxcbiAgICAgICAgbGlzdFJlcG9zQWNjZXNzaWJsZVRvSW5zdGFsbGF0aW9uOiBbXCJHRVQgL2luc3RhbGxhdGlvbi9yZXBvc2l0b3JpZXNcIl0sXG4gICAgICAgIGxpc3RTdWJzY3JpcHRpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9tYXJrZXRwbGFjZV9wdXJjaGFzZXNcIl0sXG4gICAgICAgIGxpc3RTdWJzY3JpcHRpb25zRm9yQXV0aGVudGljYXRlZFVzZXJTdHViYmVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9tYXJrZXRwbGFjZV9wdXJjaGFzZXMvc3R1YmJlZFwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0V2ViaG9va0RlbGl2ZXJpZXM6IFtcIkdFVCAvYXBwL2hvb2svZGVsaXZlcmllc1wiXSxcbiAgICAgICAgcmVkZWxpdmVyV2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICAgICAgICBcIlBPU1QgL2FwcC9ob29rL2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfS9hdHRlbXB0c1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVSZXBvRnJvbUluc3RhbGxhdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wiYXBwc1wiLCBcInJlbW92ZVJlcG9Gcm9tSW5zdGFsbGF0aW9uRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlUmVwb0Zyb21JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlc2V0VG9rZW46IFtcIlBBVENIIC9hcHBsaWNhdGlvbnMve2NsaWVudF9pZH0vdG9rZW5cIl0sXG4gICAgICAgIHJldm9rZUluc3RhbGxhdGlvbkFjY2Vzc1Rva2VuOiBbXCJERUxFVEUgL2luc3RhbGxhdGlvbi90b2tlblwiXSxcbiAgICAgICAgc2NvcGVUb2tlbjogW1wiUE9TVCAvYXBwbGljYXRpb25zL3tjbGllbnRfaWR9L3Rva2VuL3Njb3BlZFwiXSxcbiAgICAgICAgc3VzcGVuZEluc3RhbGxhdGlvbjogW1wiUFVUIC9hcHAvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9zdXNwZW5kZWRcIl0sXG4gICAgICAgIHVuc3VzcGVuZEluc3RhbGxhdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL2FwcC9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3N1c3BlbmRlZFwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVXZWJob29rQ29uZmlnRm9yQXBwOiBbXCJQQVRDSCAvYXBwL2hvb2svY29uZmlnXCJdLFxuICAgIH0sXG4gICAgYmlsbGluZzoge1xuICAgICAgICBnZXRHaXRodWJBY3Rpb25zQmlsbGluZ09yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3NldHRpbmdzL2JpbGxpbmcvYWN0aW9uc1wiXSxcbiAgICAgICAgZ2V0R2l0aHViQWN0aW9uc0JpbGxpbmdVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zZXR0aW5ncy9iaWxsaW5nL2FjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0R2l0aHViQWR2YW5jZWRTZWN1cml0eUJpbGxpbmdHaGU6IFtcbiAgICAgICAgICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vc2V0dGluZ3MvYmlsbGluZy9hZHZhbmNlZC1zZWN1cml0eVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBZHZhbmNlZFNlY3VyaXR5QmlsbGluZ09yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vc2V0dGluZ3MvYmlsbGluZy9hZHZhbmNlZC1zZWN1cml0eVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJQYWNrYWdlc0JpbGxpbmdPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9iaWxsaW5nL3BhY2thZ2VzXCJdLFxuICAgICAgICBnZXRHaXRodWJQYWNrYWdlc0JpbGxpbmdVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zZXR0aW5ncy9iaWxsaW5nL3BhY2thZ2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFNoYXJlZFN0b3JhZ2VCaWxsaW5nT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9iaWxsaW5nL3NoYXJlZC1zdG9yYWdlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFNoYXJlZFN0b3JhZ2VCaWxsaW5nVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc2V0dGluZ3MvYmlsbGluZy9zaGFyZWQtc3RvcmFnZVwiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgY2hlY2tzOiB7XG4gICAgICAgIGNyZWF0ZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stcnVuc1wiXSxcbiAgICAgICAgY3JlYXRlU3VpdGU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlc1wiXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH1cIl0sXG4gICAgICAgIGdldFN1aXRlOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlcy97Y2hlY2tfc3VpdGVfaWR9XCJdLFxuICAgICAgICBsaXN0QW5ub3RhdGlvbnM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1ydW5zL3tjaGVja19ydW5faWR9L2Fubm90YXRpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JSZWY6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9jaGVjay1ydW5zXCJdLFxuICAgICAgICBsaXN0Rm9yU3VpdGU6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1zdWl0ZXMve2NoZWNrX3N1aXRlX2lkfS9jaGVjay1ydW5zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RTdWl0ZXNGb3JSZWY6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9jaGVjay1zdWl0ZXNcIl0sXG4gICAgICAgIHJlcmVxdWVzdFJ1bjogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1ydW5zL3tjaGVja19ydW5faWR9L3JlcmVxdWVzdFwiLFxuICAgICAgICBdLFxuICAgICAgICByZXJlcXVlc3RTdWl0ZTogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1zdWl0ZXMve2NoZWNrX3N1aXRlX2lkfS9yZXJlcXVlc3RcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0U3VpdGVzUHJlZmVyZW5jZXM6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlcy9wcmVmZXJlbmNlc1wiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1ydW5zL3tjaGVja19ydW5faWR9XCJdLFxuICAgIH0sXG4gICAgY29kZVNjYW5uaW5nOiB7XG4gICAgICAgIGRlbGV0ZUFuYWx5c2lzOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbmFseXNlcy97YW5hbHlzaXNfaWR9ez9jb25maXJtX2RlbGV0ZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWxlcnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWRQYXJhbWV0ZXJzOiB7IGFsZXJ0X2lkOiBcImFsZXJ0X251bWJlclwiIH0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QW5hbHlzaXM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FuYWx5c2VzL3thbmFseXNpc19pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0U2FyaWY6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9zYXJpZnMve3NhcmlmX2lkfVwiXSxcbiAgICAgICAgbGlzdEFsZXJ0SW5zdGFuY2VzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHMve2FsZXJ0X251bWJlcn0vaW5zdGFuY2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RBbGVydHNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9jb2RlLXNjYW5uaW5nL2FsZXJ0c1wiXSxcbiAgICAgICAgbGlzdEFsZXJ0c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHNcIl0sXG4gICAgICAgIGxpc3RBbGVydHNJbnN0YW5jZXM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfS9pbnN0YW5jZXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJjb2RlU2Nhbm5pbmdcIiwgXCJsaXN0QWxlcnRJbnN0YW5jZXNcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJlY2VudEFuYWx5c2VzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYW5hbHlzZXNcIl0sXG4gICAgICAgIHVwZGF0ZUFsZXJ0OiBbXG4gICAgICAgICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGxvYWRTYXJpZjogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9zYXJpZnNcIl0sXG4gICAgfSxcbiAgICBjb2Rlc09mQ29uZHVjdDoge1xuICAgICAgICBnZXRBbGxDb2Rlc09mQ29uZHVjdDogW1wiR0VUIC9jb2Rlc19vZl9jb25kdWN0XCJdLFxuICAgICAgICBnZXRDb25kdWN0Q29kZTogW1wiR0VUIC9jb2Rlc19vZl9jb25kdWN0L3trZXl9XCJdLFxuICAgIH0sXG4gICAgY29kZXNwYWNlczoge1xuICAgICAgICBhZGRSZXBvc2l0b3J5Rm9yU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUFVUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY29kZXNwYWNlTWFjaGluZXNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9L21hY2hpbmVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL2NvZGVzcGFjZXNcIl0sXG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlUmVwb1NlY3JldDogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUFVUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZVdpdGhQckZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29kZXNwYWNlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVXaXRoUmVwb0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX1cIl0sXG4gICAgICAgIGRlbGV0ZUZyb21Pcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfS9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUmVwb1NlY3JldDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQT1NUIC91c2VyL2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfS9leHBvcnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEV4cG9ydERldGFpbHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9L2V4cG9ydHMve2V4cG9ydF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX1cIl0sXG4gICAgICAgIGdldFB1YmxpY0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMvcHVibGljLWtleVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRSZXBvUHVibGljS2V5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzL3B1YmxpYy1rZXlcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UmVwb1NlY3JldDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0RGV2Y29udGFpbmVyc0luUmVwb3NpdG9yeUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9kZXZjb250YWluZXJzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2NvZGVzcGFjZXNcIl0sXG4gICAgICAgIGxpc3RJbk9yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vY29kZXNwYWNlc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWRQYXJhbWV0ZXJzOiB7IG9yZ19pZDogXCJvcmdcIiB9IH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RJblJlcG9zaXRvcnlGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJlcG9TZWNyZXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvc2VjcmV0c1wiXSxcbiAgICAgICAgbGlzdFJlcG9zaXRvcmllc0ZvclNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFNlY3JldHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0c1wiXSxcbiAgICAgICAgcmVtb3ZlUmVwb3NpdG9yeUZvclNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlcG9NYWNoaW5lc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9tYWNoaW5lc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRSZXBvc2l0b3JpZXNGb3JTZWNyZXRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQVVQgL3VzZXIvY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXJ0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9L3N0YXJ0XCJdLFxuICAgICAgICBzdG9wRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9L3N0b3BcIl0sXG4gICAgICAgIHN0b3BJbk9yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfS9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vc3RvcFwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUEFUQ0ggL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9XCJdLFxuICAgIH0sXG4gICAgZGVwZW5kYWJvdDoge1xuICAgICAgICBhZGRTZWxlY3RlZFJlcG9Ub09yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZU9yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVSZXBvU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlT3JnU2VjcmV0OiBbXCJERUxFVEUgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgICAgIGRlbGV0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRPcmdQdWJsaWNLZXk6IFtcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMvcHVibGljLWtleVwiXSxcbiAgICAgICAgZ2V0T3JnU2VjcmV0OiBbXCJHRVQgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgICAgIGdldFJlcG9QdWJsaWNLZXk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHMvcHVibGljLWtleVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRSZXBvU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdE9yZ1NlY3JldHM6IFtcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHNcIl0sXG4gICAgICAgIGxpc3RSZXBvU2VjcmV0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHNcIl0sXG4gICAgICAgIGxpc3RTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlU2VsZWN0ZWRSZXBvRnJvbU9yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGRlcGVuZGVuY3lHcmFwaDoge1xuICAgICAgICBjcmVhdGVSZXBvc2l0b3J5U25hcHNob3Q6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kZW5jeS1ncmFwaC9zbmFwc2hvdHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGlmZlJhbmdlOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kZW5jeS1ncmFwaC9jb21wYXJlL3tiYXNlaGVhZH1cIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGVtb2ppczogeyBnZXQ6IFtcIkdFVCAvZW1vamlzXCJdIH0sXG4gICAgZW50ZXJwcmlzZUFkbWluOiB7XG4gICAgICAgIGFkZEN1c3RvbUxhYmVsc1RvU2VsZkhvc3RlZFJ1bm5lckZvckVudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGlzYWJsZVNlbGVjdGVkT3JnYW5pemF0aW9uR2l0aHViQWN0aW9uc0VudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9wZXJtaXNzaW9ucy9vcmdhbml6YXRpb25zL3tvcmdfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGVuYWJsZVNlbGVjdGVkT3JnYW5pemF0aW9uR2l0aHViQWN0aW9uc0VudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiUFVUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9wZXJtaXNzaW9ucy9vcmdhbml6YXRpb25zL3tvcmdfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbG93ZWRBY3Rpb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL3NlbGVjdGVkLWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0R2l0aHViQWN0aW9uc1Blcm1pc3Npb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFNlcnZlclN0YXRpc3RpY3M6IFtcbiAgICAgICAgICAgIFwiR0VUIC9lbnRlcnByaXNlLWluc3RhbGxhdGlvbi97ZW50ZXJwcmlzZV9vcl9vcmd9L3NlcnZlci1zdGF0aXN0aWNzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RMYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RTZWxlY3RlZE9yZ2FuaXphdGlvbnNFbmFibGVkR2l0aHViQWN0aW9uc0VudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9wZXJtaXNzaW9ucy9vcmdhbml6YXRpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUFsbEN1c3RvbUxhYmVsc0Zyb21TZWxmSG9zdGVkUnVubmVyRm9yRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJERUxFVEUgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUN1c3RvbUxhYmVsRnJvbVNlbGZIb3N0ZWRSdW5uZXJGb3JFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHMve25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEFsbG93ZWRBY3Rpb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJQVVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL3NlbGVjdGVkLWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0Q3VzdG9tTGFiZWxzRm9yU2VsZkhvc3RlZFJ1bm5lckZvckVudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiUFVUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIlBVVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0U2VsZWN0ZWRPcmdhbml6YXRpb25zRW5hYmxlZEdpdGh1YkFjdGlvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIlBVVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnMvb3JnYW5pemF0aW9uc1wiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgZ2lzdHM6IHtcbiAgICAgICAgY2hlY2tJc1N0YXJyZWQ6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L3N0YXJcIl0sXG4gICAgICAgIGNyZWF0ZTogW1wiUE9TVCAvZ2lzdHNcIl0sXG4gICAgICAgIGNyZWF0ZUNvbW1lbnQ6IFtcIlBPU1QgL2dpc3RzL3tnaXN0X2lkfS9jb21tZW50c1wiXSxcbiAgICAgICAgZGVsZXRlOiBbXCJERUxFVEUgL2dpc3RzL3tnaXN0X2lkfVwiXSxcbiAgICAgICAgZGVsZXRlQ29tbWVudDogW1wiREVMRVRFIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgICAgICBmb3JrOiBbXCJQT1NUIC9naXN0cy97Z2lzdF9pZH0vZm9ya3NcIl0sXG4gICAgICAgIGdldDogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH1cIl0sXG4gICAgICAgIGdldENvbW1lbnQ6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICAgICAgZ2V0UmV2aXNpb246IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L3tzaGF9XCJdLFxuICAgICAgICBsaXN0OiBbXCJHRVQgL2dpc3RzXCJdLFxuICAgICAgICBsaXN0Q29tbWVudHM6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzXCJdLFxuICAgICAgICBsaXN0Q29tbWl0czogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH0vY29tbWl0c1wiXSxcbiAgICAgICAgbGlzdEZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9naXN0c1wiXSxcbiAgICAgICAgbGlzdEZvcmtzOiBbXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9mb3Jrc1wiXSxcbiAgICAgICAgbGlzdFB1YmxpYzogW1wiR0VUIC9naXN0cy9wdWJsaWNcIl0sXG4gICAgICAgIGxpc3RTdGFycmVkOiBbXCJHRVQgL2dpc3RzL3N0YXJyZWRcIl0sXG4gICAgICAgIHN0YXI6IFtcIlBVVCAvZ2lzdHMve2dpc3RfaWR9L3N0YXJcIl0sXG4gICAgICAgIHVuc3RhcjogW1wiREVMRVRFIC9naXN0cy97Z2lzdF9pZH0vc3RhclwiXSxcbiAgICAgICAgdXBkYXRlOiBbXCJQQVRDSCAvZ2lzdHMve2dpc3RfaWR9XCJdLFxuICAgICAgICB1cGRhdGVDb21tZW50OiBbXCJQQVRDSCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICB9LFxuICAgIGdpdDoge1xuICAgICAgICBjcmVhdGVCbG9iOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvYmxvYnNcIl0sXG4gICAgICAgIGNyZWF0ZUNvbW1pdDogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2NvbW1pdHNcIl0sXG4gICAgICAgIGNyZWF0ZVJlZjogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZnNcIl0sXG4gICAgICAgIGNyZWF0ZVRhZzogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RhZ3NcIl0sXG4gICAgICAgIGNyZWF0ZVRyZWU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90cmVlc1wiXSxcbiAgICAgICAgZGVsZXRlUmVmOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWZzL3tyZWZ9XCJdLFxuICAgICAgICBnZXRCbG9iOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9icy97ZmlsZV9zaGF9XCJdLFxuICAgICAgICBnZXRDb21taXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2NvbW1pdHMve2NvbW1pdF9zaGF9XCJdLFxuICAgICAgICBnZXRSZWY6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZi97cmVmfVwiXSxcbiAgICAgICAgZ2V0VGFnOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90YWdzL3t0YWdfc2hhfVwiXSxcbiAgICAgICAgZ2V0VHJlZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvdHJlZXMve3RyZWVfc2hhfVwiXSxcbiAgICAgICAgbGlzdE1hdGNoaW5nUmVmczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvbWF0Y2hpbmctcmVmcy97cmVmfVwiXSxcbiAgICAgICAgdXBkYXRlUmVmOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZnMve3JlZn1cIl0sXG4gICAgfSxcbiAgICBnaXRpZ25vcmU6IHtcbiAgICAgICAgZ2V0QWxsVGVtcGxhdGVzOiBbXCJHRVQgL2dpdGlnbm9yZS90ZW1wbGF0ZXNcIl0sXG4gICAgICAgIGdldFRlbXBsYXRlOiBbXCJHRVQgL2dpdGlnbm9yZS90ZW1wbGF0ZXMve25hbWV9XCJdLFxuICAgIH0sXG4gICAgaW50ZXJhY3Rpb25zOiB7XG4gICAgICAgIGdldFJlc3RyaWN0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgICAgICBnZXRSZXN0cmljdGlvbnNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgICAgIGdldFJlc3RyaWN0aW9uc0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgICAgICBnZXRSZXN0cmljdGlvbnNGb3JZb3VyUHVibGljUmVwb3M6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2ludGVyYWN0aW9uLWxpbWl0c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcImludGVyYWN0aW9uc1wiLCBcImdldFJlc3RyaWN0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVJlc3RyaWN0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJERUxFVEUgL3VzZXIvaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgICAgICByZW1vdmVSZXN0cmljdGlvbnNGb3JPcmc6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgICAgIHJlbW92ZVJlc3RyaWN0aW9uc0ZvclJlcG86IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnRlcmFjdGlvbi1saW1pdHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlUmVzdHJpY3Rpb25zRm9yWW91clB1YmxpY1JlcG9zOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJpbnRlcmFjdGlvbnNcIiwgXCJyZW1vdmVSZXN0cmljdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBzZXRSZXN0cmljdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUFVUIC91c2VyL2ludGVyYWN0aW9uLWxpbWl0c1wiXSxcbiAgICAgICAgc2V0UmVzdHJpY3Rpb25zRm9yT3JnOiBbXCJQVVQgL29yZ3Mve29yZ30vaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgICAgICBzZXRSZXN0cmljdGlvbnNGb3JSZXBvOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ludGVyYWN0aW9uLWxpbWl0c1wiXSxcbiAgICAgICAgc2V0UmVzdHJpY3Rpb25zRm9yWW91clB1YmxpY1JlcG9zOiBbXG4gICAgICAgICAgICBcIlBVVCAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJpbnRlcmFjdGlvbnNcIiwgXCJzZXRSZXN0cmljdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgaXNzdWVzOiB7XG4gICAgICAgIGFkZEFzc2lnbmVlczogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vYXNzaWduZWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGFkZExhYmVsczogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVsc1wiXSxcbiAgICAgICAgY2hlY2tVc2VyQ2FuQmVBc3NpZ25lZDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hc3NpZ25lZXMve2Fzc2lnbmVlfVwiXSxcbiAgICAgICAgY3JlYXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXNcIl0sXG4gICAgICAgIGNyZWF0ZUNvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUxhYmVsOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHNcIl0sXG4gICAgICAgIGNyZWF0ZU1pbGVzdG9uZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lc1wiXSxcbiAgICAgICAgZGVsZXRlQ29tbWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50cy97Y29tbWVudF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlTGFiZWw6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vbGFiZWxzL3tuYW1lfVwiXSxcbiAgICAgICAgZGVsZXRlTWlsZXN0b25lOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lcy97bWlsZXN0b25lX251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfVwiXSxcbiAgICAgICAgZ2V0Q29tbWVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgICAgICBnZXRFdmVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvZXZlbnRzL3tldmVudF9pZH1cIl0sXG4gICAgICAgIGdldExhYmVsOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2xhYmVscy97bmFtZX1cIl0sXG4gICAgICAgIGdldE1pbGVzdG9uZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzL3ttaWxlc3RvbmVfbnVtYmVyfVwiXSxcbiAgICAgICAgbGlzdDogW1wiR0VUIC9pc3N1ZXNcIl0sXG4gICAgICAgIGxpc3RBc3NpZ25lZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYXNzaWduZWVzXCJdLFxuICAgICAgICBsaXN0Q29tbWVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2NvbW1lbnRzXCJdLFxuICAgICAgICBsaXN0Q29tbWVudHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50c1wiXSxcbiAgICAgICAgbGlzdEV2ZW50czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vZXZlbnRzXCJdLFxuICAgICAgICBsaXN0RXZlbnRzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvZXZlbnRzXCJdLFxuICAgICAgICBsaXN0RXZlbnRzRm9yVGltZWxpbmU6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vdGltZWxpbmVcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvaXNzdWVzXCJdLFxuICAgICAgICBsaXN0Rm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vaXNzdWVzXCJdLFxuICAgICAgICBsaXN0Rm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXNcIl0sXG4gICAgICAgIGxpc3RMYWJlbHNGb3JNaWxlc3RvbmU6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzL3ttaWxlc3RvbmVfbnVtYmVyfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdExhYmVsc0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbGFiZWxzXCJdLFxuICAgICAgICBsaXN0TGFiZWxzT25Jc3N1ZTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdE1pbGVzdG9uZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lc1wiXSxcbiAgICAgICAgbG9jazogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbG9ja1wiXSxcbiAgICAgICAgcmVtb3ZlQWxsTGFiZWxzOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVBc3NpZ25lZXM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vYXNzaWduZWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUxhYmVsOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVscy97bmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0TGFiZWxzOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sYWJlbHNcIl0sXG4gICAgICAgIHVubG9jazogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbG9ja1wiXSxcbiAgICAgICAgdXBkYXRlOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9XCJdLFxuICAgICAgICB1cGRhdGVDb21tZW50OiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICAgICAgdXBkYXRlTGFiZWw6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHMve25hbWV9XCJdLFxuICAgICAgICB1cGRhdGVNaWxlc3RvbmU6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXMve21pbGVzdG9uZV9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsaWNlbnNlczoge1xuICAgICAgICBnZXQ6IFtcIkdFVCAvbGljZW5zZXMve2xpY2Vuc2V9XCJdLFxuICAgICAgICBnZXRBbGxDb21tb25seVVzZWQ6IFtcIkdFVCAvbGljZW5zZXNcIl0sXG4gICAgICAgIGdldEZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbGljZW5zZVwiXSxcbiAgICB9LFxuICAgIG1hcmtkb3duOiB7XG4gICAgICAgIHJlbmRlcjogW1wiUE9TVCAvbWFya2Rvd25cIl0sXG4gICAgICAgIHJlbmRlclJhdzogW1xuICAgICAgICAgICAgXCJQT1NUIC9tYXJrZG93bi9yYXdcIixcbiAgICAgICAgICAgIHsgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIiB9IH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGdldDogW1wiR0VUIC9tZXRhXCJdLFxuICAgICAgICBnZXRPY3RvY2F0OiBbXCJHRVQgL29jdG9jYXRcIl0sXG4gICAgICAgIGdldFplbjogW1wiR0VUIC96ZW5cIl0sXG4gICAgICAgIHJvb3Q6IFtcIkdFVCAvXCJdLFxuICAgIH0sXG4gICAgbWlncmF0aW9uczoge1xuICAgICAgICBjYW5jZWxJbXBvcnQ6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaW1wb3J0XCJdLFxuICAgICAgICBkZWxldGVBcmNoaXZlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVBcmNoaXZlRm9yT3JnOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L2FyY2hpdmVcIixcbiAgICAgICAgXSxcbiAgICAgICAgZG93bmxvYWRBcmNoaXZlRm9yT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L2FyY2hpdmVcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QXJjaGl2ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L2FyY2hpdmVcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0Q29tbWl0QXV0aG9yczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbXBvcnQvYXV0aG9yc1wiXSxcbiAgICAgICAgZ2V0SW1wb3J0U3RhdHVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ltcG9ydFwiXSxcbiAgICAgICAgZ2V0TGFyZ2VGaWxlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbXBvcnQvbGFyZ2VfZmlsZXNcIl0sXG4gICAgICAgIGdldFN0YXR1c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfVwiXSxcbiAgICAgICAgZ2V0U3RhdHVzRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfVwiXSxcbiAgICAgICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvbWlncmF0aW9uc1wiXSxcbiAgICAgICAgbGlzdEZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnNcIl0sXG4gICAgICAgIGxpc3RSZXBvc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UmVwb3NGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiXSxcbiAgICAgICAgbGlzdFJlcG9zRm9yVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJtaWdyYXRpb25zXCIsIFwibGlzdFJlcG9zRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgbWFwQ29tbWl0QXV0aG9yOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaW1wb3J0L2F1dGhvcnMve2F1dGhvcl9pZH1cIl0sXG4gICAgICAgIHNldExmc1ByZWZlcmVuY2U6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbXBvcnQvbGZzXCJdLFxuICAgICAgICBzdGFydEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL21pZ3JhdGlvbnNcIl0sXG4gICAgICAgIHN0YXJ0Rm9yT3JnOiBbXCJQT1NUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnNcIl0sXG4gICAgICAgIHN0YXJ0SW1wb3J0OiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ltcG9ydFwiXSxcbiAgICAgICAgdW5sb2NrUmVwb0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zL3tyZXBvX25hbWV9L2xvY2tcIixcbiAgICAgICAgXSxcbiAgICAgICAgdW5sb2NrUmVwb0Zvck9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9yZXBvcy97cmVwb19uYW1lfS9sb2NrXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZUltcG9ydDogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2ltcG9ydFwiXSxcbiAgICB9LFxuICAgIG9yZ3M6IHtcbiAgICAgICAgYmxvY2tVc2VyOiBbXCJQVVQgL29yZ3Mve29yZ30vYmxvY2tzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGNhbmNlbEludml0YXRpb246IFtcIkRFTEVURSAvb3Jncy97b3JnfS9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH1cIl0sXG4gICAgICAgIGNoZWNrQmxvY2tlZFVzZXI6IFtcIkdFVCAvb3Jncy97b3JnfS9ibG9ja3Mve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY2hlY2tNZW1iZXJzaGlwRm9yVXNlcjogW1wiR0VUIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY2hlY2tQdWJsaWNNZW1iZXJzaGlwRm9yVXNlcjogW1wiR0VUIC9vcmdzL3tvcmd9L3B1YmxpY19tZW1iZXJzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGNvbnZlcnRNZW1iZXJUb091dHNpZGVDb2xsYWJvcmF0b3I6IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L291dHNpZGVfY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUludml0YXRpb246IFtcIlBPU1QgL29yZ3Mve29yZ30vaW52aXRhdGlvbnNcIl0sXG4gICAgICAgIGNyZWF0ZVdlYmhvb2s6IFtcIlBPU1QgL29yZ3Mve29yZ30vaG9va3NcIl0sXG4gICAgICAgIGRlbGV0ZVdlYmhvb2s6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgICAgIGdldDogW1wiR0VUIC9vcmdzL3tvcmd9XCJdLFxuICAgICAgICBnZXRNZW1iZXJzaGlwRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9tZW1iZXJzaGlwcy9vcmdzL3tvcmd9XCJdLFxuICAgICAgICBnZXRNZW1iZXJzaGlwRm9yVXNlcjogW1wiR0VUIC9vcmdzL3tvcmd9L21lbWJlcnNoaXBzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGdldFdlYmhvb2s6IFtcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgICAgIGdldFdlYmhvb2tDb25maWdGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vY29uZmlnXCJdLFxuICAgICAgICBnZXRXZWJob29rRGVsaXZlcnk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzL3tkZWxpdmVyeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdDogW1wiR0VUIC9vcmdhbml6YXRpb25zXCJdLFxuICAgICAgICBsaXN0QXBwSW5zdGFsbGF0aW9uczogW1wiR0VUIC9vcmdzL3tvcmd9L2luc3RhbGxhdGlvbnNcIl0sXG4gICAgICAgIGxpc3RCbG9ja2VkVXNlcnM6IFtcIkdFVCAvb3Jncy97b3JnfS9ibG9ja3NcIl0sXG4gICAgICAgIGxpc3RDdXN0b21Sb2xlczogW1wiR0VUIC9vcmdhbml6YXRpb25zL3tvcmdhbml6YXRpb25faWR9L2N1c3RvbV9yb2xlc1wiXSxcbiAgICAgICAgbGlzdEZhaWxlZEludml0YXRpb25zOiBbXCJHRVQgL29yZ3Mve29yZ30vZmFpbGVkX2ludml0YXRpb25zXCJdLFxuICAgICAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9vcmdzXCJdLFxuICAgICAgICBsaXN0Rm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L29yZ3NcIl0sXG4gICAgICAgIGxpc3RJbnZpdGF0aW9uVGVhbXM6IFtcIkdFVCAvb3Jncy97b3JnfS9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH0vdGVhbXNcIl0sXG4gICAgICAgIGxpc3RNZW1iZXJzOiBbXCJHRVQgL29yZ3Mve29yZ30vbWVtYmVyc1wiXSxcbiAgICAgICAgbGlzdE1lbWJlcnNoaXBzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9tZW1iZXJzaGlwcy9vcmdzXCJdLFxuICAgICAgICBsaXN0T3V0c2lkZUNvbGxhYm9yYXRvcnM6IFtcIkdFVCAvb3Jncy97b3JnfS9vdXRzaWRlX2NvbGxhYm9yYXRvcnNcIl0sXG4gICAgICAgIGxpc3RQZW5kaW5nSW52aXRhdGlvbnM6IFtcIkdFVCAvb3Jncy97b3JnfS9pbnZpdGF0aW9uc1wiXSxcbiAgICAgICAgbGlzdFB1YmxpY01lbWJlcnM6IFtcIkdFVCAvb3Jncy97b3JnfS9wdWJsaWNfbWVtYmVyc1wiXSxcbiAgICAgICAgbGlzdFdlYmhvb2tEZWxpdmVyaWVzOiBbXCJHRVQgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXNcIl0sXG4gICAgICAgIGxpc3RXZWJob29rczogW1wiR0VUIC9vcmdzL3tvcmd9L2hvb2tzXCJdLFxuICAgICAgICBwaW5nV2ViaG9vazogW1wiUE9TVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vcGluZ3NcIl0sXG4gICAgICAgIHJlZGVsaXZlcldlYmhvb2tEZWxpdmVyeTogW1xuICAgICAgICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzL3tkZWxpdmVyeV9pZH0vYXR0ZW1wdHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlTWVtYmVyOiBbXCJERUxFVEUgL29yZ3Mve29yZ30vbWVtYmVycy97dXNlcm5hbWV9XCJdLFxuICAgICAgICByZW1vdmVNZW1iZXJzaGlwRm9yVXNlcjogW1wiREVMRVRFIC9vcmdzL3tvcmd9L21lbWJlcnNoaXBzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIHJlbW92ZU91dHNpZGVDb2xsYWJvcmF0b3I6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L291dHNpZGVfY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVB1YmxpY01lbWJlcnNoaXBGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vcHVibGljX21lbWJlcnMve3VzZXJuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRNZW1iZXJzaGlwRm9yVXNlcjogW1wiUFVUIC9vcmdzL3tvcmd9L21lbWJlcnNoaXBzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIHNldFB1YmxpY01lbWJlcnNoaXBGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vcHVibGljX21lbWJlcnMve3VzZXJuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1bmJsb2NrVXNlcjogW1wiREVMRVRFIC9vcmdzL3tvcmd9L2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9vcmdzL3tvcmd9XCJdLFxuICAgICAgICB1cGRhdGVNZW1iZXJzaGlwRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3VzZXIvbWVtYmVyc2hpcHMvb3Jncy97b3JnfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVXZWJob29rOiBbXCJQQVRDSCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgICAgIHVwZGF0ZVdlYmhvb2tDb25maWdGb3JPcmc6IFtcIlBBVENIIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfS9jb25maWdcIl0sXG4gICAgfSxcbiAgICBwYWNrYWdlczoge1xuICAgICAgICBkZWxldGVQYWNrYWdlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVBhY2thZ2VGb3JPcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVBhY2thZ2VGb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVQYWNrYWdlVmVyc2lvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVQYWNrYWdlVmVyc2lvbkZvck9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUGFja2FnZVZlcnNpb25Gb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JBUGFja2FnZU93bmVkQnlBbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJwYWNrYWdlc1wiLCBcImdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvclBhY2thZ2VPd25lZEJ5T3JnXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvckFQYWNrYWdlT3duZWRCeVRoZUF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVuYW1lZDogW1xuICAgICAgICAgICAgICAgICAgICBcInBhY2thZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2V0QWxsUGFja2FnZVZlcnNpb25zRm9yUGFja2FnZU93bmVkQnlBdXRoZW50aWNhdGVkVXNlclwiLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JQYWNrYWdlT3duZWRCeUF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JQYWNrYWdlT3duZWRCeU9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWxsUGFja2FnZVZlcnNpb25zRm9yUGFja2FnZU93bmVkQnlVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRQYWNrYWdlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFBhY2thZ2VGb3JPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFBhY2thZ2VGb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRQYWNrYWdlVmVyc2lvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRQYWNrYWdlVmVyc2lvbkZvck9yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UGFja2FnZVZlcnNpb25Gb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UGFja2FnZXNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3BhY2thZ2VzXCJdLFxuICAgICAgICBsaXN0UGFja2FnZXNGb3JPcmdhbml6YXRpb246IFtcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlc1wiXSxcbiAgICAgICAgbGlzdFBhY2thZ2VzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzXCJdLFxuICAgICAgICByZXN0b3JlUGFja2FnZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vcmVzdG9yZXs/dG9rZW59XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlc3RvcmVQYWNrYWdlRm9yT3JnOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vcmVzdG9yZXs/dG9rZW59XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlc3RvcmVQYWNrYWdlRm9yVXNlcjogW1xuICAgICAgICAgICAgXCJQT1NUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3Jlc3RvcmV7P3Rva2VufVwiLFxuICAgICAgICBdLFxuICAgICAgICByZXN0b3JlUGFja2FnZVZlcnNpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQT1NUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9L3Jlc3RvcmVcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVzdG9yZVBhY2thZ2VWZXJzaW9uRm9yT3JnOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH0vcmVzdG9yZVwiLFxuICAgICAgICBdLFxuICAgICAgICByZXN0b3JlUGFja2FnZVZlcnNpb25Gb3JVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH0vcmVzdG9yZVwiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgcHJvamVjdHM6IHtcbiAgICAgICAgYWRkQ29sbGFib3JhdG9yOiBbXCJQVVQgL3Byb2plY3RzL3twcm9qZWN0X2lkfS9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGNyZWF0ZUNhcmQ6IFtcIlBPU1QgL3Byb2plY3RzL2NvbHVtbnMve2NvbHVtbl9pZH0vY2FyZHNcIl0sXG4gICAgICAgIGNyZWF0ZUNvbHVtbjogW1wiUE9TVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbHVtbnNcIl0sXG4gICAgICAgIGNyZWF0ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL3Byb2plY3RzXCJdLFxuICAgICAgICBjcmVhdGVGb3JPcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vcHJvamVjdHNcIl0sXG4gICAgICAgIGNyZWF0ZUZvclJlcG86IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Byb2plY3RzXCJdLFxuICAgICAgICBkZWxldGU6IFtcIkRFTEVURSAvcHJvamVjdHMve3Byb2plY3RfaWR9XCJdLFxuICAgICAgICBkZWxldGVDYXJkOiBbXCJERUxFVEUgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMve2NhcmRfaWR9XCJdLFxuICAgICAgICBkZWxldGVDb2x1bW46IFtcIkRFTEVURSAvcHJvamVjdHMvY29sdW1ucy97Y29sdW1uX2lkfVwiXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL3Byb2plY3RzL3twcm9qZWN0X2lkfVwiXSxcbiAgICAgICAgZ2V0Q2FyZDogW1wiR0VUIC9wcm9qZWN0cy9jb2x1bW5zL2NhcmRzL3tjYXJkX2lkfVwiXSxcbiAgICAgICAgZ2V0Q29sdW1uOiBbXCJHRVQgL3Byb2plY3RzL2NvbHVtbnMve2NvbHVtbl9pZH1cIl0sXG4gICAgICAgIGdldFBlcm1pc3Npb25Gb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbGxhYm9yYXRvcnMve3VzZXJuYW1lfS9wZXJtaXNzaW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RDYXJkczogW1wiR0VUIC9wcm9qZWN0cy9jb2x1bW5zL3tjb2x1bW5faWR9L2NhcmRzXCJdLFxuICAgICAgICBsaXN0Q29sbGFib3JhdG9yczogW1wiR0VUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sbGFib3JhdG9yc1wiXSxcbiAgICAgICAgbGlzdENvbHVtbnM6IFtcIkdFVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbHVtbnNcIl0sXG4gICAgICAgIGxpc3RGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9wcm9qZWN0c1wiXSxcbiAgICAgICAgbGlzdEZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHJvamVjdHNcIl0sXG4gICAgICAgIGxpc3RGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcHJvamVjdHNcIl0sXG4gICAgICAgIG1vdmVDYXJkOiBbXCJQT1NUIC9wcm9qZWN0cy9jb2x1bW5zL2NhcmRzL3tjYXJkX2lkfS9tb3Zlc1wiXSxcbiAgICAgICAgbW92ZUNvbHVtbjogW1wiUE9TVCAvcHJvamVjdHMvY29sdW1ucy97Y29sdW1uX2lkfS9tb3Zlc1wiXSxcbiAgICAgICAgcmVtb3ZlQ29sbGFib3JhdG9yOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbGxhYm9yYXRvcnMve3VzZXJuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9wcm9qZWN0cy97cHJvamVjdF9pZH1cIl0sXG4gICAgICAgIHVwZGF0ZUNhcmQ6IFtcIlBBVENIIC9wcm9qZWN0cy9jb2x1bW5zL2NhcmRzL3tjYXJkX2lkfVwiXSxcbiAgICAgICAgdXBkYXRlQ29sdW1uOiBbXCJQQVRDSCAvcHJvamVjdHMvY29sdW1ucy97Y29sdW1uX2lkfVwiXSxcbiAgICB9LFxuICAgIHB1bGxzOiB7XG4gICAgICAgIGNoZWNrSWZNZXJnZWQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9tZXJnZVwiXSxcbiAgICAgICAgY3JlYXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxsc1wiXSxcbiAgICAgICAgY3JlYXRlUmVwbHlGb3JSZXZpZXdDb21tZW50OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfaWR9L3JlcGxpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlUmV2aWV3OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3NcIl0sXG4gICAgICAgIGNyZWF0ZVJldmlld0NvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVQZW5kaW5nUmV2aWV3OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVJldmlld0NvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy9jb21tZW50cy97Y29tbWVudF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGlzbWlzc1JldmlldzogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfS9kaXNtaXNzYWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9XCJdLFxuICAgICAgICBnZXRSZXZpZXc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UmV2aWV3Q29tbWVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgICAgIGxpc3Q6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHNcIl0sXG4gICAgICAgIGxpc3RDb21tZW50c0ZvclJldmlldzogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Q29tbWl0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2NvbW1pdHNcIl0sXG4gICAgICAgIGxpc3RGaWxlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2ZpbGVzXCJdLFxuICAgICAgICBsaXN0UmVxdWVzdGVkUmV2aWV3ZXJzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXF1ZXN0ZWRfcmV2aWV3ZXJzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RSZXZpZXdDb21tZW50czogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWVudHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJldmlld0NvbW1lbnRzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy9jb21tZW50c1wiXSxcbiAgICAgICAgbGlzdFJldmlld3M6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzXCJdLFxuICAgICAgICBtZXJnZTogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L21lcmdlXCJdLFxuICAgICAgICByZW1vdmVSZXF1ZXN0ZWRSZXZpZXdlcnM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3JlcXVlc3RlZF9yZXZpZXdlcnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVxdWVzdFJldmlld2VyczogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3JlcXVlc3RlZF9yZXZpZXdlcnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc3VibWl0UmV2aWV3OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfS9ldmVudHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfVwiXSxcbiAgICAgICAgdXBkYXRlQnJhbmNoOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS91cGRhdGUtYnJhbmNoXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZVJldmlldzogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVSZXZpZXdDb21tZW50OiBbXG4gICAgICAgICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy9jb21tZW50cy97Y29tbWVudF9pZH1cIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHJhdGVMaW1pdDogeyBnZXQ6IFtcIkdFVCAvcmF0ZV9saW1pdFwiXSB9LFxuICAgIHJlYWN0aW9uczoge1xuICAgICAgICBjcmVhdGVGb3JDb21taXRDb21tZW50OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlRm9ySXNzdWU6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVGb3JJc3N1ZUNvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlRm9yUHVsbFJlcXVlc3RSZXZpZXdDb21tZW50OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlRm9yUmVsZWFzZTogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUZvclRlYW1EaXNjdXNzaW9uQ29tbWVudEluT3JnOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVGb3JUZWFtRGlzY3Vzc2lvbkluT3JnOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRm9yQ29tbWl0Q29tbWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnMve3JlYWN0aW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVGb3JJc3N1ZTogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9yZWFjdGlvbnMve3JlYWN0aW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVGb3JJc3N1ZUNvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZvclB1bGxSZXF1ZXN0Q29tbWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnMve3JlYWN0aW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVGb3JSZWxlYXNlOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZvclRlYW1EaXNjdXNzaW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZvclRlYW1EaXNjdXNzaW9uQ29tbWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JDb21taXRDb21tZW50OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Rm9ySXNzdWU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3JlYWN0aW9uc1wiXSxcbiAgICAgICAgbGlzdEZvcklzc3VlQ29tbWVudDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50cy97Y29tbWVudF9pZH0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JQdWxsUmVxdWVzdFJldmlld0NvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy9jb21tZW50cy97Y29tbWVudF9pZH0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JSZWxlYXNlOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Rm9yVGVhbURpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvclRlYW1EaXNjdXNzaW9uSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICByZXBvczoge1xuICAgICAgICBhY2NlcHRJbnZpdGF0aW9uOiBbXG4gICAgICAgICAgICBcIlBBVENIIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wicmVwb3NcIiwgXCJhY2NlcHRJbnZpdGF0aW9uRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgYWNjZXB0SW52aXRhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBBVENIIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGFkZEFwcEFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy9hcHBzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcImFwcHNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBhZGRDb2xsYWJvcmF0b3I6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBhZGRTdGF0dXNDaGVja0NvbnRleHRzOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc3RhdHVzX2NoZWNrcy9jb250ZXh0c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IG1hcFRvRGF0YTogXCJjb250ZXh0c1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFkZFRlYW1BY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdGVhbXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwidGVhbXNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBhZGRVc2VyQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3VzZXJzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcInVzZXJzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgY2hlY2tDb2xsYWJvcmF0b3I6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBjaGVja1Z1bG5lcmFiaWxpdHlBbGVydHM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS92dWxuZXJhYmlsaXR5LWFsZXJ0c1wiLFxuICAgICAgICBdLFxuICAgICAgICBjb2Rlb3duZXJzRXJyb3JzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVvd25lcnMvZXJyb3JzXCJdLFxuICAgICAgICBjb21wYXJlQ29tbWl0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21wYXJlL3tiYXNlfS4uLntoZWFkfVwiXSxcbiAgICAgICAgY29tcGFyZUNvbW1pdHNXaXRoQmFzZWhlYWQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21wYXJlL3tiYXNlaGVhZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlQXV0b2xpbms6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9saW5rc1wiXSxcbiAgICAgICAgY3JlYXRlQ29tbWl0Q29tbWVudDogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVDb21taXRTaWduYXR1cmVQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc2lnbmF0dXJlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVDb21taXRTdGF0dXM6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXR1c2VzL3tzaGF9XCJdLFxuICAgICAgICBjcmVhdGVEZXBsb3lLZXk6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXNcIl0sXG4gICAgICAgIGNyZWF0ZURlcGxveW1lbnQ6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzXCJdLFxuICAgICAgICBjcmVhdGVEZXBsb3ltZW50U3RhdHVzOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50X2lkfS9zdGF0dXNlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVEaXNwYXRjaEV2ZW50OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kaXNwYXRjaGVzXCJdLFxuICAgICAgICBjcmVhdGVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9yZXBvc1wiXSxcbiAgICAgICAgY3JlYXRlRm9yazogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZm9ya3NcIl0sXG4gICAgICAgIGNyZWF0ZUluT3JnOiBbXCJQT1NUIC9vcmdzL3tvcmd9L3JlcG9zXCJdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZUVudmlyb25tZW50OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZUZpbGVDb250ZW50czogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb250ZW50cy97cGF0aH1cIl0sXG4gICAgICAgIGNyZWF0ZVBhZ2VzU2l0ZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXNcIl0sXG4gICAgICAgIGNyZWF0ZVJlbGVhc2U6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzXCJdLFxuICAgICAgICBjcmVhdGVUYWdQcm90ZWN0aW9uOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90YWdzL3Byb3RlY3Rpb25cIl0sXG4gICAgICAgIGNyZWF0ZVVzaW5nVGVtcGxhdGU6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve3RlbXBsYXRlX293bmVyfS97dGVtcGxhdGVfcmVwb30vZ2VuZXJhdGVcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlV2ViaG9vazogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3NcIl0sXG4gICAgICAgIGRlY2xpbmVJbnZpdGF0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9yZXBvc2l0b3J5X2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInJlcG9zXCIsIFwiZGVjbGluZUludml0YXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBkZWNsaW5lSW52aXRhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9yZXBvc2l0b3J5X2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGU6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb31cIl0sXG4gICAgICAgIGRlbGV0ZUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUFkbWluQnJhbmNoUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vZW5mb3JjZV9hZG1pbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQW5FbnZpcm9ubWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQXV0b2xpbms6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b2xpbmtzL3thdXRvbGlua19pZH1cIl0sXG4gICAgICAgIGRlbGV0ZUJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUNvbW1pdENvbW1lbnQ6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgICAgICBkZWxldGVDb21taXRTaWduYXR1cmVQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zaWduYXR1cmVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZURlcGxveUtleTogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9rZXlzL3trZXlfaWR9XCJdLFxuICAgICAgICBkZWxldGVEZXBsb3ltZW50OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZpbGU6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29udGVudHMve3BhdGh9XCJdLFxuICAgICAgICBkZWxldGVJbnZpdGF0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVBhZ2VzU2l0ZTogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlc1wiXSxcbiAgICAgICAgZGVsZXRlUHVsbFJlcXVlc3RSZXZpZXdQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9wdWxsX3JlcXVlc3RfcmV2aWV3c1wiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVSZWxlYXNlOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfVwiXSxcbiAgICAgICAgZGVsZXRlUmVsZWFzZUFzc2V0OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMvYXNzZXRzL3thc3NldF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlVGFnUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhZ3MvcHJvdGVjdGlvbi97dGFnX3Byb3RlY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVdlYmhvb2s6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9XCJdLFxuICAgICAgICBkaXNhYmxlQXV0b21hdGVkU2VjdXJpdHlGaXhlczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9tYXRlZC1zZWN1cml0eS1maXhlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkaXNhYmxlTGZzRm9yUmVwbzogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sZnNcIl0sXG4gICAgICAgIGRpc2FibGVWdWxuZXJhYmlsaXR5QWxlcnRzOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vdnVsbmVyYWJpbGl0eS1hbGVydHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZG93bmxvYWRBcmNoaXZlOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vemlwYmFsbC97cmVmfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInJlcG9zXCIsIFwiZG93bmxvYWRaaXBiYWxsQXJjaGl2ZVwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBkb3dubG9hZFRhcmJhbGxBcmNoaXZlOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhcmJhbGwve3JlZn1cIl0sXG4gICAgICAgIGRvd25sb2FkWmlwYmFsbEFyY2hpdmU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vemlwYmFsbC97cmVmfVwiXSxcbiAgICAgICAgZW5hYmxlQXV0b21hdGVkU2VjdXJpdHlGaXhlczogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9tYXRlZC1zZWN1cml0eS1maXhlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBlbmFibGVMZnNGb3JSZXBvOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2xmc1wiXSxcbiAgICAgICAgZW5hYmxlVnVsbmVyYWJpbGl0eUFsZXJ0czogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Z1bG5lcmFiaWxpdHktYWxlcnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdlbmVyYXRlUmVsZWFzZU5vdGVzOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL2dlbmVyYXRlLW5vdGVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXSxcbiAgICAgICAgZ2V0QWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWRtaW5CcmFuY2hQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9lbmZvcmNlX2FkbWluc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGxFbnZpcm9ubWVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzXCJdLFxuICAgICAgICBnZXRBbGxTdGF0dXNDaGVja0NvbnRleHRzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzL2NvbnRleHRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbFRvcGljczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90b3BpY3NcIl0sXG4gICAgICAgIGdldEFwcHNXaXRoQWNjZXNzVG9Qcm90ZWN0ZWRCcmFuY2g6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy9hcHBzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEF1dG9saW5rOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9saW5rcy97YXV0b2xpbmtfaWR9XCJdLFxuICAgICAgICBnZXRCcmFuY2g6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH1cIl0sXG4gICAgICAgIGdldEJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldENsb25lczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90cmFmZmljL2Nsb25lc1wiXSxcbiAgICAgICAgZ2V0Q29kZUZyZXF1ZW5jeVN0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL2NvZGVfZnJlcXVlbmN5XCJdLFxuICAgICAgICBnZXRDb2xsYWJvcmF0b3JQZXJtaXNzaW9uTGV2ZWw6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX0vcGVybWlzc2lvblwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRDb21iaW5lZFN0YXR1c0ZvclJlZjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L3N0YXR1c1wiXSxcbiAgICAgICAgZ2V0Q29tbWl0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn1cIl0sXG4gICAgICAgIGdldENvbW1pdEFjdGl2aXR5U3RhdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3RhdHMvY29tbWl0X2FjdGl2aXR5XCJdLFxuICAgICAgICBnZXRDb21taXRDb21tZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICAgICAgZ2V0Q29tbWl0U2lnbmF0dXJlUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc2lnbmF0dXJlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRDb21tdW5pdHlQcm9maWxlTWV0cmljczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21tdW5pdHkvcHJvZmlsZVwiXSxcbiAgICAgICAgZ2V0Q29udGVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb250ZW50cy97cGF0aH1cIl0sXG4gICAgICAgIGdldENvbnRyaWJ1dG9yc1N0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL2NvbnRyaWJ1dG9yc1wiXSxcbiAgICAgICAgZ2V0RGVwbG95S2V5OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXMve2tleV9pZH1cIl0sXG4gICAgICAgIGdldERlcGxveW1lbnQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9XCJdLFxuICAgICAgICBnZXREZXBsb3ltZW50U3RhdHVzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9L3N0YXR1c2VzL3tzdGF0dXNfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEVudmlyb25tZW50OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRMYXRlc3RQYWdlc0J1aWxkOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2J1aWxkcy9sYXRlc3RcIl0sXG4gICAgICAgIGdldExhdGVzdFJlbGVhc2U6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMvbGF0ZXN0XCJdLFxuICAgICAgICBnZXRQYWdlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlc1wiXSxcbiAgICAgICAgZ2V0UGFnZXNCdWlsZDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9idWlsZHMve2J1aWxkX2lkfVwiXSxcbiAgICAgICAgZ2V0UGFnZXNIZWFsdGhDaGVjazogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9oZWFsdGhcIl0sXG4gICAgICAgIGdldFBhcnRpY2lwYXRpb25TdGF0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGF0cy9wYXJ0aWNpcGF0aW9uXCJdLFxuICAgICAgICBnZXRQdWxsUmVxdWVzdFJldmlld1Byb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3B1bGxfcmVxdWVzdF9yZXZpZXdzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFB1bmNoQ2FyZFN0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL3B1bmNoX2NhcmRcIl0sXG4gICAgICAgIGdldFJlYWRtZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWFkbWVcIl0sXG4gICAgICAgIGdldFJlYWRtZUluRGlyZWN0b3J5OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlYWRtZS97ZGlyfVwiXSxcbiAgICAgICAgZ2V0UmVsZWFzZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH1cIl0sXG4gICAgICAgIGdldFJlbGVhc2VBc3NldDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9hc3NldHMve2Fzc2V0X2lkfVwiXSxcbiAgICAgICAgZ2V0UmVsZWFzZUJ5VGFnOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3RhZ3Mve3RhZ31cIl0sXG4gICAgICAgIGdldFN0YXR1c0NoZWNrc1Byb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0VGVhbXNXaXRoQWNjZXNzVG9Qcm90ZWN0ZWRCcmFuY2g6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy90ZWFtc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRUb3BQYXRoczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90cmFmZmljL3BvcHVsYXIvcGF0aHNcIl0sXG4gICAgICAgIGdldFRvcFJlZmVycmVyczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90cmFmZmljL3BvcHVsYXIvcmVmZXJyZXJzXCJdLFxuICAgICAgICBnZXRVc2Vyc1dpdGhBY2Nlc3NUb1Byb3RlY3RlZEJyYW5jaDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3VzZXJzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFZpZXdzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYWZmaWMvdmlld3NcIl0sXG4gICAgICAgIGdldFdlYmhvb2s6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9XCJdLFxuICAgICAgICBnZXRXZWJob29rQ29uZmlnRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9jb25maWdcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0V2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0QXV0b2xpbmtzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9saW5rc1wiXSxcbiAgICAgICAgbGlzdEJyYW5jaGVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzXCJdLFxuICAgICAgICBsaXN0QnJhbmNoZXNGb3JIZWFkQ29tbWl0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97Y29tbWl0X3NoYX0vYnJhbmNoZXMtd2hlcmUtaGVhZFwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Q29sbGFib3JhdG9yczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzXCJdLFxuICAgICAgICBsaXN0Q29tbWVudHNGb3JDb21taXQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Q29tbWl0Q29tbWVudHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzXCJdLFxuICAgICAgICBsaXN0Q29tbWl0U3RhdHVzZXNGb3JSZWY6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L3N0YXR1c2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RDb21taXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHNcIl0sXG4gICAgICAgIGxpc3RDb250cmlidXRvcnM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29udHJpYnV0b3JzXCJdLFxuICAgICAgICBsaXN0RGVwbG95S2V5czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9rZXlzXCJdLFxuICAgICAgICBsaXN0RGVwbG95bWVudFN0YXR1c2VzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9L3N0YXR1c2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3REZXBsb3ltZW50czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50c1wiXSxcbiAgICAgICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcmVwb3NcIl0sXG4gICAgICAgIGxpc3RGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9yZXBvc1wiXSxcbiAgICAgICAgbGlzdEZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZXBvc1wiXSxcbiAgICAgICAgbGlzdEZvcmtzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ZvcmtzXCJdLFxuICAgICAgICBsaXN0SW52aXRhdGlvbnM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW52aXRhdGlvbnNcIl0sXG4gICAgICAgIGxpc3RJbnZpdGF0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcmVwb3NpdG9yeV9pbnZpdGF0aW9uc1wiXSxcbiAgICAgICAgbGlzdExhbmd1YWdlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYW5ndWFnZXNcIl0sXG4gICAgICAgIGxpc3RQYWdlc0J1aWxkczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9idWlsZHNcIl0sXG4gICAgICAgIGxpc3RQdWJsaWM6IFtcIkdFVCAvcmVwb3NpdG9yaWVzXCJdLFxuICAgICAgICBsaXN0UHVsbFJlcXVlc3RzQXNzb2NpYXRlZFdpdGhDb21taXQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9wdWxsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UmVsZWFzZUFzc2V0czogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9hc3NldHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJlbGVhc2VzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzXCJdLFxuICAgICAgICBsaXN0VGFnUHJvdGVjdGlvbjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90YWdzL3Byb3RlY3Rpb25cIl0sXG4gICAgICAgIGxpc3RUYWdzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhZ3NcIl0sXG4gICAgICAgIGxpc3RUZWFtczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90ZWFtc1wiXSxcbiAgICAgICAgbGlzdFdlYmhvb2tEZWxpdmVyaWVzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFdlYmhvb2tzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzXCJdLFxuICAgICAgICBtZXJnZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWVyZ2VzXCJdLFxuICAgICAgICBtZXJnZVVwc3RyZWFtOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9tZXJnZS11cHN0cmVhbVwiXSxcbiAgICAgICAgcGluZ1dlYmhvb2s6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9waW5nc1wiXSxcbiAgICAgICAgcmVkZWxpdmVyV2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzL3tkZWxpdmVyeV9pZH0vYXR0ZW1wdHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlQXBwQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvYXBwc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IG1hcFRvRGF0YTogXCJhcHBzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlQ29sbGFib3JhdG9yOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3MvY29udGV4dHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwiY29udGV4dHNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVTdGF0dXNDaGVja1Byb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlVGVhbUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3RlYW1zXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcInRlYW1zXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlVXNlckFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3VzZXJzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcInVzZXJzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVuYW1lQnJhbmNoOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9yZW5hbWVcIl0sXG4gICAgICAgIHJlcGxhY2VBbGxUb3BpY3M6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vdG9waWNzXCJdLFxuICAgICAgICByZXF1ZXN0UGFnZXNCdWlsZDogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXMvYnVpbGRzXCJdLFxuICAgICAgICBzZXRBZG1pbkJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9lbmZvcmNlX2FkbWluc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRBcHBBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy9hcHBzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcImFwcHNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzZXRTdGF0dXNDaGVja0NvbnRleHRzOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzL2NvbnRleHRzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcImNvbnRleHRzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc2V0VGVhbUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3RlYW1zXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcInRlYW1zXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc2V0VXNlckFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3VzZXJzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcInVzZXJzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgdGVzdFB1c2hXZWJob29rOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH0vdGVzdHNcIl0sXG4gICAgICAgIHRyYW5zZmVyOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90cmFuc2ZlclwiXSxcbiAgICAgICAgdXBkYXRlOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb31cIl0sXG4gICAgICAgIHVwZGF0ZUJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZUNvbW1pdENvbW1lbnQ6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgICAgIHVwZGF0ZUluZm9ybWF0aW9uQWJvdXRQYWdlc1NpdGU6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXNcIl0sXG4gICAgICAgIHVwZGF0ZUludml0YXRpb246IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVQdWxsUmVxdWVzdFJldmlld1Byb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfcHVsbF9yZXF1ZXN0X3Jldmlld3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlUmVsZWFzZTogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfVwiXSxcbiAgICAgICAgdXBkYXRlUmVsZWFzZUFzc2V0OiBbXG4gICAgICAgICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9hc3NldHMve2Fzc2V0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVTdGF0dXNDaGVja1BvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wicmVwb3NcIiwgXCJ1cGRhdGVTdGF0dXNDaGVja1Byb3RlY3Rpb25cIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlU3RhdHVzQ2hlY2tQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlV2ViaG9vazogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfVwiXSxcbiAgICAgICAgdXBkYXRlV2ViaG9va0NvbmZpZ0ZvclJlcG86IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9jb25maWdcIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBsb2FkUmVsZWFzZUFzc2V0OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9hc3NldHN7P25hbWUsbGFiZWx9XCIsXG4gICAgICAgICAgICB7IGJhc2VVcmw6IFwiaHR0cHM6Ly91cGxvYWRzLmdpdGh1Yi5jb21cIiB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgc2VhcmNoOiB7XG4gICAgICAgIGNvZGU6IFtcIkdFVCAvc2VhcmNoL2NvZGVcIl0sXG4gICAgICAgIGNvbW1pdHM6IFtcIkdFVCAvc2VhcmNoL2NvbW1pdHNcIl0sXG4gICAgICAgIGlzc3Vlc0FuZFB1bGxSZXF1ZXN0czogW1wiR0VUIC9zZWFyY2gvaXNzdWVzXCJdLFxuICAgICAgICBsYWJlbHM6IFtcIkdFVCAvc2VhcmNoL2xhYmVsc1wiXSxcbiAgICAgICAgcmVwb3M6IFtcIkdFVCAvc2VhcmNoL3JlcG9zaXRvcmllc1wiXSxcbiAgICAgICAgdG9waWNzOiBbXCJHRVQgL3NlYXJjaC90b3BpY3NcIl0sXG4gICAgICAgIHVzZXJzOiBbXCJHRVQgL3NlYXJjaC91c2Vyc1wiXSxcbiAgICB9LFxuICAgIHNlY3JldFNjYW5uaW5nOiB7XG4gICAgICAgIGdldEFsZXJ0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0QWxlcnRzRm9yRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RBbGVydHNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzXCJdLFxuICAgICAgICBsaXN0QWxlcnRzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzXCJdLFxuICAgICAgICBsaXN0TG9jYXRpb25zRm9yQWxlcnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2xvY2F0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVBbGVydDogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdGVhbXM6IHtcbiAgICAgICAgYWRkT3JVcGRhdGVNZW1iZXJzaGlwRm9yVXNlckluT3JnOiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9tZW1iZXJzaGlwcy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGFkZE9yVXBkYXRlUHJvamVjdFBlcm1pc3Npb25zSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3Byb2plY3RzL3twcm9qZWN0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBhZGRPclVwZGF0ZVJlcG9QZXJtaXNzaW9uc0luT3JnOiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvcy97b3duZXJ9L3tyZXBvfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjaGVja1Blcm1pc3Npb25zRm9yUHJvamVjdEluT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9wcm9qZWN0cy97cHJvamVjdF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY2hlY2tQZXJtaXNzaW9uc0ZvclJlcG9Jbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vcmVwb3Mve293bmVyfS97cmVwb31cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlOiBbXCJQT1NUIC9vcmdzL3tvcmd9L3RlYW1zXCJdLFxuICAgICAgICBjcmVhdGVEaXNjdXNzaW9uQ29tbWVudEluT3JnOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVEaXNjdXNzaW9uSW5Pcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnNcIl0sXG4gICAgICAgIGRlbGV0ZURpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVEaXNjdXNzaW9uSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlSW5Pcmc6IFtcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfVwiXSxcbiAgICAgICAgZ2V0QnlOYW1lOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z31cIl0sXG4gICAgICAgIGdldERpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXREaXNjdXNzaW9uSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0TWVtYmVyc2hpcEZvclVzZXJJbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0OiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXNcIl0sXG4gICAgICAgIGxpc3RDaGlsZEluT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vdGVhbXNcIl0sXG4gICAgICAgIGxpc3REaXNjdXNzaW9uQ29tbWVudHNJbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0RGlzY3Vzc2lvbnNJbk9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zXCJdLFxuICAgICAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci90ZWFtc1wiXSxcbiAgICAgICAgbGlzdE1lbWJlcnNJbk9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L21lbWJlcnNcIl0sXG4gICAgICAgIGxpc3RQZW5kaW5nSW52aXRhdGlvbnNJbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vaW52aXRhdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFByb2plY3RzSW5Pcmc6IFtcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9wcm9qZWN0c1wiXSxcbiAgICAgICAgbGlzdFJlcG9zSW5Pcmc6IFtcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvc1wiXSxcbiAgICAgICAgcmVtb3ZlTWVtYmVyc2hpcEZvclVzZXJJbk9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVQcm9qZWN0SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3Byb2plY3RzL3twcm9qZWN0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVSZXBvSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3JlcG9zL3tvd25lcn0ve3JlcG99XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZURpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZURpc2N1c3Npb25Jbk9yZzogW1xuICAgICAgICAgICAgXCJQQVRDSCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZUluT3JnOiBbXCJQQVRDSCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfVwiXSxcbiAgICB9LFxuICAgIHVzZXJzOiB7XG4gICAgICAgIGFkZEVtYWlsRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJQT1NUIC91c2VyL2VtYWlsc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwiYWRkRW1haWxGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBhZGRFbWFpbEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL2VtYWlsc1wiXSxcbiAgICAgICAgYmxvY2s6IFtcIlBVVCAvdXNlci9ibG9ja3Mve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY2hlY2tCbG9ja2VkOiBbXCJHRVQgL3VzZXIvYmxvY2tzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGNoZWNrRm9sbG93aW5nRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2ZvbGxvd2luZy97dGFyZ2V0X3VzZXJ9XCJdLFxuICAgICAgICBjaGVja1BlcnNvbklzRm9sbG93ZWRCeUF1dGhlbnRpY2F0ZWQ6IFtcIkdFVCAvdXNlci9mb2xsb3dpbmcve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY3JlYXRlR3BnS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJQT1NUIC91c2VyL2dwZ19rZXlzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJjcmVhdGVHcGdLZXlGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVHcGdLZXlGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9ncGdfa2V5c1wiXSxcbiAgICAgICAgY3JlYXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJQT1NUIC91c2VyL2tleXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImNyZWF0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL2tleXNcIl0sXG4gICAgICAgIGRlbGV0ZUVtYWlsRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIvZW1haWxzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJkZWxldGVFbWFpbEZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUVtYWlsRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9lbWFpbHNcIl0sXG4gICAgICAgIGRlbGV0ZUdwZ0tleUZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL2dwZ19rZXlzL3tncGdfa2V5X2lkfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwiZGVsZXRlR3BnS2V5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlR3BnS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9ncGdfa2V5cy97Z3BnX2tleV9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL2tleXMve2tleV9pZH1cIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImRlbGV0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJERUxFVEUgL3VzZXIva2V5cy97a2V5X2lkfVwiXSxcbiAgICAgICAgZm9sbG93OiBbXCJQVVQgL3VzZXIvZm9sbG93aW5nL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGdldEF1dGhlbnRpY2F0ZWQ6IFtcIkdFVCAvdXNlclwiXSxcbiAgICAgICAgZ2V0QnlVc2VybmFtZTogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBnZXRDb250ZXh0Rm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2hvdmVyY2FyZFwiXSxcbiAgICAgICAgZ2V0R3BnS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvZ3BnX2tleXMve2dwZ19rZXlfaWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJnZXRHcGdLZXlGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBnZXRHcGdLZXlGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2dwZ19rZXlzL3tncGdfa2V5X2lkfVwiXSxcbiAgICAgICAgZ2V0UHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIva2V5cy97a2V5X2lkfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwiZ2V0UHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9rZXlzL3trZXlfaWR9XCJdLFxuICAgICAgICBsaXN0OiBbXCJHRVQgL3VzZXJzXCJdLFxuICAgICAgICBsaXN0QmxvY2tlZEJ5QXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvYmxvY2tzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0QmxvY2tlZEJ5QXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEJsb2NrZWRCeUF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvYmxvY2tzXCJdLFxuICAgICAgICBsaXN0RW1haWxzRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvZW1haWxzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0RW1haWxzRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEVtYWlsc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZW1haWxzXCJdLFxuICAgICAgICBsaXN0Rm9sbG93ZWRCeUF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2ZvbGxvd2luZ1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwibGlzdEZvbGxvd2VkQnlBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Rm9sbG93ZWRCeUF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZm9sbG93aW5nXCJdLFxuICAgICAgICBsaXN0Rm9sbG93ZXJzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9mb2xsb3dlcnNcIl0sXG4gICAgICAgIGxpc3RGb2xsb3dlcnNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93ZXJzXCJdLFxuICAgICAgICBsaXN0Rm9sbG93aW5nRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2ZvbGxvd2luZ1wiXSxcbiAgICAgICAgbGlzdEdwZ0tleXNGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9ncGdfa2V5c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwibGlzdEdwZ0tleXNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBsaXN0R3BnS2V5c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZ3BnX2tleXNcIl0sXG4gICAgICAgIGxpc3RHcGdLZXlzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2dwZ19rZXlzXCJdLFxuICAgICAgICBsaXN0UHVibGljRW1haWxzRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvcHVibGljX2VtYWlsc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwibGlzdFB1YmxpY0VtYWlsc0ZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RQdWJsaWNFbWFpbHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3B1YmxpY19lbWFpbHNcIl0sXG4gICAgICAgIGxpc3RQdWJsaWNLZXlzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2tleXNcIl0sXG4gICAgICAgIGxpc3RQdWJsaWNTc2hLZXlzRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIva2V5c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwibGlzdFB1YmxpY1NzaEtleXNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UHVibGljU3NoS2V5c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIva2V5c1wiXSxcbiAgICAgICAgc2V0UHJpbWFyeUVtYWlsVmlzaWJpbGl0eUZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3VzZXIvZW1haWwvdmlzaWJpbGl0eVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwic2V0UHJpbWFyeUVtYWlsVmlzaWJpbGl0eUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHNldFByaW1hcnlFbWFpbFZpc2liaWxpdHlGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQQVRDSCAvdXNlci9lbWFpbC92aXNpYmlsaXR5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVuYmxvY2s6IFtcIkRFTEVURSAvdXNlci9ibG9ja3Mve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgdW5mb2xsb3c6IFtcIkRFTEVURSAvdXNlci9mb2xsb3dpbmcve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgdXBkYXRlQXV0aGVudGljYXRlZDogW1wiUEFUQ0ggL3VzZXJcIl0sXG4gICAgfSxcbn07XG5cbmNvbnN0IFZFUlNJT04gPSBcIjUuMTYuMlwiO1xuXG5mdW5jdGlvbiBlbmRwb2ludHNUb01ldGhvZHMob2N0b2tpdCwgZW5kcG9pbnRzTWFwKSB7XG4gICAgY29uc3QgbmV3TWV0aG9kcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3Njb3BlLCBlbmRwb2ludHNdIG9mIE9iamVjdC5lbnRyaWVzKGVuZHBvaW50c01hcCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kTmFtZSwgZW5kcG9pbnRdIG9mIE9iamVjdC5lbnRyaWVzKGVuZHBvaW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IFtyb3V0ZSwgZGVmYXVsdHMsIGRlY29yYXRpb25zXSA9IGVuZHBvaW50O1xuICAgICAgICAgICAgY29uc3QgW21ldGhvZCwgdXJsXSA9IHJvdXRlLnNwbGl0KC8gLyk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZCwgdXJsIH0sIGRlZmF1bHRzKTtcbiAgICAgICAgICAgIGlmICghbmV3TWV0aG9kc1tzY29wZV0pIHtcbiAgICAgICAgICAgICAgICBuZXdNZXRob2RzW3Njb3BlXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NvcGVNZXRob2RzID0gbmV3TWV0aG9kc1tzY29wZV07XG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzY29wZU1ldGhvZHNbbWV0aG9kTmFtZV0gPSBkZWNvcmF0ZShvY3Rva2l0LCBzY29wZSwgbWV0aG9kTmFtZSwgZW5kcG9pbnREZWZhdWx0cywgZGVjb3JhdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NvcGVNZXRob2RzW21ldGhvZE5hbWVdID0gb2N0b2tpdC5yZXF1ZXN0LmRlZmF1bHRzKGVuZHBvaW50RGVmYXVsdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdNZXRob2RzO1xufVxuZnVuY3Rpb24gZGVjb3JhdGUob2N0b2tpdCwgc2NvcGUsIG1ldGhvZE5hbWUsIGRlZmF1bHRzLCBkZWNvcmF0aW9ucykge1xuICAgIGNvbnN0IHJlcXVlc3RXaXRoRGVmYXVsdHMgPSBvY3Rva2l0LnJlcXVlc3QuZGVmYXVsdHMoZGVmYXVsdHMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gd2l0aERlY29yYXRpb25zKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI1NDg4XG4gICAgICAgIGxldCBvcHRpb25zID0gcmVxdWVzdFdpdGhEZWZhdWx0cy5lbmRwb2ludC5tZXJnZSguLi5hcmdzKTtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGN1cnJlbnRseSBubyBvdGhlciBkZWNvcmF0aW9ucyB0aGFuIGAubWFwVG9EYXRhYFxuICAgICAgICBpZiAoZGVjb3JhdGlvbnMubWFwVG9EYXRhKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGRhdGE6IG9wdGlvbnNbZGVjb3JhdGlvbnMubWFwVG9EYXRhXSxcbiAgICAgICAgICAgICAgICBbZGVjb3JhdGlvbnMubWFwVG9EYXRhXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFdpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb3JhdGlvbnMucmVuYW1lZCkge1xuICAgICAgICAgICAgY29uc3QgW25ld1Njb3BlLCBuZXdNZXRob2ROYW1lXSA9IGRlY29yYXRpb25zLnJlbmFtZWQ7XG4gICAgICAgICAgICBvY3Rva2l0LmxvZy53YXJuKGBvY3Rva2l0LiR7c2NvcGV9LiR7bWV0aG9kTmFtZX0oKSBoYXMgYmVlbiByZW5hbWVkIHRvIG9jdG9raXQuJHtuZXdTY29wZX0uJHtuZXdNZXRob2ROYW1lfSgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmRlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgIG9jdG9raXQubG9nLndhcm4oZGVjb3JhdGlvbnMuZGVwcmVjYXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29yYXRpb25zLnJlbmFtZWRQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjU0ODhcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSByZXF1ZXN0V2l0aERlZmF1bHRzLmVuZHBvaW50Lm1lcmdlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYWxpYXNdIG9mIE9iamVjdC5lbnRyaWVzKGRlY29yYXRpb25zLnJlbmFtZWRQYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2N0b2tpdC5sb2cud2FybihgXCIke25hbWV9XCIgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgZm9yIFwib2N0b2tpdC4ke3Njb3BlfS4ke21ldGhvZE5hbWV9KClcIi4gVXNlIFwiJHthbGlhc31cIiBpbnN0ZWFkYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFsaWFzIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2FsaWFzXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI1NDg4XG4gICAgICAgIHJldHVybiByZXF1ZXN0V2l0aERlZmF1bHRzKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih3aXRoRGVjb3JhdGlvbnMsIHJlcXVlc3RXaXRoRGVmYXVsdHMpO1xufVxuXG5mdW5jdGlvbiByZXN0RW5kcG9pbnRNZXRob2RzKG9jdG9raXQpIHtcbiAgICBjb25zdCBhcGkgPSBlbmRwb2ludHNUb01ldGhvZHMob2N0b2tpdCwgRW5kcG9pbnRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0OiBhcGksXG4gICAgfTtcbn1cbnJlc3RFbmRwb2ludE1ldGhvZHMuVkVSU0lPTiA9IFZFUlNJT047XG5mdW5jdGlvbiBsZWdhY3lSZXN0RW5kcG9pbnRNZXRob2RzKG9jdG9raXQpIHtcbiAgICBjb25zdCBhcGkgPSBlbmRwb2ludHNUb01ldGhvZHMob2N0b2tpdCwgRW5kcG9pbnRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcGksXG4gICAgICAgIHJlc3Q6IGFwaSxcbiAgICB9O1xufVxubGVnYWN5UmVzdEVuZHBvaW50TWV0aG9kcy5WRVJTSU9OID0gVkVSU0lPTjtcblxuZXhwb3J0IHsgbGVnYWN5UmVzdEVuZHBvaW50TWV0aG9kcywgcmVzdEVuZHBvaW50TWV0aG9kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJpbXBvcnQgeyBEZXByZWNhdGlvbiB9IGZyb20gJ2RlcHJlY2F0aW9uJztcbmltcG9ydCBvbmNlIGZyb20gJ29uY2UnO1xuXG5jb25zdCBsb2dPbmNlQ29kZSA9IG9uY2UoKGRlcHJlY2F0aW9uKSA9PiBjb25zb2xlLndhcm4oZGVwcmVjYXRpb24pKTtcbmNvbnN0IGxvZ09uY2VIZWFkZXJzID0gb25jZSgoZGVwcmVjYXRpb24pID0+IGNvbnNvbGUud2FybihkZXByZWNhdGlvbikpO1xuLyoqXG4gKiBFcnJvciB3aXRoIGV4dHJhIHByb3BlcnRpZXMgdG8gaGVscCB3aXRoIGRlYnVnZ2luZ1xuICovXG5jbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzQ29kZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNDb2RlO1xuICAgICAgICBsZXQgaGVhZGVycztcbiAgICAgICAgaWYgKFwiaGVhZGVyc1wiIGluIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuaGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJyZXNwb25zZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgICAgaGVhZGVycyA9IG9wdGlvbnMucmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICAvLyByZWRhY3QgcmVxdWVzdCBjcmVkZW50aWFscyB3aXRob3V0IG11dGF0aW5nIG9yaWdpbmFsIHJlcXVlc3Qgb3B0aW9uc1xuICAgICAgICBjb25zdCByZXF1ZXN0Q29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICByZXF1ZXN0Q29weS5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uLnJlcGxhY2UoLyAuKiQvLCBcIiBbUkVEQUNURURdXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdENvcHkudXJsID0gcmVxdWVzdENvcHkudXJsXG4gICAgICAgICAgICAvLyBjbGllbnRfaWQgJiBjbGllbnRfc2VjcmV0IGNhbiBiZSBwYXNzZWQgYXMgVVJMIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jcmVhc2UgcmF0ZSBsaW1pdFxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvI2luY3JlYXNpbmctdGhlLXVuYXV0aGVudGljYXRlZC1yYXRlLWxpbWl0LWZvci1vYXV0aC1hcHBsaWNhdGlvbnNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGJjbGllbnRfc2VjcmV0PVxcdysvZywgXCJjbGllbnRfc2VjcmV0PVtSRURBQ1RFRF1cIilcbiAgICAgICAgICAgIC8vIE9BdXRoIHRva2VucyBjYW4gYmUgcGFzc2VkIGFzIFVSTCBxdWVyeSBwYXJhbWV0ZXJzLCBhbHRob3VnaCBpdCBpcyBub3QgcmVjb21tZW5kZWRcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5naXRodWIuY29tL3YzLyNvYXV0aDItdG9rZW4tc2VudC1pbi1hLWhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcYmFjY2Vzc190b2tlbj1cXHcrL2csIFwiYWNjZXNzX3Rva2VuPVtSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RDb3B5O1xuICAgICAgICAvLyBkZXByZWNhdGlvbnNcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgbG9nT25jZUNvZGUobmV3IERlcHJlY2F0aW9uKFwiW0BvY3Rva2l0L3JlcXVlc3QtZXJyb3JdIGBlcnJvci5jb2RlYCBpcyBkZXByZWNhdGVkLCB1c2UgYGVycm9yLnN0YXR1c2AuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWFkZXJzXCIsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBsb2dPbmNlSGVhZGVycyhuZXcgRGVwcmVjYXRpb24oXCJbQG9jdG9raXQvcmVxdWVzdC1lcnJvcl0gYGVycm9yLmhlYWRlcnNgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgZXJyb3IucmVzcG9uc2UuaGVhZGVyc2AuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUmVxdWVzdEVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImltcG9ydCB7IGVuZHBvaW50IH0gZnJvbSAnQG9jdG9raXQvZW5kcG9pbnQnO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSAndW5pdmVyc2FsLXVzZXItYWdlbnQnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5pbXBvcnQgbm9kZUZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IHsgUmVxdWVzdEVycm9yIH0gZnJvbSAnQG9jdG9raXQvcmVxdWVzdC1lcnJvcic7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjUuNi4zXCI7XG5cbmZ1bmN0aW9uIGdldEJ1ZmZlclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG59XG5cbmZ1bmN0aW9uIGZldGNoV3JhcHBlcihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IGxvZyA9IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QgJiYgcmVxdWVzdE9wdGlvbnMucmVxdWVzdC5sb2dcbiAgICAgICAgPyByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmxvZ1xuICAgICAgICA6IGNvbnNvbGU7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVxdWVzdE9wdGlvbnMuYm9keSkgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShyZXF1ZXN0T3B0aW9ucy5ib2R5KSkge1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxdWVzdE9wdGlvbnMuYm9keSk7XG4gICAgfVxuICAgIGxldCBoZWFkZXJzID0ge307XG4gICAgbGV0IHN0YXR1cztcbiAgICBsZXQgdXJsO1xuICAgIGNvbnN0IGZldGNoID0gKHJlcXVlc3RPcHRpb25zLnJlcXVlc3QgJiYgcmVxdWVzdE9wdGlvbnMucmVxdWVzdC5mZXRjaCkgfHwgbm9kZUZldGNoO1xuICAgIHJldHVybiBmZXRjaChyZXF1ZXN0T3B0aW9ucy51cmwsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICAgICAgYm9keTogcmVxdWVzdE9wdGlvbnMuYm9keSxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgcmVkaXJlY3Q6IHJlcXVlc3RPcHRpb25zLnJlZGlyZWN0LFxuICAgIH0sIFxuICAgIC8vIGByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmFnZW50YCB0eXBlIGlzIGluY29tcGF0aWJsZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC90eXBlcy50cy9wdWxsLzI2NFxuICAgIHJlcXVlc3RPcHRpb25zLnJlcXVlc3QpKVxuICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgdXJsID0gcmVzcG9uc2UudXJsO1xuICAgICAgICBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIGZvciAoY29uc3Qga2V5QW5kVmFsdWUgb2YgcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVyc1trZXlBbmRWYWx1ZVswXV0gPSBrZXlBbmRWYWx1ZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJkZXByZWNhdGlvblwiIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBoZWFkZXJzLmxpbmsgJiYgaGVhZGVycy5saW5rLm1hdGNoKC88KFtePl0rKT47IHJlbD1cImRlcHJlY2F0aW9uXCIvKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcHJlY2F0aW9uTGluayA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICAgIGxvZy53YXJuKGBbQG9jdG9raXQvcmVxdWVzdF0gXCIke3JlcXVlc3RPcHRpb25zLm1ldGhvZH0gJHtyZXF1ZXN0T3B0aW9ucy51cmx9XCIgaXMgZGVwcmVjYXRlZC4gSXQgaXMgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgb24gJHtoZWFkZXJzLnN1bnNldH0ke2RlcHJlY2F0aW9uTGluayA/IGAuIFNlZSAke2RlcHJlY2F0aW9uTGlua31gIDogXCJcIn1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDQgfHwgc3RhdHVzID09PSAyMDUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHaXRIdWIgQVBJIHJldHVybnMgMjAwIGZvciBIRUFEIHJlcXVlc3RzXG4gICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBzdGF0dXMsIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IoXCJOb3QgbW9kaWZpZWRcIiwgc3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcih0b0Vycm9yTWVzc2FnZShkYXRhKSwgc3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9O1xuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVxdWVzdEVycm9yKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmICgvYXBwbGljYXRpb25cXC9qc29uLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRUeXBlIHx8IC9edGV4dFxcL3xjaGFyc2V0PXV0Zi04JC8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ1ZmZlclJlc3BvbnNlKHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIHRvRXJyb3JNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0ganVzdCBpbiBjYXNlXG4gICAgaWYgKFwibWVzc2FnZVwiIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5lcnJvcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7ZGF0YS5tZXNzYWdlfTogJHtkYXRhLmVycm9ycy5tYXAoSlNPTi5zdHJpbmdpZnkpLmpvaW4oXCIsIFwiKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLm1lc3NhZ2U7XG4gICAgfVxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0ganVzdCBpbiBjYXNlXG4gICAgcmV0dXJuIGBVbmtub3duIGVycm9yOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWA7XG59XG5cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhvbGRFbmRwb2ludCwgbmV3RGVmYXVsdHMpIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IG9sZEVuZHBvaW50LmRlZmF1bHRzKG5ld0RlZmF1bHRzKTtcbiAgICBjb25zdCBuZXdBcGkgPSBmdW5jdGlvbiAocm91dGUsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnRPcHRpb25zID0gZW5kcG9pbnQubWVyZ2Uocm91dGUsIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0IHx8ICFlbmRwb2ludE9wdGlvbnMucmVxdWVzdC5ob29rKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKGVuZHBvaW50LnBhcnNlKGVuZHBvaW50T3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAocm91dGUsIHBhcmFtZXRlcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFdyYXBwZXIoZW5kcG9pbnQucGFyc2UoZW5kcG9pbnQubWVyZ2Uocm91dGUsIHBhcmFtZXRlcnMpKSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVxdWVzdCwge1xuICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0Lmhvb2socmVxdWVzdCwgZW5kcG9pbnRPcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0FwaSwge1xuICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIGVuZHBvaW50KSxcbiAgICB9KTtcbn1cblxuY29uc3QgcmVxdWVzdCA9IHdpdGhEZWZhdWx0cyhlbmRwb2ludCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LXJlcXVlc3QuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWAsXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyByZXF1ZXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsInZhciByYXdfY29ubmVjdCA9IHJlcXVpcmUoJy4vbGliL2Nvbm5lY3QnKS5jb25uZWN0O1xudmFyIENoYW5uZWxNb2RlbCA9IHJlcXVpcmUoJy4vbGliL2NoYW5uZWxfbW9kZWwnKS5DaGFubmVsTW9kZWw7XG52YXIgcHJvbWlzaWZ5ID0gcmVxdWlyZSgndXRpbCcpLnByb21pc2lmeTtcblxuZnVuY3Rpb24gY29ubmVjdCh1cmwsIGNvbm5PcHRpb25zKSB7XG4gIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2IpIHtcbiAgICByZXR1cm4gcmF3X2Nvbm5lY3QodXJsLCBjb25uT3B0aW9ucywgY2IpO1xuICB9KSgpXG4gIC50aGVuKGZ1bmN0aW9uKGNvbm4pIHtcbiAgICByZXR1cm4gbmV3IENoYW5uZWxNb2RlbChjb25uKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbm1vZHVsZS5leHBvcnRzLmNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9saWIvY3JlZGVudGlhbHMnKTtcbm1vZHVsZS5leHBvcnRzLklsbGVnYWxPcGVyYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vbGliL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xuIiwiLy9cbi8vXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qXG5UaGUgY2hhbm5lbCAocHJvbWlzZSkgYW5kIGNhbGxiYWNrIEFQSXMgaGF2ZSBzaW1pbGFyIHNpZ25hdHVyZXMsIGFuZFxuaW4gcGFydGljdWxhciwgYm90aCBuZWVkIEFNUVAgZmllbGRzIHByZXBhcmVkIGZyb20gdGhlIHNhbWUgYXJndW1lbnRzXG5hbmQgb3B0aW9ucy4gVGhlIGFyZ3VtZW50cyBtYXJzaGFsbGluZyBpcyBkb25lIGhlcmUuIEVhY2ggb2YgdGhlXG5wcm9jZWR1cmVzIGJlbG93IHRha2VzIGFyZ3VtZW50cyBhbmQgb3B0aW9ucyAodGhlIGxhdHRlciBpbiBhbiBvYmplY3QpXG5wYXJ0aWN1bGFyIHRvIHRoZSBvcGVyYXRpb24gaXQgcmVwcmVzZW50cywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGhcbmZpZWxkcyBmb3IgaGFuZGluZyB0byB0aGUgZW5jb2Rlci5cbiovXG5cbi8vIEEgbnVtYmVyIG9mIEFNUVAgbWV0aG9kcyBoYXZlIGEgdGFibGUtdHlwZWQgZmllbGQgY2FsbGVkXG4vLyBgYXJndW1lbnRzYCwgdGhhdCBpcyBpbnRlbmRlZCB0byBjYXJyeSBleHRlbnNpb24tc3BlY2lmaWNcbi8vIHZhbHVlcy4gUmFiYml0TVEgdXNlcyB0aGlzIGluIGEgbnVtYmVyIG9mIHBsYWNlczsgZS5nLiwgdG8gc3BlY2lmeVxuLy8gYW4gJ2FsdGVybmF0ZSBleGNoYW5nZScuXG4vL1xuLy8gTWFueSBvZiB0aGUgbWV0aG9kcyBpbiB0aGlzIEFQSSBoYXZlIGFuIGBvcHRpb25zYCBhcmd1bWVudCwgZnJvbVxuLy8gd2hpY2ggSSB0YWtlIGJvdGggdmFsdWVzIHRoYXQgaGF2ZSBhIGRlZmF1bHQgaW4gQU1RUCAoZS5nLixcbi8vIGF1dG9EZWxldGUgaW4gUXVldWVEZWNsYXJlKSAqYW5kKiB2YWx1ZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG9cbi8vIFJhYmJpdE1RIChlLmcuLCAnYWx0ZXJuYXRlLWV4Y2hhbmdlJyksIHdoaWNoIHdvdWxkIG5vcm1hbGx5IGJlXG4vLyBzdXBwbGllZCBpbiBgYXJndW1lbnRzYC4gU28gdGhhdCBleHRlbnNpb25zIEkgZG9uJ3Qgc3VwcG9ydCB5ZXQgY2FuXG4vLyBiZSB1c2VkLCBJIGluY2x1ZGUgYGFyZ3VtZW50c2AgaXRzZWxmIGFtb25nIHRoZSBvcHRpb25zLlxuLy9cbi8vIFRoZSB1cHNob3Qgb2YgdGhpcyBpcyB0aGF0IEkgb2Z0ZW4gbmVlZCB0byBwcmVwYXJlIGFuIGBhcmd1bWVudHNgXG4vLyB2YWx1ZSB0aGF0IGhhcyBhbnkgdmFsdWVzIHBhc3NlZCBpbiBgb3B0aW9ucy5hcmd1bWVudHNgIGFzIHdlbGwgYXNcbi8vIGFueSBJJ3ZlIHByb21vdGVkIHRvIGJlaW5nIG9wdGlvbnMgdGhlbXNlbHZlcy4gU2luY2UgSSBkb24ndCB3YW50XG4vLyB0byBtdXRhdGUgYW55dGhpbmcgcGFzc2VkIGluLCB0aGUgZ2VuZXJhbCBwYXR0ZXJuIGlzIHRvIGNyZWF0ZSBhXG4vLyBmcmVzaCBvYmplY3Qgd2l0aCB0aGUgYGFyZ3VtZW50c2AgdmFsdWUgZ2l2ZW4gYXMgaXRzIHByb3RvdHlwZTsgYWxsXG4vLyBmaWVsZHMgaW4gdGhlIHN1cHBsaWVkIHZhbHVlIHdpbGwgYmUgc2VyaWFsaXNlZCwgYXMgd2VsbCBhcyBhbnkgSVxuLy8gc2V0IG9uIHRoZSBmcmVzaCBvYmplY3QuIFdoYXQgSSBkb24ndCB3YW50IHRvIGRvLCBob3dldmVyLCBpcyBzZXQgYVxuLy8gZmllbGQgdG8gdW5kZWZpbmVkIGJ5IGNvcHlpbmcgcG9zc2libHkgbWlzc2luZyBmaWVsZCB2YWx1ZXMsXG4vLyBiZWNhdXNlIHRoYXQgd2lsbCBtYXNrIGEgdmFsdWUgaW4gdGhlIHByb3RvdHlwZS5cbi8vXG4vLyBOQiB0aGUgYGFyZ3VtZW50c2AgZmllbGQgYWxyZWFkeSBoYXMgYSBkZWZhdWx0IHZhbHVlIG9mIGB7fWAsIHNvXG4vLyB0aGVyZSdzIG5vIG5lZWQgdG8gZXhwbGljaXRseSBkZWZhdWx0IGl0IHVubGVzcyBJJ20gc2V0dGluZyB2YWx1ZXMuXG5mdW5jdGlvbiBzZXRJZkRlZmluZWQob2JqLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKSBvYmpbcHJvcF0gPSB2YWx1ZTtcbn1cblxudmFyIEVNUFRZX09QVElPTlMgPSBPYmplY3QuZnJlZXplKHt9KTtcblxudmFyIEFyZ3MgPSB7fTtcblxuQXJncy5hc3NlcnRRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBvcHRpb25zKSB7XG4gIHF1ZXVlID0gcXVldWUgfHwgJyc7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG5cbiAgdmFyIGFyZ3QgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuYXJndW1lbnRzIHx8IG51bGwpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtZXhwaXJlcycsIG9wdGlvbnMuZXhwaXJlcyk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1tZXNzYWdlLXR0bCcsIG9wdGlvbnMubWVzc2FnZVR0bCk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1kZWFkLWxldHRlci1leGNoYW5nZScsXG4gICAgICAgICAgICAgICBvcHRpb25zLmRlYWRMZXR0ZXJFeGNoYW5nZSk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1kZWFkLWxldHRlci1yb3V0aW5nLWtleScsXG4gICAgICAgICAgICAgICBvcHRpb25zLmRlYWRMZXR0ZXJSb3V0aW5nS2V5KTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1heC1sZW5ndGgnLCBvcHRpb25zLm1heExlbmd0aCk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1tYXgtcHJpb3JpdHknLCBvcHRpb25zLm1heFByaW9yaXR5KTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW92ZXJmbG93Jywgb3B0aW9ucy5vdmVyZmxvdyk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1xdWV1ZS1tb2RlJywgb3B0aW9ucy5xdWV1ZU1vZGUpO1xuXG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGV4Y2x1c2l2ZTogISFvcHRpb25zLmV4Y2x1c2l2ZSxcbiAgICBkdXJhYmxlOiAob3B0aW9ucy5kdXJhYmxlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuZHVyYWJsZSxcbiAgICBhdXRvRGVsZXRlOiAhIW9wdGlvbnMuYXV0b0RlbGV0ZSxcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgLy8gZGVwcmVjYXRlZCBidXQgd2UgaGF2ZSB0byBpbmNsdWRlIGl0XG4gICAgdGlja2V0OiAwLFxuICAgIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MuY2hlY2tRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIHBhc3NpdmU6IHRydWUsIC8vIHN3aXRjaCB0byBcImNvbXBsZXRlbHkgZGlmZmVyZW50XCIgbW9kZVxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgZHVyYWJsZTogdHJ1ZSwgYXV0b0RlbGV0ZTogZmFsc2UsIGV4Y2x1c2l2ZTogZmFsc2UsIC8vIGlnbm9yZWRcbiAgICB0aWNrZXQ6IDAsXG4gIH07XG59O1xuXG5BcmdzLmRlbGV0ZVF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgaWZVbnVzZWQ6ICEhb3B0aW9ucy5pZlVudXNlZCxcbiAgICBpZkVtcHR5OiAhIW9wdGlvbnMuaWZFbXB0eSxcbiAgICB0aWNrZXQ6IDAsIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MucHVyZ2VRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5iaW5kUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGV4Y2hhbmdlOiBzb3VyY2UsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLnVuYmluZFF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICByZXR1cm4ge1xuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBleGNoYW5nZTogc291cmNlLFxuICAgIHJvdXRpbmdLZXk6IHBhdHRlcm4sXG4gICAgYXJndW1lbnRzOiBhcmd0LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5hc3NlcnRFeGNoYW5nZSA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCB0eXBlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHZhciBhcmd0ID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmFyZ3VtZW50cyB8fCBudWxsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICdhbHRlcm5hdGUtZXhjaGFuZ2UnLCBvcHRpb25zLmFsdGVybmF0ZUV4Y2hhbmdlKTtcbiAgcmV0dXJuIHtcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgdGlja2V0OiAwLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgZHVyYWJsZTogKG9wdGlvbnMuZHVyYWJsZSA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLmR1cmFibGUsXG4gICAgYXV0b0RlbGV0ZTogISFvcHRpb25zLmF1dG9EZWxldGUsXG4gICAgaW50ZXJuYWw6ICEhb3B0aW9ucy5pbnRlcm5hbCxcbiAgICBub3dhaXQ6IGZhbHNlLFxuICAgIGFyZ3VtZW50czogYXJndFxuICB9O1xufTtcblxuQXJncy5jaGVja0V4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgcGFzc2l2ZTogdHJ1ZSwgLy8gc3dpdGNoIHRvICdtYXkgYXMgd2VsbCBiZSBhbm90aGVyIG1ldGhvZCcgbW9kZVxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgLy8gZmYgYXJlIGlnbm9yZWRcbiAgICBkdXJhYmxlOiB0cnVlLCBpbnRlcm5hbDogZmFsc2UsICB0eXBlOiAnJywgIGF1dG9EZWxldGU6IGZhbHNlLFxuICAgIHRpY2tldDogMFxuICB9O1xufTtcblxuQXJncy5kZWxldGVFeGNoYW5nZSA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHJldHVybiB7XG4gICAgZXhjaGFuZ2U6IGV4Y2hhbmdlLFxuICAgIGlmVW51c2VkOiAhIW9wdGlvbnMuaWZVbnVzZWQsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmJpbmRFeGNoYW5nZSA9IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZTogc291cmNlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIHJvdXRpbmdLZXk6IHBhdHRlcm4sXG4gICAgYXJndW1lbnRzOiBhcmd0LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy51bmJpbmRFeGNoYW5nZSA9IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZTogc291cmNlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIHJvdXRpbmdLZXk6IHBhdHRlcm4sXG4gICAgYXJndW1lbnRzOiBhcmd0LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuLy8gSXQncyBjb252ZW5pZW50IHRvIGNvbnN0cnVjdCB0aGUgcHJvcGVydGllcyBhbmQgdGhlIG1ldGhvZCBmaWVsZHNcbi8vIGF0IHRoZSBzYW1lIHRpbWUsIHNpbmNlIGluIHRoZSBBUElzLCB2YWx1ZXMgZm9yIGJvdGggY2FuIGFwcGVhciBpblxuLy8gYG9wdGlvbnNgLiBTaW5jZSB0aGUgcHJvcGVydHkgb3IgbXRob2QgZmllbGQgbmFtZXMgZG9uJ3Qgb3ZlcmxhcCwgSVxuLy8ganVzdCByZXR1cm4gb25lIGJpZyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYm90aCBwdXJwb3NlcywgYW5kXG4vLyB0aGUgZW5jb2RlciB3aWxsIHBpY2sgb3V0IHdoYXQgaXQgd2FudHMuXG5BcmdzLnB1Ymxpc2ggPSBmdW5jdGlvbihleGNoYW5nZSwgcm91dGluZ0tleSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TO1xuXG4gIC8vIFRoZSBDQyBhbmQgQkNDIGZpZWxkcyBleHBlY3QgYW4gYXJyYXkgb2YgXCJsb25nc3RyXCIsIHdoaWNoIHdvdWxkXG4gIC8vIG5vcm1hbGx5IGJlIGJ1ZmZlciB2YWx1ZXMgaW4gSmF2YVNjcmlwdDsgaG93ZXZlciwgc2luY2UgYSBmaWVsZFxuICAvLyBhcnJheSAob3IgdGFibGUpIGNhbm5vdCBoYXZlIHNob3J0c3RyIHZhbHVlcywgdGhlIGNvZGVjIHdpbGxcbiAgLy8gZW5jb2RlIGFsbCBzdHJpbmdzIGFzIGxvbmdzdHJzIGFueXdheS5cbiAgZnVuY3Rpb24gY29udmVydENDKGNjKSB7XG4gICAgaWYgKGNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2MpKSB7XG4gICAgICByZXR1cm4gY2MubWFwKFN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIFtTdHJpbmcoY2MpXTtcbiAgfVxuXG4gIHZhciBoZWFkZXJzID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmhlYWRlcnMgfHwgbnVsbCk7XG4gIHNldElmRGVmaW5lZChoZWFkZXJzLCAnQ0MnLCBjb252ZXJ0Q0Mob3B0aW9ucy5DQykpO1xuICBzZXRJZkRlZmluZWQoaGVhZGVycywgJ0JDQycsIGNvbnZlcnRDQyhvcHRpb25zLkJDQykpO1xuXG4gIHZhciBkZWxpdmVyeU1vZGU7IC8vIHVuZGVmaW5lZCB3aWxsIGRlZmF1bHQgdG8gMSAobm9uLXBlcnNpc3RlbnQpXG5cbiAgLy8gUHJldmlvdXNseSBJIG92ZXJsb2FkZWQgZGVsaXZlcnlNb2RlIGJlIGEgYm9vbGVhbiBtZWFuaW5nXG4gIC8vICdwZXJzaXN0ZW50IG9yIG5vdCc7IGJldHRlciBpcyB0byBuYW1lIHRoaXMgb3B0aW9uIGZvciB3aGF0IGl0XG4gIC8vIGlzLCBidXQgSSBuZWVkIHRvIGhhdmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGVpdGhlciBzdXBwbHkgYSBudW1lcmljIG9yIGJvb2xlYW4gdmFsdWUuXG4gIGlmIChvcHRpb25zLnBlcnNpc3RlbnQgIT09IHVuZGVmaW5lZClcbiAgICBkZWxpdmVyeU1vZGUgPSAob3B0aW9ucy5wZXJzaXN0ZW50KSA/IDIgOiAxO1xuICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWxpdmVyeU1vZGUgPT09ICdudW1iZXInKVxuICAgIGRlbGl2ZXJ5TW9kZSA9IG9wdGlvbnMuZGVsaXZlcnlNb2RlO1xuICBlbHNlIGlmIChvcHRpb25zLmRlbGl2ZXJ5TW9kZSkgLy8gaXMgc3VwcGxpZWQgYW5kIHRydXRoeVxuICAgIGRlbGl2ZXJ5TW9kZSA9IDI7XG5cbiAgdmFyIGV4cGlyYXRpb24gPSBvcHRpb25zLmV4cGlyYXRpb247XG4gIGlmIChleHBpcmF0aW9uICE9PSB1bmRlZmluZWQpIGV4cGlyYXRpb24gPSBleHBpcmF0aW9uLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBtZXRob2QgZmllbGRzXG4gICAgZXhjaGFuZ2U6IGV4Y2hhbmdlLFxuICAgIHJvdXRpbmdLZXk6IHJvdXRpbmdLZXksXG4gICAgbWFuZGF0b3J5OiAhIW9wdGlvbnMubWFuZGF0b3J5LFxuICAgIGltbWVkaWF0ZTogZmFsc2UsIC8vIFJhYmJpdE1RIGRvZXNuJ3QgaW1wbGVtZW50IHRoaXMgYW55IG1vcmVcbiAgICB0aWNrZXQ6IHVuZGVmaW5lZCxcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgY29udGVudFR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUsXG4gICAgY29udGVudEVuY29kaW5nOiBvcHRpb25zLmNvbnRlbnRFbmNvZGluZyxcbiAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIGRlbGl2ZXJ5TW9kZTogZGVsaXZlcnlNb2RlLFxuICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5LFxuICAgIGNvcnJlbGF0aW9uSWQ6IG9wdGlvbnMuY29ycmVsYXRpb25JZCxcbiAgICByZXBseVRvOiBvcHRpb25zLnJlcGx5VG8sXG4gICAgZXhwaXJhdGlvbjogZXhwaXJhdGlvbixcbiAgICBtZXNzYWdlSWQ6IG9wdGlvbnMubWVzc2FnZUlkLFxuICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAsXG4gICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgIHVzZXJJZDogb3B0aW9ucy51c2VySWQsXG4gICAgYXBwSWQ6IG9wdGlvbnMuYXBwSWQsXG4gICAgY2x1c3RlcklkOiB1bmRlZmluZWRcbiAgfTtcbn07XG5cbkFyZ3MuY29uc3VtZSA9IGZ1bmN0aW9uKHF1ZXVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHZhciBhcmd0ID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmFyZ3VtZW50cyB8fCBudWxsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LXByaW9yaXR5Jywgb3B0aW9ucy5wcmlvcml0eSk7XG4gIHJldHVybiB7XG4gICAgdGlja2V0OiAwLFxuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBjb25zdW1lclRhZzogb3B0aW9ucy5jb25zdW1lclRhZyB8fCAnJyxcbiAgICBub0xvY2FsOiAhIW9wdGlvbnMubm9Mb2NhbCxcbiAgICBub0FjazogISFvcHRpb25zLm5vQWNrLFxuICAgIGV4Y2x1c2l2ZTogISFvcHRpb25zLmV4Y2x1c2l2ZSxcbiAgICBub3dhaXQ6IGZhbHNlLFxuICAgIGFyZ3VtZW50czogYXJndFxuICB9O1xufTtcblxuQXJncy5jYW5jZWwgPSBmdW5jdGlvbihjb25zdW1lclRhZykge1xuICByZXR1cm4ge1xuICAgIGNvbnN1bWVyVGFnOiBjb25zdW1lclRhZyxcbiAgICBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmdldCA9IGZ1bmN0aW9uKHF1ZXVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHJldHVybiB7XG4gICAgdGlja2V0OiAwLFxuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBub0FjazogISFvcHRpb25zLm5vQWNrXG4gIH07XG59O1xuXG5BcmdzLmFjayA9IGZ1bmN0aW9uKHRhZywgYWxsVXBUbykge1xuICByZXR1cm4ge1xuICAgIGRlbGl2ZXJ5VGFnOiB0YWcsXG4gICAgbXVsdGlwbGU6ICEhYWxsVXBUb1xuICB9O1xufTtcblxuQXJncy5uYWNrID0gZnVuY3Rpb24odGFnLCBhbGxVcFRvLCByZXF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgZGVsaXZlcnlUYWc6IHRhZyxcbiAgICBtdWx0aXBsZTogISFhbGxVcFRvLFxuICAgIHJlcXVldWU6IChyZXF1ZXVlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IHJlcXVldWVcbiAgfTtcbn07XG5cbkFyZ3MucmVqZWN0ID0gZnVuY3Rpb24odGFnLCByZXF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgZGVsaXZlcnlUYWc6IHRhZyxcbiAgICByZXF1ZXVlOiAocmVxdWV1ZSA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiByZXF1ZXVlXG4gIH07XG59O1xuXG5BcmdzLnByZWZldGNoID0gZnVuY3Rpb24oY291bnQsIGdsb2JhbCkge1xuICByZXR1cm4ge1xuICAgIHByZWZldGNoQ291bnQ6IGNvdW50IHx8IDAsXG4gICAgcHJlZmV0Y2hTaXplOiAwLFxuICAgIGdsb2JhbDogISFnbG9iYWxcbiAgfTtcbn07XG5cbkFyZ3MucmVjb3ZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge3JlcXVldWU6IHRydWV9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKEFyZ3MpO1xuIiwiLy9cbi8vXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBiaXRzZXQgaW1wbGVtZW50YXRpb24sIGFmdGVyIHRoYXQgaW4gamF2YS51dGlsLiAgWWVzIHRoZXJlXG4gKiBhbHJlYWR5IGV4aXN0IHN1Y2ggdGhpbmdzLCBidXQgbm9uZSBpbXBsZW1lbnQgbmV4dHtDbGVhcnxTZXR9Qml0IG9yXG4gKiBlcXVpdmFsZW50LCBhbmQgbm9uZSBpbnZvbHZlZCBtZSB0b29saW5nIGFib3V0IGZvciBhbiBldmVuaW5nLlxuICovXG5jbGFzcyBCaXRTZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgIGlmIChzaXplKSB7XG4gICAgICBjb25zdCBudW1Xb3JkcyA9IE1hdGguY2VpbChzaXplIC8gMzIpO1xuICAgICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheShudW1Xb3Jkcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy53b3JkcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLndvcmRzSW5Vc2UgPSAwOyAvLyA9IG51bWJlciwgbm90IGluZGV4XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bVdvcmRzXG4gICAqL1xuICBlbnN1cmVTaXplKG51bVdvcmRzKSB7XG4gICAgY29uc3Qgd29yZHNQcmVzZW50ID0gdGhpcy53b3Jkcy5sZW5ndGg7XG4gICAgaWYgKHdvcmRzUHJlc2VudCA8IG51bVdvcmRzKSB7XG4gICAgICB0aGlzLndvcmRzID0gdGhpcy53b3Jkcy5jb25jYXQobmV3IEFycmF5KG51bVdvcmRzIC0gd29yZHNQcmVzZW50KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRJbmRleFxuICAgKi9cbiAgc2V0KGJpdEluZGV4KSB7XG4gICAgY29uc3QgdyA9IHdvcmRJbmRleChiaXRJbmRleCk7XG4gICAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSB7XG4gICAgICB0aGlzLmVuc3VyZVNpemUodyArIDEpO1xuICAgICAgdGhpcy53b3Jkc0luVXNlID0gdyArIDE7XG4gICAgfVxuICAgIGNvbnN0IGJpdCA9IDEgPDwgYml0SW5kZXg7XG4gICAgdGhpcy53b3Jkc1t3XSB8PSBiaXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdEluZGV4XG4gICAqL1xuICBjbGVhcihiaXRJbmRleCkge1xuICAgIGNvbnN0IHcgPSB3b3JkSW5kZXgoYml0SW5kZXgpO1xuICAgIGlmICh3ID49IHRoaXMud29yZHNJblVzZSkgcmV0dXJuO1xuICAgIGNvbnN0IG1hc2sgPSB+KDEgPDwgYml0SW5kZXgpO1xuICAgIHRoaXMud29yZHNbd10gJj0gbWFzaztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0SW5kZXhcbiAgICovXG4gIGdldChiaXRJbmRleCkge1xuICAgIGNvbnN0IHcgPSB3b3JkSW5kZXgoYml0SW5kZXgpO1xuICAgIGlmICh3ID49IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIGZhbHNlOyAvLyA+PSBzaW5jZSBpbmRleCB2cyBzaXplXG4gICAgY29uc3QgYml0ID0gMSA8PCBiaXRJbmRleDtcbiAgICByZXR1cm4gISEodGhpcy53b3Jkc1t3XSAmIGJpdCk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZSB0aGUgbmV4dCBiaXQgdGhhdCBpcyBzZXQgb24gb3IgYWZ0ZXIgZnJvbUluZGV4LCBvciAtMSBpZiBubyBzdWNoIGJpdFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4XG4gICAqL1xuICBuZXh0U2V0Qml0KGZyb21JbmRleCkge1xuICAgIGxldCB3ID0gd29yZEluZGV4KGZyb21JbmRleCk7XG4gICAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gLTE7XG5cbiAgICAvLyB0aGUgcmlnaHQtaGFuZCBzaWRlIGlzIHNoaWZ0ZWQgdG8gb25seSB0ZXN0IHRoZSBiaXRzIG9mIHRoZSBmaXJzdFxuICAgIC8vIHdvcmQgdGhhdCBhcmUgPiBmcm9tSW5kZXhcbiAgICBsZXQgd29yZCA9IHRoaXMud29yZHNbd10gJiAoMHhmZmZmZmZmZiA8PCBmcm9tSW5kZXgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAod29yZCkgcmV0dXJuICh3ICogMzIpICsgdHJhaWxpbmdaZXJvcyh3b3JkKTtcbiAgICAgIHcrKztcbiAgICAgIGlmICh3ID09PSB0aGlzLndvcmRzSW5Vc2UpIHJldHVybiAtMTtcbiAgICAgIHdvcmQgPSB0aGlzLndvcmRzW3ddO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4XG4gICAqL1xuICBuZXh0Q2xlYXJCaXQoZnJvbUluZGV4KSB7XG4gICAgbGV0IHcgPSB3b3JkSW5kZXgoZnJvbUluZGV4KTtcbiAgICBpZiAodyA+PSB0aGlzLndvcmRzSW5Vc2UpIHJldHVybiBmcm9tSW5kZXg7XG5cbiAgICBsZXQgd29yZCA9IH4odGhpcy53b3Jkc1t3XSkgJiAoMHhmZmZmZmZmZiA8PCBmcm9tSW5kZXgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAod29yZCkgcmV0dXJuICh3ICogMzIpICsgdHJhaWxpbmdaZXJvcyh3b3JkKTtcbiAgICAgIHcrKztcbiAgICAgIGlmICh3ID09IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIHcgKiAzMjtcbiAgICAgIHdvcmQgPSB+KHRoaXMud29yZHNbd10pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRJbmRleFxuICovXG5mdW5jdGlvbiB3b3JkSW5kZXgoYml0SW5kZXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYml0SW5kZXggLyAzMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZnVuY3Rpb24gdHJhaWxpbmdaZXJvcyhpKSB7XG4gIC8vIEZyb20gSGFja2VyJ3MgRGVsaWdodCwgdmlhIEpESy4gUHJvYmFibHkgZmFyIGxlc3MgZWZmZWN0aXZlIGhlcmUsXG4gIC8vIHNpbmNlIGJpdCBvcHMgYXJlIG5vdCBuZWNlc3NhcmlseSB0aGUgcXVpY2sgd2F5IHRvIGRvIHRoaW5ncyBpblxuICAvLyBKUy5cbiAgaWYgKGkgPT09IDApIHJldHVybiAzMjtcbiAgbGV0IHksIG4gPSAzMTtcbiAgeSA9IGkgPDwgMTY7IGlmICh5ICE9IDApIHsgbiA9IG4gLTE2OyBpID0geTsgfVxuICB5ID0gaSA8PCA4OyAgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDg7IGkgPSB5OyB9XG4gIHkgPSBpIDw8IDQ7ICBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gNDsgaSA9IHk7IH1cbiAgeSA9IGkgPDwgMjsgIGlmICh5ICE9IDApIHsgbiA9IG4gLSAyOyBpID0geTsgfVxuICByZXR1cm4gbiAtICgoaSA8PCAxKSA+Pj4gMzEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5CaXRTZXQgPSBCaXRTZXQ7XG4iLCIvL1xuLy9cbi8vXG5cbi8vIENoYW5uZWwgbWFjaGluZXJ5LlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgY2xvc2VNc2cgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLmNsb3NlTWVzc2FnZTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5pbnNwZWN0O1xudmFyIG1ldGhvZE5hbWUgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLm1ldGhvZE5hbWU7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGZtdCA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG52YXIgSWxsZWdhbE9wZXJhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLklsbGVnYWxPcGVyYXRpb25FcnJvcjtcbnZhciBzdGFja0NhcHR1cmUgPSByZXF1aXJlKCcuL2Vycm9yJykuc3RhY2tDYXB0dXJlO1xuZnVuY3Rpb24gQ2hhbm5lbChjb25uZWN0aW9uKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKCB0aGlzICk7XG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gIC8vIGZvciB0aGUgcHJlc2VudGx5IG91dHN0YW5kaW5nIFJQQ1xuICB0aGlzLnJlcGx5ID0gbnVsbDtcbiAgLy8gZm9yIHRoZSBSUENzIGF3YWl0aW5nIGFjdGlvblxuICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgLy8gZm9yIHVuY29uZmlybWVkIG1lc3NhZ2VzXG4gIHRoaXMubHdtID0gMTsgLy8gdGhlIGxlYXN0LCB1bmNvbmZpcm1lZCBkZWxpdmVyeVRhZ1xuICB0aGlzLnVuY29uZmlybWVkID0gW107IC8vIHJvbGxpbmcgd2luZG93IG9mIGRlbGl2ZXJ5IGNhbGxiYWNrc1xuICB0aGlzLm9uKCdhY2snLCB0aGlzLmhhbmRsZUNvbmZpcm0uYmluZCh0aGlzLCBmdW5jdGlvbihjYikge1xuICAgIGlmIChjYikgY2IobnVsbCk7XG4gIH0pKTtcbiAgdGhpcy5vbignbmFjaycsIHRoaXMuaGFuZGxlQ29uZmlybS5iaW5kKHRoaXMsIGZ1bmN0aW9uKGNiKSB7XG4gICAgaWYgKGNiKSBjYihuZXcgRXJyb3IoJ21lc3NhZ2UgbmFja2VkJykpO1xuICB9KSk7XG4gIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYjtcbiAgICB3aGlsZSAoY2IgPSB0aGlzLnVuY29uZmlybWVkLnNoaWZ0KCkpIHtcbiAgICAgIGlmIChjYikgY2IobmV3IEVycm9yKCdjaGFubmVsIGNsb3NlZCcpKTtcbiAgICB9XG4gIH0pXG4gIC8vIG1lc3NhZ2UgZnJhbWUgc3RhdGUgbWFjaGluZVxuICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSBhY2NlcHREZWxpdmVyeU9yUmV0dXJuO1xufVxuaW5oZXJpdHMoQ2hhbm5lbCwgRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5hY2NlcHRNZXNzYWdlID0gYWNjZXB0TWVzc2FnZTtcblxudmFyIEMgPSBDaGFubmVsLnByb3RvdHlwZTtcblxuQy5hbGxvY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNoID0gdGhpcy5jb25uZWN0aW9uLmZyZXNoQ2hhbm5lbCh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEluY29taW5nIGZyYW1lcyBhcmUgZWl0aGVyIG5vdGlmaWNhdGlvbnMgb2YgZS5nLiwgbWVzc2FnZSBkZWxpdmVyeSxcbi8vIG9yIHJlcGxpZXMgdG8gc29tZXRoaW5nIHdlJ3ZlIHNlbnQuIEluIGdlbmVyYWwgSSBkZWFsIHdpdGggdGhlXG4vLyBmb3JtZXIgYnkgZW1pdHRpbmcgYW4gZXZlbnQsIGFuZCB3aXRoIHRoZSBsYXR0ZXIgYnkga2VlcGluZyBhIHRyYWNrXG4vLyBvZiB3aGF0J3MgZXhwZWN0aW5nIGEgcmVwbHkuXG4vL1xuLy8gVGhlIEFNUVAgc3BlY2lmaWNhdGlvbiBpbXBsaWVzIHRoYXQgUlBDcyBjYW4ndCBiZSBwaXBlbGluZWQ7IHRoYXRcbi8vIGlzLCB5b3UgY2FuIGhhdmUgb25seSBvbmUgb3V0c3RhbmRpbmcgUlBDIG9uIGEgY2hhbm5lbCBhdCBhXG4vLyB0aW1lLiBDZXJ0YWlubHkgdGhhdCdzIHdoYXQgUmFiYml0TVEgYW5kIGl0cyBjbGllbnRzIGFzc3VtZS4gRm9yXG4vLyB0aGlzIHJlYXNvbiwgSSBidWZmZXIgUlBDcyBpZiB0aGUgY2hhbm5lbCBpcyBhbHJlYWR5IHdhaXRpbmcgZm9yIGFcbi8vIHJlcGx5LlxuXG4vLyBKdXN0IHNlbmQgdGhlIGRhbW4gZnJhbWUuXG5DLnNlbmRJbW1lZGlhdGVseSA9IGZ1bmN0aW9uKG1ldGhvZCwgZmllbGRzKSB7XG4gIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZE1ldGhvZCh0aGlzLmNoLCBtZXRob2QsIGZpZWxkcyk7XG59O1xuXG4vLyBJbnZhcmlhbnQ6ICF0aGlzLnJlcGx5IC0+IHBlbmRpbmcubGVuZ3RoID09IDAuIFRoYXQgaXMsIHdoZW5ldmVyIHdlXG4vLyBjbGVhciBhIHJlcGx5LCB3ZSBtdXN0IHNlbmQgYW5vdGhlciBSUEMgKGFuZCB0aGVyZWJ5IGZpbGxcbi8vIHRoaXMucmVwbHkpIGlmIHRoZXJlIGlzIG9uZSB3YWl0aW5nLiBUaGUgaW52YXJpYW50IHJlbGV2YW50IGhlcmVcbi8vIGFuZCBpbiBgYWNjZXB0YC5cbkMuc2VuZE9yRW5xdWV1ZSA9IGZ1bmN0aW9uKG1ldGhvZCwgZmllbGRzLCByZXBseSkge1xuICBpZiAoIXRoaXMucmVwbHkpIHsgLy8gaWYgbm8gcmVwbHkgd2FpdGluZywgd2UgY2FuIGdvXG4gICAgYXNzZXJ0KHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApO1xuICAgIHRoaXMucmVwbHkgPSByZXBseTtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShtZXRob2QsIGZpZWxkcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5wZW5kaW5nLnB1c2goe21ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgcmVwbHk6IHJlcGx5fSk7XG4gIH1cbn07XG5cbkMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihmaWVsZHMsIHByb3BlcnRpZXMsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kTWVzc2FnZShcbiAgICB0aGlzLmNoLFxuICAgIGRlZnMuQmFzaWNQdWJsaXNoLCBmaWVsZHMsXG4gICAgZGVmcy5CYXNpY1Byb3BlcnRpZXMsIHByb3BlcnRpZXMsXG4gICAgY29udGVudCk7XG59O1xuXG4vLyBJbnRlcm5hbCwgc3luY2hyb25vdXNseSByZXNvbHZlZCBSUEM7IHRoZSByZXR1cm4gdmFsdWUgaXMgcmVzb2x2ZWRcbi8vIHdpdGggdGhlIHdob2xlIGZyYW1lLlxuQy5fcnBjID0gZnVuY3Rpb24obWV0aG9kLCBmaWVsZHMsIGV4cGVjdCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHJlcGx5KGVyciwgZikge1xuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIGlmIChmLmlkID09PSBleHBlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGYpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFdlIGhhdmUgZGV0ZWN0ZWQgYSBwcm9ibGVtLCBzbyBpdCdzIHVwIHRvIHVzIHRvIGNsb3NlIHRoZVxuICAgICAgICAvLyBjaGFubmVsXG4gICAgICAgIHZhciBleHBlY3RlZE5hbWUgPSBtZXRob2ROYW1lKGV4cGVjdCk7XG5cbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoZm10KFwiRXhwZWN0ZWQgJXM7IGdvdCAlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWROYW1lLCBpbnNwZWN0KGYsIGZhbHNlKSkpO1xuICAgICAgICBzZWxmLmNsb3NlV2l0aEVycm9yKGYuaWQsIGZtdCgnRXhwZWN0ZWQgJXM7IGdvdCAlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTmFtZSwgbWV0aG9kTmFtZShmLmlkKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5jb25zdGFudHMuVU5FWFBFQ1RFRF9GUkFNRSwgZSk7XG4gICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQW4gZXJyb3Igd2lsbCBiZSBnaXZlbiBpZiwgZm9yIGV4YW1wbGUsIHRoaXMgaXMgd2FpdGluZyB0byBiZVxuICAgIC8vIHNlbnQgYW5kIHRoZSBjb25uZWN0aW9uIGNsb3Nlc1xuICAgIGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gY2IoZXJyKTtcbiAgICAvLyBBIGNsb3NlIGZyYW1lIHdpbGwgYmUgZ2l2ZW4gaWYgdGhpcyBpcyB0aGUgUlBDIGF3YWl0aW5nIHJlcGx5XG4gICAgLy8gYW5kIHRoZSBjaGFubmVsIGlzIGNsb3NlZCBieSB0aGUgc2VydmVyXG4gICAgZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIGl0J3MgYSBjbG9zZSBmcmFtZVxuICAgICAgdmFyIGNsb3NlUmVhc29uID1cbiAgICAgICAgKGVyci5maWVsZHMuY2xhc3NJZCA8PCAxNikgKyBlcnIuZmllbGRzLm1ldGhvZElkO1xuICAgICAgdmFyIGUgPSAobWV0aG9kID09PSBjbG9zZVJlYXNvbilcbiAgICAgICAgPyBmbXQoXCJPcGVyYXRpb24gZmFpbGVkOiAlczsgJXNcIixcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZShtZXRob2QpLCBjbG9zZU1zZyhlcnIpKVxuICAgICAgICA6IGZtdChcIkNoYW5uZWwgY2xvc2VkIGJ5IHNlcnZlcjogJXNcIiwgY2xvc2VNc2coZXJyKSk7XG4gICAgICB2YXIgY2xvc2VGcmFtZUVycm9yID0gbmV3IEVycm9yKGUpO1xuICAgICAgY2xvc2VGcmFtZUVycm9yLmNvZGUgPSBlcnIuZmllbGRzLnJlcGx5Q29kZTtcbiAgICAgIGNsb3NlRnJhbWVFcnJvci5jbGFzc0lkID0gZXJyLmZpZWxkcy5jbGFzc0lkO1xuICAgICAgY2xvc2VGcmFtZUVycm9yLm1ldGhvZElkID0gZXJyLmZpZWxkcy5tZXRob2RJZDtcbiAgICAgIHJldHVybiBjYihjbG9zZUZyYW1lRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2VuZE9yRW5xdWV1ZShtZXRob2QsIGZpZWxkcywgcmVwbHkpO1xufTtcblxuLy8gU2h1dGRvd24gcHJvdG9jb2wuIFRoZXJlJ3MgdGhyZWUgc2NlbmFyaW9zOlxuLy9cbi8vIDEuIFRoZSBhcHBsaWNhdGlvbiBkZWNpZGVzIHRvIHNodXQgdGhlIGNoYW5uZWxcbi8vIDIuIFRoZSBzZXJ2ZXIgZGVjaWRlcyB0byBzaHV0IHRoZSBjaGFubmVsLCBwb3NzaWJseSBiZWNhdXNlIG9mXG4vLyBzb21ldGhpbmcgdGhlIGFwcGxpY2F0aW9uIGRpZFxuLy8gMy4gVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZywgc28gdGhlcmUgd29uJ3QgYmUgYW55IG1vcmUgZnJhbWVzXG4vLyBnb2luZyBiYWNrIGFuZCBmb3J0aC5cbi8vXG4vLyAxIGFuZCAyIGludm9sdmUgYW4gZXhjaGFuZ2Ugb2YgbWV0aG9kIGZyYW1lcyAoQ2xvc2UgYW5kIENsb3NlT2spLFxuLy8gd2hpbGUgMyBkb2Vzbid0OyB0aGUgY29ubmVjdGlvbiBzaW1wbHkgc2F5cyBcInNodXRkb3duXCIgdG8gdGhlXG4vLyBjaGFubmVsLCB3aGljaCB0aGVuIGFjdHMgYXMgaWYgaXQncyBjbG9zaW5nLCB3aXRob3V0IGdvaW5nIHRocm91Z2hcbi8vIHRoZSBleGNoYW5nZS5cblxuZnVuY3Rpb24gaW52YWxpZE9wKG1zZywgc3RhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IobXNnLCBzdGFjayk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVTZW5kKGNoLCBtc2csIHN0YWNrKSB7XG4gIGNoLnNlbmRJbW1lZGlhdGVseSA9IGNoLnNlbmRPckVucXVldWUgPSBjaC5zZW5kTWVzc2FnZSA9XG4gICAgaW52YWxpZE9wKG1zZywgc3RhY2spO1xufVxuXG4vLyBNb3ZlIHRvIGVudGlyZWx5IGNsb3NlZCBzdGF0ZS5cbkMudG9DbG9zZWQgPSBmdW5jdGlvbihjYXB0dXJlZFN0YWNrKSB7XG4gIHRoaXMuX3JlamVjdFBlbmRpbmcoKTtcbiAgaW52YWxpZGF0ZVNlbmQodGhpcywgJ0NoYW5uZWwgY2xvc2VkJywgY2FwdHVyZWRTdGFjayk7XG4gIHRoaXMuYWNjZXB0ID0gaW52YWxpZE9wKCdDaGFubmVsIGNsb3NlZCcsIGNhcHR1cmVkU3RhY2spO1xuICB0aGlzLmNvbm5lY3Rpb24ucmVsZWFzZUNoYW5uZWwodGhpcy5jaCk7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbi8vIFN0b3AgYmVpbmcgYWJsZSB0byBzZW5kIGFuZCByZWNlaXZlIG1ldGhvZHMgYW5kIGNvbnRlbnQuIFVzZWQgd2hlblxuLy8gd2UgY2xvc2UgdGhlIGNoYW5uZWwuIEludm9rZXMgdGhlIGNvbnRpbnVhdGlvbiBvbmNlIHRoZSBzZXJ2ZXIgaGFzXG4vLyBhY2tub3dsZWRnZWQgdGhlIGNsb3NlLCBidXQgYmVmb3JlIHRoZSBjaGFubmVsIGlzIG1vdmVkIHRvIHRoZVxuLy8gY2xvc2VkIHN0YXRlLlxuQy50b0Nsb3NpbmcgPSBmdW5jdGlvbihjYXB0dXJlZFN0YWNrLCBrKSB7XG4gIHZhciBzZW5kID0gdGhpcy5zZW5kSW1tZWRpYXRlbHkuYmluZCh0aGlzKTtcbiAgaW52YWxpZGF0ZVNlbmQodGhpcywgJ0NoYW5uZWwgY2xvc2luZycsIGNhcHR1cmVkU3RhY2spO1xuXG4gIHRoaXMuYWNjZXB0ID0gZnVuY3Rpb24oZikge1xuICAgIGlmIChmLmlkID09PSBkZWZzLkNoYW5uZWxDbG9zZU9rKSB7XG4gICAgICBpZiAoaykgaygpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ0NoYW5uZWxDbG9zZU9rIGZyYW1lIHJlY2VpdmVkJyk7XG4gICAgICB0aGlzLnRvQ2xvc2VkKHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNoYW5uZWxDbG9zZSkge1xuICAgICAgc2VuZChkZWZzLkNoYW5uZWxDbG9zZU9rLCB7fSk7XG4gICAgfVxuICAgIC8vIGVsc2UgaWdub3JlIGZyYW1lXG4gIH07XG59O1xuXG5DLl9yZWplY3RQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHJlaihyKSB7XG4gICAgcihuZXcgRXJyb3IoXCJDaGFubmVsIGVuZGVkLCBubyByZXBseSB3aWxsIGJlIGZvcnRoY29taW5nXCIpKTtcbiAgfVxuICBpZiAodGhpcy5yZXBseSAhPT0gbnVsbCkgcmVqKHRoaXMucmVwbHkpO1xuICB0aGlzLnJlcGx5ID0gbnVsbDtcblxuICB2YXIgZGlzY2FyZDtcbiAgd2hpbGUgKGRpc2NhcmQgPSB0aGlzLnBlbmRpbmcuc2hpZnQoKSkgcmVqKGRpc2NhcmQucmVwbHkpO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsOyAvLyBzbyBwdXNoZXMgd2lsbCBicmVha1xufTtcblxuQy5jbG9zZUJlY2F1c2UgPSBmdW5jdGlvbihyZWFzb24sIGNvZGUsIGspIHtcbiAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5DaGFubmVsQ2xvc2UsIHtcbiAgICByZXBseVRleHQ6IHJlYXNvbixcbiAgICByZXBseUNvZGU6IGNvZGUsXG4gICAgbWV0aG9kSWQ6MCwgY2xhc3NJZDogMFxuICB9KTtcbiAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ2Nsb3NlQmVjYXVzZSBjYWxsZWQ6ICcgKyByZWFzb24pO1xuICB0aGlzLnRvQ2xvc2luZyhzLCBrKTtcbn07XG5cbi8vIElmIHdlIGNsb3NlIGJlY2F1c2UgdGhlcmUncyBiZWVuIGFuIGVycm9yLCB3ZSBuZWVkIHRvIGRpc3Rpbmd1aXNoXG4vLyBiZXR3ZWVuIHdoYXQgd2UgdGVsbCB0aGUgc2VydmVyIChgcmVhc29uYCkgYW5kIHdoYXQgd2UgcmVwb3J0IGFzXG4vLyB0aGUgY2F1c2UgaW4gdGhlIGNsaWVudCAoYGVycm9yYCkuXG5DLmNsb3NlV2l0aEVycm9yID0gZnVuY3Rpb24oaWQsIHJlYXNvbiwgY29kZSwgZXJyb3IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmNsb3NlQmVjYXVzZShyZWFzb24sIGNvZGUsIGZ1bmN0aW9uKCkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgIC8vIGNvbnRlbnQgZnJhbWVzIGFuZCBjb25zdW1lciBlcnJvcnMgZG8gbm90IHByb3ZpZGUgYSBtZXRob2QgYSBjbGFzcy9tZXRob2QgSURcbiAgICBpZiAoaWQpIHtcbiAgICAgIGVycm9yLmNsYXNzSWQgPSBkZWZzLmluZm8oaWQpLmNsYXNzSWQ7XG4gICAgICBlcnJvci5tZXRob2RJZCA9IGRlZnMuaW5mbyhpZCkubWV0aG9kSWQ7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIH0pO1xufTtcblxuLy8gQSB0cmFtcG9saW5pbmcgc3RhdGUgbWFjaGluZSBmb3IgbWVzc2FnZSBmcmFtZXMgb24gYSBjaGFubmVsLiBBXG4vLyBtZXNzYWdlIGFycml2ZXMgaW4gYXQgbGVhc3QgdHdvIGZyYW1lczogZmlyc3QsIGEgbWV0aG9kIGFubm91bmNpbmdcbi8vIHRoZSBtZXNzYWdlIChlaXRoZXIgYSBCYXNpY0RlbGl2ZXIgb3IgQmFzaWNHZXRPayk7IHRoZW4sIGEgbWVzc2FnZVxuLy8gaGVhZGVyIHdpdGggdGhlIG1lc3NhZ2UgcHJvcGVydGllczsgdGhlbiwgemVybyBvciBtb3JlIGNvbnRlbnRcbi8vIGZyYW1lcy5cblxuLy8gS2VlcCB0aGUgdHJ5L2NhdGNoIGxvY2FsaXNlZCwgaW4gYW4gYXR0ZW1wdCB0byBhdm9pZCBkaXNhYmxpbmdcbi8vIG9wdGltaXNhdGlvblxuQy5hY2NlcHRNZXNzYWdlRnJhbWUgPSBmdW5jdGlvbihmKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5oYW5kbGVNZXNzYWdlID0gdGhpcy5oYW5kbGVNZXNzYWdlKGYpO1xuICB9XG4gIGNhdGNoIChtc2cpIHtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZi5pZCwgbXNnLCBkZWZzLmNvbnN0YW50cy5VTkVYUEVDVEVEX0ZSQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IobXNnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKGYuaWQsICdFcnJvciB3aGlsZSBwcm9jZXNzaW5nIG1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLmNvbnN0YW50cy5JTlRFUk5BTF9FUlJPUiwgbXNnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKGYuaWQsICdJbnRlcm5hbCBlcnJvciB3aGlsZSBwcm9jZXNzaW5nIG1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLmNvbnN0YW50cy5JTlRFUk5BTF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKG1zZy50b1N0cmluZygpKSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBLaWNrIG9mZiBhIG1lc3NhZ2UgZGVsaXZlcnkgZ2l2ZW4gYSBCYXNpY0RlbGl2ZXIgb3IgQmFzaWNSZXR1cm5cbi8vIGZyYW1lIChCYXNpY0dldCB1c2VzIHRoZSBSUEMgbWVjaGFuaXNtKVxuZnVuY3Rpb24gYWNjZXB0RGVsaXZlcnlPclJldHVybihmKSB7XG4gIHZhciBldmVudDtcbiAgaWYgKGYuaWQgPT09IGRlZnMuQmFzaWNEZWxpdmVyKSBldmVudCA9ICdkZWxpdmVyeSc7XG4gIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQmFzaWNSZXR1cm4pIGV2ZW50ID0gJ3JldHVybic7XG4gIGVsc2UgdGhyb3cgZm10KFwiRXhwZWN0ZWQgQmFzaWNEZWxpdmVyIG9yIEJhc2ljUmV0dXJuOyBnb3QgJXNcIixcbiAgICAgICAgICAgICAgICAgaW5zcGVjdChmKSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZmllbGRzID0gZi5maWVsZHM7XG4gIHJldHVybiBhY2NlcHRNZXNzYWdlKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlLmZpZWxkcyA9IGZpZWxkcztcbiAgICBzZWxmLmVtaXQoZXZlbnQsIG1lc3NhZ2UpO1xuICB9KTtcbn1cblxuLy8gTW92ZSB0byB0aGUgc3RhdGUgb2Ygd2FpdGluZyBmb3IgbWVzc2FnZSBmcmFtZXMgKGhlYWRlcnMsIHRoZW5cbi8vIG9uZSBvciBtb3JlIGNvbnRlbnQgZnJhbWVzKVxuZnVuY3Rpb24gYWNjZXB0TWVzc2FnZShjb250aW51YXRpb24pIHtcbiAgdmFyIHRvdGFsU2l6ZSA9IDAsIHJlbWFpbmluZyA9IDA7XG4gIHZhciBidWZmZXJzID0gbnVsbDtcblxuICB2YXIgbWVzc2FnZSA9IHtcbiAgICBmaWVsZHM6IG51bGwsXG4gICAgcHJvcGVydGllczogbnVsbCxcbiAgICBjb250ZW50OiBudWxsXG4gIH07XG5cbiAgcmV0dXJuIGhlYWRlcnM7XG5cbiAgLy8gZXhwZWN0IGEgaGVhZGVycyBmcmFtZVxuICBmdW5jdGlvbiBoZWFkZXJzKGYpIHtcbiAgICBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY1Byb3BlcnRpZXMpIHtcbiAgICAgIG1lc3NhZ2UucHJvcGVydGllcyA9IGYuZmllbGRzO1xuICAgICAgdG90YWxTaXplID0gcmVtYWluaW5nID0gZi5zaXplO1xuXG4gICAgICAvLyBmb3IgemVyby1sZW5ndGggbWVzc2FnZXMsIGNvbnRlbnQgZnJhbWVzIGFyZW4ndCByZXF1aXJlZC5cbiAgICAgIGlmICh0b3RhbFNpemUgPT09IDApIHtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBjb250aW51YXRpb24obWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhY2NlcHREZWxpdmVyeU9yUmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IFwiRXhwZWN0ZWQgaGVhZGVycyBmcmFtZSBhZnRlciBkZWxpdmVyeVwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cGVjdCBhIGNvbnRlbnQgZnJhbWVcbiAgLy8gJSUlIFRPRE8gY2FuY2VsbGVkIG1lc3NhZ2VzIChzZW50IGFzIHplcm8tbGVuZ3RoIGNvbnRlbnQgZnJhbWUpXG4gIGZ1bmN0aW9uIGNvbnRlbnQoZikge1xuICAgIGlmIChmLmNvbnRlbnQpIHtcbiAgICAgIHZhciBzaXplID0gZi5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHJlbWFpbmluZyAtPSBzaXplO1xuICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBpZiAoYnVmZmVycyAhPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZlcnMucHVzaChmLmNvbnRlbnQpO1xuICAgICAgICAgIG1lc3NhZ2UuY29udGVudCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gZi5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGFjY2VwdERlbGl2ZXJ5T3JSZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZW1haW5pbmcgPCAwKSB7XG4gICAgICAgIHRocm93IGZtdChcIlRvbyBtdWNoIGNvbnRlbnQgc2VudCEgRXhwZWN0ZWQgJWQgYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlcnMgIT09IG51bGwpXG4gICAgICAgICAgYnVmZmVycy5wdXNoKGYuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWZmZXJzID0gW2YuY29udGVudF07XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHRocm93IFwiRXhwZWN0ZWQgY29udGVudCBmcmFtZSBhZnRlciBoZWFkZXJzXCJcbiAgfVxufVxuXG5DLmhhbmRsZUNvbmZpcm0gPSBmdW5jdGlvbihoYW5kbGUsIGYpIHtcbiAgdmFyIHRhZyA9IGYuZGVsaXZlcnlUYWc7XG4gIHZhciBtdWx0aSA9IGYubXVsdGlwbGU7XG5cbiAgaWYgKG11bHRpKSB7XG4gICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMudW5jb25maXJtZWQuc3BsaWNlKDAsIHRhZyAtIHRoaXMubHdtICsgMSk7XG4gICAgdGhpcy5sd20gPSB0YWcgKyAxO1xuICAgIGNvbmZpcm1lZC5mb3JFYWNoKGhhbmRsZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGM7XG4gICAgaWYgKHRhZyA9PT0gdGhpcy5sd20pIHtcbiAgICAgIGMgPSB0aGlzLnVuY29uZmlybWVkLnNoaWZ0KCk7XG4gICAgICB0aGlzLmx3bSsrO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgTFdNIGFuZCB0aGUgd2luZG93IHRvIHRoZSBuZXh0IG5vbi1nYXAsIG9yXG4gICAgICAvLyBwb3NzaWJseSB0byB0aGUgZW5kXG4gICAgICB3aGlsZSAodGhpcy51bmNvbmZpcm1lZFswXSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuY29uZmlybWVkLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMubHdtKys7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYyA9IHRoaXMudW5jb25maXJtZWRbdGFnIC0gdGhpcy5sd21dO1xuICAgICAgdGhpcy51bmNvbmZpcm1lZFt0YWcgLSB0aGlzLmx3bV0gPSBudWxsO1xuICAgIH1cbiAgICAvLyBUZWNobmljYWxseSwgaW4gdGhlIHNpbmdsZS1kZWxpdmVyeVRhZyBjYXNlLCBJIHNob3VsZCByZXBvcnQgYVxuICAgIC8vIHByb3RvY29sIGJyZWFjaCBpZiBpdCdzIGFscmVhZHkgYmVlbiBjb25maXJtZWQuXG4gICAgaGFuZGxlKGMpO1xuICB9XG59O1xuXG5DLnB1c2hDb25maXJtQ2FsbGJhY2sgPSBmdW5jdGlvbihjYikge1xuICAvLyBgbnVsbGAgaXMgdXNlZCBzcGVjaWZpY2FsbHkgZm9yIG1hcmtpbmcgYWxyZWFkeSBjb25maXJtZWQgc2xvdHMsXG4gIC8vIHNvIEkgY29lcmNlIGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgdG8gZmFsc2U7IGZ1bmN0aW9ucyBhcmUgbmV2ZXJcbiAgLy8gZmFsc2V5LlxuICB0aGlzLnVuY29uZmlybWVkLnB1c2goY2IgfHwgZmFsc2UpO1xufTtcblxuLy8gSW50ZXJmYWNlIGZvciBjb25uZWN0aW9uIHRvIHVzZVxuXG5DLmFjY2VwdCA9IGZ1bmN0aW9uKGYpIHtcblxuICBzd2l0Y2ggKGYuaWQpIHtcblxuICAgIC8vIE1lc3NhZ2UgZnJhbWVzXG4gIGNhc2UgdW5kZWZpbmVkOiAvLyBjb250ZW50IGZyYW1lIVxuICBjYXNlIGRlZnMuQmFzaWNEZWxpdmVyOlxuICBjYXNlIGRlZnMuQmFzaWNSZXR1cm46XG4gIGNhc2UgZGVmcy5CYXNpY1Byb3BlcnRpZXM6XG4gICAgcmV0dXJuIHRoaXMuYWNjZXB0TWVzc2FnZUZyYW1lKGYpO1xuXG4gICAgLy8gY29uZmlybWF0aW9ucywgbmVlZCB0byBkbyBjb25maXJtLnNlbGVjdCBmaXJzdFxuICBjYXNlIGRlZnMuQmFzaWNBY2s6XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnYWNrJywgZi5maWVsZHMpO1xuICBjYXNlIGRlZnMuQmFzaWNOYWNrOlxuICAgIHJldHVybiB0aGlzLmVtaXQoJ25hY2snLCBmLmZpZWxkcyk7XG4gIGNhc2UgZGVmcy5CYXNpY0NhbmNlbDpcbiAgICAvLyBUaGUgYnJva2VyIGNhbiBzZW5kIHRoaXMgaWYgZS5nLiwgdGhlIHF1ZXVlIGlzIGRlbGV0ZWQuXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnY2FuY2VsJywgZi5maWVsZHMpO1xuXG4gIGNhc2UgZGVmcy5DaGFubmVsQ2xvc2U6XG4gICAgLy8gQW55IHJlbW90ZSBjbG9zdXJlIGlzIGFuIGVycm9yIHRvIHVzLiBSZWplY3QgdGhlIHBlbmRpbmcgcmVwbHlcbiAgICAvLyB3aXRoIHRoZSBjbG9zZSBmcmFtZSwgc28gaXQgY2FuIHNlZSB3aGV0aGVyIGl0IHdhcyB0aGF0XG4gICAgLy8gb3BlcmF0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIGNsb3NlLlxuICAgIGlmICh0aGlzLnJlcGx5KSB7XG4gICAgICB2YXIgcmVwbHkgPSB0aGlzLnJlcGx5OyB0aGlzLnJlcGx5ID0gbnVsbDtcbiAgICAgIHJlcGx5KGYpO1xuICAgIH1cbiAgICB2YXIgZW1zZyA9IFwiQ2hhbm5lbCBjbG9zZWQgYnkgc2VydmVyOiBcIiArIGNsb3NlTXNnKGYpO1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KGRlZnMuQ2hhbm5lbENsb3NlT2ssIHt9KTtcblxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlbXNnKTtcbiAgICBlcnJvci5jb2RlID0gZi5maWVsZHMucmVwbHlDb2RlO1xuICAgIGVycm9yLmNsYXNzSWQgPSBmLmZpZWxkcy5jbGFzc0lkO1xuICAgIGVycm9yLm1ldGhvZElkID0gZi5maWVsZHMubWV0aG9kSWQ7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcblxuICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKGVtc2cpO1xuICAgIHRoaXMudG9DbG9zZWQocyk7XG4gICAgcmV0dXJuO1xuXG4gIGNhc2UgZGVmcy5CYXNpY0Zsb3c6XG4gICAgLy8gUmFiYml0TVEgZG9lc24ndCBzZW5kIHRoaXMsIGl0IGp1c3QgYmxvY2tzIHRoZSBUQ1Agc29ja2V0XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VXaXRoRXJyb3IoZi5pZCwgXCJGbG93IG5vdCBpbXBsZW1lbnRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLk5PVF9JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0Zsb3cgbm90IGltcGxlbWVudGVkJykpO1xuXG4gIGRlZmF1bHQ6IC8vIGFzc3VtZSBhbGwgb3RoZXIgdGhpbmdzIGFyZSByZXBsaWVzXG4gICAgLy8gUmVzb2x2aW5nIHRoZSByZXBseSBtYXkgbGVhZCB0byBhbm90aGVyIFJQQzsgdG8gbWFrZSBzdXJlIHdlXG4gICAgLy8gZG9uJ3QgaG9sZCB0aGF0IHVwLCBjbGVhciB0aGlzLnJlcGx5XG4gICAgdmFyIHJlcGx5ID0gdGhpcy5yZXBseTsgdGhpcy5yZXBseSA9IG51bGw7XG4gICAgLy8gaG93ZXZlciwgbWF5YmUgdGhlcmUncyBhbiBSUEMgd2FpdGluZyB0byBnbz8gSWYgc28sIHRoYXQnbGxcbiAgICAvLyBmaWxsIHRoaXMucmVwbHkgYWdhaW4sIHJlc3RvcmluZyB0aGUgaW52YXJpYW50LiBUaGlzIGRvZXMgcmVseVxuICAgIC8vIG9uIGFueSByZXNwb25zZSBiZWluZyByZWN2J2VkIGFmdGVyIHJlc29sdmluZyB0aGUgcHJvbWlzZSxcbiAgICAvLyBiZWxvdzsgaGVuY2UsIEkgdXNlIHN5bmNocm9ub3VzIGRlZmVyLlxuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHNlbmQgPSB0aGlzLnBlbmRpbmcuc2hpZnQoKTtcbiAgICAgIHRoaXMucmVwbHkgPSBzZW5kLnJlcGx5O1xuICAgICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoc2VuZC5tZXRob2QsIHNlbmQuZmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5KG51bGwsIGYpO1xuICB9XG59O1xuXG5DLm9uQnVmZmVyRHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdkcmFpbicpO1xufTtcblxuXG4vLyBUaGlzIGFkZHMganVzdCBhIGJpdCBtb3JlIHN0dWZmIHVzZWZ1bCBmb3IgdGhlIEFQSXMsIGJ1dCBub3Rcbi8vIGxvdy1sZXZlbCBtYWNoaW5lcnkuXG5mdW5jdGlvbiBCYXNlQ2hhbm5lbChjb25uZWN0aW9uKSB7XG4gIENoYW5uZWwuY2FsbCh0aGlzLCBjb25uZWN0aW9uKTtcbiAgdGhpcy5jb25zdW1lcnMgPSBuZXcgTWFwKCk7XG59XG5pbmhlcml0cyhCYXNlQ2hhbm5lbCwgQ2hhbm5lbCk7XG5cbm1vZHVsZS5leHBvcnRzLkJhc2VDaGFubmVsID0gQmFzZUNoYW5uZWw7XG5cbi8vIE5vdCBzdXJlIEkgbGlrZSB0aGUgZmYsIGl0J3MgZ29pbmcgdG8gYmUgY2hhbmdpbmcgaGlkZGVuIGNsYXNzZXNcbi8vIGFsbCBvdmVyIHRoZSBwbGFjZS4gT24gdGhlIG90aGVyIGhhbmQsIHdoYWRkeWEgZG8uXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUucmVnaXN0ZXJDb25zdW1lciA9IGZ1bmN0aW9uKHRhZywgY2FsbGJhY2spIHtcbiAgdGhpcy5jb25zdW1lcnMuc2V0KHRhZywgY2FsbGJhY2spO1xufTtcblxuQmFzZUNoYW5uZWwucHJvdG90eXBlLnVucmVnaXN0ZXJDb25zdW1lciA9IGZ1bmN0aW9uKHRhZykge1xuICB0aGlzLmNvbnN1bWVycy5kZWxldGUodGFnKTtcbn07XG5cbkJhc2VDaGFubmVsLnByb3RvdHlwZS5kaXNwYXRjaE1lc3NhZ2UgPSBmdW5jdGlvbihmaWVsZHMsIG1lc3NhZ2UpIHtcbiAgdmFyIGNvbnN1bWVyVGFnID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICB2YXIgY29uc3VtZXIgPSB0aGlzLmNvbnN1bWVycy5nZXQoY29uc3VtZXJUYWcpO1xuICBpZiAoY29uc3VtZXIpIHtcbiAgICByZXR1cm4gY29uc3VtZXIobWVzc2FnZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gJSUlIFN1cmVseSBhIHJhY2UgaGVyZVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29uc3VtZXI6IFwiICsgY29uc3VtZXJUYWcpO1xuICB9XG59O1xuXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUuaGFuZGxlRGVsaXZlcnkgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLmRpc3BhdGNoTWVzc2FnZShtZXNzYWdlLmZpZWxkcywgbWVzc2FnZSk7XG59O1xuXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUuaGFuZGxlQ2FuY2VsID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmRpc3BhdGNoTWVzc2FnZShmaWVsZHMsIG51bGwpO1xuICB0aGlzLnVucmVnaXN0ZXJDb25zdW1lcihmaWVsZHMuY29uc3VtZXJUYWcpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vXG4vL1xuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3V0aWwnKS5wcm9taXNpZnk7XG5jb25zdCBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG5jb25zdCB7QmFzZUNoYW5uZWx9ID0gcmVxdWlyZSgnLi9jaGFubmVsJyk7XG5jb25zdCB7YWNjZXB0TWVzc2FnZX0gPSByZXF1aXJlKCcuL2NoYW5uZWwnKTtcbmNvbnN0IEFyZ3MgPSByZXF1aXJlKCcuL2FwaV9hcmdzJyk7XG5jb25zdCB7aW5zcGVjdH0gPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXG5jbGFzcyBDaGFubmVsTW9kZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG4gICAgWydlcnJvcicsICdjbG9zZScsICdibG9ja2VkJywgJ3VuYmxvY2tlZCddLmZvckVhY2goZXYgPT4ge1xuICAgICAgY29ubmVjdGlvbi5vbihldiwgdGhpcy5lbWl0LmJpbmQodGhpcywgZXYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBwcm9taXNpZnkodGhpcy5jb25uZWN0aW9uLmNsb3NlLmJpbmQodGhpcy5jb25uZWN0aW9uKSkoKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUNoYW5uZWwoKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IG5ldyBDaGFubmVsKHRoaXMuY29ubmVjdGlvbik7XG4gICAgYXdhaXQgY2hhbm5lbC5vcGVuKCk7XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cblxuICBhc3luYyBjcmVhdGVDb25maXJtQ2hhbm5lbCgpIHtcbiAgICBjb25zdCBjaGFubmVsID0gbmV3IENvbmZpcm1DaGFubmVsKHRoaXMuY29ubmVjdGlvbik7XG4gICAgYXdhaXQgY2hhbm5lbC5vcGVuKCk7XG4gICAgYXdhaXQgY2hhbm5lbC5ycGMoZGVmcy5Db25maXJtU2VsZWN0LCB7bm93YWl0OiBmYWxzZX0sIGRlZnMuQ29uZmlybVNlbGVjdE9rKTtcbiAgICByZXR1cm4gY2hhbm5lbDtcbiAgfVxufVxuXG4vLyBDaGFubmVsc1xuXG5jbGFzcyBDaGFubmVsIGV4dGVuZHMgQmFzZUNoYW5uZWwge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbik7XG4gICAgdGhpcy5vbignZGVsaXZlcnknLCB0aGlzLmhhbmRsZURlbGl2ZXJ5LmJpbmQodGhpcykpO1xuICAgIHRoaXMub24oJ2NhbmNlbCcsIHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gQW4gUlBDIHRoYXQgcmV0dXJucyBhICdwcm9wZXInIHByb21pc2UsIHdoaWNoIHJlc29sdmVzIHRvIGp1c3QgdGhlXG4gIC8vIHJlc3BvbnNlJ3MgZmllbGRzOyB0aGlzIGlzIGludGVuZGVkIHRvIGJlIHN1aXRhYmxlIGZvciBpbXBsZW1lbnRpbmdcbiAgLy8gQVBJIHByb2NlZHVyZXMuXG4gIGFzeW5jIHJwYyhtZXRob2QsIGZpZWxkcywgZXhwZWN0KSB7XG4gICAgY29uc3QgZiA9IGF3YWl0IHByb21pc2lmeShjYiA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fcnBjKG1ldGhvZCwgZmllbGRzLCBleHBlY3QsIGNiKTtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIGYuZmllbGRzO1xuICB9XG5cbiAgLy8gRG8gdGhlIHJlbWFya2FibHkgc2ltcGxlIGNoYW5uZWwgb3BlbiBoYW5kc2hha2VcbiAgYXN5bmMgb3BlbigpIHtcbiAgICBjb25zdCBjaCA9IGF3YWl0IHRoaXMuYWxsb2NhdGUuYmluZCh0aGlzKSgpO1xuICAgIHJldHVybiBjaC5ycGMoZGVmcy5DaGFubmVsT3Blbiwge291dE9mQmFuZDogXCJcIn0sXG4gICAgICAgICAgICAgICAgICBkZWZzLkNoYW5uZWxPcGVuT2spO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIHByb21pc2lmeShjYiA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9zZUJlY2F1c2UoXCJHb29kYnllXCIsIGRlZnMuY29uc3RhbnRzLlJFUExZX1NVQ0NFU1MsXG4gICAgICAgICAgICAgICAgICAgICAgY2IpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvLyA9PT0gUHVibGljIEFQSSwgZGVjbGFyaW5nIHF1ZXVlcyBhbmQgc3R1ZmYgPT09XG5cbiAgYXNzZXJ0UXVldWUocXVldWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZURlY2xhcmUsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuYXNzZXJ0UXVldWUocXVldWUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlRGVjbGFyZU9rKTtcbiAgfVxuXG4gIGNoZWNrUXVldWUocXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZURlY2xhcmUsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuY2hlY2tRdWV1ZShxdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVEZWNsYXJlT2spO1xuICB9XG5cbiAgZGVsZXRlUXVldWUocXVldWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZURlbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5kZWxldGVRdWV1ZShxdWV1ZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVEZWxldGVPayk7XG4gIH1cblxuICBwdXJnZVF1ZXVlKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVQdXJnZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5wdXJnZVF1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5RdWV1ZVB1cmdlT2spO1xuICB9XG5cbiAgYmluZFF1ZXVlKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZUJpbmQsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuYmluZFF1ZXVlKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlQmluZE9rKTtcbiAgfVxuXG4gIHVuYmluZFF1ZXVlKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZVVuYmluZCxcbiAgICAgICAgICAgICAgICAgICAgQXJncy51bmJpbmRRdWV1ZShxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5RdWV1ZVVuYmluZE9rKTtcbiAgfVxuXG4gIGFzc2VydEV4Y2hhbmdlKGV4Y2hhbmdlLCB0eXBlLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIHNlcnZlciByZXBseSBpcyBhbiBlbXB0eSBzZXQgb2YgZmllbGRzLCBidXQgaXQncyBjb252ZW5pZW50XG4gICAgLy8gdG8gaGF2ZSB0aGUgZXhjaGFuZ2UgbmFtZSBoYW5kZWQgdG8gdGhlIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZURlY2xhcmUsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuYXNzZXJ0RXhjaGFuZ2UoZXhjaGFuZ2UsIHR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlRGVjbGFyZU9rKVxuICAgICAgLnRoZW4oX29rID0+IHsgcmV0dXJuIHsgZXhjaGFuZ2UgfTsgfSk7XG4gIH1cblxuICBjaGVja0V4Y2hhbmdlKGV4Y2hhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VEZWNsYXJlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmNoZWNrRXhjaGFuZ2UoZXhjaGFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlRGVjbGFyZU9rKTtcbiAgfVxuXG4gIGRlbGV0ZUV4Y2hhbmdlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZURlbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5kZWxldGVFeGNoYW5nZShuYW1lLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZURlbGV0ZU9rKTtcbiAgfVxuXG4gIGJpbmRFeGNoYW5nZShkZXN0LCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZUJpbmQsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuYmluZEV4Y2hhbmdlKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuRXhjaGFuZ2VCaW5kT2spO1xuICB9XG5cbiAgdW5iaW5kRXhjaGFuZ2UoZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VVbmJpbmQsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MudW5iaW5kRXhjaGFuZ2UoZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZVVuYmluZE9rKTtcbiAgfVxuXG4gIC8vIFdvcmtpbmcgd2l0aCBtZXNzYWdlc1xuXG4gIHB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaWVsZHNBbmRQcm9wcyA9IEFyZ3MucHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoZmllbGRzQW5kUHJvcHMsIGZpZWxkc0FuZFByb3BzLCBjb250ZW50KTtcbiAgfVxuXG4gIHNlbmRUb1F1ZXVlKHF1ZXVlLCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaCgnJywgcXVldWUsIGNvbnRlbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3VtZShxdWV1ZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBOQiB3ZSB3YW50IHRoZSBjYWxsYmFjayB0byBiZSBydW4gc3luY2hyb25vdXNseSwgc28gdGhhdCB3ZSd2ZVxuICAgIC8vIHJlZ2lzdGVyZWQgdGhlIGNvbnN1bWVyVGFnIGJlZm9yZSBhbnkgbWVzc2FnZXMgY2FuIGFycml2ZS5cbiAgICBjb25zdCBmaWVsZHMgPSBBcmdzLmNvbnN1bWUocXVldWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9ycGMoZGVmcy5CYXNpY0NvbnN1bWUsIGZpZWxkcywgZGVmcy5CYXNpY0NvbnN1bWVPaywgKGVyciwgb2spID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29uc3VtZXIob2suZmllbGRzLmNvbnN1bWVyVGFnLCBjYWxsYmFjayk7XG4gICAgICAgIHJlc29sdmUob2suZmllbGRzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY2FuY2VsKGNvbnN1bWVyVGFnKSB7XG4gICAgY29uc3Qgb2sgPSBhd2FpdCBwcm9taXNpZnkoY2IgPT4ge1xuICAgICAgdGhpcy5fcnBjKGRlZnMuQmFzaWNDYW5jZWwsIEFyZ3MuY2FuY2VsKGNvbnN1bWVyVGFnKSxcbiAgICAgICAgICAgIGRlZnMuQmFzaWNDYW5jZWxPayxcbiAgICAgICAgICAgIGNiKTtcbiAgICB9KSgpXG4gICAgLnRoZW4ob2sgPT4ge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyQ29uc3VtZXIoY29uc3VtZXJUYWcpO1xuICAgICAgcmV0dXJuIG9rLmZpZWxkcztcbiAgICB9KTtcbiAgfVxuXG4gIGdldChxdWV1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpZWxkcyA9IEFyZ3MuZ2V0KHF1ZXVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5zZW5kT3JFbnF1ZXVlKGRlZnMuQmFzaWNHZXQsIGZpZWxkcywgKGVyciwgZikgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIGlmIChmLmlkID09PSBkZWZzLkJhc2ljR2V0RW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY0dldE9rKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gZi5maWVsZHM7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlID0gYWNjZXB0TWVzc2FnZShtID0+IHtcbiAgICAgICAgICAgIG0uZmllbGRzID0gZmllbGRzO1xuICAgICAgICAgICAgcmVzb2x2ZShtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmV4cGVjdGVkIHJlc3BvbnNlIHRvIEJhc2ljR2V0OiAke2luc3BlY3QoZil9YCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFjayhtZXNzYWdlLCBhbGxVcFRvKSB7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoXG4gICAgICBkZWZzLkJhc2ljQWNrLFxuICAgICAgQXJncy5hY2sobWVzc2FnZS5maWVsZHMuZGVsaXZlcnlUYWcsIGFsbFVwVG8pKTtcbiAgfVxuXG4gIGFja0FsbCgpIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShkZWZzLkJhc2ljQWNrLCBBcmdzLmFjaygwLCB0cnVlKSk7XG4gIH1cblxuICBuYWNrKG1lc3NhZ2UsIGFsbFVwVG8sIHJlcXVldWUpIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShcbiAgICAgIGRlZnMuQmFzaWNOYWNrLFxuICAgICAgQXJncy5uYWNrKG1lc3NhZ2UuZmllbGRzLmRlbGl2ZXJ5VGFnLCBhbGxVcFRvLCByZXF1ZXVlKSk7XG4gIH1cblxuICBuYWNrQWxsKHJlcXVldWUpIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShkZWZzLkJhc2ljTmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICBBcmdzLm5hY2soMCwgdHJ1ZSwgcmVxdWV1ZSkpO1xuICB9XG5cbiAgLy8gYEJhc2ljLk5hY2tgIGlzIG5vdCBhdmFpbGFibGUgaW4gb2xkZXIgUmFiYml0TVEgdmVyc2lvbnMgKG9yIGluIHRoZVxuICAvLyBBTVFQIHNwZWNpZmljYXRpb24pLCBzbyB5b3UgaGF2ZSB0byB1c2UgdGhlIG9uZS1hdC1hLXRpbWVcbiAgLy8gYEJhc2ljLlJlamVjdGAuIFRoaXMgaXMgb3RoZXJ3aXNlIHN5bm9ueW1vdXMgd2l0aFxuICAvLyBgI25hY2sobWVzc2FnZSwgZmFsc2UsIHJlcXVldWUpYC5cbiAgcmVqZWN0KG1lc3NhZ2UsIHJlcXVldWUpIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShcbiAgICAgIGRlZnMuQmFzaWNSZWplY3QsXG4gICAgICBBcmdzLnJlamVjdChtZXNzYWdlLmZpZWxkcy5kZWxpdmVyeVRhZywgcmVxdWV1ZSkpO1xuICB9XG5cbiAgcmVjb3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5CYXNpY1JlY292ZXIsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MucmVjb3ZlcigpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkJhc2ljUmVjb3Zlck9rKTtcbiAgfVxuXG4gIHFvcyhjb3VudCwgZ2xvYmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuQmFzaWNRb3MsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MucHJlZmV0Y2goY291bnQsIGdsb2JhbCksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuQmFzaWNRb3NPayk7XG4gIH1cbn1cblxuLy8gVGhlcmUgYXJlIG1vcmUgb3B0aW9ucyBpbiBBTVFQIHRoYW4gZXhwb3NlZCBoZXJlOyBSYWJiaXRNUSBvbmx5XG4vLyBpbXBsZW1lbnRzIHByZWZldGNoIGJhc2VkIG9uIG1lc3NhZ2UgY291bnQsIGFuZCBvbmx5IGZvciBpbmRpdmlkdWFsXG4vLyBjaGFubmVscyBvciBjb25zdW1lcnMuIFJhYmJpdE1RIHYzLjMuMCBhbmQgYWZ0ZXIgdHJlYXQgcHJlZmV0Y2hcbi8vICh3aXRob3V0IGBnbG9iYWxgIHNldCkgYXMgcGVyLWNvbnN1bWVyIChmb3IgY29uc3VtZXJzIGZvbGxvd2luZyksXG4vLyBhbmQgcHJlZmV0Y2ggd2l0aCBgZ2xvYmFsYCBzZXQgYXMgcGVyLWNoYW5uZWwuXG5DaGFubmVsLnByb3RvdHlwZS5wcmVmZXRjaCA9IENoYW5uZWwucHJvdG90eXBlLnFvc1xuXG4vLyBDb25maXJtIGNoYW5uZWwuIFRoaXMgaXMgYSBjaGFubmVsIHdpdGggY29uZmlybXMgJ3N3aXRjaGVkIG9uJyxcbi8vIG1lYW5pbmcgc2VudCBtZXNzYWdlcyB3aWxsIHByb3Zva2UgYSByZXNwb25kaW5nICdhY2snIG9yICduYWNrJ1xuLy8gZnJvbSB0aGUgc2VydmVyLiBUaGUgdXBzaG90IG9mIHRoaXMgaXMgdGhhdCBgcHVibGlzaGAgYW5kXG4vLyBgc2VuZFRvUXVldWVgIGJvdGggdGFrZSBhIGNhbGxiYWNrLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBlaXRoZXJcbi8vIHdpdGggYG51bGxgIGFzIGl0cyBhcmd1bWVudCB0byBzaWduaWZ5ICdhY2snLCBvciBhbiBleGNlcHRpb24gYXNcbi8vIGl0cyBhcmd1bWVudCB0byBzaWduaWZ5ICduYWNrJy5cblxuY2xhc3MgQ29uZmlybUNoYW5uZWwgZXh0ZW5kcyBDaGFubmVsIHtcbiAgcHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLnB1c2hDb25maXJtQ2FsbGJhY2soY2IpO1xuICAgIHJldHVybiBDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoLmNhbGwodGhpcywgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgc2VuZFRvUXVldWUocXVldWUsIGNvbnRlbnQsIG9wdGlvbnMsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaCgnJywgcXVldWUsIGNvbnRlbnQsIG9wdGlvbnMsIGNiKTtcbiAgfVxuXG4gIHdhaXRGb3JDb25maXJtcygpIHtcbiAgICBjb25zdCBhd2FpdGluZyA9IFtdO1xuICAgIGNvbnN0IHVuY29uZmlybWVkID0gdGhpcy51bmNvbmZpcm1lZDtcbiAgICB1bmNvbmZpcm1lZC5mb3JFYWNoKCh2YWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB1bmNvbmZpcm1lZFtpbmRleF0gPSBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbCkgdmFsKGVycik7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBudWxsKSByZXNvbHZlKCk7XG4gICAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdGluZy5wdXNoKGNvbmZpcm1lZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQ2hhbm5lbCBjbG9zZWRcbiAgICBpZiAoIXRoaXMucGVuZGluZykge1xuICAgICAgdmFyIGNiO1xuICAgICAgd2hpbGUgKGNiID0gdGhpcy51bmNvbmZpcm1lZC5zaGlmdCgpKSB7XG4gICAgICAgIGlmIChjYikgY2IobmV3IEVycm9yKCdjaGFubmVsIGNsb3NlZCcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGF3YWl0aW5nKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Db25maXJtQ2hhbm5lbCA9IENvbmZpcm1DaGFubmVsO1xubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsTW9kZWwgPSBDaGFubmVsTW9kZWw7XG4iLCIvL1xuLy9cbi8vXG5cbi8qXG5cblRoZSBBTVFQIDAtOS0xIGlzIGEgbWVzcyB3aGVuIGl0IGNvbWVzIHRvIHRoZSB0eXBlcyB0aGF0IGNhbiBiZVxuZW5jb2RlZCBvbiB0aGUgd2lyZS5cblxuVGhlcmUgYXJlIGZvdXIgZW5jb2Rpbmcgc2NoZW1lcywgYW5kIHRocmVlIG92ZXJsYXBwaW5nIHNldHMgb2YgdHlwZXM6XG5mcmFtZXMsIG1ldGhvZHMsIChmaWVsZC0pdGFibGVzLCBhbmQgcHJvcGVydGllcy5cblxuRWFjaCAqZnJhbWUgdHlwZSogaGFzIGEgc2V0IGxheW91dCBpbiB3aGljaCB2YWx1ZXMgb2YgZ2l2ZW4gdHlwZXMgYXJlXG5jb25jYXRlbmF0ZWQgYWxvbmcgd2l0aCBzZWN0aW9ucyBvZiBcInJhdyBiaW5hcnlcIiBkYXRhLlxuXG5JbiBmcmFtZXMgdGhlcmUgYXJlIGBzaG9ydHN0cmBzLCB0aGF0IGlzIGxlbmd0aC1wcmVmaXhlZCBzdHJpbmdzIG9mXG5VVEY4IGNoYXJzLCA4IGJpdCB1bnNpZ25lZCBpbnRlZ2VycyAoY2FsbGVkIGBvY3RldGApLCB1bnNpZ25lZCAxNiBiaXRcbmludGVnZXJzIChjYWxsZWQgYHNob3J0YCBvciBgc2hvcnQtdWludGApLCB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlcnNcbihjYWxsZWQgYGxvbmdgIG9yIGBsb25nLXVpbnRgKSwgdW5zaWduZWQgNjQgYml0IGludGVnZXJzIChjYWxsZWRcbmBsb25nbG9uZ2Agb3IgYGxvbmdsb25nLXVpbnRgKSwgYW5kIGZsYWdzIChjYWxsZWQgYGJpdGApLlxuXG5NZXRob2RzIGFyZSBlbmNvZGVkIGFzIGEgZnJhbWUgZ2l2aW5nIGEgbWV0aG9kIElEIGFuZCBhIHNlcXVlbmNlIG9mXG5hcmd1bWVudHMgb2Yga25vd24gdHlwZXMuIFRoZSBlbmNvZGVkIG1ldGhvZCBhcmd1bWVudCB2YWx1ZXMgYXJlXG5jb25jYXRlbmF0ZWQgKHdpdGggc29tZSBmdW4gY29tcGxpY2F0aW9ucyBhcm91bmQgXCJwYWNraW5nXCIgY29uc2VjdXRpdmVcbmJpdCB2YWx1ZXMgaW50byBieXRlcykuXG5cbkFsb25nIHdpdGggdGhlIHR5cGVzIGdpdmVuIGluIGZyYW1lcywgbWV0aG9kIGFyZ3VtZW50cyBtYXkgYmUgbG9uZ1xuYnl0ZSBzdHJpbmdzIChgbG9uZ3N0cmAsIG5vdCByZXF1aXJlZCB0byBiZSBVVEY4KSBvciA2NCBiaXQgdW5zaWduZWRcbmludGVnZXJzIHRvIGJlIGludGVycHJldGVkIGFzIHRpbWVzdGFtcHMgKHllYWggSSBkb24ndCBrbm93IHdoeVxuZWl0aGVyKSwgb3IgYXJiaXRyYXJ5IHNldHMgb2Yga2V5LXZhbHVlIHBhaXJzIChjYWxsZWQgYGZpZWxkLXRhYmxlYCkuXG5cbkluc2lkZSBhIGZpZWxkIHRhYmxlIHRoZSBrZXlzIGFyZSBgc2hvcnRzdHJgIGFuZCB0aGUgdmFsdWVzIGFyZVxucHJlZml4ZWQgd2l0aCBhIGJ5dGUgdGFnIGdpdmluZyB0aGUgdHlwZS4gVGhlIHR5cGVzIGFyZSBhbnkgb2YgdGhlXG5hYm92ZSBleGNlcHQgZm9yIGJpdHMgKHdoaWNoIGFyZSByZXBsYWNlZCBieSBieXRlLXdpZGUgYGJvb2xgKSwgYWxvbmdcbndpdGggYSBOVUxMIHZhbHVlIGB2b2lkYCwgYSBzcGVjaWFsIGZpeGVkLXByZWNpc2lvbiBudW1iZXIgZW5jb2RpbmdcbihgZGVjaW1hbGApLCBJRUVFNzU0IGBmbG9hdGBzIGFuZCBgZG91YmxlYHMsIHNpZ25lZCBpbnRlZ2VycyxcbmBmaWVsZC1hcnJheWAgKGEgc2VxdWVuY2Ugb2YgdGFnZ2VkIHZhbHVlcyksIGFuZCBuZXN0ZWQgZmllbGQtdGFibGVzLlxuXG5SYWJiaXRNUSBhbmQgUVBpZCB1c2UgYSBzdWJzZXQgb2YgdGhlIGZpZWxkLXRhYmxlIHR5cGVzLCBhbmQgZGlmZmVyZW50XG52YWx1ZSB0YWdzLCBlc3RhYmxpc2hlZCBiZWZvcmUgdGhlIEFNUVAgMC05LTEgc3BlY2lmaWNhdGlvbiB3YXNcbnB1Ymxpc2hlZC4gU28gZmFyIGFzIEkga25vdywgbm8tb25lIHVzZXMgdGhlIHR5cGVzIGFuZCB0YWdzIGFzXG5wdWJsaXNoZWQuIGh0dHA6Ly93d3cucmFiYml0bXEuY29tL2FtcXAtMC05LTEtZXJyYXRhLmh0bWwgZ2l2ZXMgdGhlXG5saXN0IG9mIGZpZWxkLXRhYmxlIHR5cGVzLlxuXG5MYXN0bHksIHRoZXJlIGFyZSAoc2V0cyBvZikgcHJvcGVydGllcywgb25seSBvbmUgb2Ygd2hpY2ggaXMgZ2l2ZW4gaW5cbkFNUVAgMC05LTE6IGBCYXNpY1Byb3BlcnRpZXNgLiBUaGVzZSBhcmUgYWxtb3N0IHRoZSBzYW1lIGFzIG1ldGhvZHMsXG5leGNlcHQgdGhhdCB0aGV5IGFwcGVhciBpbiBjb250ZW50IGhlYWRlciBmcmFtZXMsIHdoaWNoIGluY2x1ZGUgYVxuY29udGVudCBzaXplLCBhbmQgdGhleSBjYXJyeSBhIHNldCBvZiBmbGFncyBpbmRpY2F0aW5nIHdoaWNoXG5wcm9wZXJ0aWVzIGFyZSBwcmVzZW50LiBUaGlzIHNjaGVtZSBjYW4gc2F2ZSBvbmVzIG9mIGJ5dGVzIHBlciBtZXNzYWdlXG4obWVzc2FnZXMgd2hpY2ggdGFrZSBhIG1pbmltdW0gb2YgdGhyZWUgZnJhbWVzIGVhY2ggdG8gc2VuZCkuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludHMgPSByZXF1aXJlKCdidWZmZXItbW9yZS1pbnRzJyk7XG5cbi8vIEphdmFTY3JpcHQgdXNlcyBvbmx5IGRvdWJsZXMgc28gd2hhdCBJJ20gdGVzdGluZyBmb3IgaXMgd2hldGhlclxuLy8gaXQncyAqYmV0dGVyKiB0byBlbmNvZGUgYSBudW1iZXIgYXMgYSBmbG9hdCBvciBkb3VibGUuIFRoaXMgcmVhbGx5XG4vLyBqdXN0IGFtb3VudHMgdG8gdGVzdGluZyB3aGV0aGVyIHRoZXJlJ3MgYSBmcmFjdGlvbmFsIHBhcnQgdG8gdGhlXG4vLyBudW1iZXIsIGV4Y2VwdCB0aGF0IHNlZSBiZWxvdy4gTkIgSSBkb24ndCB1c2UgYml0d2lzZSBvcGVyYXRpb25zIHRvXG4vLyBkbyB0aGlzICdlZmZpY2llbnRseScgLS0gaXQgd291bGQgbWFzayB0aGUgbnVtYmVyIHRvIDMyIGJpdHMuXG4vL1xuLy8gQXQgMl41MCwgZG91YmxlcyBkb24ndCBoYXZlIHN1ZmZpY2llbnQgcHJlY2lzaW9uIHRvIGRpc3Rpbmd1aXNoXG4vLyBiZXR3ZWVuIGZsb2F0aW5nIHBvaW50IGFuZCBpbnRlZ2VyIG51bWJlcnMgKGBNYXRoLnBvdygyLCA1MCkgKyAwLjFcbi8vID09PSBNYXRoLnBvdygyLCA1MClgIChhbmQsIGFib3ZlIDJeNTMsIGRvdWJsZXMgY2Fubm90IHJlcHJlc2VudCBhbGxcbi8vIGludGVnZXJzIChgTWF0aC5wb3coMiwgNTMpICsgMSA9PT0gTWF0aC5wb3coMiwgNTMpYCkpLiBIZW5jZVxuLy8gYW55dGhpbmcgd2l0aCBhIG1hZ25pdHVkZSBhdCBvciBhYm92ZSAyXjUwIG1heSBhcyB3ZWxsIGJlIGVuY29kZWRcbi8vIGFzIGEgNjQtYml0IGludGVnZXIuIEV4Y2VwdCB0aGF0IG9ubHkgc2lnbmVkIGludGVnZXJzIGFyZSBzdXBwb3J0ZWRcbi8vIGJ5IFJhYmJpdE1RLCBzbyBhbnl0aGluZyBhYm92ZSAyXjYzIC0gMSBtdXN0IGJlIGEgZG91YmxlLlxuZnVuY3Rpb24gaXNGbG9hdGluZ1BvaW50KG4pIHtcbiAgICByZXR1cm4gbiA+PSAweDgwMDAwMDAwMDAwMDAwMDAgfHxcbiAgICAgICAgKE1hdGguYWJzKG4pIDwgMHg0MDAwMDAwMDAwMDAwXG4gICAgICAgICAmJiBNYXRoLmZsb29yKG4pICE9PSBuKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVGFibGUoYnVmZmVyLCB2YWwsIG9mZnNldCkge1xuICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICBvZmZzZXQgKz0gNDsgLy8gbGVhdmUgcm9vbSBmb3IgdGhlIHRhYmxlIGxlbmd0aFxuICAgIGZvciAodmFyIGtleSBpbiB2YWwpIHtcbiAgICAgICAgaWYgKHZhbFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoa2V5KTtcbiAgICAgICAgICBidWZmZXIud3JpdGVVSW50OChsZW4sIG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICAgIGJ1ZmZlci53cml0ZShrZXksIG9mZnNldCwgJ3V0ZjgnKTsgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICBvZmZzZXQgKz0gZW5jb2RlRmllbGRWYWx1ZShidWZmZXIsIHZhbFtrZXldLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzaXplID0gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUoc2l6ZSAtIDQsIHN0YXJ0KTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXkoYnVmZmVyLCB2YWwsIG9mZnNldCkge1xuICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBmb3IgKHZhciBpPTAsIG51bT12YWwubGVuZ3RoOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgb2Zmc2V0ICs9IGVuY29kZUZpZWxkVmFsdWUoYnVmZmVyLCB2YWxbaV0sIG9mZnNldCk7XG4gICAgfVxuICAgIHZhciBzaXplID0gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUoc2l6ZSAtIDQsIHN0YXJ0KTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRmllbGRWYWx1ZShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsIHZhbCA9IHZhbHVlO1xuICAgIC8vIEEgdHJhcGRvb3IgZm9yIHNwZWNpZnlpbmcgYSB0eXBlLCBlLmcuLCB0aW1lc3RhbXBcbiAgICBpZiAodmFsdWUgJiYgdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJyEnKSkge1xuICAgICAgICB2YWwgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgdHlwZSA9IHZhbHVlWychJ107XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBhIEpTIG51bWJlciwgd2UnbGwgaGF2ZSB0byBndWVzcyB3aGF0IHR5cGUgdG8gZW5jb2RlIGl0XG4gICAgLy8gYXMuXG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gTWFraW5nIGFzc3VtcHRpb25zIGFib3V0IHRoZSBraW5kIG9mIG51bWJlciAoZmxvYXRpbmcgcG9pbnRcbiAgICAgICAgLy8gdiBpbnRlZ2VyLCBzaWduZWQsIHVuc2lnbmVkLCBzaXplKSBkZXNpcmVkIGlzIGRhbmdlcm91cyBpblxuICAgICAgICAvLyBnZW5lcmFsOyBob3dldmVyLCBpbiBwcmFjdGljZSBSYWJiaXRNUSB1c2VzIG9ubHlcbiAgICAgICAgLy8gbG9uZ3N0cmluZ3MgYW5kIHVuc2lnbmVkIGludGVnZXJzIGluIGl0cyBhcmd1bWVudHMsIGFuZFxuICAgICAgICAvLyBvdGhlciBjbGllbnRzIGdlbmVyYWxseSBjb25mbGF0ZSBudW1iZXIgdHlwZXMgYW55d2F5LiBTb1xuICAgICAgICAvLyB0aGUgb25seSBkaXN0aW5jdGlvbiB3ZSBjYXJlIGFib3V0IGlzIGZsb2F0aW5nIHBvaW50IHZzXG4gICAgICAgIC8vIGludGVnZXJzLCBwcmVmZXJyaW5nIGludGVnZXJzIHNpbmNlIHRob3NlIGNhbiBiZSBwcm9tb3RlZFxuICAgICAgICAvLyBpZiBuZWNlc3NhcnkuIElmIGZsb2F0aW5nIHBvaW50IGlzIHJlcXVpcmVkLCB3ZSBtYXkgYXMgd2VsbFxuICAgICAgICAvLyB1c2UgZG91YmxlIHByZWNpc2lvbi5cbiAgICAgICAgaWYgKGlzRmxvYXRpbmdQb2ludCh2YWwpKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2RvdWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG9ubHkgc2lnbmVkIHZhbHVlcyBhcmUgdXNlZCBpbiB0YWJsZXMgYnlcbiAgICAgICAgICAgICAgIC8vIFJhYmJpdE1RLiBJdCAqdXNlZCogdG8gKDwgdjMuMy4wKSB0cmVhdCB0aGUgYnl0ZSAnYidcbiAgICAgICAgICAgICAgIC8vIHR5cGUgYXMgdW5zaWduZWQsIGJ1dCBtb3N0IGNsaWVudHMgKGFuZCB0aGUgc3BlYylcbiAgICAgICAgICAgICAgIC8vIHRoaW5rIGl0J3Mgc2lnbmVkLCBhbmQgbm93IFJhYmJpdE1RIGRvZXMgdG9vLlxuICAgICAgICAgICAgaWYgKHZhbCA8IDEyOCAmJiB2YWwgPj0gLTEyOCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnYnl0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPj0gLTB4ODAwMCAmJiB2YWwgPCAweDgwMDApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3Nob3J0J1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID49IC0weDgwMDAwMDAwICYmIHZhbCA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2ludCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2xvbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFnKHQpIHsgYnVmZmVyLndyaXRlKHQsIG9mZnNldCk7IG9mZnNldCsrOyB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdHJpbmcnOiAvLyBubyBzaG9ydHN0ciBpbiBmaWVsZCB0YWJsZXNcbiAgICAgICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgJ3V0ZjgnKTtcbiAgICAgICAgdGFnKCdTJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgJ3V0ZjgnKTsgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGFnKCdWJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB0YWcoJ0EnKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbmNvZGVBcnJheShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgICAgICAgICAgdGFnKCd4Jyk7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwubGVuZ3RoLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTsgb2Zmc2V0ICs9IHZhbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YWcoJ0YnKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbmNvZGVUYWJsZShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgdGFnKCd0Jyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KCh2YWwpID8gMSA6IDAsIG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICBicmVhaztcbiAgICAvLyBUaGVzZSBhcmUgdGhlIHR5cGVzIHRoYXQgYXJlIGVpdGhlciBndWVzc2VkIGFib3ZlLCBvclxuICAgIC8vIGV4cGxpY2l0bHkgZ2l2ZW4gdXNpbmcgdGhlIHsnISc6IHR5cGV9IG5vdGF0aW9uLlxuICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHRhZygnZCcpO1xuICAgICAgICBidWZmZXIud3JpdGVEb3VibGVCRSh2YWwsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdieXRlJzpcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgdGFnKCdiJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDgodmFsLCBvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2hvcnQnOlxuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgdGFnKCdzJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDE2QkUodmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW50JzpcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHRhZygnSScpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkJFKHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xvbmcnOlxuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgdGFnKCdsJyk7XG4gICAgICAgIGludHMud3JpdGVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAvLyBOb3cgZm9yIGV4b3RpYyB0eXBlcywgdGhvc2UgY2FuIF9vbmx5XyBiZSBkZW5vdGVkIGJ5IHVzaW5nXG4gICAgLy8gYHsnISc6IHR5cGUsIHZhbHVlOiB2YWx9XG4gICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgdGFnKCdUJyk7XG4gICAgICAgIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgdGFnKCdmJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0QkUodmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVjaW1hbCc6XG4gICAgICAgIHRhZygnRCcpO1xuICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5KCdwbGFjZXMnKSAmJiB2YWwuaGFzT3duUHJvcGVydHkoJ2RpZ2l0cycpXG4gICAgICAgICAgICAmJiB2YWwucGxhY2VzID49IDAgJiYgdmFsLnBsYWNlcyA8IDI1Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSB2YWwucGxhY2VzOyBvZmZzZXQrKztcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbC5kaWdpdHMsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRGVjaW1hbCB2YWx1ZSBtdXN0IGJlIHsncGxhY2VzJzogMC4uMjU1LCAnZGlnaXRzJzogdWludDMyfSwgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ290IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gdHlwZSB0byBlbmNvZGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xufVxuXG4vLyBBc3N1bWUgd2UncmUgZ2l2ZW4gYSBzbGljZSBvZiB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMganVzdCB0aGVcbi8vIGZpZWxkcy5cbmZ1bmN0aW9uIGRlY29kZUZpZWxkcyhzbGljZSkge1xuICAgIHZhciBmaWVsZHMgPSB7fSwgb2Zmc2V0ID0gMCwgc2l6ZSA9IHNsaWNlLmxlbmd0aDtcbiAgICB2YXIgbGVuLCBrZXksIHZhbDtcblxuICAgIGZ1bmN0aW9uIGRlY29kZUZpZWxkVmFsdWUoKSB7XG4gICAgICAgIHZhciB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNsaWNlW29mZnNldF0pOyBvZmZzZXQrKztcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkSW50OChvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnRvU3RyaW5nKCd1dGY4Jywgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWRJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0QnOiAvLyBvbmx5IHBvc2l0aXZlIGRlY2ltYWxzLCBhcHBhcmVudGx5LlxuICAgICAgICAgICAgdmFyIHBsYWNlcyA9IHNsaWNlW29mZnNldF07IG9mZnNldCsrO1xuICAgICAgICAgICAgdmFyIGRpZ2l0cyA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IHsnISc6ICdkZWNpbWFsJywgdmFsdWU6IHtwbGFjZXM6IHBsYWNlcywgZGlnaXRzOiBkaWdpdHN9fTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKHNsaWNlLCBvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhbCA9IHsnISc6ICd0aW1lc3RhbXAnLCB2YWx1ZTogdmFsfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IGRlY29kZUZpZWxkcyhzbGljZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGRlY29kZUFycmF5KG9mZnNldCArIGxlbik7XG4gICAgICAgICAgICAvLyBOQiBkZWNvZGVBcnJheSB3aWxsIGl0c2VsZiB1cGRhdGUgb2Zmc2V0IGFuZCB2YWxcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWREb3VibGVCRShvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWRGbG9hdEJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgdmFsID0gaW50cy5yZWFkSW50NjRCRShzbGljZSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkSW50MTZCRShvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlW29mZnNldF0gIT0gMDsgb2Zmc2V0Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgbGVuID0gc2xpY2UucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdmFsID0gc2xpY2Uuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCB0eXBlIHRhZyBcIicgKyB0YWcgKydcIicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQXJyYXkodW50aWwpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IHVudGlsKSB7XG4gICAgICAgICAgICBkZWNvZGVGaWVsZFZhbHVlKCk7XG4gICAgICAgICAgICB2YWxzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICB2YWwgPSB2YWxzO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50OChvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAga2V5ID0gc2xpY2UudG9TdHJpbmcoJ3V0ZjgnLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgICAgIG9mZnNldCArPSBsZW47XG4gICAgICAgIGRlY29kZUZpZWxkVmFsdWUoKTtcbiAgICAgICAgZmllbGRzW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZVRhYmxlID0gZW5jb2RlVGFibGU7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGVGaWVsZHMgPSBkZWNvZGVGaWVsZHM7XG4iLCIvL1xuLy9cbi8vXG5cbi8vIEdlbmVyYWwtcHVycG9zZSBBUEkgZm9yIGdsdWVpbmcgZXZlcnl0aGluZyB0b2dldGhlci5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG52YXIgUVMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xudmFyIENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKS5Db25uZWN0aW9uO1xudmFyIGZtdCA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG52YXIgY3JlZGVudGlhbHMgPSByZXF1aXJlKCcuL2NyZWRlbnRpYWxzJyk7XG5cbmZ1bmN0aW9uIGNvcHlJbnRvKG9iaiwgdGFyZ2V0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICB0YXJnZXRba10gPSBvYmpba107XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIHV0aWwuX2V4dGVuZCwgd2hpY2ggaXMgdG9vIGZyaW5nZSB0byB1c2UuXG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIGNvcHlJbnRvKG9iaiwge30pO1xufVxuXG52YXIgQ0xJRU5UX1BST1BFUlRJRVMgPSB7XG4gIFwicHJvZHVjdFwiOiBcImFtcXBsaWJcIixcbiAgXCJ2ZXJzaW9uXCI6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG4gIFwicGxhdGZvcm1cIjogZm10KCdOb2RlLkpTICVzJywgcHJvY2Vzcy52ZXJzaW9uKSxcbiAgXCJpbmZvcm1hdGlvblwiOiBcImh0dHA6Ly9zcXVhcmVtby5naXRodWIuaW8vYW1xcC5ub2RlXCIsXG4gIFwiY2FwYWJpbGl0aWVzXCI6IHtcbiAgICBcInB1Ymxpc2hlcl9jb25maXJtc1wiOiB0cnVlLFxuICAgIFwiZXhjaGFuZ2VfZXhjaGFuZ2VfYmluZGluZ3NcIjogdHJ1ZSxcbiAgICBcImJhc2ljLm5hY2tcIjogdHJ1ZSxcbiAgICBcImNvbnN1bWVyX2NhbmNlbF9ub3RpZnlcIjogdHJ1ZSxcbiAgICBcImNvbm5lY3Rpb24uYmxvY2tlZFwiOiB0cnVlLFxuICAgIFwiYXV0aGVudGljYXRpb25fZmFpbHVyZV9jbG9zZVwiOiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdCB0aGUgbWFpbiBmcmFtZXMgdXNlZCBpbiB0aGUgb3BlbmluZyBoYW5kc2hha2VcbmZ1bmN0aW9uIG9wZW5GcmFtZXModmhvc3QsIHF1ZXJ5LCBjcmVkZW50aWFscywgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKSB7XG4gIGlmICghdmhvc3QpXG4gICAgdmhvc3QgPSAnLyc7XG4gIGVsc2VcbiAgICB2aG9zdCA9IFFTLnVuZXNjYXBlKHZob3N0KTtcblxuICB2YXIgcXVlcnkgPSBxdWVyeSB8fCB7fTtcblxuICBmdW5jdGlvbiBpbnRPckRlZmF1bHQodmFsLCBkZWYpIHtcbiAgICByZXR1cm4gKHZhbCA9PT0gdW5kZWZpbmVkKSA/IGRlZiA6IHBhcnNlSW50KHZhbCk7XG4gIH1cblxuICB2YXIgY2xpZW50UHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoQ0xJRU5UX1BST1BFUlRJRVMpO1xuXG4gIHJldHVybiB7XG4gICAgLy8gc3RhcnQtb2tcbiAgICAnY2xpZW50UHJvcGVydGllcyc6IGNvcHlJbnRvKGV4dHJhQ2xpZW50UHJvcGVydGllcywgY2xpZW50UHJvcGVydGllcyksXG4gICAgJ21lY2hhbmlzbSc6IGNyZWRlbnRpYWxzLm1lY2hhbmlzbSxcbiAgICAncmVzcG9uc2UnOiBjcmVkZW50aWFscy5yZXNwb25zZSgpLFxuICAgICdsb2NhbGUnOiBxdWVyeS5sb2NhbGUgfHwgJ2VuX1VTJyxcblxuICAgIC8vIHR1bmUtb2tcbiAgICAnY2hhbm5lbE1heCc6IGludE9yRGVmYXVsdChxdWVyeS5jaGFubmVsTWF4LCAwKSxcbiAgICAnZnJhbWVNYXgnOiBpbnRPckRlZmF1bHQocXVlcnkuZnJhbWVNYXgsIDB4MTAwMCksXG4gICAgJ2hlYXJ0YmVhdCc6IGludE9yRGVmYXVsdChxdWVyeS5oZWFydGJlYXQsIDApLFxuXG4gICAgLy8gb3BlblxuICAgICd2aXJ0dWFsSG9zdCc6IHZob3N0LFxuICAgICdjYXBhYmlsaXRpZXMnOiAnJyxcbiAgICAnaW5zaXN0JzogMFxuICB9O1xufVxuXG4vLyBEZWNpZGUgb24gY3JlZGVudGlhbHMgYmFzZWQgb24gd2hhdCB3ZSdyZSBzdXBwbGllZC5cbmZ1bmN0aW9uIGNyZWRlbnRpYWxzRnJvbVVybChwYXJ0cykge1xuICB2YXIgdXNlciA9ICdndWVzdCcsIHBhc3N3ZCA9ICdndWVzdCc7XG4gIGlmIChwYXJ0cy51c2VybmFtZSAhPSAnJyB8fCBwYXJ0cy5wYXNzd29yZCAhPSAnJykge1xuICAgIHVzZXIgPSAocGFydHMudXNlcm5hbWUpID8gdW5lc2NhcGUocGFydHMudXNlcm5hbWUpIDogJyc7XG4gICAgcGFzc3dkID0gKHBhcnRzLnBhc3N3b3JkKSA/IHVuZXNjYXBlKHBhcnRzLnBhc3N3b3JkKSA6ICcnO1xuICB9XG4gIHJldHVybiBjcmVkZW50aWFscy5wbGFpbih1c2VyLCBwYXNzd2QpO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0KHVybCwgc29ja2V0T3B0aW9ucywgb3BlbkNhbGxiYWNrKSB7XG4gIC8vIHRscy5jb25uZWN0IHVzZXMgYHV0aWwuX2V4dGVuZCgpYCBvbiB0aGUgb3B0aW9ucyBnaXZlbiBpdCwgd2hpY2hcbiAgLy8gY29waWVzIG9ubHkgcHJvcGVydGllcyBtZW50aW9uZWQgaW4gYE9iamVjdC5rZXlzKClgLCB3aGVuXG4gIC8vIHByb2Nlc3NpbmcgdGhlIG9wdGlvbnMuIFNvIEkgaGF2ZSB0byBtYWtlIGNvcGllcyB0b28sIHJhdGhlclxuICAvLyB0aGFuIHVzaW5nIGBPYmplY3QuY3JlYXRlKClgLlxuICB2YXIgc29ja29wdHMgPSBjbG9uZShzb2NrZXRPcHRpb25zIHx8IHt9KTtcbiAgdXJsID0gdXJsIHx8ICdhbXFwOi8vbG9jYWxob3N0JztcblxuICB2YXIgbm9EZWxheSA9ICEhc29ja29wdHMubm9EZWxheTtcbiAgdmFyIHRpbWVvdXQgPSBzb2Nrb3B0cy50aW1lb3V0O1xuICB2YXIga2VlcEFsaXZlID0gISFzb2Nrb3B0cy5rZWVwQWxpdmU7XG4gIC8vIDAgaXMgZGVmYXVsdCBmb3Igbm9kZVxuICB2YXIga2VlcEFsaXZlRGVsYXkgPSBzb2Nrb3B0cy5rZWVwQWxpdmVEZWxheSB8fCAwO1xuXG4gIHZhciBleHRyYUNsaWVudFByb3BlcnRpZXMgPSBzb2Nrb3B0cy5jbGllbnRQcm9wZXJ0aWVzIHx8IHt9O1xuXG4gIHZhciBwcm90b2NvbCwgZmllbGRzO1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm90b2NvbCA9ICh1cmwucHJvdG9jb2wgfHwgJ2FtcXAnKSArICc6JztcbiAgICBzb2Nrb3B0cy5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHNvY2tvcHRzLnNlcnZlcm5hbWUgPSBzb2Nrb3B0cy5zZXJ2ZXJuYW1lIHx8IHVybC5ob3N0bmFtZTtcbiAgICBzb2Nrb3B0cy5wb3J0ID0gdXJsLnBvcnQgfHwgKChwcm90b2NvbCA9PT0gJ2FtcXA6JykgPyA1NjcyIDogNTY3MSk7XG5cbiAgICB2YXIgdXNlciwgcGFzcztcbiAgICAvLyBPbmx5IGRlZmF1bHQgaWYgYm90aCBhcmUgbWlzc2luZywgdG8gaGF2ZSB0aGUgc2FtZSBiZWhhdmlvdXIgYXNcbiAgICAvLyB0aGUgc3RyaW5nbHkgVVJMLlxuICAgIGlmICh1cmwudXNlcm5hbWUgPT0gdW5kZWZpbmVkICYmIHVybC5wYXNzd29yZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZXIgPSAnZ3Vlc3QnOyBwYXNzID0gJ2d1ZXN0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdXNlciA9IHVybC51c2VybmFtZSB8fCAnJztcbiAgICAgIHBhc3MgPSB1cmwucGFzc3dvcmQgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgIGxvY2FsZTogdXJsLmxvY2FsZSxcbiAgICAgIGNoYW5uZWxNYXg6IHVybC5jaGFubmVsTWF4LFxuICAgICAgZnJhbWVNYXg6IHVybC5mcmFtZU1heCxcbiAgICAgIGhlYXJ0YmVhdDogdXJsLmhlYXJ0YmVhdCxcbiAgICB9O1xuXG4gICAgZmllbGRzID0gb3BlbkZyYW1lcyh1cmwudmhvc3QsIGNvbmZpZywgc29ja29wdHMuY3JlZGVudGlhbHMgfHwgY3JlZGVudGlhbHMucGxhaW4odXNlciwgcGFzcyksIGV4dHJhQ2xpZW50UHJvcGVydGllcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gVVJMKHVybCwgdHJ1ZSk7IC8vIHllcywgcGFyc2UgdGhlIHF1ZXJ5IHN0cmluZ1xuICAgIHByb3RvY29sID0gcGFydHMucHJvdG9jb2w7XG4gICAgc29ja29wdHMuaG9zdCA9IHBhcnRzLmhvc3RuYW1lO1xuICAgIHNvY2tvcHRzLnNlcnZlcm5hbWUgPSBzb2Nrb3B0cy5zZXJ2ZXJuYW1lIHx8IHBhcnRzLmhvc3RuYW1lO1xuICAgIHNvY2tvcHRzLnBvcnQgPSBwYXJzZUludChwYXJ0cy5wb3J0KSB8fCAoKHByb3RvY29sID09PSAnYW1xcDonKSA/IDU2NzIgOiA1NjcxKTtcbiAgICB2YXIgdmhvc3QgPSBwYXJ0cy5wYXRobmFtZSA/IHBhcnRzLnBhdGhuYW1lLnN1YnN0cigxKSA6IG51bGw7XG4gICAgZmllbGRzID0gb3BlbkZyYW1lcyh2aG9zdCwgcGFydHMucXVlcnksIHNvY2tvcHRzLmNyZWRlbnRpYWxzIHx8IGNyZWRlbnRpYWxzRnJvbVVybChwYXJ0cyksIGV4dHJhQ2xpZW50UHJvcGVydGllcyk7XG4gIH1cblxuICB2YXIgc29ja29rID0gZmFsc2U7XG4gIHZhciBzb2NrO1xuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdCgpIHtcbiAgICBzb2Nrb2sgPSB0cnVlO1xuICAgIHNvY2suc2V0Tm9EZWxheShub0RlbGF5KTtcbiAgICBpZiAoa2VlcEFsaXZlKSBzb2NrLnNldEtlZXBBbGl2ZShrZWVwQWxpdmUsIGtlZXBBbGl2ZURlbGF5KTtcblxuICAgIHZhciBjID0gbmV3IENvbm5lY3Rpb24oc29jayk7XG4gICAgYy5vcGVuKGZpZWxkcywgZnVuY3Rpb24oZXJyLCBvaykge1xuICAgICAgLy8gZGlzYWJsZSB0aW1lb3V0IG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbiwgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gaXQgZm91bGluZyB0aGluZ3NcbiAgICAgIGlmICh0aW1lb3V0KSBzb2NrLnNldFRpbWVvdXQoMCk7XG4gICAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICAgIG9wZW5DYWxsYmFjayhudWxsLCBjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjb25uZWN0aW9uIGlzbid0IGNsb3NlZCBieSB0aGUgc2VydmVyIG9uIGUuZy4gd3JvbmcgcGFzc3dvcmRcbiAgICAgICAgc29jay5lbmQoKTtcbiAgICAgICAgc29jay5kZXN0cm95KCk7XG4gICAgICAgIG9wZW5DYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnYW1xcDonKSB7XG4gICAgc29jayA9IHJlcXVpcmUoJ25ldCcpLmNvbm5lY3Qoc29ja29wdHMsIG9uQ29ubmVjdCk7XG4gIH1cbiAgZWxzZSBpZiAocHJvdG9jb2wgPT09ICdhbXFwczonKSB7XG4gICAgc29jayA9IHJlcXVpcmUoJ3RscycpLmNvbm5lY3Qoc29ja29wdHMsIG9uQ29ubmVjdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYW1xcDogb3IgYW1xcHM6IGFzIHRoZSBwcm90b2NvbDsgZ290IFwiICsgcHJvdG9jb2wpO1xuICB9XG5cbiAgaWYgKHRpbWVvdXQpIHtcbiAgICBzb2NrLnNldFRpbWVvdXQodGltZW91dCwgZnVuY3Rpb24oKSB7XG4gICAgICBzb2NrLmVuZCgpO1xuICAgICAgc29jay5kZXN0cm95KCk7XG4gICAgICBvcGVuQ2FsbGJhY2sobmV3IEVycm9yKCdjb25uZWN0IEVUSU1FRE9VVCcpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNvY2sub25jZSgnZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoIXNvY2tvaykgb3BlbkNhbGxiYWNrKGVycik7XG4gIH0pO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xubW9kdWxlLmV4cG9ydHMuY3JlZGVudGlhbHNGcm9tVXJsID0gY3JlZGVudGlhbHNGcm9tVXJsO1xuIiwiLy9cbi8vXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgY29uc3RhbnRzID0gZGVmcy5jb25zdGFudHM7XG52YXIgZnJhbWUgPSByZXF1aXJlKCcuL2ZyYW1lJyk7XG52YXIgSEVBUlRCRUFUID0gZnJhbWUuSEVBUlRCRUFUO1xudmFyIE11eCA9IHJlcXVpcmUoJy4vbXV4JykuTXV4O1xuXG52YXIgRHVwbGV4ID1cbiAgcmVxdWlyZSgnc3RyZWFtJykuRHVwbGV4IHx8XG4gIHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgSGVhcnQgPSByZXF1aXJlKCcuL2hlYXJ0YmVhdCcpLkhlYXJ0O1xuXG52YXIgbWV0aG9kTmFtZSA9IHJlcXVpcmUoJy4vZm9ybWF0JykubWV0aG9kTmFtZTtcbnZhciBjbG9zZU1zZyA9IHJlcXVpcmUoJy4vZm9ybWF0JykuY2xvc2VNZXNzYWdlO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLmluc3BlY3Q7XG5cbnZhciBCaXRTZXQgPSByZXF1aXJlKCcuL2JpdHNldCcpLkJpdFNldDtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBmbXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xudmFyIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnc3RyZWFtJykuUGFzc1Rocm91Z2ggfHxcbiAgcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoJyk7XG52YXIgSWxsZWdhbE9wZXJhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLklsbGVnYWxPcGVyYXRpb25FcnJvcjtcbnZhciBzdGFja0NhcHR1cmUgPSByZXF1aXJlKCcuL2Vycm9yJykuc3RhY2tDYXB0dXJlO1xuXG4vLyBIaWdoLXdhdGVyIG1hcmsgZm9yIGNoYW5uZWwgd3JpdGUgYnVmZmVycywgaW4gJ29iamVjdHMnICh3aGljaCBhcmVcbi8vIGVuY29kZWQgZnJhbWVzIGFzIGJ1ZmZlcnMpLlxudmFyIERFRkFVTFRfV1JJVEVfSFdNID0gMTAyNDtcbi8vIElmIGFsbCB0aGUgZnJhbWVzIG9mIGEgbWVzc2FnZSAobWV0aG9kLCBwcm9wZXJ0aWVzLCBjb250ZW50KSB0b3RhbFxuLy8gdG8gbGVzcyB0aGFuIHRoaXMsIGNvcHkgdGhlbSBpbnRvIGEgc2luZ2xlIGJ1ZmZlciBhbmQgd3JpdGUgaXQgYWxsXG4vLyBhdCBvbmNlLiBOb3RlIHRoYXQgdGhpcyBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gZnJhbWUgc2l6ZTogaWYgaXRcbi8vIHdhcyBncmVhdGVyLCB3ZSBtaWdodCBoYXZlIHRvIGZyYWdtZW50IHRoZSBjb250ZW50LlxudmFyIFNJTkdMRV9DSFVOS19USFJFU0hPTEQgPSAyMDQ4O1xuXG5mdW5jdGlvbiBDb25uZWN0aW9uKHVuZGVybHlpbmcpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwoIHRoaXMgKTtcbiAgdmFyIHN0cmVhbSA9IHRoaXMuc3RyZWFtID0gd3JhcFN0cmVhbSh1bmRlcmx5aW5nKTtcbiAgdGhpcy5tdXhlciA9IG5ldyBNdXgoc3RyZWFtKTtcblxuICAvLyBmcmFtZXNcbiAgdGhpcy5yZXN0ID0gQnVmZmVyLmFsbG9jKDApO1xuICB0aGlzLmZyYW1lTWF4ID0gY29uc3RhbnRzLkZSQU1FX01JTl9TSVpFO1xuICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IGZhbHNlO1xuICB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjayA9IGZhbHNlO1xuXG4gIHRoaXMuZXhwZWN0U29ja2V0Q2xvc2UgPSBmYWxzZTtcbiAgdGhpcy5mcmVlQ2hhbm5lbHMgPSBuZXcgQml0U2V0KCk7XG4gIHRoaXMuY2hhbm5lbHMgPSBbe2NoYW5uZWw6IHthY2NlcHQ6IGNoYW5uZWwwKHRoaXMpfSxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB1bmRlcmx5aW5nfV07XG59XG5pbmhlcml0cyhDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuXG52YXIgQyA9IENvbm5lY3Rpb24ucHJvdG90eXBlO1xuXG4vLyBVc3VhbCBmcmFtZSBhY2NlcHQgbW9kZVxuZnVuY3Rpb24gbWFpbkFjY2VwdChmcmFtZSkge1xuICB2YXIgcmVjID0gdGhpcy5jaGFubmVsc1tmcmFtZS5jaGFubmVsXTtcbiAgaWYgKHJlYykgeyByZXR1cm4gcmVjLmNoYW5uZWwuYWNjZXB0KGZyYW1lKTsgfVxuICAvLyBOQiBDSEFOTkVMX0VSUk9SIG1heSBub3QgYmUgcmlnaHQsIGJ1dCBJIGRvbid0IGtub3cgd2hhdCBpcyAuLlxuICBlbHNlXG4gICAgdGhpcy5jbG9zZVdpdGhFcnJvcihcbiAgICAgIGZtdCgnRnJhbWUgb24gdW5rbm93biBjaGFubmVsICVkJywgZnJhbWUuY2hhbm5lbCksXG4gICAgICBjb25zdGFudHMuQ0hBTk5FTF9FUlJPUixcbiAgICAgIG5ldyBFcnJvcihmbXQoXCJGcmFtZSBvbiB1bmtub3duIGNoYW5uZWw6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3QoZnJhbWUsIGZhbHNlKSkpKTtcbn1cblxuLy8gSGFuZGxlIGFueXRoaW5nIHRoYXQgY29tZXMgdGhyb3VnaCBvbiBjaGFubmVsIDAsIHRoYXQncyB0aGVcbi8vIGNvbm5lY3Rpb24gY29udHJvbCBjaGFubmVsLiBUaGlzIGlzIG9ubHkgdXNlZCBvbmNlIG1haW5BY2NlcHQgaXNcbi8vIGluc3RhbGxlZCBhcyB0aGUgZnJhbWUgaGFuZGxlciwgYWZ0ZXIgdGhlIG9wZW5pbmcgaGFuZHNoYWtlLlxuZnVuY3Rpb24gY2hhbm5lbDAoY29ubmVjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgIC8vIE9uY2Ugd2UgZ2V0IGEgJ2Nsb3NlJywgd2Uga25vdyAxLiB3ZSdsbCBnZXQgbm8gbW9yZSBmcmFtZXMsIGFuZFxuICAgIC8vIDIuIGFueXRoaW5nIHdlIHNlbmQgZXhjZXB0IGNsb3NlLCBvciBjbG9zZS1vaywgd2lsbCBiZVxuICAgIC8vIGlnbm9yZWQuIElmIHdlIGFscmVhZHkgc2VudCAnY2xvc2UnLCB0aGlzIHdvbid0IGJlIGludm9rZWQgc2luY2VcbiAgICAvLyB3ZSdyZSBhbHJlYWR5IGluIGNsb3NpbmcgbW9kZTsgaWYgd2UgZGlkbid0IHdlbGwgd2UncmUgbm90IGdvaW5nXG4gICAgLy8gdG8gc2VuZCBpdCBub3cgYXJlIHdlLlxuICAgIGlmIChmID09PSBIRUFSVEJFQVQpOyAvLyBpZ25vcmU7IGl0J3MgYWxyZWFkeSBjb3VudGVkIGFzIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBzb2NrZXQsIHdoaWNoIGlzIGl0cyBwdXJwb3NlXG4gICAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5Db25uZWN0aW9uQ2xvc2UpIHtcbiAgICAgIC8vIE9oLiBPSy4gSSBndWVzcyB3ZSdyZSBkb25lIGhlcmUgdGhlbi5cbiAgICAgIGNvbm5lY3Rpb24uc2VuZE1ldGhvZCgwLCBkZWZzLkNvbm5lY3Rpb25DbG9zZU9rLCB7fSk7XG4gICAgICB2YXIgZW1zZyA9IGZtdCgnQ29ubmVjdGlvbiBjbG9zZWQ6ICVzJywgY2xvc2VNc2coZikpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoZW1zZyk7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgIGUuY29kZSA9IGYuZmllbGRzLnJlcGx5Q29kZTtcbiAgICAgIGlmIChpc0ZhdGFsRXJyb3IoZSkpIHtcbiAgICAgICAgY29ubmVjdGlvbi5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgfVxuICAgICAgY29ubmVjdGlvbi50b0Nsb3NlZChzLCBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5Db25uZWN0aW9uQmxvY2tlZCkge1xuICAgICAgY29ubmVjdGlvbi5lbWl0KCdibG9ja2VkJywgZi5maWVsZHMucmVhc29uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5Db25uZWN0aW9uVW5ibG9ja2VkKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ3VuYmxvY2tlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2VXaXRoRXJyb3IoXG4gICAgICAgIGZtdChcIlVuZXhwZWN0ZWQgZnJhbWUgb24gY2hhbm5lbCAwXCIpLFxuICAgICAgICBjb25zdGFudHMuVU5FWFBFQ1RFRF9GUkFNRSxcbiAgICAgICAgbmV3IEVycm9yKGZtdChcIlVuZXhwZWN0ZWQgZnJhbWUgb24gY2hhbm5lbCAwOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIGluc3BlY3QoZiwgZmFsc2UpKSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVGhpcyBjaGFuZ2VkIGJldHdlZW4gdmVyc2lvbnMsIGFzIGRpZCB0aGUgY29kZWMsIG1ldGhvZHMsIGV0Yy4gQU1RUFxuLy8gMC05LTEgaXMgZmFpcmx5IHNpbWlsYXIgdG8gMC44LCBidXQgYmV0dGVyLCBhbmQgbm90aGluZyBpbXBsZW1lbnRzXG4vLyAwLjggdGhhdCBkb2Vzbid0IGltcGxlbWVudCAwLTktMS4gSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWFrZVxuLy8gbXVjaCBzZW5zZSB0byBnZW5lcmFsaXNlIGhlcmUuXG5DLnNlbmRQcm90b2NvbEhlYWRlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlbmRCeXRlcyhmcmFtZS5QUk9UT0NPTF9IRUFERVIpO1xufTtcblxuLypcbiAgVGhlIGZyaWdodGVuaW5nbHkgY29tcGxpY2F0ZWQgb3BlbmluZyBwcm90b2NvbCAoc3BlYyBzZWN0aW9uIDIuMi40KTpcblxuICAgICBDbGllbnQgLT4gU2VydmVyXG5cbiAgICAgICBwcm90b2NvbCBoZWFkZXIgLT5cbiAgICAgICAgIDwtIHN0YXJ0XG4gICAgICAgc3RhcnQtb2sgLT5cbiAgICAgLi4gbmV4dCB0d28gemVybyBvciBtb3JlIHRpbWVzIC4uXG4gICAgICAgICA8LSBzZWN1cmVcbiAgICAgICBzZWN1cmUtb2sgLT5cbiAgICAgICAgIDwtIHR1bmVcbiAgICAgICB0dW5lLW9rIC0+XG4gICAgICAgb3BlbiAtPlxuICAgICAgICAgPC0gb3Blbi1va1xuXG5JZiBJJ20gb25seSBzdXBwb3J0aW5nIFNBU0wncyBQTEFJTiBtZWNoYW5pc20gKHdoaWNoIEkgYW0gZm9yIHRoZSB0aW1lXG5iZWluZyksIGl0IGdldHMgYSBiaXQgZWFzaWVyIHNpbmNlIHRoZSBzZXJ2ZXIgd29uJ3QgaW4gZ2VuZXJhbCBzZW5kXG5iYWNrIGEgYHNlY3VyZWAsIGl0J2xsIGp1c3Qgc2VuZCBgdHVuZWAgYWZ0ZXIgdGhlIGBzdGFydC1va2AuXG4oU0FTTCBQTEFJTjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDYxNilcblxuKi9cblxuQy5vcGVuID0gZnVuY3Rpb24oYWxsRmllbGRzLCBvcGVuQ2FsbGJhY2swKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9wZW5DYWxsYmFjayA9IG9wZW5DYWxsYmFjazAgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAvLyBUaGlzIGlzIHdoZXJlIHdlJ2xsIHB1dCBvdXIgbmVnb3RpYXRlZCB2YWx1ZXNcbiAgdmFyIHR1bmVkT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYWxsRmllbGRzKTtcblxuICBmdW5jdGlvbiB3YWl0KGspIHtcbiAgICBzZWxmLnN0ZXAoZnVuY3Rpb24oZXJyLCBmcmFtZSkge1xuICAgICAgaWYgKGVyciAhPT0gbnVsbCkgYmFpbChlcnIpO1xuICAgICAgZWxzZSBpZiAoZnJhbWUuY2hhbm5lbCAhPT0gMCkge1xuICAgICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgICBmbXQoXCJGcmFtZSBvbiBjaGFubmVsICE9IDAgZHVyaW5nIGhhbmRzaGFrZTogJXNcIixcbiAgICAgICAgICAgICAgaW5zcGVjdChmcmFtZSwgZmFsc2UpKSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBrKGZyYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGVjdChNZXRob2QsIGspIHtcbiAgICB3YWl0KGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICBpZiAoZnJhbWUuaWQgPT09IE1ldGhvZCkgayhmcmFtZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgYmFpbChuZXcgRXJyb3IoXG4gICAgICAgICAgZm10KFwiRXhwZWN0ZWQgJXM7IGdvdCAlc1wiLFxuICAgICAgICAgICAgICBtZXRob2ROYW1lKE1ldGhvZCksIGluc3BlY3QoZnJhbWUsIGZhbHNlKSkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhaWwoZXJyKSB7XG4gICAgb3BlbkNhbGxiYWNrKGVycik7XG4gIH1cblxuICBmdW5jdGlvbiBzZW5kKE1ldGhvZCkge1xuICAgIC8vIFRoaXMgY2FuIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSdzIHNvbWUgcHJvYmxlbSB3aXRoIHRoZVxuICAgIC8vIG9wdGlvbnM7IGUuZy4sIHNvbWV0aGluZyBpcyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgbnVtYmVyLlxuICAgIHNlbGYuc2VuZE1ldGhvZCgwLCBNZXRob2QsIHR1bmVkT3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZWdvdGlhdGUoc2VydmVyLCBkZXNpcmVkKSB7XG4gICAgLy8gV2UgZ2V0IHNlbnQgdmFsdWVzIGZvciBjaGFubmVsTWF4LCBmcmFtZU1heCBhbmQgaGVhcnRiZWF0LFxuICAgIC8vIHdoaWNoIHdlIG1heSBhY2NlcHQgb3IgbG93ZXIgKHN1YmplY3QgdG8gYSBtaW5pbXVtIGZvclxuICAgIC8vIGZyYW1lTWF4LCBidXQgd2UnbGwgbGVhdmUgdGhhdCB0byB0aGUgc2VydmVyIHRvIGVuZm9yY2UpLiBJblxuICAgIC8vIGFsbCBjYXNlcywgYDBgIHJlYWxseSBtZWFucyBcIm5vIGxpbWl0XCIsIG9yIHJhdGhlciB0aGUgaGlnaGVzdFxuICAgIC8vIHZhbHVlIGluIHRoZSBlbmNvZGluZywgZS5nLiwgdW5zaWduZWQgc2hvcnQgZm9yIGNoYW5uZWxNYXguXG4gICAgaWYgKHNlcnZlciA9PT0gMCB8fCBkZXNpcmVkID09PSAwKSB7XG4gICAgICAvLyBpLmUuLCB3aGljaGV2ZXIgcGxhY2VzIGEgbGltaXQsIGlmIGVpdGhlclxuICAgICAgcmV0dXJuIE1hdGgubWF4KHNlcnZlciwgZGVzaXJlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHNlcnZlciwgZGVzaXJlZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdGFydChzdGFydCkge1xuICAgIHZhciBtZWNoYW5pc21zID0gc3RhcnQuZmllbGRzLm1lY2hhbmlzbXMudG9TdHJpbmcoKS5zcGxpdCgnICcpO1xuICAgIGlmIChtZWNoYW5pc21zLmluZGV4T2YoYWxsRmllbGRzLm1lY2hhbmlzbSkgPCAwKSB7XG4gICAgICBiYWlsKG5ldyBFcnJvcihmbXQoJ1NBU0wgbWVjaGFuaXNtICVzIGlzIG5vdCBwcm92aWRlZCBieSB0aGUgc2VydmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGaWVsZHMubWVjaGFuaXNtKSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnNlcnZlclByb3BlcnRpZXMgPSBzdGFydC5maWVsZHMuc2VydmVyUHJvcGVydGllcztcbiAgICB0cnkge1xuICAgICAgc2VuZChkZWZzLkNvbm5lY3Rpb25TdGFydE9rKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGJhaWwoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FpdChhZnRlclN0YXJ0T2spO1xuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJTdGFydE9rKHJlcGx5KSB7XG4gICAgc3dpdGNoIChyZXBseS5pZCkge1xuICAgIGNhc2UgZGVmcy5Db25uZWN0aW9uU2VjdXJlOlxuICAgICAgYmFpbChuZXcgRXJyb3IoXG4gICAgICAgIFwiV2Fzbid0IGV4cGVjdGluZyB0byBoYXZlIHRvIGdvIHRocm91Z2ggc2VjdXJlXCIpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZGVmcy5Db25uZWN0aW9uQ2xvc2U6XG4gICAgICBiYWlsKG5ldyBFcnJvcihmbXQoXCJIYW5kc2hha2UgdGVybWluYXRlZCBieSBzZXJ2ZXI6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VNc2cocmVwbHkpKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBkZWZzLkNvbm5lY3Rpb25UdW5lOlxuICAgICAgdmFyIGZpZWxkcyA9IHJlcGx5LmZpZWxkcztcbiAgICAgIHR1bmVkT3B0aW9ucy5mcmFtZU1heCA9XG4gICAgICAgIG5lZ290aWF0ZShmaWVsZHMuZnJhbWVNYXgsIGFsbEZpZWxkcy5mcmFtZU1heCk7XG4gICAgICB0dW5lZE9wdGlvbnMuY2hhbm5lbE1heCA9XG4gICAgICAgIG5lZ290aWF0ZShmaWVsZHMuY2hhbm5lbE1heCwgYWxsRmllbGRzLmNoYW5uZWxNYXgpO1xuICAgICAgdHVuZWRPcHRpb25zLmhlYXJ0YmVhdCA9XG4gICAgICAgIG5lZ290aWF0ZShmaWVsZHMuaGVhcnRiZWF0LCBhbGxGaWVsZHMuaGVhcnRiZWF0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbmQoZGVmcy5Db25uZWN0aW9uVHVuZU9rKTtcbiAgICAgICAgc2VuZChkZWZzLkNvbm5lY3Rpb25PcGVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBiYWlsKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4cGVjdChkZWZzLkNvbm5lY3Rpb25PcGVuT2ssIG9uT3Blbk9rKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgZm10KFwiRXhwZWN0ZWQgY29ubmVjdGlvbi5zZWN1cmUsIGNvbm5lY3Rpb24uY2xvc2UsIFwiICtcbiAgICAgICAgICAgIFwib3IgY29ubmVjdGlvbi50dW5lIGR1cmluZyBoYW5kc2hha2U7IGdvdCAlc1wiLFxuICAgICAgICAgICAgaW5zcGVjdChyZXBseSwgZmFsc2UpKSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25PcGVuT2sob3Blbk9rKSB7XG4gICAgLy8gSW1wb3NlIHRoZSBtYXhpbXVtIG9mIHRoZSBlbmNvZGVkIHZhbHVlLCBpZiB0aGUgbmVnb3RpYXRlZFxuICAgIC8vIHZhbHVlIGlzIHplcm8sIG1lYW5pbmcgXCJubywgbm8gbGltaXRzXCJcbiAgICBzZWxmLmNoYW5uZWxNYXggPSB0dW5lZE9wdGlvbnMuY2hhbm5lbE1heCB8fCAweGZmZmY7XG4gICAgc2VsZi5mcmFtZU1heCA9IHR1bmVkT3B0aW9ucy5mcmFtZU1heCB8fCAweGZmZmZmZmZmO1xuICAgIC8vIDAgbWVhbnMgXCJubyBoZWFydGJlYXRcIiwgcmF0aGVyIHRoYW4gXCJtYXhpbXVtIHBlcmlvZCBvZlxuICAgIC8vIGhlYXJ0YmVhdGluZ1wiXG4gICAgc2VsZi5oZWFydGJlYXQgPSB0dW5lZE9wdGlvbnMuaGVhcnRiZWF0O1xuICAgIHNlbGYuaGVhcnRiZWF0ZXIgPSBzZWxmLnN0YXJ0SGVhcnRiZWF0ZXIoKTtcbiAgICBzZWxmLmFjY2VwdCA9IG1haW5BY2NlcHQ7XG4gICAgc3VjY2VlZChvcGVuT2spO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNlcnZlciBjbG9zZXMgdGhlIGNvbm5lY3Rpb24sIGl0J3MgcHJvYmFibHkgYmVjYXVzZSBvZlxuICAvLyBzb21ldGhpbmcgd2UgZGlkXG4gIGZ1bmN0aW9uIGVuZFdoaWxlT3BlbmluZyhlcnIpIHtcbiAgICBiYWlsKGVyciB8fCBuZXcgRXJyb3IoJ1NvY2tldCBjbG9zZWQgYWJydXB0bHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkdXJpbmcgb3BlbmluZyBoYW5kc2hha2UnKSk7XG4gIH1cblxuICB0aGlzLnN0cmVhbS5vbignZW5kJywgZW5kV2hpbGVPcGVuaW5nKTtcbiAgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgZW5kV2hpbGVPcGVuaW5nKTtcblxuICBmdW5jdGlvbiBzdWNjZWVkKG9rKSB7XG4gICAgc2VsZi5zdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGVuZFdoaWxlT3BlbmluZyk7XG4gICAgc2VsZi5zdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZW5kV2hpbGVPcGVuaW5nKTtcbiAgICBzZWxmLnN0cmVhbS5vbignZXJyb3InLCBzZWxmLm9uU29ja2V0RXJyb3IuYmluZChzZWxmKSk7XG4gICAgc2VsZi5zdHJlYW0ub24oJ2VuZCcsIHNlbGYub25Tb2NrZXRFcnJvci5iaW5kKFxuICAgICAgc2VsZiwgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNsb3NlJykpKTtcbiAgICBzZWxmLm9uKCdmcmFtZUVycm9yJywgc2VsZi5vblNvY2tldEVycm9yLmJpbmQoc2VsZikpO1xuICAgIHNlbGYuYWNjZXB0TG9vcCgpO1xuICAgIG9wZW5DYWxsYmFjayhudWxsLCBvayk7XG4gIH1cblxuICAvLyBOb3cga2ljayBvZmYgdGhlIGhhbmRzaGFrZSBieSBwcm9tcHRpbmcgdGhlIHNlcnZlclxuICB0aGlzLnNlbmRQcm90b2NvbEhlYWRlcigpO1xuICBleHBlY3QoZGVmcy5Db25uZWN0aW9uU3RhcnQsIG9uU3RhcnQpO1xufTtcblxuLy8gQ2xvc2luZyB0aGluZ3M6IEFNUVAgaGFzIGEgY2xvc2luZyBoYW5kc2hha2UgdGhhdCBhcHBsaWVzIHRvXG4vLyBjbG9zaW5nIGJvdGggY29ubmVjdHMgYW5kIGNoYW5uZWxzLiBBcyB0aGUgaW5pdGlhdGluZyBwYXJ0eSwgSSBzZW5kXG4vLyBDbG9zZSwgdGhlbiBpZ25vcmUgYWxsIGZyYW1lcyB1bnRpbCBJIHNlZSBlaXRoZXIgQ2xvc2VPSyAtLVxuLy8gd2hpY2ggc2lnbmlmaWVzIHRoYXQgdGhlIG90aGVyIHBhcnR5IGhhcyBzZWVuIHRoZSBDbG9zZSBhbmQgc2h1dFxuLy8gdGhlIGNvbm5lY3Rpb24gb3IgY2hhbm5lbCBkb3duLCBzbyBpdCdzIGZpbmUgdG8gZnJlZSByZXNvdXJjZXM7IG9yXG4vLyBDbG9zZSwgd2hpY2ggbWVhbnMgdGhlIG90aGVyIHBhcnR5IGFsc28gd2FudGVkIHRvIGNsb3NlIHRoZVxuLy8gd2hhdGV2ZXIsIGFuZCBJIHNob3VsZCBzZW5kIENsb3NlT2sgc28gaXQgY2FuIGZyZWUgcmVzb3VyY2VzLFxuLy8gdGhlbiBnbyBiYWNrIHRvIHdhaXRpbmcgZm9yIHRoZSBDbG9zZU9rLiBJZiBJIHJlY2VpdmUgYSBDbG9zZVxuLy8gb3V0IG9mIHRoZSBibHVlLCBJIHNob3VsZCB0aHJvdyBhd2F5IGFueSB1bnNlbnQgZnJhbWVzICh0aGV5IHdpbGxcbi8vIGJlIGlnbm9yZWQgYW55d2F5KSBhbmQgc2VuZCBDbG9zZU9rLCB0aGVuIGNsZWFuIHVwIHJlc291cmNlcy4gSW5cbi8vIGdlbmVyYWwsIENsb3NlIG91dCBvZiB0aGUgYmx1ZSBzaWduYWxzIGFuIGVycm9yIChvciBhIGZvcmNlZFxuLy8gY2xvc3VyZSwgd2hpY2ggbWF5IGFzIHdlbGwgYmUgYW4gZXJyb3IpLlxuLy9cbi8vICBSVU5OSU5HIFsxXSAtLS0gc2VuZCBDbG9zZSAtLS0+IENsb3NpbmcgWzJdIC0tLT4gcmVjdiBDbG9zZSAtLStcbi8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgWzNdXG4vLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tIHNlbmQgQ2xvc2VPayAtLS0tLS0rXG4vLyAgcmVjdiBDbG9zZSAgICAgICAgICAgICAgICAgICByZWN2IENsb3NlT2tcbi8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vICAgICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZcbi8vICBFbmRlZCBbNF0gLS0tLSBzZW5kIENsb3NlT2sgLS0tPiBDbG9zZWQgWzVdXG4vL1xuLy8gWzFdIEFsbCBmcmFtZXMgYWNjZXB0ZWQ7IGdldHRpbmcgYSBDbG9zZSBmcmFtZSBmcm9tIHRoZSBzZXJ2ZXJcbi8vIG1vdmVzIHRvIEVuZGVkOyBjbGllbnQgbWF5IGluaXRpYXRlIGEgY2xvc2UgYnkgc2VuZGluZyBDbG9zZVxuLy8gaXRzZWxmLlxuLy8gWzJdIENsaWVudCBoYXMgaW5pdGlhdGVkIGEgY2xvc2U7IG9ubHkgQ2xvc2VPayBvciAoc2ltdWxhdGFuZW91c2x5XG4vLyBzZW50KSBDbG9zZSBpcyBhY2NlcHRlZC5cbi8vIFszXSBTaW11bHRhbmVvdXMgY2xvc2Vcbi8vIFs0XSBTZXJ2ZXIgd29uJ3Qgc2VuZCBhbnkgbW9yZSBmcmFtZXM7IGFjY2VwdCBubyBtb3JlIGZyYW1lcywgc2VuZFxuLy8gQ2xvc2VPay5cbi8vIFs1XSBGdWxseSBjbG9zZWQsIGNsaWVudCB3aWxsIHNlbmQgbm8gbW9yZSwgc2VydmVyIHdpbGwgc2VuZCBub1xuLy8gbW9yZS4gU2lnbmFsICdjbG9zZScgb3IgJ2Vycm9yJy5cbi8vXG4vLyBUaGVyZSBhcmUgdHdvIHNpZ25hbGxpbmcgbWVjaGFuaXNtcyB1c2VkIGluIHRoZSBBUEkuIFRoZSBmaXJzdCBpc1xuLy8gdGhhdCBjYWxsaW5nIGBjbG9zZWAgd2lsbCByZXR1cm4gYSBwcm9taXNlLCB0aGF0IHdpbGwgZWl0aGVyXG4vLyByZXNvbHZlIG9uY2UgdGhlIGNvbm5lY3Rpb24gb3IgY2hhbm5lbCBpcyBjbGVhbmx5IHNodXQgZG93biwgb3Jcbi8vIHdpbGwgcmVqZWN0IGlmIHRoZSBzaHV0ZG93biB0aW1lcyBvdXQuXG4vL1xuLy8gVGhlIHNlY29uZCBpcyB0aGUgJ2Nsb3NlJyBhbmQgJ2Vycm9yJyBldmVudHMuIFRoZXNlIGFyZVxuLy8gZW1pdHRlZCBhcyBhYm92ZS4gVGhlIGV2ZW50cyB3aWxsIGZpcmUgKmJlZm9yZSogcHJvbWlzZXMgYXJlXG4vLyByZXNvbHZlZC5cblxuLy8gQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2l0aG91dCBldmVuIGdpdmluZyBhIHJlYXNvbi4gVHlwaWNhbC5cbkMuY2xvc2UgPSBmdW5jdGlvbihjbG9zZUNhbGxiYWNrKSB7XG4gIHZhciBrID0gY2xvc2VDYWxsYmFjayAmJiBmdW5jdGlvbigpIHsgY2xvc2VDYWxsYmFjayhudWxsKTsgfTtcbiAgdGhpcy5jbG9zZUJlY2F1c2UoXCJDaGVlcnMsIHRoYW5rc1wiLCBjb25zdGFudHMuUkVQTFlfU1VDQ0VTUywgayk7XG59O1xuXG4vLyBDbG9zZSB3aXRoIGEgcmVhc29uIGFuZCBhICdjb2RlJy4gSSdtIHByZXR0eSBzdXJlIFJhYmJpdE1RIHRvdGFsbHlcbi8vIGlnbm9yZXMgdGhlc2U7IG1heWJlIGl0IGxvZ3MgdGhlbS4gVGhlIGNvbnRpbnVhdGlvbiB3aWxsIGJlIGludm9rZWRcbi8vIHdoZW4gdGhlIENsb3NlT2sgaGFzIGJlZW4gcmVjZWl2ZWQsIGFuZCBiZWZvcmUgdGhlICdjbG9zZScgZXZlbnQuXG5DLmNsb3NlQmVjYXVzZSA9IGZ1bmN0aW9uKHJlYXNvbiwgY29kZSwgaykge1xuICB0aGlzLnNlbmRNZXRob2QoMCwgZGVmcy5Db25uZWN0aW9uQ2xvc2UsIHtcbiAgICByZXBseVRleHQ6IHJlYXNvbixcbiAgICByZXBseUNvZGU6IGNvZGUsXG4gICAgbWV0aG9kSWQ6IDAsIGNsYXNzSWQ6IDBcbiAgfSk7XG4gIHZhciBzID0gc3RhY2tDYXB0dXJlKCdjbG9zZUJlY2F1c2UgY2FsbGVkOiAnICsgcmVhc29uKTtcbiAgdGhpcy50b0Nsb3Npbmcocywgayk7XG59O1xuXG5DLmNsb3NlV2l0aEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCBjb2RlLCBlcnJvcikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB0aGlzLmNsb3NlQmVjYXVzZShyZWFzb24sIGNvZGUpO1xufTtcblxuQy5vblNvY2tldEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5leHBlY3RTb2NrZXRDbG9zZSkge1xuICAgIC8vIGZvcmVzdGFsbCBhbnkgbW9yZSBjYWxscyB0byBvblNvY2tldEVycm9yLCBzaW5jZSB3ZSdyZSBzaWduZWRcbiAgICAvLyB1cCBmb3IgYCdlcnJvcidgICphbmQqIGAnZW5kJ2BcbiAgICB0aGlzLmV4cGVjdFNvY2tldENsb3NlID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnU29ja2V0IGVycm9yJyk7XG4gICAgdGhpcy50b0Nsb3NlZChzLCBlcnIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbnZhbGlkT3AobXNnLCBzdGFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihtc2csIHN0YWNrKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZVNlbmQoY29ubiwgbXNnLCBzdGFjaykge1xuICBjb25uLnNlbmRNZXRob2QgPSBjb25uLnNlbmRDb250ZW50ID0gY29ubi5zZW5kTWVzc2FnZSA9XG4gICAgaW52YWxpZE9wKG1zZywgc3RhY2spO1xufVxuXG4vLyBBIGNsb3NlIGhhcyBiZWVuIGluaXRpYXRlZC4gUmVwZWF0OiBhIGNsb3NlIGhhcyBiZWVuIGluaXRpYXRlZC5cbi8vIFRoaXMgbWVhbnMgd2Ugc2hvdWxkIG5vdCBzZW5kIG1vcmUgZnJhbWVzLCBhbnl3YXkgdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLiBXZSBhbHNvIGhhdmUgdG8gc2h1dCBkb3duIGFsbCB0aGUgY2hhbm5lbHMuXG5DLnRvQ2xvc2luZyA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2ssIGspIHtcbiAgdmFyIHNlbmQgPSB0aGlzLnNlbmRNZXRob2QuYmluZCh0aGlzKTtcblxuICB0aGlzLmFjY2VwdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoZi5pZCA9PT0gZGVmcy5Db25uZWN0aW9uQ2xvc2VPaykge1xuICAgICAgaWYgKGspIGsoKTtcbiAgICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKCdDb25uZWN0aW9uQ2xvc2VPayByZWNlaXZlZCcpO1xuICAgICAgdGhpcy50b0Nsb3NlZChzLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZSkge1xuICAgICAgc2VuZCgwLCBkZWZzLkNvbm5lY3Rpb25DbG9zZU9rLCB7fSk7XG4gICAgfVxuICAgIC8vIGVsc2UgaWdub3JlIGZyYW1lXG4gIH07XG4gIGludmFsaWRhdGVTZW5kKHRoaXMsICdDb25uZWN0aW9uIGNsb3NpbmcnLCBjYXB0dXJlZFN0YWNrKTtcbn07XG5cbkMuX2Nsb3NlQ2hhbm5lbHMgPSBmdW5jdGlvbihjYXB0dXJlZFN0YWNrKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgaWYgKGNoICE9PSBudWxsKSB7XG4gICAgICBjaC5jaGFubmVsLnRvQ2xvc2VkKGNhcHR1cmVkU3RhY2spOyAvLyAlJSUgb3Igd2l0aCBhbiBlcnJvcj8gbm90IGNsZWFyXG4gICAgfVxuICB9XG59O1xuXG4vLyBBIGNsb3NlIGhhcyBiZWVuIGNvbmZpcm1lZC4gQ2Vhc2UgYWxsIGNvbW11bmljYXRpb24uXG5DLnRvQ2xvc2VkID0gZnVuY3Rpb24oY2FwdHVyZWRTdGFjaywgbWF5YmVFcnIpIHtcbiAgdGhpcy5fY2xvc2VDaGFubmVscyhjYXB0dXJlZFN0YWNrKTtcbiAgdmFyIGluZm8gPSBmbXQoJ0Nvbm5lY3Rpb24gY2xvc2VkICglcyknLFxuICAgICAgICAgICAgICAgICAobWF5YmVFcnIpID8gbWF5YmVFcnIudG9TdHJpbmcoKSA6ICdieSBjbGllbnQnKTtcbiAgLy8gVGlkeSB1cCwgaW52YWxpZGF0ZSBlbnZlcnl0aGluZywgZHluYW1pdGUgdGhlIGJyaWRnZXMuXG4gIGludmFsaWRhdGVTZW5kKHRoaXMsIGluZm8sIGNhcHR1cmVkU3RhY2spO1xuICB0aGlzLmFjY2VwdCA9IGludmFsaWRPcChpbmZvLCBjYXB0dXJlZFN0YWNrKTtcbiAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgY2IgJiYgY2IobmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihpbmZvLCBjYXB0dXJlZFN0YWNrKSk7XG4gIH07XG4gIGlmICh0aGlzLmhlYXJ0YmVhdGVyKSB0aGlzLmhlYXJ0YmVhdGVyLmNsZWFyKCk7XG4gIC8vIFRoaXMgaXMgY2VydGFpbmx5IHRydWUgbm93LCBpZiBpdCB3YXNuJ3QgYmVmb3JlXG4gIHRoaXMuZXhwZWN0U29ja2V0Q2xvc2UgPSB0cnVlO1xuICB0aGlzLnN0cmVhbS5lbmQoKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG1heWJlRXJyKTtcbn07XG5cbi8vID09PVxuXG5DLnN0YXJ0SGVhcnRiZWF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaGVhcnRiZWF0ID09PSAwKSByZXR1cm4gbnVsbDtcbiAgZWxzZSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBoYiA9IG5ldyBIZWFydCh0aGlzLmhlYXJ0YmVhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1NlbmQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1JlY3YuYmluZCh0aGlzKSk7XG4gICAgaGIub24oJ3RpbWVvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoYmVyciA9IG5ldyBFcnJvcihcIkhlYXJ0YmVhdCB0aW1lb3V0XCIpO1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGhiZXJyKTtcbiAgICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKCdIZWFydGJlYXQgdGltZW91dCcpO1xuICAgICAgc2VsZi50b0Nsb3NlZChzLCBoYmVycik7XG4gICAgfSk7XG4gICAgaGIub24oJ2JlYXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuc2VuZEhlYXJ0YmVhdCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBoYjtcbiAgfVxufTtcblxuLy8gSSB1c2UgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2hhbm5lbHMsIHJhdGhlciB0aGFuIGFuXG4vLyBvYmplY3QuIFRoZSBjaGFubmVsIGlkZW50aWZpZXJzIGFyZSBudW1iZXJzLCBhbmQgYWxsb2NhdGVkIGJ5IHRoZVxuLy8gY29ubmVjdGlvbi4gSWYgSSB0cnkgdG8gYWxsb2NhdGUgbG93IG51bWJlcnMgd2hlbiB0aGV5IGFyZVxuLy8gYXZhaWxhYmxlICh3aGljaCBJIGRvLCBieSBsb29raW5nIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBiaXRzZXQpLFxuLy8gdGhpcyBvdWdodCB0byBrZWVwIHRoZSBhcnJheSBzbWFsbCwgYW5kIG91dCBvZiAnc3BhcnNlIGFycmF5XG4vLyBzdG9yYWdlJy4gSSBhbHNvIHNldCBlbnRyaWVzIHRvIG51bGwsIHJhdGhlciB0aGFuIGRlbGV0aW5nIHRoZW0sIGluXG4vLyB0aGUgZXhwZWN0YXRpb24gdGhhdCB0aGUgbmV4dCBjaGFubmVsIGFsbG9jYXRpb24gd2lsbCBmaWxsIHRoZSBzbG90XG4vLyBhZ2FpbiByYXRoZXIgdGhhbiBncm93aW5nIHRoZSBhcnJheS4gU2VlXG4vLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9zcGVlZC92OC9cbkMuZnJlc2hDaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbCwgb3B0aW9ucykge1xuICB2YXIgbmV4dCA9IHRoaXMuZnJlZUNoYW5uZWxzLm5leHRDbGVhckJpdCgxKTtcbiAgaWYgKG5leHQgPCAwIHx8IG5leHQgPiB0aGlzLmNoYW5uZWxNYXgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhbm5lbHMgbGVmdCB0byBhbGxvY2F0ZVwiKTtcbiAgdGhpcy5mcmVlQ2hhbm5lbHMuc2V0KG5leHQpO1xuXG4gIHZhciBod20gPSAob3B0aW9ucyAmJiBvcHRpb25zLmhpZ2hXYXRlck1hcmspIHx8IERFRkFVTFRfV1JJVEVfSFdNO1xuICB2YXIgd3JpdGVCdWZmZXIgPSBuZXcgUGFzc1Rocm91Z2goe1xuICAgIG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IGh3bVxuICB9KTtcbiAgdGhpcy5jaGFubmVsc1tuZXh0XSA9IHtjaGFubmVsOiBjaGFubmVsLCBidWZmZXI6IHdyaXRlQnVmZmVyfTtcbiAgd3JpdGVCdWZmZXIub24oJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgY2hhbm5lbC5vbkJ1ZmZlckRyYWluKCk7XG4gIH0pO1xuICB0aGlzLm11eGVyLnBpcGVGcm9tKHdyaXRlQnVmZmVyKTtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG5DLnJlbGVhc2VDaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbCkge1xuICB0aGlzLmZyZWVDaGFubmVscy5jbGVhcihjaGFubmVsKTtcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uYnVmZmVyO1xuICBidWZmZXIuZW5kKCk7IC8vIHdpbGwgYWxzbyBjYXVzZSBpdCB0byBiZSB1bnBpcGVkXG4gIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0gPSBudWxsO1xufTtcblxuQy5hY2NlcHRMb29wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBnbygpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGY7IHdoaWxlIChmID0gc2VsZi5yZWN2RnJhbWUoKSkgc2VsZi5hY2NlcHQoZik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZyYW1lRXJyb3InLCBlKTtcbiAgICB9XG4gIH1cbiAgc2VsZi5zdHJlYW0ub24oJ3JlYWRhYmxlJywgZ28pO1xuICBnbygpO1xufTtcblxuQy5zdGVwID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiByZWN2KCkge1xuICAgIHZhciBmO1xuICAgIHRyeSB7XG4gICAgICBmID0gc2VsZi5yZWN2RnJhbWUoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUsIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZikgY2IobnVsbCwgZik7XG4gICAgZWxzZSBzZWxmLnN0cmVhbS5vbmNlKCdyZWFkYWJsZScsIHJlY3YpO1xuICB9XG4gIHJlY3YoKTtcbn07XG5cbkMuY2hlY2tTZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGVjayA9IHRoaXMuc2VudFNpbmNlTGFzdENoZWNrO1xuICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IGZhbHNlO1xuICByZXR1cm4gY2hlY2s7XG59XG5cbkMuY2hlY2tSZWN2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGVjayA9IHRoaXMucmVjdlNpbmNlTGFzdENoZWNrO1xuICB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjayA9IGZhbHNlO1xuICByZXR1cm4gY2hlY2s7XG59XG5cbkMuc2VuZEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5zZW50U2luY2VMYXN0Q2hlY2sgPSB0cnVlO1xuICB0aGlzLnN0cmVhbS53cml0ZShieXRlcyk7XG59O1xuXG5DLnNlbmRIZWFydGJlYXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2VuZEJ5dGVzKGZyYW1lLkhFQVJUQkVBVF9CVUYpO1xufTtcblxudmFyIGVuY29kZU1ldGhvZCA9IGRlZnMuZW5jb2RlTWV0aG9kO1xudmFyIGVuY29kZVByb3BlcnRpZXMgPSBkZWZzLmVuY29kZVByb3BlcnRpZXM7XG5cbkMuc2VuZE1ldGhvZCA9IGZ1bmN0aW9uKGNoYW5uZWwsIE1ldGhvZCwgZmllbGRzKSB7XG4gIHZhciBmcmFtZSA9IGVuY29kZU1ldGhvZChNZXRob2QsIGNoYW5uZWwsIGZpZWxkcyk7XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uYnVmZmVyO1xuICByZXR1cm4gYnVmZmVyLndyaXRlKGZyYW1lKTtcbn07XG5cbkMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihjaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgIE1ldGhvZCwgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnRpZXMsIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGVudCBpcyBub3QgYSBidWZmZXInKTtcblxuICB2YXIgbWZyYW1lID0gZW5jb2RlTWV0aG9kKE1ldGhvZCwgY2hhbm5lbCwgZmllbGRzKTtcbiAgdmFyIHBmcmFtZSA9IGVuY29kZVByb3BlcnRpZXMoUHJvcGVydGllcywgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5sZW5ndGgsIHByb3BzKTtcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uYnVmZmVyO1xuICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IHRydWU7XG5cbiAgdmFyIG1ldGhvZEhlYWRlckxlbiA9IG1mcmFtZS5sZW5ndGggKyBwZnJhbWUubGVuZ3RoO1xuICB2YXIgYm9keUxlbiA9IChjb250ZW50Lmxlbmd0aCA+IDApID9cbiAgICBjb250ZW50Lmxlbmd0aCArIEZSQU1FX09WRVJIRUFEIDogMDtcbiAgdmFyIGFsbExlbiA9IG1ldGhvZEhlYWRlckxlbiArIGJvZHlMZW47XG5cbiAgaWYgKGFsbExlbiA8IFNJTkdMRV9DSFVOS19USFJFU0hPTEQpIHtcbiAgICAvLyBVc2UgYGFsbG9jVW5zYWZlYCB0byBhdm9pZCBleGNlc3NpdmUgYWxsb2NhdGlvbnMgYW5kIENQVSB1c2FnZVxuICAgIC8vIGZyb20gemVyb2luZy4gVGhlIHJldHVybmVkIEJ1ZmZlciBpcyBub3QgemVyb2VkIGFuZCBzbyBtdXN0IGJlXG4gICAgLy8gY29tcGxldGVseSBmaWxsZWQgdG8gYmUgdXNlZCBzYWZlbHkuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXFwLW5vZGUvYW1xcGxpYi9wdWxsLzY5NVxuICAgIHZhciBhbGwgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYWxsTGVuKTtcbiAgICB2YXIgb2Zmc2V0ID0gbWZyYW1lLmNvcHkoYWxsLCAwKTtcbiAgICBvZmZzZXQgKz0gcGZyYW1lLmNvcHkoYWxsLCBvZmZzZXQpO1xuXG4gICAgaWYgKGJvZHlMZW4gPiAwKVxuICAgICAgbWFrZUJvZHlGcmFtZShjaGFubmVsLCBjb250ZW50KS5jb3B5KGFsbCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYnVmZmVyLndyaXRlKGFsbCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKG1ldGhvZEhlYWRlckxlbiA8IFNJTkdMRV9DSFVOS19USFJFU0hPTEQpIHtcbiAgICAgIC8vIFVzZSBgYWxsb2NVbnNhZmVgIHRvIGF2b2lkIGV4Y2Vzc2l2ZSBhbGxvY2F0aW9ucyBhbmQgQ1BVIHVzYWdlXG4gICAgICAvLyBmcm9tIHplcm9pbmcuIFRoZSByZXR1cm5lZCBCdWZmZXIgaXMgbm90IHplcm9lZCBhbmQgc28gbXVzdCBiZVxuICAgICAgLy8gY29tcGxldGVseSBmaWxsZWQgdG8gYmUgdXNlZCBzYWZlbHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FtcXAtbm9kZS9hbXFwbGliL3B1bGwvNjk1XG4gICAgICB2YXIgYm90aCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXRob2RIZWFkZXJMZW4pO1xuICAgICAgdmFyIG9mZnNldCA9IG1mcmFtZS5jb3B5KGJvdGgsIDApO1xuICAgICAgcGZyYW1lLmNvcHkoYm90aCwgb2Zmc2V0KTtcbiAgICAgIGJ1ZmZlci53cml0ZShib3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBidWZmZXIud3JpdGUobWZyYW1lKTtcbiAgICAgIGJ1ZmZlci53cml0ZShwZnJhbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZW5kQ29udGVudChjaGFubmVsLCBjb250ZW50KTtcbiAgfVxufTtcblxudmFyIEZSQU1FX09WRVJIRUFEID0gZGVmcy5GUkFNRV9PVkVSSEVBRDtcbnZhciBtYWtlQm9keUZyYW1lID0gZnJhbWUubWFrZUJvZHlGcmFtZTtcblxuQy5zZW5kQ29udGVudCA9IGZ1bmN0aW9uKGNoYW5uZWwsIGJvZHkpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZtdChcIkV4cGVjdGVkIGJ1ZmZlcjsgZ290ICVzXCIsIGJvZHkpKTtcbiAgfVxuICB2YXIgd3JpdGVSZXN1bHQgPSB0cnVlO1xuICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG5cbiAgdmFyIG1heEJvZHkgPSB0aGlzLmZyYW1lTWF4IC0gRlJBTUVfT1ZFUkhFQUQ7XG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYm9keS5sZW5ndGg7IG9mZnNldCArPSBtYXhCb2R5KSB7XG4gICAgdmFyIGVuZCA9IG9mZnNldCArIG1heEJvZHk7XG4gICAgdmFyIHNsaWNlID0gKGVuZCA+IGJvZHkubGVuZ3RoKSA/IGJvZHkuc2xpY2Uob2Zmc2V0KSA6IGJvZHkuc2xpY2Uob2Zmc2V0LCBlbmQpO1xuICAgIHZhciBib2R5RnJhbWUgPSBtYWtlQm9keUZyYW1lKGNoYW5uZWwsIHNsaWNlKTtcbiAgICB3cml0ZVJlc3VsdCA9IGJ1ZmZlci53cml0ZShib2R5RnJhbWUpO1xuICB9XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcbiAgcmV0dXJuIHdyaXRlUmVzdWx0O1xufTtcblxudmFyIHBhcnNlRnJhbWUgPSBmcmFtZS5wYXJzZUZyYW1lO1xudmFyIGRlY29kZUZyYW1lID0gZnJhbWUuZGVjb2RlRnJhbWU7XG5cbkMucmVjdkZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIC8vICUlJSBpZGVudGlmeWluZyBpbnZhcmlhbnRzIG1pZ2h0IGhlbHAgaGVyZT9cbiAgdmFyIGZyYW1lID0gcGFyc2VGcmFtZSh0aGlzLnJlc3QsIHRoaXMuZnJhbWVNYXgpO1xuXG4gIGlmICghZnJhbWUpIHtcbiAgICB2YXIgaW5jb21pbmcgPSB0aGlzLnN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGluY29taW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZWN2U2luY2VMYXN0Q2hlY2sgPSB0cnVlO1xuICAgICAgdGhpcy5yZXN0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5yZXN0LCBpbmNvbWluZ10pO1xuICAgICAgcmV0dXJuIHRoaXMucmVjdkZyYW1lKCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMucmVzdCA9IGZyYW1lLnJlc3Q7XG4gICAgcmV0dXJuIGRlY29kZUZyYW1lKGZyYW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JhcFN0cmVhbShzKSB7XG4gIGlmIChzIGluc3RhbmNlb2YgRHVwbGV4KSByZXR1cm4gcztcbiAgZWxzZSB7XG4gICAgdmFyIHdzID0gbmV3IER1cGxleCgpO1xuICAgIHdzLndyYXAocyk7IC8vd3JhcHMgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhpbmdzXG4gICAgd3MuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHMud3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gd3M7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGYXRhbEVycm9yKGVycm9yKSB7XG4gIHN3aXRjaCAoZXJyb3IgJiYgZXJyb3IuY29kZSkge1xuICBjYXNlIGRlZnMuY29uc3RhbnRzLkNPTk5FQ1RJT05fRk9SQ0VEOlxuICBjYXNlIGRlZnMuY29uc3RhbnRzLlJFUExZX1NVQ0NFU1M6XG4gICAgcmV0dXJuIGZhbHNlO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuaXNGYXRhbEVycm9yID0gaXNGYXRhbEVycm9yO1xuIiwiLy9cbi8vXG4vL1xuXG4vLyBEaWZmZXJlbnQga2luZCBvZiBjcmVkZW50aWFscyB0aGF0IGNhbiBiZSBzdXBwbGllZCB3aGVuIG9wZW5pbmcgYVxuLy8gY29ubmVjdGlvbiwgY29ycmVzcG9uZGluZyB0byBTQVNMIG1lY2hhbmlzbXMgVGhlcmUncyBvbmx5IHR3b1xuLy8gdXNlZnVsIG1lY2hhbmlzbXMgdGhhdCBSYWJiaXRNUSBpbXBsZW1lbnRzOlxuLy8gICogUExBSU4gKHNlbmQgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGluIHRoZSBwbGFpbilcbi8vICAqIEVYVEVSTkFMIChhc3N1bWUgdGhlIHNlcnZlciB3aWxsIGZpZ3VyZSBvdXQgd2hvIHlvdSBhcmUgZnJvbVxuLy8gICAgY29udGV4dCwgaS5lLiwgeW91ciBTU0wgY2VydGlmaWNhdGUpXG52YXIgY29kZWMgPSByZXF1aXJlKCcuL2NvZGVjJylcblxubW9kdWxlLmV4cG9ydHMucGxhaW4gPSBmdW5jdGlvbih1c2VyLCBwYXNzd2QpIHtcbiAgcmV0dXJuIHtcbiAgICBtZWNoYW5pc206ICdQTEFJTicsXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFsnJywgdXNlciwgcGFzc3dkXS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUoMCkpKVxuICAgIH0sXG4gICAgdXNlcm5hbWU6IHVzZXIsXG4gICAgcGFzc3dvcmQ6IHBhc3N3ZFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLmFtcXBsYWluID0gZnVuY3Rpb24odXNlciwgcGFzc3dkKSB7XG4gIHJldHVybiB7XG4gICAgbWVjaGFuaXNtOiAnQU1RUExBSU4nLFxuICAgIHJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNjM4NCk7XG4gICAgICBjb25zdCBzaXplID0gY29kZWMuZW5jb2RlVGFibGUoYnVmZmVyLCB7IExPR0lOOiB1c2VyLCBQQVNTV09SRDogcGFzc3dkfSwgMCk7XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDQsIHNpemUpO1xuICAgIH0sXG4gICAgdXNlcm5hbWU6IHVzZXIsXG4gICAgcGFzc3dvcmQ6IHBhc3N3ZFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLmV4dGVybmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbWVjaGFuaXNtOiAnRVhURVJOQUwnLFxuICAgIHJlc3BvbnNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKCcnKTsgfVxuICB9XG59XG4iLCIvKiogQHByZXNlcnZlIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIHNjcmlwdFxuICogLi4vYmluL2dlbmVyYXRlLWRlZnMuanMsIHdoaWNoIGlzIG5vdCBpbiBnZW5lcmFsIGluY2x1ZGVkIGluIGFcbiAqIGRpc3RyaWJ1dGlvbiwgYnV0IGlzIGF2YWlsYWJsZSBpbiB0aGUgc291cmNlIHJlcG9zaXRvcnkgZS5nLiBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL3NxdWFyZW1vL2FtcXAubm9kZS9cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25TdGFydChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdmVyc2lvbk1ham9yOiB2b2lkIDAsXG4gICAgdmVyc2lvbk1pbm9yOiB2b2lkIDAsXG4gICAgc2VydmVyUHJvcGVydGllczogdm9pZCAwLFxuICAgIG1lY2hhbmlzbXM6IHZvaWQgMCxcbiAgICBsb2NhbGVzOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyW29mZnNldF07XG4gIG9mZnNldCsrO1xuICBmaWVsZHMudmVyc2lvbk1ham9yID0gdmFsO1xuICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgb2Zmc2V0Kys7XG4gIGZpZWxkcy52ZXJzaW9uTWlub3IgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnNlcnZlclByb3BlcnRpZXMgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5tZWNoYW5pc21zID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMubG9jYWxlcyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblN0YXJ0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMuc2VydmVyUHJvcGVydGllcztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3NlcnZlclByb3BlcnRpZXMnXCIpO1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3NlcnZlclByb3BlcnRpZXMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIHNlcnZlclByb3BlcnRpZXNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICB2YXJ5aW5nU2l6ZSArPSBzZXJ2ZXJQcm9wZXJ0aWVzX2VuY29kZWQubGVuZ3RoO1xuICB2YWwgPSBmaWVsZHMubWVjaGFuaXNtcztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBCdWZmZXIuZnJvbShcIlBMQUlOXCIpOyBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVjaGFuaXNtcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5sb2NhbGVzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IEJ1ZmZlci5mcm9tKFwiZW5fVVNcIik7IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdsb2NhbGVzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTM3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudmVyc2lvbk1ham9yO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ZlcnNpb25NYWpvcicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDgodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gZmllbGRzLnZlcnNpb25NaW5vcjtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSA5OyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd2ZXJzaW9uTWlub3InIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIG9mZnNldCArPSBzZXJ2ZXJQcm9wZXJ0aWVzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIHZhbCA9IGZpZWxkcy5tZWNoYW5pc21zO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gQnVmZmVyLmZyb20oXCJQTEFJTlwiKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgdmFsID0gZmllbGRzLmxvY2FsZXM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbShcImVuX1VTXCIpKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25TdGFydE9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjbGllbnRQcm9wZXJ0aWVzOiB2b2lkIDAsXG4gICAgbWVjaGFuaXNtOiB2b2lkIDAsXG4gICAgcmVzcG9uc2U6IHZvaWQgMCxcbiAgICBsb2NhbGU6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jbGllbnRQcm9wZXJ0aWVzID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLm1lY2hhbmlzbSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlc3BvbnNlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmxvY2FsZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblN0YXJ0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jbGllbnRQcm9wZXJ0aWVzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY2xpZW50UHJvcGVydGllcydcIik7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2xpZW50UHJvcGVydGllcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgY2xpZW50UHJvcGVydGllc19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGNsaWVudFByb3BlcnRpZXNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5tZWNoYW5pc207XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJQTEFJTlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZWNoYW5pc20nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgbWVjaGFuaXNtX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBtZWNoYW5pc21fbGVuO1xuICB2YWwgPSBmaWVsZHMucmVzcG9uc2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZXNwb25zZSdcIik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVzcG9uc2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YWwgPSBmaWVsZHMubG9jYWxlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiZW5fVVNcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbG9jYWxlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGxvY2FsZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gbG9jYWxlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTM3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBvZmZzZXQgKz0gY2xpZW50UHJvcGVydGllc19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICB2YWwgPSBmaWVsZHMubWVjaGFuaXNtO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJQTEFJTlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBtZWNoYW5pc21fbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBtZWNoYW5pc21fbGVuO1xuICB2YWwgPSBmaWVsZHMucmVzcG9uc2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbSh2b2lkIDApKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICB2YWwgPSBmaWVsZHMubG9jYWxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJlbl9VU1wiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBsb2NhbGVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBsb2NhbGVfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25TZWN1cmUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNoYWxsZW5nZTogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jaGFsbGVuZ2UgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25TZWN1cmUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNoYWxsZW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NoYWxsZW5nZSdcIik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbGxlbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTM4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY2hhbGxlbmdlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gQnVmZmVyLmZyb20odm9pZCAwKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uU2VjdXJlT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlc3BvbnNlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uU2VjdXJlT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnJlc3BvbnNlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVzcG9uc2UnXCIpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3Jlc3BvbnNlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTM4MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVzcG9uc2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbSh2b2lkIDApKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25UdW5lKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbE1heDogdm9pZCAwLFxuICAgIGZyYW1lTWF4OiB2b2lkIDAsXG4gICAgaGVhcnRiZWF0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNoYW5uZWxNYXggPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5mcmFtZU1heCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmhlYXJ0YmVhdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblR1bmUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjApO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzkwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jaGFubmVsTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NoYW5uZWxNYXgnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5mcmFtZU1heDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdmcmFtZU1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLmhlYXJ0YmVhdDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdoZWFydGJlYXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblR1bmVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNoYW5uZWxNYXg6IHZvaWQgMCxcbiAgICBmcmFtZU1heDogdm9pZCAwLFxuICAgIGhlYXJ0YmVhdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5jaGFubmVsTWF4ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMuZnJhbWVNYXggPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5oZWFydGJlYXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25UdW5lT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjApO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jaGFubmVsTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NoYW5uZWxNYXgnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5mcmFtZU1heDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdmcmFtZU1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLmhlYXJ0YmVhdDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdoZWFydGJlYXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbk9wZW4oYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHZpcnR1YWxIb3N0OiB2b2lkIDAsXG4gICAgY2FwYWJpbGl0aWVzOiB2b2lkIDAsXG4gICAgaW5zaXN0OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy52aXJ0dWFsSG9zdCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jYXBhYmlsaXRpZXMgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5pbnNpc3QgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25PcGVuKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnZpcnR1YWxIb3N0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiL1wiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd2aXJ0dWFsSG9zdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciB2aXJ0dWFsSG9zdF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmlydHVhbEhvc3RfbGVuO1xuICB2YWwgPSBmaWVsZHMuY2FwYWJpbGl0aWVzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NhcGFiaWxpdGllcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjYXBhYmlsaXRpZXNfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNhcGFiaWxpdGllc19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTUgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnZpcnR1YWxIb3N0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCIvXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHZpcnR1YWxIb3N0X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gdmlydHVhbEhvc3RfbGVuO1xuICB2YWwgPSBmaWVsZHMuY2FwYWJpbGl0aWVzO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY2FwYWJpbGl0aWVzX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY2FwYWJpbGl0aWVzX2xlbjtcbiAgdmFsID0gZmllbGRzLmluc2lzdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25PcGVuT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGtub3duSG9zdHM6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmtub3duSG9zdHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25PcGVuT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5rbm93bkhvc3RzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2tub3duSG9zdHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIga25vd25Ib3N0c19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0ga25vd25Ib3N0c19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MDEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmtub3duSG9zdHM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBrbm93bkhvc3RzX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0ga25vd25Ib3N0c19sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbkNsb3NlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXBseUNvZGU6IHZvaWQgMCxcbiAgICByZXBseVRleHQ6IHZvaWQgMCxcbiAgICBjbGFzc0lkOiB2b2lkIDAsXG4gICAgbWV0aG9kSWQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucmVwbHlDb2RlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlcGx5VGV4dCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNsYXNzSWQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5tZXRob2RJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbkNsb3NlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTkgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlcGx5Q29kZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3JlcGx5Q29kZSdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXBseUNvZGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRleHQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByZXBseVRleHRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByZXBseVRleHRfbGVuO1xuICB2YWwgPSBmaWVsZHMuY2xhc3NJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NsYXNzSWQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2xhc3NJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLm1ldGhvZElkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWV0aG9kSWQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWV0aG9kSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbkNsb3NlT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbkNsb3NlT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1NDExLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbkJsb2NrZWQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlYXNvbjogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVhc29uID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uQmxvY2tlZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnJlYXNvbjtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZWFzb24nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcmVhc29uX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByZWFzb25fbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1NDIwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZWFzb247XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByZWFzb25fbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByZWFzb25fbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25VbmJsb2NrZWQoYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblVuYmxvY2tlZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDaGFubmVsT3BlbihidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgb3V0T2ZCYW5kOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5vdXRPZkJhbmQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxPcGVuKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMub3V0T2ZCYW5kO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ291dE9mQmFuZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBvdXRPZkJhbmRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IG91dE9mQmFuZF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzMwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5vdXRPZkJhbmQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBvdXRPZkJhbmRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBvdXRPZkJhbmRfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxPcGVuT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNoYW5uZWxJZDogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jaGFubmVsSWQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxPcGVuT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBCdWZmZXIuZnJvbShcIlwiKTsgZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NoYW5uZWxJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzMxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jaGFubmVsSWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbShcIlwiKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDaGFubmVsRmxvdyhidWZmZXIpIHtcbiAgdmFyIHZhbCwgZmllbGRzID0ge1xuICAgIGFjdGl2ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbMF0pO1xuICBmaWVsZHMuYWN0aXZlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDaGFubmVsRmxvdyhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMTMxMDc0MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuYWN0aXZlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnYWN0aXZlJ1wiKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxGbG93T2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGZpZWxkcyA9IHtcbiAgICBhY3RpdmU6IHZvaWQgMFxuICB9O1xuICB2YWwgPSAhISgxICYgYnVmZmVyWzBdKTtcbiAgZmllbGRzLmFjdGl2ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbEZsb3dPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMTMxMDc0MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuYWN0aXZlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnYWN0aXZlJ1wiKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxDbG9zZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVwbHlDb2RlOiB2b2lkIDAsXG4gICAgcmVwbHlUZXh0OiB2b2lkIDAsXG4gICAgY2xhc3NJZDogdm9pZCAwLFxuICAgIG1ldGhvZElkOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnJlcGx5Q29kZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZXBseVRleHQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5jbGFzc0lkID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMubWV0aG9kSWQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxDbG9zZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXBseVRleHQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcmVwbHlUZXh0X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByZXBseVRleHRfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE5ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMTMxMDc2MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVwbHlDb2RlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVwbHlDb2RlJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5Q29kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VGV4dF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jbGFzc0lkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY2xhc3NJZCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbGFzc0lkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMubWV0aG9kSWQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXRob2RJZCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXRob2RJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDaGFubmVsQ2xvc2VPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDaGFubmVsQ2xvc2VPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzYxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQWNjZXNzUmVxdWVzdChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVhbG06IHZvaWQgMCxcbiAgICBleGNsdXNpdmU6IHZvaWQgMCxcbiAgICBwYXNzaXZlOiB2b2lkIDAsXG4gICAgYWN0aXZlOiB2b2lkIDAsXG4gICAgd3JpdGU6IHZvaWQgMCxcbiAgICByZWFkOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZWFsbSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmV4Y2x1c2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnBhc3NpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5hY3RpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy53cml0ZSA9IHZhbDtcbiAgdmFsID0gISEoMTYgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZWFkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVBY2Nlc3NSZXF1ZXN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnJlYWxtO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiL2RhdGFcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVhbG0nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcmVhbG1fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlYWxtX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDE5NjYwOTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlYWxtO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCIvZGF0YVwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByZWFsbV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlYWxtX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2x1c2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMucGFzc2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICB2YWwgPSBmaWVsZHMuYWN0aXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gNCk7XG4gIHZhbCA9IGZpZWxkcy53cml0ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDgpO1xuICB2YWwgPSBmaWVsZHMucmVhZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBY2Nlc3NSZXF1ZXN0T2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVBY2Nlc3NSZXF1ZXN0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTQpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMTk2NjA5MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDE7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZURlY2xhcmUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgdHlwZTogdm9pZCAwLFxuICAgIHBhc3NpdmU6IHZvaWQgMCxcbiAgICBkdXJhYmxlOiB2b2lkIDAsXG4gICAgYXV0b0RlbGV0ZTogdm9pZCAwLFxuICAgIGludGVybmFsOiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDAsXG4gICAgYXJndW1lbnRzOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy50eXBlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucGFzc2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmR1cmFibGUgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5hdXRvRGVsZXRlID0gdmFsO1xuICB2YWwgPSAhISg4ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaW50ZXJuYWwgPSB2YWw7XG4gIHZhbCA9ICEhKDE2ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdleGNoYW5nZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdleGNoYW5nZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBleGNoYW5nZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMudHlwZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcImRpcmVjdFwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0eXBlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHR5cGVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHR5cGVfbGVuO1xuICB2YWwgPSBmaWVsZHMuYXJndW1lbnRzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IHt9OyBlbHNlIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnYXJndW1lbnRzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBhcmd1bWVudHNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICB2YXJ5aW5nU2l6ZSArPSBhcmd1bWVudHNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTcgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDUwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMudHlwZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiZGlyZWN0XCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHR5cGVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSB0eXBlX2xlbjtcbiAgdmFsID0gZmllbGRzLnBhc3NpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgdmFsID0gZmllbGRzLmR1cmFibGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAyKTtcbiAgdmFsID0gZmllbGRzLmF1dG9EZWxldGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLmludGVybmFsO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxNik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWNsYXJlT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VEZWNsYXJlT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ1MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlRGVsZXRlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIGlmVW51c2VkOiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmlmVW51c2VkID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlbGV0ZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDYwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMuaWZVbnVzZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlRGVsZXRlT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VEZWxldGVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDYxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VCaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBkZXN0aW5hdGlvbjogdm9pZCAwLFxuICAgIHNvdXJjZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmRlc3RpbmF0aW9uID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnNvdXJjZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZUJpbmQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMuZGVzdGluYXRpb247XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdkZXN0aW5hdGlvbidcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZXN0aW5hdGlvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBkZXN0aW5hdGlvbl9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gZGVzdGluYXRpb25fbGVuO1xuICB2YWwgPSBmaWVsZHMuc291cmNlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnc291cmNlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3NvdXJjZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBzb3VyY2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHNvdXJjZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5kZXN0aW5hdGlvbjtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZGVzdGluYXRpb25fbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBkZXN0aW5hdGlvbl9sZW47XG4gIHZhbCA9IGZpZWxkcy5zb3VyY2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IHNvdXJjZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHNvdXJjZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VCaW5kT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VCaW5kT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlVW5iaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBkZXN0aW5hdGlvbjogdm9pZCAwLFxuICAgIHNvdXJjZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmRlc3RpbmF0aW9uID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnNvdXJjZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZVVuYmluZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5kZXN0aW5hdGlvbjtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2Rlc3RpbmF0aW9uJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2Rlc3RpbmF0aW9uJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGRlc3RpbmF0aW9uX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBkZXN0aW5hdGlvbl9sZW47XG4gIHZhbCA9IGZpZWxkcy5zb3VyY2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdzb3VyY2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnc291cmNlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHNvdXJjZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gc291cmNlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE4ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmRlc3RpbmF0aW9uO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBkZXN0aW5hdGlvbl9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGRlc3RpbmF0aW9uX2xlbjtcbiAgdmFsID0gZmllbGRzLnNvdXJjZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gc291cmNlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gc291cmNlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZVVuYmluZE9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlVW5iaW5kT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ5MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlRGVjbGFyZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBwYXNzaXZlOiB2b2lkIDAsXG4gICAgZHVyYWJsZTogdm9pZCAwLFxuICAgIGV4Y2x1c2l2ZTogdm9pZCAwLFxuICAgIGF1dG9EZWxldGU6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucGFzc2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmR1cmFibGUgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5leGNsdXNpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5hdXRvRGVsZXRlID0gdmFsO1xuICB2YWwgPSAhISgxNiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmFyZ3VtZW50cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVEZWNsYXJlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMucGFzc2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuZHVyYWJsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICB2YWwgPSBmaWVsZHMuZXhjbHVzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gNCk7XG4gIHZhbCA9IGZpZWxkcy5hdXRvRGVsZXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxNik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWNsYXJlT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgbWVzc2FnZUNvdW50OiB2b2lkIDAsXG4gICAgY29uc3VtZXJDb3VudDogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5tZXNzYWdlQ291bnQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5jb25zdW1lckNvdW50ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlY2xhcmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncXVldWUnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMSArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21lc3NhZ2VDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lckNvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY29uc3VtZXJDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lckNvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlQmluZChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlQmluZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdleGNoYW5nZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdleGNoYW5nZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBleGNoYW5nZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMuYXJndW1lbnRzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IHt9OyBlbHNlIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnYXJndW1lbnRzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBhcmd1bWVudHNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICB2YXJ5aW5nU2l6ZSArPSBhcmd1bWVudHNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTggKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODIwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBleGNoYW5nZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZUJpbmRPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZUJpbmRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODIxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVQdXJnZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZVB1cmdlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODMwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlUHVyZ2VPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIG1lc3NhZ2VDb3VudDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5tZXNzYWdlQ291bnQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlUHVyZ2VPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODMxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXNzYWdlQ291bnQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVzc2FnZUNvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlRGVsZXRlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIGlmVW51c2VkOiB2b2lkIDAsXG4gICAgaWZFbXB0eTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5pZlVudXNlZCA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmlmRW1wdHkgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODQwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmlmVW51c2VkO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5pZkVtcHR5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZURlbGV0ZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgbWVzc2FnZUNvdW50OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVEZWxldGVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODQxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXNzYWdlQ291bnQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVzc2FnZUNvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlVW5iaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZVVuYmluZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlVW5iaW5kT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVVbmJpbmRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNRb3MoYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBwcmVmZXRjaFNpemU6IHZvaWQgMCxcbiAgICBwcmVmZXRjaENvdW50OiB2b2lkIDAsXG4gICAgZ2xvYmFsOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLnByZWZldGNoU2l6ZSA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnByZWZldGNoQ291bnQgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5nbG9iYWwgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUW9zKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMTcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5wcmVmZXRjaFNpemU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncHJlZmV0Y2hTaXplJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBmaWVsZHMucHJlZmV0Y2hDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdwcmVmZXRjaENvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMuZ2xvYmFsO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNRb3NPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1Fvc09rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxNzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY0NvbnN1bWUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgY29uc3VtZXJUYWc6IHZvaWQgMCxcbiAgICBub0xvY2FsOiB2b2lkIDAsXG4gICAgbm9BY2s6IHZvaWQgMCxcbiAgICBleGNsdXNpdmU6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9Mb2NhbCA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vQWNrID0gdmFsO1xuICB2YWwgPSAhISg0ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZXhjbHVzaXZlID0gdmFsO1xuICB2YWwgPSAhISg4ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0NvbnN1bWUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyVGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNvbnN1bWVyVGFnX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxODAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjb25zdW1lclRhZ19sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vTG9jYWw7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgdmFsID0gZmllbGRzLm5vQWNrO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5leGNsdXNpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDgpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQ29uc3VtZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjb25zdW1lclRhZzogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY29uc3VtZXJUYWcgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljQ29uc3VtZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE4MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQ2FuY2VsKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY29uc3VtZXJUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljQ2FuY2VsKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY29uc3VtZXJUYWcnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxOTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjb25zdW1lclRhZ19sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQ2FuY2VsT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDYW5jZWxPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY29uc3VtZXJUYWcnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxOTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjb25zdW1lclRhZ19sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1B1Ymxpc2goYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG1hbmRhdG9yeTogdm9pZCAwLFxuICAgIGltbWVkaWF0ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm1hbmRhdG9yeSA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmltbWVkaWF0ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNQdWJsaXNoKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTcgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjAwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBleGNoYW5nZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5tYW5kYXRvcnk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgdmFsID0gZmllbGRzLmltbWVkaWF0ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmV0dXJuKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXBseUNvZGU6IHZvaWQgMCxcbiAgICByZXBseVRleHQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucmVwbHlDb2RlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlcGx5VGV4dCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1JldHVybihjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXBseVRleHQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcmVwbHlUZXh0X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByZXBseVRleHRfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdleGNoYW5nZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdleGNoYW5nZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBleGNoYW5nZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3JvdXRpbmdLZXknXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyMTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlcGx5Q29kZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3JlcGx5Q29kZSdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXBseUNvZGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRleHQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByZXBseVRleHRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByZXBseVRleHRfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljRGVsaXZlcihidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY29uc3VtZXJUYWc6IHZvaWQgMCxcbiAgICBkZWxpdmVyeVRhZzogdm9pZCAwLFxuICAgIHJlZGVsaXZlcmVkOiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgdmFsID0gaW50cy5yZWFkVUludDY0QkUoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgZmllbGRzLmRlbGl2ZXJ5VGFnID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVkZWxpdmVyZWQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljRGVsaXZlcihjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NvbnN1bWVyVGFnJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyVGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNvbnN1bWVyVGFnX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncm91dGluZ0tleSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDI0ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIyMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdkZWxpdmVyeVRhZydcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZWxpdmVyeVRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgdmFsID0gZmllbGRzLnJlZGVsaXZlcmVkO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljR2V0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIG5vQWNrOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vQWNrID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIzMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5ub0FjaztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljR2V0T2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgcmVkZWxpdmVyZWQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMCxcbiAgICBtZXNzYWdlQ291bnQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICBmaWVsZHMuZGVsaXZlcnlUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZWRlbGl2ZXJlZCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNHZXRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncm91dGluZ0tleSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDI3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIzMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdkZWxpdmVyeVRhZydcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZWxpdmVyeVRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgdmFsID0gZmllbGRzLnJlZGVsaXZlcmVkO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMubWVzc2FnZUNvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWVzc2FnZUNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lc3NhZ2VDb3VudCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY0dldEVtcHR5KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjbHVzdGVySWQ6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNsdXN0ZXJJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNHZXRFbXB0eShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNsdXN0ZXJJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbHVzdGVySWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY2x1c3RlcklkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBjbHVzdGVySWRfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIzMiwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY2x1c3RlcklkO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY2x1c3RlcklkX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY2x1c3RlcklkX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY0FjayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgbXVsdGlwbGU6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICBmaWVsZHMuZGVsaXZlcnlUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5tdWx0aXBsZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNBY2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmRlbGl2ZXJ5VGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMubXVsdGlwbGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1JlamVjdChidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlcXVldWUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmVqZWN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjUwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVjb3ZlckFzeW5jKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBmaWVsZHMgPSB7XG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbMF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNSZWNvdmVyQXN5bmMoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlcXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1JlY292ZXIoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGZpZWxkcyA9IHtcbiAgICByZXF1ZXVlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlclswXSk7XG4gIGZpZWxkcy5yZXF1ZXVlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1JlY292ZXIoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlcXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1JlY292ZXJPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1JlY292ZXJPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNOYWNrKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICBtdWx0aXBsZTogdm9pZCAwLFxuICAgIHJlcXVldWU6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICBmaWVsZHMuZGVsaXZlcnlUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5tdWx0aXBsZSA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlcXVldWUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljTmFjayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjEpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIHZhbCA9IGZpZWxkcy5tdWx0aXBsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4U2VsZWN0KGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4U2VsZWN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeFNlbGVjdE9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4U2VsZWN0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTg5ODI1MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4Q29tbWl0KGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4Q29tbWl0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeENvbW1pdE9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4Q29tbWl0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTg5ODI2MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4Um9sbGJhY2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhSb2xsYmFjayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhSb2xsYmFja09rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4Um9sbGJhY2tPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29uZmlybVNlbGVjdChidWZmZXIpIHtcbiAgdmFyIHZhbCwgZmllbGRzID0ge1xuICAgIG5vd2FpdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbMF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25maXJtU2VsZWN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1NTcwNTcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25maXJtU2VsZWN0T2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29uZmlybVNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU1NzA1NzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1Byb3BlcnRpZXMoY2hhbm5lbCwgc2l6ZSwgZmllbGRzKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmxhZ3MgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29udGVudFR5cGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnRlbnRUeXBlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgY29udGVudFR5cGVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBjb250ZW50VHlwZV9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmNvbnRlbnRFbmNvZGluZztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29udGVudEVuY29kaW5nJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgY29udGVudEVuY29kaW5nX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gY29udGVudEVuY29kaW5nX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuaGVhZGVycztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2hlYWRlcnMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICAgIHZhciBoZWFkZXJzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICAgIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICAgIHZhcnlpbmdTaXplICs9IGhlYWRlcnNfZW5jb2RlZC5sZW5ndGg7XG4gIH1cbiAgdmFsID0gZmllbGRzLmRlbGl2ZXJ5TW9kZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlNb2RlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gIH1cbiAgdmFsID0gZmllbGRzLnByaW9yaXR5O1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdwcmlvcml0eScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jb3JyZWxhdGlvbklkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb3JyZWxhdGlvbklkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgY29ycmVsYXRpb25JZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGNvcnJlbGF0aW9uSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRvO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXBseVRvJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgcmVwbHlUb19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IHJlcGx5VG9fbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5leHBpcmF0aW9uO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdleHBpcmF0aW9uJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgZXhwaXJhdGlvbl9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGV4cGlyYXRpb25fbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlSWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lc3NhZ2VJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIG1lc3NhZ2VJZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IG1lc3NhZ2VJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLnRpbWVzdGFtcDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGltZXN0YW1wJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDg7XG4gIH1cbiAgdmFsID0gZmllbGRzLnR5cGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3R5cGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciB0eXBlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gdHlwZV9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLnVzZXJJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndXNlcklkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgdXNlcklkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gdXNlcklkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuYXBwSWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FwcElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgYXBwSWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBhcHBJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmNsdXN0ZXJJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2x1c3RlcklkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgY2x1c3RlcklkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gY2x1c3RlcklkX2xlbjtcbiAgfVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIyICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAyO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE2MCwgNyk7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHNpemUsIDExKTtcbiAgZmxhZ3MgPSAwO1xuICBvZmZzZXQgPSAyMTtcbiAgdmFsID0gZmllbGRzLmNvbnRlbnRUeXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDMyNzY4O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gY29udGVudFR5cGVfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBjb250ZW50VHlwZV9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmNvbnRlbnRFbmNvZGluZztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAxNjM4NDtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGNvbnRlbnRFbmNvZGluZ19sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGNvbnRlbnRFbmNvZGluZ19sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmhlYWRlcnM7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gODE5MjtcbiAgICBvZmZzZXQgKz0gaGVhZGVyc19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeU1vZGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gNDA5NjtcbiAgICBidWZmZXIud3JpdGVVSW50OCh2YWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gIH1cbiAgdmFsID0gZmllbGRzLnByaW9yaXR5O1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDIwNDg7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsLCBvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jb3JyZWxhdGlvbklkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDEwMjQ7XG4gICAgYnVmZmVyW29mZnNldF0gPSBjb3JyZWxhdGlvbklkX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gY29ycmVsYXRpb25JZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLnJlcGx5VG87XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gNTEyO1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gcmVwbHlUb19sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IHJlcGx5VG9fbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5leHBpcmF0aW9uO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDI1NjtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGV4cGlyYXRpb25fbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBleHBpcmF0aW9uX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMubWVzc2FnZUlkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDEyODtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IG1lc3NhZ2VJZF9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IG1lc3NhZ2VJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLnRpbWVzdGFtcDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA2NDtcbiAgICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDg7XG4gIH1cbiAgdmFsID0gZmllbGRzLnR5cGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMzI7XG4gICAgYnVmZmVyW29mZnNldF0gPSB0eXBlX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gdHlwZV9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLnVzZXJJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAxNjtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHVzZXJJZF9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IHVzZXJJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmFwcElkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDg7XG4gICAgYnVmZmVyW29mZnNldF0gPSBhcHBJZF9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGFwcElkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuY2x1c3RlcklkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDQ7XG4gICAgYnVmZmVyW29mZnNldF0gPSBjbHVzdGVySWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBjbHVzdGVySWRfbGVuO1xuICB9XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoZmxhZ3MsIDE5KTtcbiAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBvZmZzZXQgKyAxKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNQcm9wZXJ0aWVzKGJ1ZmZlcikge1xuICB2YXIgZmxhZ3MsIHZhbCwgbGVuLCBvZmZzZXQgPSAyO1xuICBmbGFncyA9IGJ1ZmZlci5yZWFkVUludDE2QkUoMCk7XG4gIGlmICgwID09PSBmbGFncykgcmV0dXJuIHt9O1xuICB2YXIgZmllbGRzID0ge1xuICAgIGNvbnRlbnRUeXBlOiB2b2lkIDAsXG4gICAgY29udGVudEVuY29kaW5nOiB2b2lkIDAsXG4gICAgaGVhZGVyczogdm9pZCAwLFxuICAgIGRlbGl2ZXJ5TW9kZTogdm9pZCAwLFxuICAgIHByaW9yaXR5OiB2b2lkIDAsXG4gICAgY29ycmVsYXRpb25JZDogdm9pZCAwLFxuICAgIHJlcGx5VG86IHZvaWQgMCxcbiAgICBleHBpcmF0aW9uOiB2b2lkIDAsXG4gICAgbWVzc2FnZUlkOiB2b2lkIDAsXG4gICAgdGltZXN0YW1wOiB2b2lkIDAsXG4gICAgdHlwZTogdm9pZCAwLFxuICAgIHVzZXJJZDogdm9pZCAwLFxuICAgIGFwcElkOiB2b2lkIDAsXG4gICAgY2x1c3RlcklkOiB2b2lkIDBcbiAgfTtcbiAgaWYgKDMyNzY4ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuY29udGVudFR5cGUgPSB2YWw7XG4gIH1cbiAgaWYgKDE2Mzg0ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuY29udGVudEVuY29kaW5nID0gdmFsO1xuICB9XG4gIGlmICg4MTkyICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmhlYWRlcnMgPSB2YWw7XG4gIH1cbiAgaWYgKDQwOTYgJiBmbGFncykge1xuICAgIHZhbCA9IGJ1ZmZlcltvZmZzZXRdO1xuICAgIG9mZnNldCsrO1xuICAgIGZpZWxkcy5kZWxpdmVyeU1vZGUgPSB2YWw7XG4gIH1cbiAgaWYgKDIwNDggJiBmbGFncykge1xuICAgIHZhbCA9IGJ1ZmZlcltvZmZzZXRdO1xuICAgIG9mZnNldCsrO1xuICAgIGZpZWxkcy5wcmlvcml0eSA9IHZhbDtcbiAgfVxuICBpZiAoMTAyNCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmNvcnJlbGF0aW9uSWQgPSB2YWw7XG4gIH1cbiAgaWYgKDUxMiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLnJlcGx5VG8gPSB2YWw7XG4gIH1cbiAgaWYgKDI1NiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmV4cGlyYXRpb24gPSB2YWw7XG4gIH1cbiAgaWYgKDEyOCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLm1lc3NhZ2VJZCA9IHZhbDtcbiAgfVxuICBpZiAoNjQgJiBmbGFncykge1xuICAgIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gODtcbiAgICBmaWVsZHMudGltZXN0YW1wID0gdmFsO1xuICB9XG4gIGlmICgzMiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLnR5cGUgPSB2YWw7XG4gIH1cbiAgaWYgKDE2ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMudXNlcklkID0gdmFsO1xuICB9XG4gIGlmICg4ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuYXBwSWQgPSB2YWw7XG4gIH1cbiAgaWYgKDQgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5jbHVzdGVySWQgPSB2YWw7XG4gIH1cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxudmFyIGNvZGVjID0gcmVxdWlyZShcIi4vY29kZWNcIiksIGludHMgPSByZXF1aXJlKFwiYnVmZmVyLW1vcmUtaW50c1wiKSwgZW5jb2RlVGFibGUgPSBjb2RlYy5lbmNvZGVUYWJsZSwgZGVjb2RlRmllbGRzID0gY29kZWMuZGVjb2RlRmllbGRzLCBTQ1JBVENIID0gQnVmZmVyLmFsbG9jKDY1NTM2KSwgRU1QVFlfT0JKRUNUID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbm1vZHVsZS5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgRlJBTUVfTUVUSE9EOiAxLFxuICBGUkFNRV9IRUFERVI6IDIsXG4gIEZSQU1FX0JPRFk6IDMsXG4gIEZSQU1FX0hFQVJUQkVBVDogOCxcbiAgRlJBTUVfTUlOX1NJWkU6IDQwOTYsXG4gIEZSQU1FX0VORDogMjA2LFxuICBSRVBMWV9TVUNDRVNTOiAyMDAsXG4gIENPTlRFTlRfVE9PX0xBUkdFOiAzMTEsXG4gIE5PX1JPVVRFOiAzMTIsXG4gIE5PX0NPTlNVTUVSUzogMzEzLFxuICBBQ0NFU1NfUkVGVVNFRDogNDAzLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgUkVTT1VSQ0VfTE9DS0VEOiA0MDUsXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQwNixcbiAgQ09OTkVDVElPTl9GT1JDRUQ6IDMyMCxcbiAgSU5WQUxJRF9QQVRIOiA0MDIsXG4gIEZSQU1FX0VSUk9SOiA1MDEsXG4gIFNZTlRBWF9FUlJPUjogNTAyLFxuICBDT01NQU5EX0lOVkFMSUQ6IDUwMyxcbiAgQ0hBTk5FTF9FUlJPUjogNTA0LFxuICBVTkVYUEVDVEVEX0ZSQU1FOiA1MDUsXG4gIFJFU09VUkNFX0VSUk9SOiA1MDYsXG4gIE5PVF9BTExPV0VEOiA1MzAsXG4gIE5PVF9JTVBMRU1FTlRFRDogNTQwLFxuICBJTlRFUk5BTF9FUlJPUjogNTQxXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudF9zdHJzID0ge1xuICBcIjFcIjogXCJGUkFNRS1NRVRIT0RcIixcbiAgXCIyXCI6IFwiRlJBTUUtSEVBREVSXCIsXG4gIFwiM1wiOiBcIkZSQU1FLUJPRFlcIixcbiAgXCI4XCI6IFwiRlJBTUUtSEVBUlRCRUFUXCIsXG4gIFwiMjAwXCI6IFwiUkVQTFktU1VDQ0VTU1wiLFxuICBcIjIwNlwiOiBcIkZSQU1FLUVORFwiLFxuICBcIjMxMVwiOiBcIkNPTlRFTlQtVE9PLUxBUkdFXCIsXG4gIFwiMzEyXCI6IFwiTk8tUk9VVEVcIixcbiAgXCIzMTNcIjogXCJOTy1DT05TVU1FUlNcIixcbiAgXCIzMjBcIjogXCJDT05ORUNUSU9OLUZPUkNFRFwiLFxuICBcIjQwMlwiOiBcIklOVkFMSUQtUEFUSFwiLFxuICBcIjQwM1wiOiBcIkFDQ0VTUy1SRUZVU0VEXCIsXG4gIFwiNDA0XCI6IFwiTk9ULUZPVU5EXCIsXG4gIFwiNDA1XCI6IFwiUkVTT1VSQ0UtTE9DS0VEXCIsXG4gIFwiNDA2XCI6IFwiUFJFQ09ORElUSU9OLUZBSUxFRFwiLFxuICBcIjUwMVwiOiBcIkZSQU1FLUVSUk9SXCIsXG4gIFwiNTAyXCI6IFwiU1lOVEFYLUVSUk9SXCIsXG4gIFwiNTAzXCI6IFwiQ09NTUFORC1JTlZBTElEXCIsXG4gIFwiNTA0XCI6IFwiQ0hBTk5FTC1FUlJPUlwiLFxuICBcIjUwNVwiOiBcIlVORVhQRUNURUQtRlJBTUVcIixcbiAgXCI1MDZcIjogXCJSRVNPVVJDRS1FUlJPUlwiLFxuICBcIjUzMFwiOiBcIk5PVC1BTExPV0VEXCIsXG4gIFwiNTQwXCI6IFwiTk9ULUlNUExFTUVOVEVEXCIsXG4gIFwiNTQxXCI6IFwiSU5URVJOQUwtRVJST1JcIixcbiAgXCI0MDk2XCI6IFwiRlJBTUUtTUlOLVNJWkVcIlxufTtcblxubW9kdWxlLmV4cG9ydHMuRlJBTUVfT1ZFUkhFQUQgPSA4O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpZCwgYnVmKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgIGNhc2UgNjU1MzcwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uU3RhcnQoYnVmKTtcblxuICAgY2FzZSA2NTUzNzE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TdGFydE9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1MzgwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uU2VjdXJlKGJ1Zik7XG5cbiAgIGNhc2UgNjU1MzgxOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uU2VjdXJlT2soYnVmKTtcblxuICAgY2FzZSA2NTUzOTA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25UdW5lKGJ1Zik7XG5cbiAgIGNhc2UgNjU1MzkxOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uVHVuZU9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDAwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uT3BlbihidWYpO1xuXG4gICBjYXNlIDY1NTQwMTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvbk9wZW5PayhidWYpO1xuXG4gICBjYXNlIDY1NTQxMDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvbkNsb3NlKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDExOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uQ2xvc2VPayhidWYpO1xuXG4gICBjYXNlIDY1NTQyMDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvbkJsb2NrZWQoYnVmKTtcblxuICAgY2FzZSA2NTU0MjE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25VbmJsb2NrZWQoYnVmKTtcblxuICAgY2FzZSAxMzEwNzMwOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsT3BlbihidWYpO1xuXG4gICBjYXNlIDEzMTA3MzE6XG4gICAgcmV0dXJuIGRlY29kZUNoYW5uZWxPcGVuT2soYnVmKTtcblxuICAgY2FzZSAxMzEwNzQwOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsRmxvdyhidWYpO1xuXG4gICBjYXNlIDEzMTA3NDE6XG4gICAgcmV0dXJuIGRlY29kZUNoYW5uZWxGbG93T2soYnVmKTtcblxuICAgY2FzZSAxMzEwNzYwOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsQ2xvc2UoYnVmKTtcblxuICAgY2FzZSAxMzEwNzYxOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsQ2xvc2VPayhidWYpO1xuXG4gICBjYXNlIDE5NjYwOTA6XG4gICAgcmV0dXJuIGRlY29kZUFjY2Vzc1JlcXVlc3QoYnVmKTtcblxuICAgY2FzZSAxOTY2MDkxOlxuICAgIHJldHVybiBkZWNvZGVBY2Nlc3NSZXF1ZXN0T2soYnVmKTtcblxuICAgY2FzZSAyNjIxNDUwOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZURlY2xhcmUoYnVmKTtcblxuICAgY2FzZSAyNjIxNDUxOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZURlY2xhcmVPayhidWYpO1xuXG4gICBjYXNlIDI2MjE0NjA6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlRGVsZXRlKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ2MTpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VEZWxldGVPayhidWYpO1xuXG4gICBjYXNlIDI2MjE0NzA6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlQmluZChidWYpO1xuXG4gICBjYXNlIDI2MjE0NzE6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlQmluZE9rKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ4MDpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VVbmJpbmQoYnVmKTtcblxuICAgY2FzZSAyNjIxNDkxOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZVVuYmluZE9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgxMDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVEZWNsYXJlKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgxMTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVEZWNsYXJlT2soYnVmKTtcblxuICAgY2FzZSAzMjc2ODIwOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZUJpbmQoYnVmKTtcblxuICAgY2FzZSAzMjc2ODIxOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZUJpbmRPayhidWYpO1xuXG4gICBjYXNlIDMyNzY4MzA6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlUHVyZ2UoYnVmKTtcblxuICAgY2FzZSAzMjc2ODMxOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZVB1cmdlT2soYnVmKTtcblxuICAgY2FzZSAzMjc2ODQwOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZURlbGV0ZShidWYpO1xuXG4gICBjYXNlIDMyNzY4NDE6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlRGVsZXRlT2soYnVmKTtcblxuICAgY2FzZSAzMjc2ODUwOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZVVuYmluZChidWYpO1xuXG4gICBjYXNlIDMyNzY4NTE6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlVW5iaW5kT2soYnVmKTtcblxuICAgY2FzZSAzOTMyMTcwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1FvcyhidWYpO1xuXG4gICBjYXNlIDM5MzIxNzE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUW9zT2soYnVmKTtcblxuICAgY2FzZSAzOTMyMTgwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0NvbnN1bWUoYnVmKTtcblxuICAgY2FzZSAzOTMyMTgxOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0NvbnN1bWVPayhidWYpO1xuXG4gICBjYXNlIDM5MzIxOTA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQ2FuY2VsKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE5MTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNDYW5jZWxPayhidWYpO1xuXG4gICBjYXNlIDM5MzIyMDA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUHVibGlzaChidWYpO1xuXG4gICBjYXNlIDM5MzIyMTA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUmV0dXJuKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIyMDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNEZWxpdmVyKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIzMDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNHZXQoYnVmKTtcblxuICAgY2FzZSAzOTMyMjMxOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0dldE9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIzMjpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNHZXRFbXB0eShidWYpO1xuXG4gICBjYXNlIDM5MzIyNDA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQWNrKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI1MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZWplY3QoYnVmKTtcblxuICAgY2FzZSAzOTMyMjYwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1JlY292ZXJBc3luYyhidWYpO1xuXG4gICBjYXNlIDM5MzIyNzA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUmVjb3ZlcihidWYpO1xuXG4gICBjYXNlIDM5MzIyNzE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUmVjb3Zlck9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI4MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNOYWNrKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI1MDpcbiAgICByZXR1cm4gZGVjb2RlVHhTZWxlY3QoYnVmKTtcblxuICAgY2FzZSA1ODk4MjUxOlxuICAgIHJldHVybiBkZWNvZGVUeFNlbGVjdE9rKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI2MDpcbiAgICByZXR1cm4gZGVjb2RlVHhDb21taXQoYnVmKTtcblxuICAgY2FzZSA1ODk4MjYxOlxuICAgIHJldHVybiBkZWNvZGVUeENvbW1pdE9rKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI3MDpcbiAgICByZXR1cm4gZGVjb2RlVHhSb2xsYmFjayhidWYpO1xuXG4gICBjYXNlIDU4OTgyNzE6XG4gICAgcmV0dXJuIGRlY29kZVR4Um9sbGJhY2tPayhidWYpO1xuXG4gICBjYXNlIDU1NzA1NzA6XG4gICAgcmV0dXJuIGRlY29kZUNvbmZpcm1TZWxlY3QoYnVmKTtcblxuICAgY2FzZSA1NTcwNTcxOlxuICAgIHJldHVybiBkZWNvZGVDb25maXJtU2VsZWN0T2soYnVmKTtcblxuICAgY2FzZSA2MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNQcm9wZXJ0aWVzKGJ1Zik7XG5cbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjbGFzcy9tZXRob2QgSURcIik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZU1ldGhvZCA9IGZ1bmN0aW9uKGlkLCBjaGFubmVsLCBmaWVsZHMpIHtcbiAgc3dpdGNoIChpZCkge1xuICAgY2FzZSA2NTUzNzA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25TdGFydChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTM3MTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblN0YXJ0T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzODA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25TZWN1cmUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzODE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25TZWN1cmVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTM5MDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblR1bmUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzOTE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25UdW5lT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MDA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25PcGVuKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDAxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uT3Blbk9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDEwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uQ2xvc2UoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MTE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25DbG9zZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDIwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uQmxvY2tlZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQyMTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblVuYmxvY2tlZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3MzA6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxPcGVuKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDczMTpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbE9wZW5PayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NDA6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxGbG93KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDc0MTpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbEZsb3dPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NjA6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxDbG9zZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NjE6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxDbG9zZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTk2NjA5MDpcbiAgICByZXR1cm4gZW5jb2RlQWNjZXNzUmVxdWVzdChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDE5NjYwOTE6XG4gICAgcmV0dXJuIGVuY29kZUFjY2Vzc1JlcXVlc3RPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NTA6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlRGVjbGFyZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NTE6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ2MDpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VEZWxldGUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDYxOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ3MDpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VCaW5kKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ3MTpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VCaW5kT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDgwOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZVVuYmluZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0OTE6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlVW5iaW5kT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODEwOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODExOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZURlY2xhcmVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MjA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlQmluZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MjE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlQmluZE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgzMDpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVQdXJnZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MzE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlUHVyZ2VPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4NDA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3Njg0MTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVEZWxldGVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4NTA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3Njg1MTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVVbmJpbmRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxNzA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUW9zKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE3MTpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNRb3NPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxODA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQ29uc3VtZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxODE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQ29uc3VtZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE5MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNDYW5jZWwoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTkxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0NhbmNlbE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIwMDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNQdWJsaXNoKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIxMDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNSZXR1cm4oY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjIwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0RlbGl2ZXIoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjMwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0dldChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMzE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljR2V0T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjMyOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0dldEVtcHR5KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI0MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNBY2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjUwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1JlamVjdChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNjA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmVjb3ZlckFzeW5jKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI3MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNSZWNvdmVyKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI3MTpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNSZWNvdmVyT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjgwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY05hY2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjUwOlxuICAgIHJldHVybiBlbmNvZGVUeFNlbGVjdChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNTE6XG4gICAgcmV0dXJuIGVuY29kZVR4U2VsZWN0T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjYwOlxuICAgIHJldHVybiBlbmNvZGVUeENvbW1pdChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNjE6XG4gICAgcmV0dXJuIGVuY29kZVR4Q29tbWl0T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjcwOlxuICAgIHJldHVybiBlbmNvZGVUeFJvbGxiYWNrKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI3MTpcbiAgICByZXR1cm4gZW5jb2RlVHhSb2xsYmFja09rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTU3MDU3MDpcbiAgICByZXR1cm4gZW5jb2RlQ29uZmlybVNlbGVjdChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU1NzA1NzE6XG4gICAgcmV0dXJuIGVuY29kZUNvbmZpcm1TZWxlY3RPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2xhc3MvbWV0aG9kIElEXCIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaWQsIGNoYW5uZWwsIHNpemUsIGZpZWxkcykge1xuICBzd2l0Y2ggKGlkKSB7XG4gICBjYXNlIDYwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1Byb3BlcnRpZXMoY2hhbm5lbCwgc2l6ZSwgZmllbGRzKTtcblxuICAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNsYXNzL3Byb3BlcnRpZXMgSURcIik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmluZm8gPSBmdW5jdGlvbihpZCkge1xuICBzd2l0Y2ggKGlkKSB7XG4gICBjYXNlIDY1NTM3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydDtcblxuICAgY2FzZSA2NTUzNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnRPaztcblxuICAgY2FzZSA2NTUzODA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlO1xuXG4gICBjYXNlIDY1NTM4MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmVPaztcblxuICAgY2FzZSA2NTUzOTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZTtcblxuICAgY2FzZSA2NTUzOTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZU9rO1xuXG4gICBjYXNlIDY1NTQwMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuO1xuXG4gICBjYXNlIDY1NTQwMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuT2s7XG5cbiAgIGNhc2UgNjU1NDEwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlO1xuXG4gICBjYXNlIDY1NTQxMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZU9rO1xuXG4gICBjYXNlIDY1NTQyMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25CbG9ja2VkO1xuXG4gICBjYXNlIDY1NTQyMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25VbmJsb2NrZWQ7XG5cbiAgIGNhc2UgMTMxMDczMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxPcGVuO1xuXG4gICBjYXNlIDEzMTA3MzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsT3Blbk9rO1xuXG4gICBjYXNlIDEzMTA3NDA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsRmxvdztcblxuICAgY2FzZSAxMzEwNzQxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbEZsb3dPaztcblxuICAgY2FzZSAxMzEwNzYwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbENsb3NlO1xuXG4gICBjYXNlIDEzMTA3NjE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsQ2xvc2VPaztcblxuICAgY2FzZSAxOTY2MDkwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdDtcblxuICAgY2FzZSAxOTY2MDkxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdE9rO1xuXG4gICBjYXNlIDI2MjE0NTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmU7XG5cbiAgIGNhc2UgMjYyMTQ1MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZU9rO1xuXG4gICBjYXNlIDI2MjE0NjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZTtcblxuICAgY2FzZSAyNjIxNDYxOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VEZWxldGVPaztcblxuICAgY2FzZSAyNjIxNDcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kO1xuXG4gICBjYXNlIDI2MjE0NzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZUJpbmRPaztcblxuICAgY2FzZSAyNjIxNDgwOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmQ7XG5cbiAgIGNhc2UgMjYyMTQ5MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kT2s7XG5cbiAgIGNhc2UgMzI3NjgxMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlRGVjbGFyZTtcblxuICAgY2FzZSAzMjc2ODExOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVEZWNsYXJlT2s7XG5cbiAgIGNhc2UgMzI3NjgyMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlQmluZDtcblxuICAgY2FzZSAzMjc2ODIxOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVCaW5kT2s7XG5cbiAgIGNhc2UgMzI3NjgzMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlUHVyZ2U7XG5cbiAgIGNhc2UgMzI3NjgzMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlUHVyZ2VPaztcblxuICAgY2FzZSAzMjc2ODQwOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVEZWxldGU7XG5cbiAgIGNhc2UgMzI3Njg0MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlRGVsZXRlT2s7XG5cbiAgIGNhc2UgMzI3Njg1MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlVW5iaW5kO1xuXG4gICBjYXNlIDMyNzY4NTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZVVuYmluZE9rO1xuXG4gICBjYXNlIDM5MzIxNzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1FvcztcblxuICAgY2FzZSAzOTMyMTcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNRb3NPaztcblxuICAgY2FzZSAzOTMyMTgwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNDb25zdW1lO1xuXG4gICBjYXNlIDM5MzIxODE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0NvbnN1bWVPaztcblxuICAgY2FzZSAzOTMyMTkwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNDYW5jZWw7XG5cbiAgIGNhc2UgMzkzMjE5MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljQ2FuY2VsT2s7XG5cbiAgIGNhc2UgMzkzMjIwMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUHVibGlzaDtcblxuICAgY2FzZSAzOTMyMjEwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNSZXR1cm47XG5cbiAgIGNhc2UgMzkzMjIyMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljRGVsaXZlcjtcblxuICAgY2FzZSAzOTMyMjMwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNHZXQ7XG5cbiAgIGNhc2UgMzkzMjIzMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljR2V0T2s7XG5cbiAgIGNhc2UgMzkzMjIzMjpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljR2V0RW1wdHk7XG5cbiAgIGNhc2UgMzkzMjI0MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljQWNrO1xuXG4gICBjYXNlIDM5MzIyNTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JlamVjdDtcblxuICAgY2FzZSAzOTMyMjYwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNSZWNvdmVyQXN5bmM7XG5cbiAgIGNhc2UgMzkzMjI3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUmVjb3ZlcjtcblxuICAgY2FzZSAzOTMyMjcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNSZWNvdmVyT2s7XG5cbiAgIGNhc2UgMzkzMjI4MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljTmFjaztcblxuICAgY2FzZSA1ODk4MjUwOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhTZWxlY3Q7XG5cbiAgIGNhc2UgNTg5ODI1MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4U2VsZWN0T2s7XG5cbiAgIGNhc2UgNTg5ODI2MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Q29tbWl0O1xuXG4gICBjYXNlIDU4OTgyNjE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeENvbW1pdE9rO1xuXG4gICBjYXNlIDU4OTgyNzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeFJvbGxiYWNrO1xuXG4gICBjYXNlIDU4OTgyNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeFJvbGxiYWNrT2s7XG5cbiAgIGNhc2UgNTU3MDU3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NvbmZpcm1TZWxlY3Q7XG5cbiAgIGNhc2UgNTU3MDU3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NvbmZpcm1TZWxlY3RPaztcblxuICAgY2FzZSA2MDpcbiAgICByZXR1cm4gcHJvcGVydGllc0luZm9CYXNpY1Byb3BlcnRpZXM7XG5cbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjbGFzcy9tZXRob2QgSURcIik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25TdGFydCA9IDY1NTM3MDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0ID0ge1xuICBpZDogNjU1MzcwLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25TdGFydFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcIm9jdGV0XCIsXG4gICAgbmFtZTogXCJ2ZXJzaW9uTWFqb3JcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcIm9jdGV0XCIsXG4gICAgbmFtZTogXCJ2ZXJzaW9uTWlub3JcIixcbiAgICBkZWZhdWx0OiA5XG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJzZXJ2ZXJQcm9wZXJ0aWVzXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwibWVjaGFuaXNtc1wiLFxuICAgIGRlZmF1bHQ6IFwiUExBSU5cIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJsb2NhbGVzXCIsXG4gICAgZGVmYXVsdDogXCJlbl9VU1wiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblN0YXJ0T2sgPSA2NTUzNzE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0T2sgPSB7XG4gIGlkOiA2NTUzNzEsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblN0YXJ0T2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiY2xpZW50UHJvcGVydGllc1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJtZWNoYW5pc21cIixcbiAgICBkZWZhdWx0OiBcIlBMQUlOXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwicmVzcG9uc2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwibG9jYWxlXCIsXG4gICAgZGVmYXVsdDogXCJlbl9VU1wiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblNlY3VyZSA9IDY1NTM4MDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmUgPSB7XG4gIGlkOiA2NTUzODAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblNlY3VyZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcImNoYWxsZW5nZVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblNlY3VyZU9rID0gNjU1MzgxO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlT2sgPSB7XG4gIGlkOiA2NTUzODEsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblNlY3VyZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwicmVzcG9uc2VcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25UdW5lID0gNjU1MzkwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lID0ge1xuICBpZDogNjU1MzkwLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDMwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25UdW5lXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImNoYW5uZWxNYXhcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcImZyYW1lTWF4XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiaGVhcnRiZWF0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25UdW5lT2sgPSA2NTUzOTE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblR1bmVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uVHVuZU9rID0ge1xuICBpZDogNjU1MzkxLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25UdW5lT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiY2hhbm5lbE1heFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwiZnJhbWVNYXhcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJoZWFydGJlYXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk9wZW4gPSA2NTU0MDA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbk9wZW4gPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvbk9wZW4gPSB7XG4gIGlkOiA2NTU0MDAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNDAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbk9wZW5cIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwidmlydHVhbEhvc3RcIixcbiAgICBkZWZhdWx0OiBcIi9cIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY2FwYWJpbGl0aWVzXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImluc2lzdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk9wZW5PayA9IDY1NTQwMTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uT3Blbk9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuT2sgPSB7XG4gIGlkOiA2NTU0MDEsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNDEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbk9wZW5Pa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJrbm93bkhvc3RzXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25DbG9zZSA9IDY1NTQxMDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2UgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlID0ge1xuICBpZDogNjU1NDEwLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDUwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25DbG9zZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJyZXBseUNvZGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVwbHlUZXh0XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiY2xhc3NJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJtZXRob2RJZFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbkNsb3NlT2sgPSA2NTU0MTE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlT2sgPSB7XG4gIGlkOiA2NTU0MTEsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNTEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbkNsb3NlT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25CbG9ja2VkID0gNjU1NDIwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25CbG9ja2VkID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25CbG9ja2VkID0ge1xuICBpZDogNjU1NDIwLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDYwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25CbG9ja2VkXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlYXNvblwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uVW5ibG9ja2VkID0gNjU1NDIxO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25VbmJsb2NrZWQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblVuYmxvY2tlZCA9IHtcbiAgaWQ6IDY1NTQyMSxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiA2MSxcbiAgbmFtZTogXCJDb25uZWN0aW9uVW5ibG9ja2VkXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsT3BlbiA9IDEzMTA3MzA7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbE9wZW4gPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbE9wZW4gPSB7XG4gIGlkOiAxMzEwNzMwLFxuICBjbGFzc0lkOiAyMCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIkNoYW5uZWxPcGVuXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcIm91dE9mQmFuZFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsT3Blbk9rID0gMTMxMDczMTtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsT3Blbk9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxPcGVuT2sgPSB7XG4gIGlkOiAxMzEwNzMxLFxuICBjbGFzc0lkOiAyMCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkNoYW5uZWxPcGVuT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJjaGFubmVsSWRcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbEZsb3cgPSAxMzEwNzQwO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxGbG93ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxGbG93ID0ge1xuICBpZDogMTMxMDc0MCxcbiAgY2xhc3NJZDogMjAsXG4gIG1ldGhvZElkOiAyMCxcbiAgbmFtZTogXCJDaGFubmVsRmxvd1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYWN0aXZlXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsRmxvd09rID0gMTMxMDc0MTtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsRmxvd09rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxGbG93T2sgPSB7XG4gIGlkOiAxMzEwNzQxLFxuICBjbGFzc0lkOiAyMCxcbiAgbWV0aG9kSWQ6IDIxLFxuICBuYW1lOiBcIkNoYW5uZWxGbG93T2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImFjdGl2ZVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbENsb3NlID0gMTMxMDc2MDtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsQ2xvc2UgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbENsb3NlID0ge1xuICBpZDogMTMxMDc2MCxcbiAgY2xhc3NJZDogMjAsXG4gIG1ldGhvZElkOiA0MCxcbiAgbmFtZTogXCJDaGFubmVsQ2xvc2VcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwicmVwbHlDb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VGV4dFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImNsYXNzSWRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwibWV0aG9kSWRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxDbG9zZU9rID0gMTMxMDc2MTtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsQ2xvc2VPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9DaGFubmVsQ2xvc2VPayA9IHtcbiAgaWQ6IDEzMTA3NjEsXG4gIGNsYXNzSWQ6IDIwLFxuICBtZXRob2RJZDogNDEsXG4gIG5hbWU6IFwiQ2hhbm5lbENsb3NlT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkFjY2Vzc1JlcXVlc3QgPSAxOTY2MDkwO1xuXG52YXIgbWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQWNjZXNzUmVxdWVzdCA9IHtcbiAgaWQ6IDE5NjYwOTAsXG4gIGNsYXNzSWQ6IDMwLFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiQWNjZXNzUmVxdWVzdFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyZWFsbVwiLFxuICAgIGRlZmF1bHQ6IFwiL2RhdGFcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImV4Y2x1c2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicGFzc2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICEwXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYWN0aXZlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJ3cml0ZVwiLFxuICAgIGRlZmF1bHQ6ICEwXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVhZFwiLFxuICAgIGRlZmF1bHQ6ICEwXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQWNjZXNzUmVxdWVzdE9rID0gMTk2NjA5MTtcblxudmFyIG1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQWNjZXNzUmVxdWVzdE9rID0ge1xuICBpZDogMTk2NjA5MSxcbiAgY2xhc3NJZDogMzAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJBY2Nlc3NSZXF1ZXN0T2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlRGVjbGFyZSA9IDI2MjE0NTA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZSA9IHtcbiAgaWQ6IDI2MjE0NTAsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiRXhjaGFuZ2VEZWNsYXJlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInR5cGVcIixcbiAgICBkZWZhdWx0OiBcImRpcmVjdFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicGFzc2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZHVyYWJsZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYXV0b0RlbGV0ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiaW50ZXJuYWxcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlRGVjbGFyZU9rID0gMjYyMTQ1MTtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmVPayA9IHtcbiAgaWQ6IDI2MjE0NTEsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiRXhjaGFuZ2VEZWNsYXJlT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlRGVsZXRlID0gMjYyMTQ2MDtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZSA9IHtcbiAgaWQ6IDI2MjE0NjAsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiRXhjaGFuZ2VEZWxldGVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImlmVW51c2VkXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlRGVsZXRlT2sgPSAyNjIxNDYxO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWxldGVPayA9IHtcbiAgaWQ6IDI2MjE0NjEsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiRXhjaGFuZ2VEZWxldGVPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VCaW5kID0gMjYyMTQ3MDtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZUJpbmQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VCaW5kID0ge1xuICBpZDogMjYyMTQ3MCxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJFeGNoYW5nZUJpbmRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZGVzdGluYXRpb25cIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwic291cmNlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VCaW5kT2sgPSAyNjIxNDcxO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlQmluZE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlQmluZE9rID0ge1xuICBpZDogMjYyMTQ3MSxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiAzMSxcbiAgbmFtZTogXCJFeGNoYW5nZUJpbmRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VVbmJpbmQgPSAyNjIxNDgwO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kID0ge1xuICBpZDogMjYyMTQ4MCxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiA0MCxcbiAgbmFtZTogXCJFeGNoYW5nZVVuYmluZFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJkZXN0aW5hdGlvblwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJzb3VyY2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZVVuYmluZE9rID0gMjYyMTQ5MTtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZVVuYmluZE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kT2sgPSB7XG4gIGlkOiAyNjIxNDkxLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDUxLFxuICBuYW1lOiBcIkV4Y2hhbmdlVW5iaW5kT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVjbGFyZSA9IDMyNzY4MTA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVEZWNsYXJlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlRGVjbGFyZSA9IHtcbiAgaWQ6IDMyNzY4MTAsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiUXVldWVEZWNsYXJlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInBhc3NpdmVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImR1cmFibGVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImV4Y2x1c2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYXV0b0RlbGV0ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVEZWNsYXJlT2sgPSAzMjc2ODExO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlRGVjbGFyZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlRGVjbGFyZU9rID0ge1xuICBpZDogMzI3NjgxMSxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJRdWV1ZURlY2xhcmVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VDb3VudFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcImNvbnN1bWVyQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlQmluZCA9IDMyNzY4MjA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVCaW5kID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlQmluZCA9IHtcbiAgaWQ6IDMyNzY4MjAsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiUXVldWVCaW5kXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZUJpbmRPayA9IDMyNzY4MjE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVCaW5kT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVCaW5kT2sgPSB7XG4gIGlkOiAzMjc2ODIxLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDIxLFxuICBuYW1lOiBcIlF1ZXVlQmluZE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVB1cmdlID0gMzI3NjgzMDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZVB1cmdlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlUHVyZ2UgPSB7XG4gIGlkOiAzMjc2ODMwLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDMwLFxuICBuYW1lOiBcIlF1ZXVlUHVyZ2VcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVB1cmdlT2sgPSAzMjc2ODMxO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlUHVyZ2VPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVB1cmdlT2sgPSB7XG4gIGlkOiAzMjc2ODMxLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIlF1ZXVlUHVyZ2VPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VDb3VudFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVEZWxldGUgPSAzMjc2ODQwO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlRGVsZXRlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlRGVsZXRlID0ge1xuICBpZDogMzI3Njg0MCxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiA0MCxcbiAgbmFtZTogXCJRdWV1ZURlbGV0ZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpZlVudXNlZFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiaWZFbXB0eVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlbGV0ZU9rID0gMzI3Njg0MTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZURlbGV0ZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlRGVsZXRlT2sgPSB7XG4gIGlkOiAzMjc2ODQxLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDQxLFxuICBuYW1lOiBcIlF1ZXVlRGVsZXRlT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlVW5iaW5kID0gMzI3Njg1MDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZVVuYmluZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVVuYmluZCA9IHtcbiAgaWQ6IDMyNzY4NTAsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogNTAsXG4gIG5hbWU6IFwiUXVldWVVbmJpbmRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyb3V0aW5nS2V5XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVVuYmluZE9rID0gMzI3Njg1MTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZVVuYmluZE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlVW5iaW5kT2sgPSB7XG4gIGlkOiAzMjc2ODUxLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDUxLFxuICBuYW1lOiBcIlF1ZXVlVW5iaW5kT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUW9zID0gMzkzMjE3MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1FvcyA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1FvcyA9IHtcbiAgaWQ6IDM5MzIxNzAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiQmFzaWNRb3NcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJwcmVmZXRjaFNpemVcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJwcmVmZXRjaENvdW50XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImdsb2JhbFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNRb3NPayA9IDM5MzIxNzE7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNRb3NPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1Fvc09rID0ge1xuICBpZDogMzkzMjE3MSxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJCYXNpY1Fvc09rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0NvbnN1bWUgPSAzOTMyMTgwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQ29uc3VtZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0NvbnN1bWUgPSB7XG4gIGlkOiAzOTMyMTgwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDIwLFxuICBuYW1lOiBcIkJhc2ljQ29uc3VtZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnN1bWVyVGFnXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vTG9jYWxcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vQWNrXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJleGNsdXNpdmVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ29uc3VtZU9rID0gMzkzMjE4MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NvbnN1bWVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0NvbnN1bWVPayA9IHtcbiAgaWQ6IDM5MzIxODEsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiQmFzaWNDb25zdW1lT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ2FuY2VsID0gMzkzMjE5MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NhbmNlbCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0NhbmNlbCA9IHtcbiAgaWQ6IDM5MzIxOTAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMzAsXG4gIG5hbWU6IFwiQmFzaWNDYW5jZWxcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNDYW5jZWxPayA9IDM5MzIxOTE7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNDYW5jZWxPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0NhbmNlbE9rID0ge1xuICBpZDogMzkzMjE5MSxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAzMSxcbiAgbmFtZTogXCJCYXNpY0NhbmNlbE9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnN1bWVyVGFnXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1B1Ymxpc2ggPSAzOTMyMjAwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUHVibGlzaCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1B1Ymxpc2ggPSB7XG4gIGlkOiAzOTMyMjAwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDQwLFxuICBuYW1lOiBcIkJhc2ljUHVibGlzaFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibWFuZGF0b3J5XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpbW1lZGlhdGVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUmV0dXJuID0gMzkzMjIxMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1JldHVybiA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1JldHVybiA9IHtcbiAgaWQ6IDM5MzIyMTAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNTAsXG4gIG5hbWU6IFwiQmFzaWNSZXR1cm5cIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwicmVwbHlDb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VGV4dFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljRGVsaXZlciA9IDM5MzIyMjA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNEZWxpdmVyID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljRGVsaXZlciA9IHtcbiAgaWQ6IDM5MzIyMjAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNjAsXG4gIG5hbWU6IFwiQmFzaWNEZWxpdmVyXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnN1bWVyVGFnXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZWRlbGl2ZXJlZFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyb3V0aW5nS2V5XCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0dldCA9IDM5MzIyMzA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNHZXQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNHZXQgPSB7XG4gIGlkOiAzOTMyMjMwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDcwLFxuICBuYW1lOiBcIkJhc2ljR2V0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vQWNrXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0dldE9rID0gMzkzMjIzMTtcblxudmFyIG1ldGhvZEluZm9CYXNpY0dldE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljR2V0T2sgPSB7XG4gIGlkOiAzOTMyMjMxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDcxLFxuICBuYW1lOiBcIkJhc2ljR2V0T2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nbG9uZ1wiLFxuICAgIG5hbWU6IFwiZGVsaXZlcnlUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlZGVsaXZlcmVkXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0RW1wdHkgPSAzOTMyMjMyO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljR2V0RW1wdHkgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNHZXRFbXB0eSA9IHtcbiAgaWQ6IDM5MzIyMzIsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNzIsXG4gIG5hbWU6IFwiQmFzaWNHZXRFbXB0eVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjbHVzdGVySWRcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNBY2sgPSAzOTMyMjQwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQWNrID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQWNrID0ge1xuICBpZDogMzkzMjI0MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA4MCxcbiAgbmFtZTogXCJCYXNpY0Fja1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJtdWx0aXBsZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZWplY3QgPSAzOTMyMjUwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmVqZWN0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmVqZWN0ID0ge1xuICBpZDogMzkzMjI1MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA5MCxcbiAgbmFtZTogXCJCYXNpY1JlamVjdFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6ICEwXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZWNvdmVyQXN5bmMgPSAzOTMyMjYwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmVjb3ZlckFzeW5jID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmVjb3ZlckFzeW5jID0ge1xuICBpZDogMzkzMjI2MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMDAsXG4gIG5hbWU6IFwiQmFzaWNSZWNvdmVyQXN5bmNcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlcXVldWVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUmVjb3ZlciA9IDM5MzIyNzA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWNvdmVyID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmVjb3ZlciA9IHtcbiAgaWQ6IDM5MzIyNzAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMTEwLFxuICBuYW1lOiBcIkJhc2ljUmVjb3ZlclwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZWNvdmVyT2sgPSAzOTMyMjcxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmVjb3Zlck9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmVjb3Zlck9rID0ge1xuICBpZDogMzkzMjI3MSxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMTEsXG4gIG5hbWU6IFwiQmFzaWNSZWNvdmVyT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljTmFjayA9IDM5MzIyODA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNOYWNrID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljTmFjayA9IHtcbiAgaWQ6IDM5MzIyODAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMTIwLFxuICBuYW1lOiBcIkJhc2ljTmFja1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJtdWx0aXBsZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6ICEwXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuVHhTZWxlY3QgPSA1ODk4MjUwO1xuXG52YXIgbWV0aG9kSW5mb1R4U2VsZWN0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1R4U2VsZWN0ID0ge1xuICBpZDogNTg5ODI1MCxcbiAgY2xhc3NJZDogOTAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJUeFNlbGVjdFwiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuVHhTZWxlY3RPayA9IDU4OTgyNTE7XG5cbnZhciBtZXRob2RJbmZvVHhTZWxlY3RPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFNlbGVjdE9rID0ge1xuICBpZDogNTg5ODI1MSxcbiAgY2xhc3NJZDogOTAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJUeFNlbGVjdE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeENvbW1pdCA9IDU4OTgyNjA7XG5cbnZhciBtZXRob2RJbmZvVHhDb21taXQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhDb21taXQgPSB7XG4gIGlkOiA1ODk4MjYwLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDIwLFxuICBuYW1lOiBcIlR4Q29tbWl0XCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeENvbW1pdE9rID0gNTg5ODI2MTtcblxudmFyIG1ldGhvZEluZm9UeENvbW1pdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1R4Q29tbWl0T2sgPSB7XG4gIGlkOiA1ODk4MjYxLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDIxLFxuICBuYW1lOiBcIlR4Q29tbWl0T2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Um9sbGJhY2sgPSA1ODk4MjcwO1xuXG52YXIgbWV0aG9kSW5mb1R4Um9sbGJhY2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhSb2xsYmFjayA9IHtcbiAgaWQ6IDU4OTgyNzAsXG4gIGNsYXNzSWQ6IDkwLFxuICBtZXRob2RJZDogMzAsXG4gIG5hbWU6IFwiVHhSb2xsYmFja1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuVHhSb2xsYmFja09rID0gNTg5ODI3MTtcblxudmFyIG1ldGhvZEluZm9UeFJvbGxiYWNrT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhSb2xsYmFja09rID0ge1xuICBpZDogNTg5ODI3MSxcbiAgY2xhc3NJZDogOTAsXG4gIG1ldGhvZElkOiAzMSxcbiAgbmFtZTogXCJUeFJvbGxiYWNrT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbmZpcm1TZWxlY3QgPSA1NTcwNTcwO1xuXG52YXIgbWV0aG9kSW5mb0NvbmZpcm1TZWxlY3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29uZmlybVNlbGVjdCA9IHtcbiAgaWQ6IDU1NzA1NzAsXG4gIGNsYXNzSWQ6IDg1LFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiQ29uZmlybVNlbGVjdFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25maXJtU2VsZWN0T2sgPSA1NTcwNTcxO1xuXG52YXIgbWV0aG9kSW5mb0NvbmZpcm1TZWxlY3RPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25maXJtU2VsZWN0T2sgPSB7XG4gIGlkOiA1NTcwNTcxLFxuICBjbGFzc0lkOiA4NSxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkNvbmZpcm1TZWxlY3RPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNQcm9wZXJ0aWVzID0gNjA7XG5cbnZhciBwcm9wZXJ0aWVzSW5mb0Jhc2ljUHJvcGVydGllcyA9IG1vZHVsZS5leHBvcnRzLnByb3BlcnRpZXNJbmZvQmFzaWNQcm9wZXJ0aWVzID0ge1xuICBpZDogNjAsXG4gIG5hbWU6IFwiQmFzaWNQcm9wZXJ0aWVzXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnRlbnRUeXBlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnRlbnRFbmNvZGluZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJoZWFkZXJzXCJcbiAgfSwge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5TW9kZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcIm9jdGV0XCIsXG4gICAgbmFtZTogXCJwcmlvcml0eVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb3JyZWxhdGlvbklkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VG9cIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhwaXJhdGlvblwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlSWRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJ0aW1lc3RhbXBcIixcbiAgICBuYW1lOiBcInRpbWVzdGFtcFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJ0eXBlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInVzZXJJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJhcHBJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjbHVzdGVySWRcIlxuICB9IF1cbn07IiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG5mdW5jdGlvbiB0cmltU3RhY2soc3RhY2ssIG51bSkge1xuICByZXR1cm4gc3RhY2sgJiYgc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKG51bSkuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIElsbGVnYWxPcGVyYXRpb25FcnJvcihtc2csIHN0YWNrKSB7XG4gIHZhciB0bXAgPSBuZXcgRXJyb3IoKTtcbiAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICB0aGlzLnN0YWNrID0gdGhpcy50b1N0cmluZygpICsgJ1xcbicgKyB0cmltU3RhY2sodG1wLnN0YWNrLCAyKTtcbiAgdGhpcy5zdGFja0F0U3RhdGVDaGFuZ2UgPSBzdGFjaztcbn1cbmluaGVyaXRzKElsbGVnYWxPcGVyYXRpb25FcnJvciwgRXJyb3IpO1xuXG5JbGxlZ2FsT3BlcmF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSWxsZWdhbE9wZXJhdGlvbkVycm9yJztcblxuZnVuY3Rpb24gc3RhY2tDYXB0dXJlKHJlYXNvbikge1xuICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICByZXR1cm4gJ1N0YWNrIGNhcHR1cmU6ICcgKyByZWFzb24gKyAnXFxuJyArXG4gICAgdHJpbVN0YWNrKGUuc3RhY2ssIDIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5JbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSBJbGxlZ2FsT3BlcmF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5zdGFja0NhcHR1cmUgPSBzdGFja0NhcHR1cmU7XG4iLCIvL1xuLy9cbi8vXG5cbi8vIFN0cmluZ2lmeWluZyB2YXJpb3VzIHRoaW5nc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBIRUFSVEJFQVQgPSByZXF1aXJlKCcuL2ZyYW1lJykuSEVBUlRCRUFUO1xuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZU1lc3NhZ2UgPSBmdW5jdGlvbihjbG9zZSkge1xuICB2YXIgY29kZSA9IGNsb3NlLmZpZWxkcy5yZXBseUNvZGU7XG4gIHJldHVybiBmb3JtYXQoJyVkICglcykgd2l0aCBtZXNzYWdlIFwiJXNcIicsXG4gICAgICAgICAgICAgICAgY29kZSwgZGVmcy5jb25zdGFudF9zdHJzW2NvZGVdLFxuICAgICAgICAgICAgICAgIGNsb3NlLmZpZWxkcy5yZXBseVRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXRob2ROYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGRlZnMuaW5mbyhpZCkubmFtZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmluc3BlY3QgPSBmdW5jdGlvbihmcmFtZSwgc2hvd0ZpZWxkcykge1xuICBpZiAoZnJhbWUgPT09IEhFQVJUQkVBVCkge1xuICAgIHJldHVybiAnPEhlYXJ0YmVhdD4nO1xuICB9XG4gIGVsc2UgaWYgKCFmcmFtZS5pZCkge1xuICAgIHJldHVybiBmb3JtYXQoJzxDb250ZW50IGNoYW5uZWw6JWQgc2l6ZTolZD4nLFxuICAgICAgICAgICAgICAgICAgZnJhbWUuY2hhbm5lbCwgZnJhbWUuc2l6ZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGluZm8gPSBkZWZzLmluZm8oZnJhbWUuaWQpO1xuICAgIHJldHVybiBmb3JtYXQoJzwlcyBjaGFubmVsOiVkJXM+JywgaW5mby5uYW1lLCBmcmFtZS5jaGFubmVsLFxuICAgICAgICAgICAgICAgICAgKHNob3dGaWVsZHMpXG4gICAgICAgICAgICAgICAgICA/ICcgJyArIEpTT04uc3RyaW5naWZ5KGZyYW1lLmZpZWxkcywgdW5kZWZpbmVkLCAyKVxuICAgICAgICAgICAgICAgICAgOiAnJyk7XG4gIH1cbn1cbiIsIi8vIFRoZSByaXZlciBzd2VlcHMgdGhyb3VnaFxuLy8gU2lsdCBhbmQgdHdpZ3MsIGdyYXZlbCBhbmQgbGVhdmVzXG4vLyBEcml2aW5nIHRoZSB3aGVlbCBvblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgY29uc3RhbnRzID0gZGVmcy5jb25zdGFudHM7XG52YXIgZGVjb2RlID0gZGVmcy5kZWNvZGU7XG5cbnZhciBCaXRzID0gcmVxdWlyZSgnQGFjdW1pbm91cy9iaXRzeW50YXgnKTtcblxubW9kdWxlLmV4cG9ydHMuUFJPVE9DT0xfSEVBREVSID0gXCJBTVFQXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDAsIDksIDEpO1xuXG4vKlxuICBGcmFtZSBmb3JtYXQ6XG5cbiAgMCAgICAgIDEgICAgICAgICAzICAgICAgICAgICAgIDcgICAgICAgICAgICAgICAgc2l6ZSs3IHNpemUrOFxuICArLS0tLS0tKy0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKyArLS0tLS0tLS0tLS0tKyArLS0tLS0tLS0tLS0rXG4gIHwgdHlwZSB8IGNoYW5uZWwgfCBzaXplICAgICAgICB8IHwgcGF5bG9hZCAgICB8IHwgZnJhbWUtZW5kIHxcbiAgKy0tLS0tLSstLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSsgKy0tLS0tLS0tLS0tLSsgKy0tLS0tLS0tLS0tK1xuICBvY3RldCAgIHNob3J0ICAgICBsb25nICAgICAgICAgICAgc2l6ZSBvY3RldHMgICAgb2N0ZXRcblxuICBJbiBnZW5lcmFsIEkgd2FudCB0byBrbm93IHRob3NlIGZpcnN0IHRocmVlIHRoaW5ncyBzdHJhaWdodCBhd2F5LCBzbyBJXG4gIGNhbiBkaXNjYXJkIGZyYW1lcyBlYXJseS5cblxuKi9cblxuLy8gZnJhbWluZyBjb25zdGFudHNcbnZhciBGUkFNRV9NRVRIT0QgPSBjb25zdGFudHMuRlJBTUVfTUVUSE9ELFxuRlJBTUVfSEVBUlRCRUFUID0gY29uc3RhbnRzLkZSQU1FX0hFQVJUQkVBVCxcbkZSQU1FX0hFQURFUiA9IGNvbnN0YW50cy5GUkFNRV9IRUFERVIsXG5GUkFNRV9CT0RZID0gY29uc3RhbnRzLkZSQU1FX0JPRFksXG5GUkFNRV9FTkQgPSBjb25zdGFudHMuRlJBTUVfRU5EO1xuXG52YXIgYm9keUNvbnMgPVxuICBCaXRzLmJ1aWxkZXIoRlJBTUVfQk9EWSxcbiAgICAgICAgICAgICAgICdjaGFubmVsOjE2LCBzaXplOjMyLCBwYXlsb2FkOnNpemUvYmluYXJ5JyxcbiAgICAgICAgICAgICAgIEZSQU1FX0VORCk7XG5cbi8vICUlJSBURVNUTUUgcG9zc2libHkgYmV0dGVyIHRvIGNvbnMgdGhlIGZpcnN0IGJpdCBhbmQgd3JpdGUgdGhlXG4vLyBzZWNvbmQgZGlyZWN0bHksIGluIHRoZSBhYnNlbmNlIG9mIElPIGxpc3RzXG5tb2R1bGUuZXhwb3J0cy5tYWtlQm9keUZyYW1lID0gZnVuY3Rpb24oY2hhbm5lbCwgcGF5bG9hZCkge1xuICByZXR1cm4gYm9keUNvbnMoe2NoYW5uZWw6IGNoYW5uZWwsIHNpemU6IHBheWxvYWQubGVuZ3RoLCBwYXlsb2FkOiBwYXlsb2FkfSk7XG59O1xuXG52YXIgZnJhbWVIZWFkZXJQYXR0ZXJuID0gQml0cy5tYXRjaGVyKCd0eXBlOjgnLCAnY2hhbm5lbDoxNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOjMyJywgJ3Jlc3QvYmluYXJ5Jyk7XG5cbmZ1bmN0aW9uIHBhcnNlRnJhbWUoYmluLCBtYXgpIHtcbiAgdmFyIGZoID0gZnJhbWVIZWFkZXJQYXR0ZXJuKGJpbik7XG4gIGlmIChmaCkge1xuICAgIHZhciBzaXplID0gZmguc2l6ZSwgcmVzdCA9IGZoLnJlc3Q7XG4gICAgaWYgKHNpemUgPiBtYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWUgc2l6ZSBleGNlZWRzIGZyYW1lIG1heCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN0Lmxlbmd0aCA+IHNpemUpIHtcbiAgICAgIGlmIChyZXN0W3NpemVdICE9PSBGUkFNRV9FTkQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcmFtZScpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBmaC50eXBlLFxuICAgICAgICBjaGFubmVsOiBmaC5jaGFubmVsLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBwYXlsb2FkOiByZXN0LnNsaWNlKDAsIHNpemUpLFxuICAgICAgICByZXN0OiByZXN0LnNsaWNlKHNpemUgKyAxKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZUZyYW1lID0gcGFyc2VGcmFtZTtcblxudmFyIGhlYWRlclBhdHRlcm4gPSBCaXRzLm1hdGNoZXIoJ2NsYXNzOjE2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdfd2VpZ2h0OjE2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOjY0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmbGFnc0FuZGZpZWxkcy9iaW5hcnknKTtcblxudmFyIG1ldGhvZFBhdHRlcm4gPSBCaXRzLm1hdGNoZXIoJ2lkOjMyLCBhcmdzL2JpbmFyeScpO1xuXG52YXIgSEVBUlRCRUFUID0ge2NoYW5uZWw6IDB9O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGVGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIHZhciBwYXlsb2FkID0gZnJhbWUucGF5bG9hZDtcbiAgc3dpdGNoIChmcmFtZS50eXBlKSB7XG4gIGNhc2UgRlJBTUVfTUVUSE9EOlxuICAgIHZhciBpZEFuZEFyZ3MgPSBtZXRob2RQYXR0ZXJuKHBheWxvYWQpO1xuICAgIHZhciBpZCA9IGlkQW5kQXJncy5pZDtcbiAgICB2YXIgZmllbGRzID0gZGVjb2RlKGlkLCBpZEFuZEFyZ3MuYXJncyk7XG4gICAgcmV0dXJuIHtpZDogaWQsIGNoYW5uZWw6IGZyYW1lLmNoYW5uZWwsIGZpZWxkczogZmllbGRzfTtcbiAgY2FzZSBGUkFNRV9IRUFERVI6XG4gICAgdmFyIHBhcnRzID0gaGVhZGVyUGF0dGVybihwYXlsb2FkKTtcbiAgICB2YXIgaWQgPSBwYXJ0c1snY2xhc3MnXTtcbiAgICB2YXIgZmllbGRzID0gZGVjb2RlKGlkLCBwYXJ0cy5mbGFnc0FuZGZpZWxkcyk7XG4gICAgcmV0dXJuIHtpZDogaWQsIGNoYW5uZWw6IGZyYW1lLmNoYW5uZWwsXG4gICAgICAgICAgICBzaXplOiBwYXJ0cy5zaXplLCBmaWVsZHM6IGZpZWxkc307XG4gIGNhc2UgRlJBTUVfQk9EWTpcbiAgICByZXR1cm4ge2NoYW5uZWw6IGZyYW1lLmNoYW5uZWwsIGNvbnRlbnQ6IGZyYW1lLnBheWxvYWR9O1xuICBjYXNlIEZSQU1FX0hFQVJUQkVBVDpcbiAgICByZXR1cm4gSEVBUlRCRUFUO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmcmFtZSB0eXBlICcgKyBmcmFtZS50eXBlKTtcbiAgfVxufVxuXG4vLyBlbmNvZGVkIGhlYXJ0YmVhdFxubW9kdWxlLmV4cG9ydHMuSEVBUlRCRUFUX0JVRiA9IEJ1ZmZlci5mcm9tKFtjb25zdGFudHMuRlJBTUVfSEVBUlRCRUFULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIC8vIHNpemUgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgLy8gY2hhbm5lbCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuRlJBTUVfRU5EXSk7XG5cbm1vZHVsZS5leHBvcnRzLkhFQVJUQkVBVCA9IEhFQVJUQkVBVDtcbiIsIi8vXG4vL1xuLy9cblxuLy8gSGVhcnRiZWF0cy4gSW4gQU1RUCBib3RoIGNsaWVudHMgYW5kIHNlcnZlcnMgbWF5IGV4cGVjdCBhIGhlYXJ0YmVhdFxuLy8gZnJhbWUgaWYgdGhlcmUgaXMgbm8gYWN0aXZpdHkgb24gdGhlIGNvbm5lY3Rpb24gZm9yIGEgbmVnb3RpYXRlZFxuLy8gcGVyaW9kIG9mIHRpbWUuIElmIHRoZXJlJ3Mgbm8gYWN0aXZpdHkgZm9yIHR3byBzdWNoIGludGVydmFscywgdGhlXG4vLyBzZXJ2ZXIgb3IgY2xpZW50IGlzIGFsbG93ZWQgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24gb24gdGhlXG4vLyBwcmVzdW1wdGlvbiB0aGF0IHRoZSBvdGhlciBwYXJ0eSBpcyBkZWFkLlxuLy9cbi8vIFRoZSBjbGllbnQgaGFzIHR3byBqb2JzIGhlcmU6IHRoZSBmaXJzdCBpcyB0byBzZW5kIGEgaGVhcnRiZWF0XG4vLyBmcmFtZSBpZiBpdCdzIG5vdCBzZW50IGFueSBmcmFtZXMgZm9yIGEgd2hpbGUsIHNvIHRoYXQgdGhlIHNlcnZlclxuLy8gZG9lc24ndCB0aGluayBpdCdzIGRlYWQ7IHRoZSBzZWNvbmQgaXMgdG8gY2hlY2sgcGVyaW9kaWNhbGx5IHRoYXRcbi8vIGl0J3Mgc2VlbiBhY3Rpdml0eSBmcm9tIHRoZSBzZXJ2ZXIsIGFuZCB0byBhZHZpc2UgaWYgdGhlcmUgZG9lc24ndFxuLy8gYXBwZWFyIHRvIGhhdmUgYmVlbiBhbnkgZm9yIG92ZXIgdHdvIGludGVydmFscy5cbi8vXG4vLyBOb2RlLkpTIHRpbWVycyBhcmUgYSBiaXQgdW5yZWxpYWJsZSwgaW4gdGhhdCB0aGV5IGVuZGVhdm91ciBvbmx5IHRvXG4vLyBmaXJlIGF0IHNvbWUgaW5kZXRlcm1pbmF0ZSBwb2ludCAqYWZ0ZXIqIHRoZSBnaXZlbiB0aW1lIChyYXRoZXJcbi8vIGdpdmVzIHRoZSBsaWUgdG8gJ3JlYWx0aW1lJywgZHVubml0KS4gQmVjYXVzZSB0aGUgc2NoZWR1bGVyIGlzIGp1c3Rcbi8vIGFuIGV2ZW50IGxvb3AsIGl0J3MgcXVpdGUgZWFzeSB0byBkZWxheSB0aW1lcnMgaW5kZWZpbml0ZWx5IGJ5XG4vLyByZWFjdGluZyB0byBzb21lIEkvTyB3aXRoIGEgbG90IG9mIGNvbXB1dGF0aW9uLlxuLy9cbi8vIFRvIG1pdGlnYXRlIHRoaXMgSSBuZWVkIGEgYml0IG9mIGNyZWF0aXZlIGludGVycHJldGF0aW9uOlxuLy9cbi8vICAtIEknbGwgc2NoZWR1bGUgYSBzZXJ2ZXIgYWN0aXZpdHkgY2hlY2sgZm9yIGV2ZXJ5IGBpbnRlcnZhbGAsIGFuZFxuLy8gICAgY2hlY2sganVzdCBob3cgbXVjaCB0aW1lIGhhcyBwYXNzZWQuIEl0IHdpbGwgb3ZlcnNob290IGJ5IGF0XG4vLyAgICBsZWFzdCBhIHNtYWxsIG1hcmdpbjsgbW9kdWxvIG1pc3NpbmcgdGltZXIgZGVhZGxpbmVzLCBpdCdsbFxuLy8gICAgbm90aWNlIGJldHdlZW4gdHdvIGFuZCB0aHJlZSBpbnRlcnZhbHMgYWZ0ZXIgYWN0aXZpdHkgYWN0dWFsbHlcbi8vICAgIHN0b3BzIChvdGhlcndpc2UsIGF0IHNvbWUgcG9pbnQgYWZ0ZXIgdHdvIGludGVydmFscykuXG4vL1xuLy8gIC0gRXZlcnkgYGludGVydmFsIC8gMmAgSSdsbCBjaGVjayB0aGF0IHdlJ3ZlIHNlbnQgc29tZXRoaW5nIHNpbmNlXG4vLyAgICB0aGUgbGFzdCBjaGVjaywgYW5kIGlmIG5vdCwgc2VuZCBhIGhlYXJ0YmVhdCBmcmFtZS4gSWYgd2UncmVcbi8vICAgIHJlYWxseSB0b28gYnVzeSB0byBldmVuIHJ1biB0aGUgY2hlY2sgZm9yIHR3byB3aG9sZSBoZWFydGJlYXRcbi8vICAgIGludGVydmFscywgdGhlcmUgbXVzdCBiZSBhIGxvdCBvZiBJIChidXQgbm90IE8sIGF0IGxlYXN0IG5vdCBvblxuLy8gICAgdGhlIGNvbm5lY3Rpb24pLCBvciBjb21wdXRhdGlvbiwgaW4gd2hpY2ggY2FzZSBwZXJoYXBzIGl0J3MgYmVzdFxuLy8gICAgdGhlIHNlcnZlciBjdXRzIHVzIG9mZiBhbnl3YXkuIFdoeSBgaW50ZXJ2YWwgLyAyYD8gQmVjYXVzZSB0aGVcbi8vICAgIGVkZ2UgY2FzZSBpcyB0aGF0IHRoZSBjbGllbnQgc2VudCBhIGZyYW1lIGp1c3QgYWZ0ZXIgYVxuLy8gICAgaGVhcnRiZWF0LCB3aGljaCB3b3VsZCBtZWFuIEkgb25seSBzZW5kIG9uZSBhZnRlciBhbG1vc3QgdHdvXG4vLyAgICBpbnRlcnZhbHMuIChOQiBhIGhlYXJ0YmVhdCBjb3VudHMgYXMgYSBzZW5kLCBzbyBpdCdsbCBiZSBjaGVja2VkXG4vLyAgICBhdCBsZWFzdCB0d2ljZSBiZWZvcmUgc2VuZGluZyBhbm90aGVyKVxuLy9cbi8vIFRoaXMgZGVzaWduIGlzIGJhc2VkIGxhcmdlbHkgb24gUmFiYml0TVEncyBoZWFydGJlYXRpbmc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmFiYml0bXEvcmFiYml0bXEtY29tbW9uL2Jsb2IvbWFzdGVyL3NyYy9yYWJiaXRfaGVhcnRiZWF0LmVybFxuXG4vLyAlJSBZZXMsIEkgY291bGQgYXBwbHkgdGhlIHNhbWUgJ2FjdHVhbGx5IHBhc3NhZ2Ugb2YgdGltZScgdGhpbmcgdG9cbi8vICUlIHNlbmQgYXMgd2VsbCBhcyB0byByZWN2LlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8vIEV4cG9ydGVkIHNvIHRoYXQgd2UgY2FuIG1lc3Mgd2l0aCBpdCBpbiB0ZXN0c1xubW9kdWxlLmV4cG9ydHMuVU5JVFNfVE9fTVMgPSAxMDAwO1xuXG5mdW5jdGlvbiBIZWFydChpbnRlcnZhbCwgY2hlY2tTZW5kLCBjaGVja1JlY3YpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuICB2YXIgaW50ZXJ2YWxNcyA9IGludGVydmFsICogbW9kdWxlLmV4cG9ydHMuVU5JVFNfVE9fTVM7XG4gIC8vIEZ1bmN0aW9uI2JpbmQgaXMgbXkgbmV3IGJlc3QgZnJpZW5kXG4gIHZhciBiZWF0ID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2JlYXQnKTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndGltZW91dCcpO1xuXG4gIHRoaXMuc2VuZFRpbWVyID0gc2V0SW50ZXJ2YWwoXG4gICAgdGhpcy5ydW5IZWFydGJlYXQuYmluZCh0aGlzLCBjaGVja1NlbmQsIGJlYXQpLCBpbnRlcnZhbE1zIC8gMik7XG5cbiAgLy8gQSB0aW1lb3V0IG9jY3VycyBpZiBJIHNlZSBub3RoaW5nIGZvciAqdHdvIGNvbnNlY3V0aXZlKiBpbnRlcnZhbHNcbiAgdmFyIHJlY3ZNaXNzZWQgPSAwO1xuICBmdW5jdGlvbiBtaXNzZWRUd28oKSB7XG4gICAgaWYgKCFjaGVja1JlY3YoKSkgcmV0dXJuICgrK3JlY3ZNaXNzZWQgPCAyKTtcbiAgICBlbHNlIHsgcmVjdk1pc3NlZCA9IDA7IHJldHVybiB0cnVlOyB9XG4gIH1cbiAgdGhpcy5yZWN2VGltZXIgPSBzZXRJbnRlcnZhbChcbiAgICB0aGlzLnJ1bkhlYXJ0YmVhdC5iaW5kKHRoaXMsIG1pc3NlZFR3bywgdGltZW91dCksIGludGVydmFsTXMpO1xufVxuaW5oZXJpdHMoSGVhcnQsIEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzLkhlYXJ0ID0gSGVhcnQ7XG5cbkhlYXJ0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBjbGVhckludGVydmFsKHRoaXMuc2VuZFRpbWVyKTtcbiAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY3ZUaW1lcik7XG59O1xuXG5IZWFydC5wcm90b3R5cGUucnVuSGVhcnRiZWF0ID0gZnVuY3Rpb24oY2hlY2ssIGZhaWwpIHtcbiAgLy8gSGF2ZSB3ZSBzZWVuIGFjdGl2aXR5P1xuICBpZiAoIWNoZWNrKCkpIGZhaWwoKTtcbn07XG4iLCIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gQSBNdXggaXMgYW4gb2JqZWN0IGludG8gd2hpY2ggb3RoZXIgcmVhZGFibGUgc3RyZWFtcyBtYXkgYmUgcGlwZWQ7XG4vLyBpdCB0aGVuIHdyaXRlcyAncGFja2V0cycgZnJvbSB0aGUgdXBzdHJlYW1zIHRvIHRoZSBnaXZlblxuLy8gZG93bnN0cmVhbS5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgc2NoZWR1bGUgPSAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgP1xuICBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzLm5leHRUaWNrO1xuXG5mdW5jdGlvbiBNdXgoZG93bnN0cmVhbSkge1xuICB0aGlzLm5ld1N0cmVhbXMgPSBbXTtcbiAgdGhpcy5vbGRTdHJlYW1zID0gW107XG4gIHRoaXMuYmxvY2tlZCA9IGZhbHNlO1xuICB0aGlzLnNjaGVkdWxlZFJlYWQgPSBmYWxzZTtcblxuICB0aGlzLm91dCA9IGRvd25zdHJlYW07XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZG93bnN0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmJsb2NrZWQgPSBmYWxzZTtcbiAgICBzZWxmLl9yZWFkSW5jb21pbmcoKTtcbiAgfSk7XG59XG5cbi8vIFRoZXJlIGFyZSAyIHN0YXRlcyB3ZSBjYW4gYmUgaW46XG5cbi8vIC0gd2FpdGluZyBmb3Igb3V0Ym91bmQgY2FwYWNpdHksIHdoaWNoIHdpbGwgYmUgc2lnbmFsbGVkIGJ5IGFcbi8vIC0gJ2RyYWluJyBldmVudCBvbiB0aGUgZG93bnN0cmVhbTsgb3IsXG5cbi8vIC0gbm8gcGFja2V0cyB0byBzZW5kLCB3YWl0aW5nIGZvciBhbiBpbmJvdW5kIGJ1ZmZlciB0byBoYXZlXG4vLyAgIHBhY2tldHMsIHdoaWNoIHdpbGwgYmUgc2lnbmFsbGVkIGJ5IGEgJ3JlYWRhYmxlJyBldmVudFxuXG4vLyBJZiB3ZSB3cml0ZSBhbGwgcGFja2V0cyBhdmFpbGFibGUgd2hlbmV2ZXIgdGhlcmUgaXMgb3V0Ym91bmRcbi8vIGNhcGFjaXR5LCB3ZSB3aWxsIGVpdGhlciBydW4gb3V0IG9mIG91dGJvdW5kIGNhcGFjaXR5IChgI3dyaXRlYFxuLy8gcmV0dXJucyBmYWxzZSksIG9yIHJ1biBvdXQgb2YgcGFja2V0cyAoYWxsIGNhbGxzIHRvIGFuXG4vLyBgaW5ib3VuZC5yZWFkKClgIGhhdmUgcmV0dXJuZWQgbnVsbCkuXG5cbk11eC5wcm90b3R5cGUuX3JlYWRJbmNvbWluZyA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIFdlIG1heSBiZSBzZW50IGhlcmUgc3BlY3VsYXRpdmVseSwgaWYgYW4gaW5jb21pbmcgc3RyZWFtIGhhc1xuICAvLyBiZWNvbWUgcmVhZGFibGVcbiAgaWYgKHRoaXMuYmxvY2tlZCkgcmV0dXJuO1xuXG4gIHZhciBhY2NlcHRpbmcgPSB0cnVlO1xuICB2YXIgb3V0ID0gdGhpcy5vdXQ7XG5cbiAgLy8gVHJ5IHRvIHJlYWQgYSBjaHVuayBmcm9tIGVhY2ggc3RyZWFtIGluIHR1cm4sIHVudGlsIGFsbCBzdHJlYW1zXG4gIC8vIGFyZSBlbXB0eSwgb3Igd2UgZXhoYXVzdCBvdXIgYWJpbGl0eSB0byBhY2NlcHQgY2h1bmtzLlxuICBmdW5jdGlvbiByb3VuZHJvYmluKHN0cmVhbXMpIHtcbiAgICB2YXIgcztcbiAgICB3aGlsZSAoYWNjZXB0aW5nICYmIChzID0gc3RyZWFtcy5zaGlmdCgpKSkge1xuICAgICAgdmFyIGNodW5rID0gcy5yZWFkKCk7XG4gICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgYWNjZXB0aW5nID0gb3V0LndyaXRlKGNodW5rKTtcbiAgICAgICAgc3RyZWFtcy5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJvdW5kcm9iaW4odGhpcy5uZXdTdHJlYW1zKTtcblxuICAvLyBFaXRoZXIgd2UgZXhoYXVzdGVkIHRoZSBuZXcgcXVldWVzLCBvciB3ZSByYW4gb3V0IG9mIGNhcGFjaXR5LiBJZlxuICAvLyB3ZSByYW4gb3V0IG9mIGNhcGFjaXR5LCBhbGwgdGhlIHJlbWFpbmluZyBuZXcgc3RyZWFtcyAoaS5lLixcbiAgLy8gdGhvc2Ugd2l0aCBwYWNrZXRzIGxlZnQpIGJlY29tZSBvbGQgc3RyZWFtcy4gVGhpcyBlZmZlY3RpdmVseVxuICAvLyBwcmlvcml0aXNlcyBzdHJlYW1zIHRoYXQga2VlcCB0aGVpciBidWZmZXJzIGNsb3NlIHRvIGVtcHR5IG92ZXJcbiAgLy8gdGhvc2UgdGhhdCBhcmUgY29uc3RhbnRseSBuZWFyIGZ1bGwuXG5cbiAgaWYgKGFjY2VwdGluZykgeyAvLyBhbGwgbmV3IHF1ZXVlcyBhcmUgZXhoYXVzdGVkLCB3cml0ZSBhcyBtYW55IGFzXG4gICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGZyb20gdGhlIG9sZCBzdHJlYW1zXG4gICAgYXNzZXJ0LmVxdWFsKDAsIHRoaXMubmV3U3RyZWFtcy5sZW5ndGgpO1xuICAgIHJvdW5kcm9iaW4odGhpcy5vbGRTdHJlYW1zKTtcbiAgfVxuICBlbHNlIHsgLy8gcmFuIG91dCBvZiByb29tXG4gICAgYXNzZXJ0KHRoaXMubmV3U3RyZWFtcy5sZW5ndGggPiAwLCBcIkV4cGVjdCBzb21lIG5ldyBzdHJlYW1zIHRvIHJlbWFpblwiKTtcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLm9sZFN0cmVhbXMsIHRoaXMubmV3U3RyZWFtcyk7XG4gICAgdGhpcy5uZXdTdHJlYW1zID0gW107XG4gIH1cbiAgLy8gV2UgbWF5IGhhdmUgZXhoYXVzdGVkIGFsbCB0aGUgb2xkIHF1ZXVlcywgb3IgcnVuIG91dCBvZiByb29tO1xuICAvLyBlaXRoZXIgd2F5LCBhbGwgd2UgbmVlZCB0byBkbyBpcyByZWNvcmQgd2hldGhlciB3ZSBoYXZlIGNhcGFjaXR5XG4gIC8vIG9yIG5vdCwgc28gYW55IHNwZWN1bGF0aXZlIHJlYWRzIHdpbGwga25vd1xuICB0aGlzLmJsb2NrZWQgPSAhYWNjZXB0aW5nO1xufTtcblxuTXV4LnByb3RvdHlwZS5fc2NoZWR1bGVSZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuc2NoZWR1bGVkUmVhZCkge1xuICAgIHNjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5zY2hlZHVsZWRSZWFkID0gZmFsc2U7XG4gICAgICBzZWxmLl9yZWFkSW5jb21pbmcoKTtcbiAgICB9KTtcbiAgICBzZWxmLnNjaGVkdWxlZFJlYWQgPSB0cnVlO1xuICB9XG59O1xuXG5NdXgucHJvdG90eXBlLnBpcGVGcm9tID0gZnVuY3Rpb24ocmVhZGFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGVucXVldWUoKSB7XG4gICAgc2VsZi5uZXdTdHJlYW1zLnB1c2gocmVhZGFibGUpO1xuICAgIHNlbGYuX3NjaGVkdWxlUmVhZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICByZWFkYWJsZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBlbnF1ZXVlKTtcbiAgICByZWFkYWJsZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBjbGVhbnVwKTtcbiAgICByZWFkYWJsZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgcmVhZGFibGUucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZUZyb20nLCBjbGVhbnVwSWZNZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW51cElmTWUoZGVzdCkge1xuICAgIGlmIChkZXN0ID09PSBzZWxmKSBjbGVhbnVwKCk7XG4gIH1cblxuICByZWFkYWJsZS5vbigndW5waXBlRnJvbScsIGNsZWFudXBJZk1lKTtcbiAgcmVhZGFibGUub24oJ2VuZCcsIGNsZWFudXApO1xuICByZWFkYWJsZS5vbignZXJyb3InLCBjbGVhbnVwKTtcbiAgcmVhZGFibGUub24oJ3JlYWRhYmxlJywgZW5xdWV1ZSk7XG59O1xuXG5NdXgucHJvdG90eXBlLnVucGlwZUZyb20gPSBmdW5jdGlvbihyZWFkYWJsZSkge1xuICByZWFkYWJsZS5lbWl0KCd1bnBpcGVGcm9tJywgdGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5NdXggPSBNdXg7XG4iLCJ2YXIgcmVnaXN0ZXIgPSByZXF1aXJlKFwiLi9saWIvcmVnaXN0ZXJcIik7XG52YXIgYWRkSG9vayA9IHJlcXVpcmUoXCIuL2xpYi9hZGRcIik7XG52YXIgcmVtb3ZlSG9vayA9IHJlcXVpcmUoXCIuL2xpYi9yZW1vdmVcIik7XG5cbi8vIGJpbmQgd2l0aCBhcnJheSBvZiBhcmd1bWVudHM6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTc5MjkxM1xudmFyIGJpbmQgPSBGdW5jdGlvbi5iaW5kO1xudmFyIGJpbmRhYmxlID0gYmluZC5iaW5kKGJpbmQpO1xuXG5mdW5jdGlvbiBiaW5kQXBpKGhvb2ssIHN0YXRlLCBuYW1lKSB7XG4gIHZhciByZW1vdmVIb29rUmVmID0gYmluZGFibGUocmVtb3ZlSG9vaywgbnVsbCkuYXBwbHkoXG4gICAgbnVsbCxcbiAgICBuYW1lID8gW3N0YXRlLCBuYW1lXSA6IFtzdGF0ZV1cbiAgKTtcbiAgaG9vay5hcGkgPSB7IHJlbW92ZTogcmVtb3ZlSG9va1JlZiB9O1xuICBob29rLnJlbW92ZSA9IHJlbW92ZUhvb2tSZWY7XG4gIFtcImJlZm9yZVwiLCBcImVycm9yXCIsIFwiYWZ0ZXJcIiwgXCJ3cmFwXCJdLmZvckVhY2goZnVuY3Rpb24gKGtpbmQpIHtcbiAgICB2YXIgYXJncyA9IG5hbWUgPyBbc3RhdGUsIGtpbmQsIG5hbWVdIDogW3N0YXRlLCBraW5kXTtcbiAgICBob29rW2tpbmRdID0gaG9vay5hcGlba2luZF0gPSBiaW5kYWJsZShhZGRIb29rLCBudWxsKS5hcHBseShudWxsLCBhcmdzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIEhvb2tTaW5ndWxhcigpIHtcbiAgdmFyIHNpbmd1bGFySG9va05hbWUgPSBcImhcIjtcbiAgdmFyIHNpbmd1bGFySG9va1N0YXRlID0ge1xuICAgIHJlZ2lzdHJ5OiB7fSxcbiAgfTtcbiAgdmFyIHNpbmd1bGFySG9vayA9IHJlZ2lzdGVyLmJpbmQobnVsbCwgc2luZ3VsYXJIb29rU3RhdGUsIHNpbmd1bGFySG9va05hbWUpO1xuICBiaW5kQXBpKHNpbmd1bGFySG9vaywgc2luZ3VsYXJIb29rU3RhdGUsIHNpbmd1bGFySG9va05hbWUpO1xuICByZXR1cm4gc2luZ3VsYXJIb29rO1xufVxuXG5mdW5jdGlvbiBIb29rQ29sbGVjdGlvbigpIHtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHJlZ2lzdHJ5OiB7fSxcbiAgfTtcblxuICB2YXIgaG9vayA9IHJlZ2lzdGVyLmJpbmQobnVsbCwgc3RhdGUpO1xuICBiaW5kQXBpKGhvb2ssIHN0YXRlKTtcblxuICByZXR1cm4gaG9vaztcbn1cblxudmFyIGNvbGxlY3Rpb25Ib29rRGVwcmVjYXRpb25NZXNzYWdlRGlzcGxheWVkID0gZmFsc2U7XG5mdW5jdGlvbiBIb29rKCkge1xuICBpZiAoIWNvbGxlY3Rpb25Ib29rRGVwcmVjYXRpb25NZXNzYWdlRGlzcGxheWVkKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1tiZWZvcmUtYWZ0ZXItaG9va106IFwiSG9vaygpXCIgcmVwdXJwb3Npbmcgd2FybmluZywgdXNlIFwiSG9vay5Db2xsZWN0aW9uKClcIi4gUmVhZCBtb3JlOiBodHRwczovL2dpdC5pby91cGdyYWRlLWJlZm9yZS1hZnRlci1ob29rLXRvLTEuNCdcbiAgICApO1xuICAgIGNvbGxlY3Rpb25Ib29rRGVwcmVjYXRpb25NZXNzYWdlRGlzcGxheWVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gSG9va0NvbGxlY3Rpb24oKTtcbn1cblxuSG9vay5TaW5ndWxhciA9IEhvb2tTaW5ndWxhci5iaW5kKCk7XG5Ib29rLkNvbGxlY3Rpb24gPSBIb29rQ29sbGVjdGlvbi5iaW5kKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSG9vaztcbi8vIGV4cG9zZSBjb25zdHJ1Y3RvcnMgYXMgYSBuYW1lZCBwcm9wZXJ0eSBmb3IgVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuSG9vayA9IEhvb2s7XG5tb2R1bGUuZXhwb3J0cy5TaW5ndWxhciA9IEhvb2suU2luZ3VsYXI7XG5tb2R1bGUuZXhwb3J0cy5Db2xsZWN0aW9uID0gSG9vay5Db2xsZWN0aW9uO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGRIb29rO1xuXG5mdW5jdGlvbiBhZGRIb29rKHN0YXRlLCBraW5kLCBuYW1lLCBob29rKSB7XG4gIHZhciBvcmlnID0gaG9vaztcbiAgaWYgKCFzdGF0ZS5yZWdpc3RyeVtuYW1lXSkge1xuICAgIHN0YXRlLnJlZ2lzdHJ5W25hbWVdID0gW107XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJiZWZvcmVcIikge1xuICAgIGhvb2sgPSBmdW5jdGlvbiAobWV0aG9kLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4ob3JpZy5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbihtZXRob2QuYmluZChudWxsLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImFmdGVyXCIpIHtcbiAgICBob29rID0gZnVuY3Rpb24gKG1ldGhvZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihtZXRob2QuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdF8pIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHRfO1xuICAgICAgICAgIHJldHVybiBvcmlnKHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiZXJyb3JcIikge1xuICAgIGhvb2sgPSBmdW5jdGlvbiAobWV0aG9kLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZyhlcnJvciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5wdXNoKHtcbiAgICBob29rOiBob29rLFxuICAgIG9yaWc6IG9yaWcsXG4gIH0pO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjtcblxuZnVuY3Rpb24gcmVnaXN0ZXIoc3RhdGUsIG5hbWUsIG1ldGhvZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGZvciBiZWZvcmUgaG9vayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGNhbGxiYWNrLCBuYW1lKSB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSwgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sIG1ldGhvZCkoKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5yZWR1Y2UoZnVuY3Rpb24gKG1ldGhvZCwgcmVnaXN0ZXJlZCkge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQuaG9vay5iaW5kKG51bGwsIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgfSwgbWV0aG9kKSgpO1xuICB9KTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlSG9vaztcblxuZnVuY3Rpb24gcmVtb3ZlSG9vayhzdGF0ZSwgbmFtZSwgbWV0aG9kKSB7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5kZXggPSBzdGF0ZS5yZWdpc3RyeVtuYW1lXVxuICAgIC5tYXAoZnVuY3Rpb24gKHJlZ2lzdGVyZWQpIHtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkLm9yaWc7XG4gICAgfSlcbiAgICAuaW5kZXhPZihtZXRob2QpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBKYXZhU2NyaXB0IGlzIG51bWVyaWNhbGx5IGNoYWxsZW5nZWRcbnZhciBTSElGVF9MRUZUXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xudmFyIFNISUZUX1JJR0hUXzMyID0gMSAvIFNISUZUX0xFRlRfMzI7XG5cbi8vIFRoZSBtYXhpbXVtIGNvbnRpZ3VvdXMgaW50ZWdlciB0aGF0IGNhbiBiZSBoZWxkIGluIGEgSUVFRTc1NCBkb3VibGVcbnZhciBNQVhfSU5UID0gMHgxZmZmZmZmZmZmZmZmZjtcblxuZnVuY3Rpb24gaXNDb250aWd1b3VzSW50KHZhbCkge1xuICAgIHJldHVybiB2YWwgPD0gTUFYX0lOVCAmJiB2YWwgPj0gLU1BWF9JTlQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbnRpZ3VvdXNJbnQodmFsKSB7XG4gICAgaWYgKCFpc0NvbnRpZ3VvdXNJbnQodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibnVtYmVyIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGNvbnRpZ3VvdXMgaW50ZWdlclwiKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLmlzQ29udGlndW91c0ludCA9IGlzQ29udGlndW91c0ludDtcbm1vZHVsZS5leHBvcnRzLmFzc2VydENvbnRpZ3VvdXNJbnQgPSBhc3NlcnRDb250aWd1b3VzSW50O1xuXG4vLyBGaWxsIGluIHRoZSByZWd1bGFyIHByb2NlZHVyZXNcblsnVUludCcsICdJbnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWduKSB7XG4gIHZhciBzdWZmaXggPSBzaWduICsgJzgnO1xuICBtb2R1bGUuZXhwb3J0c1sncmVhZCcgKyBzdWZmaXhdID1cbiAgICBCdWZmZXIucHJvdG90eXBlWydyZWFkJyArIHN1ZmZpeF0uY2FsbDtcbiAgbW9kdWxlLmV4cG9ydHNbJ3dyaXRlJyArIHN1ZmZpeF0gPVxuICAgIEJ1ZmZlci5wcm90b3R5cGVbJ3dyaXRlJyArIHN1ZmZpeF0uY2FsbDtcblxuICBbJzE2JywgJzMyJ10uZm9yRWFjaChmdW5jdGlvbiAoc2l6ZSkge1xuICAgIFsnTEUnLCAnQkUnXS5mb3JFYWNoKGZ1bmN0aW9uIChlbmRpYW4pIHtcbiAgICAgIHZhciBzdWZmaXggPSBzaWduICsgc2l6ZSArIGVuZGlhbjtcbiAgICAgIHZhciByZWFkID0gQnVmZmVyLnByb3RvdHlwZVsncmVhZCcgKyBzdWZmaXhdO1xuICAgICAgbW9kdWxlLmV4cG9ydHNbJ3JlYWQnICsgc3VmZml4XSA9XG4gICAgICAgIGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICAgIHJldHVybiByZWFkLmNhbGwoYnVmLCBvZmZzZXQpO1xuICAgICAgICB9O1xuICAgICAgdmFyIHdyaXRlID0gQnVmZmVyLnByb3RvdHlwZVsnd3JpdGUnICsgc3VmZml4XTtcbiAgICAgIG1vZHVsZS5leHBvcnRzWyd3cml0ZScgKyBzdWZmaXhdID1cbiAgICAgICAgZnVuY3Rpb24gKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gd3JpdGUuY2FsbChidWYsIHZhbCwgb2Zmc2V0KTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gQ2hlY2sgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIgd2l0aGluIHRoZSBnaXZlbiByYW5nZVxuZnVuY3Rpb24gY2hlY2tfdmFsdWUodmFsLCBtaW4sIG1heCkge1xuICAgIHZhbCA9ICt2YWw7XG4gICAgaWYgKHR5cGVvZih2YWwpICE9ICdudW1iZXInIHx8IHZhbCA8IG1pbiB8fCB2YWwgPiBtYXggfHwgTWF0aC5mbG9vcih2YWwpICE9PSB2YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gQ2hlY2sgdGhhdCBzb21ldGhpbmcgaXMgd2l0aGluIHRoZSBCdWZmZXIgYm91bmRzXG5mdW5jdGlvbiBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIGxlbikge1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIGxlbiA+IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkVUludDI0QkUoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1Zi5yZWFkVUludDgob2Zmc2V0KSA8PCAxNiB8IGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDI0QkUgPSByZWFkVUludDI0QkU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDI0QkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgMyk7XG4gICAgYnVmLndyaXRlVUludDgodmFsID4+PiAxNiwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVVSW50MTZCRSh2YWwgJiAweGZmZmYsIG9mZnNldCArIDEpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50MjRCRSA9IHdyaXRlVUludDI0QkU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50NDBCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoYnVmLnJlYWRVSW50OChvZmZzZXQpIHx8IDApICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDQwQkUgPSByZWFkVUludDQwQkU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDQwQkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDUpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDEpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NDBCRSA9IHdyaXRlVUludDQwQkU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50NDhCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKG9mZnNldCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyAyKTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50NDhCRSA9IHJlYWRVSW50NDhCRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50NDhCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA2KTtcbiAgICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAyKTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDQ4QkUgPSB3cml0ZVVJbnQ0OEJFO1xuXG5mdW5jdGlvbiByZWFkVUludDU2QkUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKChidWYucmVhZFVJbnQ4KG9mZnNldCkgfHwgMCkgPDwgMTYgfCBidWYucmVhZFVJbnQxNkJFKG9mZnNldCArIDEpKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDMpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ1NkJFID0gcmVhZFVJbnQ1NkJFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ1NkJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNyk7XG5cbiAgICBpZiAodmFsIDwgMHgxMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMik7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KGhpID4+PiAxNiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDE2QkUoaGkgJiAweGZmZmYsIG9mZnNldCArIDEpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjU2LTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNTZcbiAgICAgICAgYnVmW29mZnNldF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDU2QkUgPSB3cml0ZVVJbnQ1NkJFO1xuXG5mdW5jdGlvbiByZWFkVUludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDY0QkUgPSByZWFkVUludDY0QkU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDY0QkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDgpO1xuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBiZWNhdXNlIDJeNjQtMSBnZXRzIHJvdW5kZWQgdXAgdG8gMl42NFxuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzJdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCszXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzVdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs2XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrN10gPSAweGZmO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDY0QkUgPSB3cml0ZVVJbnQ2NEJFO1xuXG5mdW5jdGlvbiByZWFkVUludDI0TEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50OChvZmZzZXQgKyAyKSA8PCAxNiB8IGJ1Zi5yZWFkVUludDE2TEUob2Zmc2V0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50MjRMRSA9IHJlYWRVSW50MjRMRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MjRMRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCAzKTtcblxuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKHZhbCAmIDB4ZmZmZiwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVVSW50OCh2YWwgPj4+IDE2LCBvZmZzZXQgKyAyKTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDI0TEUgPSB3cml0ZVVJbnQyNExFO1xuXG5mdW5jdGlvbiByZWFkVUludDQwTEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGJ1Zi5yZWFkVUludDgob2Zmc2V0ICsgNCkgfHwgMCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ0MExFID0gcmVhZFVJbnQ0MExFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ0MExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIDAsIDB4ZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA1KTtcbiAgICBidWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDQwTEUgPSB3cml0ZVVJbnQ0MExFO1xuXG5mdW5jdGlvbiByZWFkVUludDQ4TEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZMRShvZmZzZXQgKyA0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDQ4TEUgPSByZWFkVUludDQ4TEU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDQ4TEUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNik7XG4gICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVVSW50MTZMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0ICsgNCk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ0OExFID0gd3JpdGVVSW50NDhMRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ1NkxFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuICgoYnVmLnJlYWRVSW50OChvZmZzZXQgKyA2KSB8fCAwKSA8PCAxNiB8IGJ1Zi5yZWFkVUludDE2TEUob2Zmc2V0ICsgNCkpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50NTZMRSA9IHJlYWRVSW50NTZMRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50NTZMRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDcpO1xuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCk7XG4gICAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZMRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KGhpID4+PiAxNiwgb2Zmc2V0ICsgNik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41Ni0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU2XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ1NkxFID0gd3JpdGVVSW50NTZMRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ2NExFID0gcmVhZFVJbnQ2NExFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA4KTtcblxuICAgIGlmICh2YWwgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjY0LTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNjRcbiAgICAgICAgYnVmW29mZnNldF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzddID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ2NExFID0gd3JpdGVVSW50NjRMRTtcblxuXG5mdW5jdGlvbiByZWFkSW50MjRCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoYnVmLnJlYWRJbnQ4KG9mZnNldCkgPDwgMTYpICsgYnVmLnJlYWRVSW50MTZCRShvZmZzZXQgKyAxKTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQyNEJFID0gcmVhZEludDI0QkU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50MjRCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAtMHg4MDAwMDAsIDB4N2ZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDMpO1xuICAgIGJ1Zi53cml0ZUludDgodmFsID4+IDE2LCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkJFKHZhbCAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDI0QkUgPSB3cml0ZUludDI0QkU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ0MEJFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZEludDgob2Zmc2V0KSB8fCAwKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDEpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDQwQkUgPSByZWFkSW50NDBCRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ0MEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA1KTtcbiAgICBidWYud3JpdGVJbnQ4KE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDEpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ0MEJFID0gd3JpdGVJbnQ0MEJFO1xuXG5mdW5jdGlvbiByZWFkSW50NDhCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZEludDE2QkUob2Zmc2V0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDIpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDQ4QkUgPSByZWFkSW50NDhCRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ0OEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNik7XG4gICAgYnVmLndyaXRlSW50MTZCRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAyKTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50NDhCRSA9IHdyaXRlSW50NDhCRTtcblxuZnVuY3Rpb24gcmVhZEludDU2QkUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKCgoYnVmLnJlYWRJbnQ4KG9mZnNldCkgfHwgMCkgPDwgMTYpICsgYnVmLnJlYWRVSW50MTZCRShvZmZzZXQgKyAxKSkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyAzKTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQ1NkJFID0gcmVhZEludDU2QkU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50NTZCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAtMHg4MDAwMDAwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNyk7XG5cbiAgICBpZiAodmFsIDwgMHg4MDAwMDAwMDAwMDAwMCkge1xuICAgICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKTtcbiAgICAgICAgYnVmLndyaXRlSW50OChoaSA+PiAxNiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDE2QkUoaGkgJiAweGZmZmYsIG9mZnNldCArIDEpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjU1LTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNTVcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDdmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50NTZCRSA9IHdyaXRlSW50NTZCRTtcblxuZnVuY3Rpb24gcmVhZEludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYnVmLnJlYWRJbnQzMkJFKG9mZnNldCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQ2NEJFID0gcmVhZEludDY0QkU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50NjRCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAtMHg4MDAwMDAwMDAwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA4KTtcblxuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRSh2YWwgJiAtMSwgb2Zmc2V0ICsgNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl42My0xIGdldHMgcm91bmRlZCB1cCB0byAyXjYzXG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHg3ZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs3XSA9IDB4ZmY7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ2NEJFID0gd3JpdGVJbnQ2NEJFO1xuXG5mdW5jdGlvbiByZWFkSW50MjRMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoYnVmLnJlYWRJbnQ4KG9mZnNldCArIDIpIDw8IDE2KSArIGJ1Zi5yZWFkVUludDE2TEUob2Zmc2V0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQyNExFID0gcmVhZEludDI0TEU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50MjRMRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAtMHg4MDAwMDAsIDB4N2ZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDMpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKHZhbCAmIDB4ZmZmZiwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVJbnQ4KHZhbCA+PiAxNiwgb2Zmc2V0ICsgMik7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDI0TEUgPSB3cml0ZUludDI0TEU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ0MExFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZEludDgob2Zmc2V0ICsgNCkgfHwgMCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDQwTEUgPSByZWFkSW50NDBMRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ0MExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA1KTtcbiAgICBidWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCArIDQpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ0MExFID0gd3JpdGVJbnQ0MExFO1xuXG5mdW5jdGlvbiByZWFkSW50NDhMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZEludDE2TEUob2Zmc2V0ICsgNCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDQ4TEUgPSByZWFkSW50NDhMRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ0OExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNik7XG4gICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0KTtcbiAgICBidWYud3JpdGVJbnQxNkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50NDhMRSA9IHdyaXRlSW50NDhMRTtcblxuZnVuY3Rpb24gcmVhZEludDU2TEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKCgoYnVmLnJlYWRJbnQ4KG9mZnNldCArIDYpIHx8IDApIDw8IDE2KSArIGJ1Zi5yZWFkVUludDE2TEUob2Zmc2V0ICsgNCkpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQ1NkxFID0gcmVhZEludDU2TEU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50NTZMRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAtMHg4MDAwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA3KTtcblxuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCk7XG4gICAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZMRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDgoaGkgPj4gMTYsIG9mZnNldCArIDYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBiZWNhdXNlIDJeNTUtMSBnZXRzIHJvdW5kZWQgdXAgdG8gMl41NVxuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzJdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCszXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzVdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs2XSA9IDB4N2Y7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ1NkxFID0gd3JpdGVJbnQ1NkxFO1xuXG5mdW5jdGlvbiByZWFkSW50NjRMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZEludDMyTEUob2Zmc2V0ICsgNCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDY0TEUgPSByZWFkSW50NjRMRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ2NExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA4KTtcblxuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0ICsgNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41NS0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU1XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs3XSA9IDB4N2Y7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ2NExFID0gd3JpdGVJbnQ2NExFO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCJjbGFzcyBEZXByZWNhdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpOyAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9ICdEZXByZWNhdGlvbic7XG4gIH1cblxufVxuXG5leHBvcnQgeyBEZXByZWNhdGlvbiB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuXHQvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcblx0Ly8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG5cdC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG5cdHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWxPYmplY3QgPSBnZXRHbG9iYWwoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZ2xvYmFsT2JqZWN0LmZldGNoO1xuXG4vLyBOZWVkZWQgZm9yIFR5cGVTY3JpcHQgYW5kIFdlYnBhY2suXG5pZiAoZ2xvYmFsT2JqZWN0LmZldGNoKSB7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbE9iamVjdC5mZXRjaC5iaW5kKGdsb2JhbE9iamVjdCk7XG59XG5cbmV4cG9ydHMuSGVhZGVycyA9IGdsb2JhbE9iamVjdC5IZWFkZXJzO1xuZXhwb3J0cy5SZXF1ZXN0ID0gZ2xvYmFsT2JqZWN0LlJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gZ2xvYmFsT2JqZWN0LlJlc3BvbnNlO1xuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ3V0aWwnKTtcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc1N0cmluZyhjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IHV0aWwuaXNOdWxsKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAoIXV0aWwuaXNOdW1iZXIobikgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAodXRpbC5pc051bGwocmV0KSkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHJldCkpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiZcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxuICAgICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbilcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gICAgICAgICAgc2VsZi5yZWFkKDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB9XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdW1lXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHN0cmVhbVtpXSkgJiYgdXRpbC5pc1VuZGVmaW5lZCh0aGlzW2ldKSkge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNiKSlcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdXRpbC5pc1N0cmluZyhjaHVuaykpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpXG4gICAgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO1xuICBlbHNlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcik7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGNicyA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKVxuICAgICAgY2JzLnB1c2goc3RhdGUuYnVmZmVyW2NdLmNhbGxiYWNrKTtcblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5idWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICAgIHN0YXRlLmJ1ZmZlciA9IFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYysrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gICAgZWxzZVxuICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuXG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihjaHVuaykpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZVxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhbXFwbGliXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFtcXBsaWJcIikpO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYWN0aW9ucy9jb3JlXCIpKTtcbmNvbnN0IGdpdGh1Yl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYWN0aW9ucy9naXRodWJcIikpO1xuZnVuY3Rpb24gbWFpbigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBicmFuY2ggPSBjb3JlXzEuZGVmYXVsdC5nZXRJbnB1dChcImJyYW5jaFwiKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIGFtcXBsaWJfMS5kZWZhdWx0LmNvbm5lY3QoXCJhbXFwOi8vbG9jYWxob3N0XCIpOyAvLyBBbHRlcmFyIHBhcmEgSVAgZG8gc2Vydmlkb3IgKGxhcHRvcClcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHlpZWxkIGNvbm5lY3Rpb24uY3JlYXRlQ2hhbm5lbCgpO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFwibm90aWZ5LWRpc2NvcmRcIjtcbiAgICAgICAgeWllbGQgY2hhbm5lbC5hc3NlcnRRdWV1ZShxdWV1ZSwgeyBkdXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICBjaGFubmVsLnNlbmRUb1F1ZXVlKHF1ZXVlLCBCdWZmZXIuZnJvbShicmFuY2gpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFt4XSBTZW50ICR7YnJhbmNofSB0byAke3F1ZXVlfWApO1xuICAgICAgICB5aWVsZCBjaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHlpZWxkIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KGdpdGh1Yl8xLmRlZmF1bHQuY29udGV4dC5wYXlsb2FkLCB1bmRlZmluZWQsIDIpO1xuICAgICAgICBjb25zb2xlLmxvZyhgVGhlIGV2ZW50IHBheWxvYWQ6ICR7cGF5bG9hZH1gKTtcbiAgICB9KTtcbn1cbm1haW4oKS5jYXRjaChlcnJvciA9PiB7XG4gICAgY29yZV8xLmRlZmF1bHQuc2V0RmFpbGVkKGVycm9yLm1lc3NhZ2UpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3R1bm5lbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdGxzID0gcmVxdWlyZSgndGxzJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuXG5leHBvcnRzLmh0dHBPdmVySHR0cCA9IGh0dHBPdmVySHR0cDtcbmV4cG9ydHMuaHR0cHNPdmVySHR0cCA9IGh0dHBzT3Zlckh0dHA7XG5leHBvcnRzLmh0dHBPdmVySHR0cHMgPSBodHRwT3Zlckh0dHBzO1xuZXhwb3J0cy5odHRwc092ZXJIdHRwcyA9IGh0dHBzT3Zlckh0dHBzO1xuXG5cbmZ1bmN0aW9uIGh0dHBPdmVySHR0cChvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKTtcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHAucmVxdWVzdDtcbiAgcmV0dXJuIGFnZW50O1xufVxuXG5mdW5jdGlvbiBodHRwc092ZXJIdHRwKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpO1xuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0O1xuICBhZ2VudC5jcmVhdGVTb2NrZXQgPSBjcmVhdGVTZWN1cmVTb2NrZXQ7XG4gIGFnZW50LmRlZmF1bHRQb3J0ID0gNDQzO1xuICByZXR1cm4gYWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGh0dHBPdmVySHR0cHMob3B0aW9ucykge1xuICB2YXIgYWdlbnQgPSBuZXcgVHVubmVsaW5nQWdlbnQob3B0aW9ucyk7XG4gIGFnZW50LnJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0O1xuICByZXR1cm4gYWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGh0dHBzT3Zlckh0dHBzKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpO1xuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdDtcbiAgYWdlbnQuY3JlYXRlU29ja2V0ID0gY3JlYXRlU2VjdXJlU29ja2V0O1xuICBhZ2VudC5kZWZhdWx0UG9ydCA9IDQ0MztcbiAgcmV0dXJuIGFnZW50O1xufVxuXG5cbmZ1bmN0aW9uIFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBzZWxmLnByb3h5T3B0aW9ucyA9IHNlbGYub3B0aW9ucy5wcm94eSB8fCB7fTtcbiAgc2VsZi5tYXhTb2NrZXRzID0gc2VsZi5vcHRpb25zLm1heFNvY2tldHMgfHwgaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cztcbiAgc2VsZi5yZXF1ZXN0cyA9IFtdO1xuICBzZWxmLnNvY2tldHMgPSBbXTtcblxuICBzZWxmLm9uKCdmcmVlJywgZnVuY3Rpb24gb25GcmVlKHNvY2tldCwgaG9zdCwgcG9ydCwgbG9jYWxBZGRyZXNzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0b09wdGlvbnMoaG9zdCwgcG9ydCwgbG9jYWxBZGRyZXNzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5yZXF1ZXN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIHBlbmRpbmcgPSBzZWxmLnJlcXVlc3RzW2ldO1xuICAgICAgaWYgKHBlbmRpbmcuaG9zdCA9PT0gb3B0aW9ucy5ob3N0ICYmIHBlbmRpbmcucG9ydCA9PT0gb3B0aW9ucy5wb3J0KSB7XG4gICAgICAgIC8vIERldGVjdCB0aGUgcmVxdWVzdCB0byBjb25uZWN0IHNhbWUgb3JpZ2luIHNlcnZlcixcbiAgICAgICAgLy8gcmV1c2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIHNlbGYucmVxdWVzdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICBwZW5kaW5nLnJlcXVlc3Qub25Tb2NrZXQoc29ja2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIHNlbGYucmVtb3ZlU29ja2V0KHNvY2tldCk7XG4gIH0pO1xufVxudXRpbC5pbmhlcml0cyhUdW5uZWxpbmdBZ2VudCwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0ID0gZnVuY3Rpb24gYWRkUmVxdWVzdChyZXEsIGhvc3QsIHBvcnQsIGxvY2FsQWRkcmVzcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBvcHRpb25zID0gbWVyZ2VPcHRpb25zKHtyZXF1ZXN0OiByZXF9LCBzZWxmLm9wdGlvbnMsIHRvT3B0aW9ucyhob3N0LCBwb3J0LCBsb2NhbEFkZHJlc3MpKTtcblxuICBpZiAoc2VsZi5zb2NrZXRzLmxlbmd0aCA+PSB0aGlzLm1heFNvY2tldHMpIHtcbiAgICAvLyBXZSBhcmUgb3ZlciBsaW1pdCBzbyB3ZSdsbCBhZGQgaXQgdG8gdGhlIHF1ZXVlLlxuICAgIHNlbGYucmVxdWVzdHMucHVzaChvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiB3ZSBhcmUgdW5kZXIgbWF4U29ja2V0cyBjcmVhdGUgYSBuZXcgb25lLlxuICBzZWxmLmNyZWF0ZVNvY2tldChvcHRpb25zLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICBzb2NrZXQub24oJ2ZyZWUnLCBvbkZyZWUpO1xuICAgIHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlT3JSZW1vdmUpO1xuICAgIHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpO1xuICAgIHJlcS5vblNvY2tldChzb2NrZXQpO1xuXG4gICAgZnVuY3Rpb24gb25GcmVlKCkge1xuICAgICAgc2VsZi5lbWl0KCdmcmVlJywgc29ja2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsb3NlT3JSZW1vdmUoZXJyKSB7XG4gICAgICBzZWxmLnJlbW92ZVNvY2tldChzb2NrZXQpO1xuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlT3JSZW1vdmUpO1xuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdhZ2VudFJlbW92ZScsIG9uQ2xvc2VPclJlbW92ZSk7XG4gICAgfVxuICB9KTtcbn07XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5jcmVhdGVTb2NrZXQgPSBmdW5jdGlvbiBjcmVhdGVTb2NrZXQob3B0aW9ucywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcGxhY2Vob2xkZXIgPSB7fTtcbiAgc2VsZi5zb2NrZXRzLnB1c2gocGxhY2Vob2xkZXIpO1xuXG4gIHZhciBjb25uZWN0T3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh7fSwgc2VsZi5wcm94eU9wdGlvbnMsIHtcbiAgICBtZXRob2Q6ICdDT05ORUNUJyxcbiAgICBwYXRoOiBvcHRpb25zLmhvc3QgKyAnOicgKyBvcHRpb25zLnBvcnQsXG4gICAgYWdlbnQ6IGZhbHNlLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCArICc6JyArIG9wdGlvbnMucG9ydFxuICAgIH1cbiAgfSk7XG4gIGlmIChvcHRpb25zLmxvY2FsQWRkcmVzcykge1xuICAgIGNvbm5lY3RPcHRpb25zLmxvY2FsQWRkcmVzcyA9IG9wdGlvbnMubG9jYWxBZGRyZXNzO1xuICB9XG4gIGlmIChjb25uZWN0T3B0aW9ucy5wcm94eUF1dGgpIHtcbiAgICBjb25uZWN0T3B0aW9ucy5oZWFkZXJzID0gY29ubmVjdE9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICBjb25uZWN0T3B0aW9ucy5oZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArXG4gICAgICAgIG5ldyBCdWZmZXIoY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH1cblxuICBkZWJ1ZygnbWFraW5nIENPTk5FQ1QgcmVxdWVzdCcpO1xuICB2YXIgY29ubmVjdFJlcSA9IHNlbGYucmVxdWVzdChjb25uZWN0T3B0aW9ucyk7XG4gIGNvbm5lY3RSZXEudXNlQ2h1bmtlZEVuY29kaW5nQnlEZWZhdWx0ID0gZmFsc2U7IC8vIGZvciB2MC42XG4gIGNvbm5lY3RSZXEub25jZSgncmVzcG9uc2UnLCBvblJlc3BvbnNlKTsgLy8gZm9yIHYwLjZcbiAgY29ubmVjdFJlcS5vbmNlKCd1cGdyYWRlJywgb25VcGdyYWRlKTsgICAvLyBmb3IgdjAuNlxuICBjb25uZWN0UmVxLm9uY2UoJ2Nvbm5lY3QnLCBvbkNvbm5lY3QpOyAgIC8vIGZvciB2MC43IG9yIGxhdGVyXG4gIGNvbm5lY3RSZXEub25jZSgnZXJyb3InLCBvbkVycm9yKTtcbiAgY29ubmVjdFJlcS5lbmQoKTtcblxuICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcykge1xuICAgIC8vIFZlcnkgaGFja3kuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGh0dHAtcGFyc2VyIGxlYWtzLlxuICAgIHJlcy51cGdyYWRlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVXBncmFkZShyZXMsIHNvY2tldCwgaGVhZCkge1xuICAgIC8vIEhhY2t5LlxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBvbkNvbm5lY3QocmVzLCBzb2NrZXQsIGhlYWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBzdGF0dXNDb2RlPSVkJyxcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigndHVubmVsaW5nIHNvY2tldCBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsICcgK1xuICAgICAgICAnc3RhdHVzQ29kZT0nICsgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJztcbiAgICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIHNlbGYucmVtb3ZlU29ja2V0KHBsYWNlaG9sZGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkge1xuICAgICAgZGVidWcoJ2dvdCBpbGxlZ2FsIHJlc3BvbnNlIGJvZHkgZnJvbSBwcm94eScpO1xuICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignZ290IGlsbGVnYWwgcmVzcG9uc2UgYm9keSBmcm9tIHByb3h5Jyk7XG4gICAgICBlcnJvci5jb2RlID0gJ0VDT05OUkVTRVQnO1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgc2VsZi5yZW1vdmVTb2NrZXQocGxhY2Vob2xkZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWJ1ZygndHVubmVsaW5nIGNvbm5lY3Rpb24gaGFzIGVzdGFibGlzaGVkJyk7XG4gICAgc2VsZi5zb2NrZXRzW3NlbGYuc29ja2V0cy5pbmRleE9mKHBsYWNlaG9sZGVyKV0gPSBzb2NrZXQ7XG4gICAgcmV0dXJuIGNiKHNvY2tldCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGNhdXNlKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIGRlYnVnKCd0dW5uZWxpbmcgc29ja2V0IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCwgY2F1c2U9JXNcXG4nLFxuICAgICAgICAgIGNhdXNlLm1lc3NhZ2UsIGNhdXNlLnN0YWNrKTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NhdXNlPScgKyBjYXVzZS5tZXNzYWdlKTtcbiAgICBlcnJvci5jb2RlID0gJ0VDT05OUkVTRVQnO1xuICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICBzZWxmLnJlbW92ZVNvY2tldChwbGFjZWhvbGRlcik7XG4gIH1cbn07XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5yZW1vdmVTb2NrZXQgPSBmdW5jdGlvbiByZW1vdmVTb2NrZXQoc29ja2V0KSB7XG4gIHZhciBwb3MgPSB0aGlzLnNvY2tldHMuaW5kZXhPZihzb2NrZXQpXG4gIGlmIChwb3MgPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuc29ja2V0cy5zcGxpY2UocG9zLCAxKTtcblxuICB2YXIgcGVuZGluZyA9IHRoaXMucmVxdWVzdHMuc2hpZnQoKTtcbiAgaWYgKHBlbmRpbmcpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgcmVxdWVzdHMgYW5kIGEgc29ja2V0IGdldHMgY2xvc2VkIGEgbmV3IG9uZVxuICAgIC8vIG5lZWRzIHRvIGJlIGNyZWF0ZWQgdG8gdGFrZSBvdmVyIGluIHRoZSBwb29sIGZvciB0aGUgb25lIHRoYXQgY2xvc2VkLlxuICAgIHRoaXMuY3JlYXRlU29ja2V0KHBlbmRpbmcsIGZ1bmN0aW9uKHNvY2tldCkge1xuICAgICAgcGVuZGluZy5yZXF1ZXN0Lm9uU29ja2V0KHNvY2tldCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlY3VyZVNvY2tldChvcHRpb25zLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5jcmVhdGVTb2NrZXQuY2FsbChzZWxmLCBvcHRpb25zLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICB2YXIgaG9zdEhlYWRlciA9IG9wdGlvbnMucmVxdWVzdC5nZXRIZWFkZXIoJ2hvc3QnKTtcbiAgICB2YXIgdGxzT3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh7fSwgc2VsZi5vcHRpb25zLCB7XG4gICAgICBzb2NrZXQ6IHNvY2tldCxcbiAgICAgIHNlcnZlcm5hbWU6IGhvc3RIZWFkZXIgPyBob3N0SGVhZGVyLnJlcGxhY2UoLzouKiQvLCAnJykgOiBvcHRpb25zLmhvc3RcbiAgICB9KTtcblxuICAgIC8vIDAgaXMgZHVtbXkgcG9ydCBmb3IgdjAuNlxuICAgIHZhciBzZWN1cmVTb2NrZXQgPSB0bHMuY29ubmVjdCgwLCB0bHNPcHRpb25zKTtcbiAgICBzZWxmLnNvY2tldHNbc2VsZi5zb2NrZXRzLmluZGV4T2Yoc29ja2V0KV0gPSBzZWN1cmVTb2NrZXQ7XG4gICAgY2Ioc2VjdXJlU29ja2V0KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gdG9PcHRpb25zKGhvc3QsIHBvcnQsIGxvY2FsQWRkcmVzcykge1xuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7IC8vIHNpbmNlIHYwLjEwXG4gICAgcmV0dXJuIHtcbiAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICBwb3J0OiBwb3J0LFxuICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3NcbiAgICB9O1xuICB9XG4gIHJldHVybiBob3N0OyAvLyBmb3IgdjAuMTEgb3IgbGF0ZXJcbn1cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIG92ZXJyaWRlcyA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAodHlwZW9mIG92ZXJyaWRlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBrZXlMZW4gPSBrZXlzLmxlbmd0aDsgaiA8IGtleUxlbjsgKytqKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tqXTtcbiAgICAgICAgaWYgKG92ZXJyaWRlc1trXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0W2tdID0gb3ZlcnJpZGVzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxudmFyIGRlYnVnO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL1xcYnR1bm5lbFxcYi8udGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSkge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBhcmdzWzBdID0gJ1RVTk5FTDogJyArIGFyZ3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudW5zaGlmdCgnVFVOTkVMOicpO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG59XG5leHBvcnRzLmRlYnVnID0gZGVidWc7IC8vIGZvciB0ZXN0XG4iLCJmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBcInZlcnNpb25cIiBpbiBwcm9jZXNzKSB7XG4gICAgICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke3Byb2Nlc3MuYXJjaH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cblxuZXhwb3J0IHsgZ2V0VXNlckFnZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgY29udHJvbE9yV2hpdGVzcGFjZSA9IC9eW1xceDAwLVxceDIwXFx1MDBhMFxcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdKy9cbiAgLCBDUkhUTEYgPSAvW1xcblxcclxcdF0vZ1xuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy9cbiAgLCBwb3J0ID0gLzpcXGQrJC9cbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcXFwvXSspPyhbXFxTXFxzXSopL2lcbiAgLCB3aW5kb3dzRHJpdmVMZXR0ZXIgPSAvXlthLXpBLVpdOi87XG5cbi8qKlxuICogUmVtb3ZlIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIG5ldyBzdHJpbmcgcmVwcmVzZW50aW5nIGBzdHJgIHN0cmlwcGVkIG9mIGNvbnRyb2xcbiAqICAgICBjaGFyYWN0ZXJzIGFuZCB3aGl0ZXNwYWNlIGZyb20gaXRzIGJlZ2lubmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiAoc3RyID8gc3RyIDogJycpLnRvU3RyaW5nKCkucmVwbGFjZShjb250cm9sT3JXaGl0ZXNwYWNlLCAnJyk7XG59XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MsIHVybCkgeyAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpID8gYWRkcmVzcy5yZXBsYWNlKC9cXFxcL2csICcvJykgOiBhZGRyZXNzO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQqKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGdsb2JhbFZhcjtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHdpbmRvdztcbiAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IGdsb2JhbDtcbiAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBzZWxmO1xuICBlbHNlIGdsb2JhbFZhciA9IHt9O1xuXG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbFZhci5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gVGhlIHByb3RvY29sIHNjaGVtZSBvZiB0aGUgVVJMXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb3RvY29sIHNjaGVtZSBpcyBzcGVjaWFsLCBlbHNlIGBmYWxzZWBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3BlY2lhbChzY2hlbWUpIHtcbiAgcmV0dXJuIChcbiAgICBzY2hlbWUgPT09ICdmaWxlOicgfHxcbiAgICBzY2hlbWUgPT09ICdmdHA6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2h0dHA6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2h0dHBzOicgfHxcbiAgICBzY2hlbWUgPT09ICd3czonIHx8XG4gICAgc2NoZW1lID09PSAnd3NzOidcbiAgKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhdGlvblxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcywgbG9jYXRpb24pIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKENSSFRMRiwgJycpO1xuICBsb2NhdGlvbiA9IGxvY2F0aW9uIHx8IHt9O1xuXG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcbiAgdmFyIHByb3RvY29sID0gbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gIHZhciBmb3J3YXJkU2xhc2hlcyA9ICEhbWF0Y2hbMl07XG4gIHZhciBvdGhlclNsYXNoZXMgPSAhIW1hdGNoWzNdO1xuICB2YXIgc2xhc2hlc0NvdW50ID0gMDtcbiAgdmFyIHJlc3Q7XG5cbiAgaWYgKGZvcndhcmRTbGFzaGVzKSB7XG4gICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgcmVzdCA9IG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzJdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFszXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbM10ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0ID0gbWF0Y2hbNF1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICBpZiAoc2xhc2hlc0NvdW50ID49IDIpIHtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NwZWNpYWwocHJvdG9jb2wpKSB7XG4gICAgcmVzdCA9IG1hdGNoWzRdO1xuICB9IGVsc2UgaWYgKHByb3RvY29sKSB7XG4gICAgaWYgKGZvcndhcmRTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2xhc2hlc0NvdW50ID49IDIgJiYgaXNTcGVjaWFsKGxvY2F0aW9uLnByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIHNsYXNoZXM6IGZvcndhcmRTbGFzaGVzIHx8IGlzU3BlY2lhbChwcm90b2NvbCksXG4gICAgc2xhc2hlc0NvdW50OiBzbGFzaGVzQ291bnQsXG4gICAgcmVzdDogcmVzdFxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgaWYgKHJlbGF0aXZlID09PSAnJykgcmV0dXJuIGJhc2U7XG5cbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtsb2NhdGlvbl0gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbcGFyc2VyXSBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG4gIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoQ1JIVExGLCAnJyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycsIGxvY2F0aW9uKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmIChcbiAgICBleHRyYWN0ZWQucHJvdG9jb2wgPT09ICdmaWxlOicgJiYgKFxuICAgICAgZXh0cmFjdGVkLnNsYXNoZXNDb3VudCAhPT0gMiB8fCB3aW5kb3dzRHJpdmVMZXR0ZXIudGVzdChhZGRyZXNzKSkgfHxcbiAgICAoIWV4dHJhY3RlZC5zbGFzaGVzICYmXG4gICAgICAoZXh0cmFjdGVkLnByb3RvY29sIHx8XG4gICAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgPCAyIHx8XG4gICAgICAgICFpc1NwZWNpYWwodXJsLnByb3RvY29sKSkpXG4gICkge1xuICAgIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuICB9XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzLCB1cmwpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGluZGV4ID0gcGFyc2UgPT09ICdAJ1xuICAgICAgICA/IGFkZHJlc3MubGFzdEluZGV4T2YocGFyc2UpXG4gICAgICAgIDogYWRkcmVzcy5pbmRleE9mKHBhcnNlKTtcblxuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGEgLyBmb3IgcGF0aG5hbWUgaWYgbm9uZSBleGlzdHMuIFRoaXMgbm9ybWFsaXplcyB0aGUgVVJMXG4gIC8vIHRvIGFsd2F5cyBoYXZlIGEgL1xuICAvL1xuICBpZiAodXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gJy8nICsgdXJsLnBhdGhuYW1lO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG5cbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5kZXggPSB1cmwuYXV0aC5pbmRleE9mKCc6Jyk7XG5cbiAgICBpZiAofmluZGV4KSB7XG4gICAgICB1cmwudXNlcm5hbWUgPSB1cmwuYXV0aC5zbGljZSgwLCBpbmRleCk7XG4gICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC51c2VybmFtZSkpO1xuXG4gICAgICB1cmwucGFzc3dvcmQgPSB1cmwuYXV0aC5zbGljZShpbmRleCArIDEpO1xuICAgICAgdXJsLnBhc3N3b3JkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5hdXRoKSk7XG4gICAgfVxuXG4gICAgdXJsLmF1dGggPSB1cmwucGFzc3dvcmQgPyB1cmwudXNlcm5hbWUgKyc6JysgdXJsLnBhc3N3b3JkIDogdXJsLnVzZXJuYW1lO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAocG9ydC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXNlcm5hbWUnOlxuICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgIHVybFtwYXJ0XSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dGgnOlxuICAgICAgdmFyIGluZGV4ID0gdmFsdWUuaW5kZXhPZignOicpO1xuXG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIHVybC51c2VybmFtZSA9IHZhbHVlLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcblxuICAgICAgICB1cmwucGFzc3dvcmQgPSB2YWx1ZS5zbGljZShpbmRleCArIDEpO1xuICAgICAgICB1cmwucGFzc3dvcmQgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5wYXNzd29yZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsnOicrIHVybC5wYXNzd29yZCA6IHVybC51c2VybmFtZTtcblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmIHVybC5ob3N0XG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaG9zdCA9IHVybC5ob3N0XG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID1cbiAgICBwcm90b2NvbCArXG4gICAgKCh1cmwucHJvdG9jb2wgJiYgdXJsLnNsYXNoZXMpIHx8IGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfSBlbHNlIGlmICh1cmwucGFzc3dvcmQpIHtcbiAgICByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfSBlbHNlIGlmIChcbiAgICB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJlxuICAgICFob3N0ICYmXG4gICAgdXJsLnBhdGhuYW1lICE9PSAnLydcbiAgKSB7XG4gICAgLy9cbiAgICAvLyBBZGQgYmFjayB0aGUgZW1wdHkgdXNlcmluZm8sIG90aGVyd2lzZSB0aGUgb3JpZ2luYWwgaW52YWxpZCBVUkxcbiAgICAvLyBtaWdodCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgdmFsaWQgb25lIHdpdGggYHVybC5wYXRobmFtZWAgYXMgaG9zdC5cbiAgICAvL1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICAvL1xuICAvLyBUcmFpbGluZyBjb2xvbiBpcyByZW1vdmVkIGZyb20gYHVybC5ob3N0YCB3aGVuIGl0IGlzIHBhcnNlZC4gSWYgaXQgc3RpbGxcbiAgLy8gZW5kcyB3aXRoIGEgY29sb24sIHRoZW4gYWRkIGJhY2sgdGhlIHRyYWlsaW5nIGNvbG9uIHRoYXQgd2FzIHJlbW92ZWQuIFRoaXNcbiAgLy8gcHJldmVudHMgYW4gaW52YWxpZCBVUkwgZnJvbSBiZWluZyB0cmFuc2Zvcm1lZCBpbnRvIGEgdmFsaWQgb25lLlxuICAvL1xuICBpZiAoaG9zdFtob3N0Lmxlbmd0aCAtIDFdID09PSAnOicgfHwgKHBvcnQudGVzdCh1cmwuaG9zdG5hbWUpICYmICF1cmwucG9ydCkpIHtcbiAgICBob3N0ICs9ICc6JztcbiAgfVxuXG4gIHJlc3VsdCArPSBob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyIsIi8qXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcbiAqXG4gKiBNb2RpZmljYXRpb24gb2YgSmF2YVNjcmlwdCBNRDVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIHZhciB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICB2YXIgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgcmV0dXJuIChpbnB1dExlbmd0aDggKyA2NCA+Pj4gOSA8PCA0KSArIDE0ICsgMTtcbn1cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5cblxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMjtcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xuICB2YXIgYSA9IDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgdmFyIG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuZ3RoOCkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiLCJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICB2YXIgdjtcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsIi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICB2YXIgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgKytfaSkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtfaV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47ICsrX2kyKSB7XG4gICAgdmFyIFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtfaTJdW3RdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF90ID0gMTY7IF90IDwgODA7ICsrX3QpIHtcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKF90MiAvIDIwKTtcbiAgICAgIHZhciBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbX3QyXSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG5cbnZhciBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbnZhciB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7IiwiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwiLyogKGlnbm9yZWQpICovIiwiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKGN0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgaXNQbGFpbk9iamVjdCB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=