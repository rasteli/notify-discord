/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@actions/core/lib/command.js":
/*!***************************************************!*\
  !*** ./node_modules/@actions/core/lib/command.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/core/lib/utils.js");
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/core.js":
/*!************************************************!*\
  !*** ./node_modules/@actions/core/lib/core.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __webpack_require__(/*! ./command */ "./node_modules/@actions/core/lib/command.js");
const file_command_1 = __webpack_require__(/*! ./file-command */ "./node_modules/@actions/core/lib/file-command.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/core/lib/utils.js");
const os = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const path = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const oidc_utils_1 = __webpack_require__(/*! ./oidc-utils */ "./node_modules/@actions/core/lib/oidc-utils.js");
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __webpack_require__(/*! ./summary */ "./node_modules/@actions/core/lib/summary.js");
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __webpack_require__(/*! ./summary */ "./node_modules/@actions/core/lib/summary.js");
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __webpack_require__(/*! ./path-utils */ "./node_modules/@actions/core/lib/path-utils.js");
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/file-command.js":
/*!********************************************************!*\
  !*** ./node_modules/@actions/core/lib/file-command.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const os = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/core/lib/utils.js");
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/oidc-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@actions/core/lib/oidc-utils.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __webpack_require__(/*! @actions/http-client */ "./node_modules/@actions/http-client/lib/index.js");
const auth_1 = __webpack_require__(/*! @actions/http-client/lib/auth */ "./node_modules/@actions/http-client/lib/auth.js");
const core_1 = __webpack_require__(/*! ./core */ "./node_modules/@actions/core/lib/core.js");
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/path-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@actions/core/lib/path-utils.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/summary.js":
/*!***************************************************!*\
  !*** ./node_modules/@actions/core/lib/summary.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
const fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ "./node_modules/@actions/core/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@actions/core/lib/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/@actions/github/lib/context.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
const fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
const os_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
class Context {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
            }
            else {
                const path = process.env.GITHUB_EVENT_PATH;
                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
    }
    get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
        if (process.env.GITHUB_REPOSITORY) {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            return { owner, repo };
        }
        if (this.payload.repository) {
            return {
                owner: this.payload.repository.owner.login,
                repo: this.payload.repository.name
            };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/github.js":
/*!****************************************************!*\
  !*** ./node_modules/@actions/github/lib/github.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokit = exports.context = void 0;
const Context = __importStar(__webpack_require__(/*! ./context */ "./node_modules/@actions/github/lib/context.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@actions/github/lib/utils.js");
exports.context = new Context.Context();
/**
 * Returns a hydrated octokit ready to use for GitHub Actions
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokit(token, options, ...additionalPlugins) {
    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
    return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));
}
exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/internal/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@actions/github/lib/internal/utils.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
const httpClient = __importStar(__webpack_require__(/*! @actions/http-client */ "./node_modules/@actions/http-client/lib/index.js"));
function getAuthString(token, options) {
    if (!token && !options.auth) {
        throw new Error('Parameter token or opts.auth is required');
    }
    else if (token && options.auth) {
        throw new Error('Parameters token and opts.auth may not both be specified');
    }
    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
}
exports.getAuthString = getAuthString;
function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
}
exports.getProxyAgent = getProxyAgent;
function getApiBaseUrl() {
    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
}
exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@actions/github/lib/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/@actions/github/lib/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
const Context = __importStar(__webpack_require__(/*! ./context */ "./node_modules/@actions/github/lib/context.js"));
const Utils = __importStar(__webpack_require__(/*! ./internal/utils */ "./node_modules/@actions/github/lib/internal/utils.js"));
// octokit + plugins
const core_1 = __webpack_require__(/*! @octokit/core */ "./node_modules/@octokit/core/dist-web/index.js");
const plugin_rest_endpoint_methods_1 = __webpack_require__(/*! @octokit/plugin-rest-endpoint-methods */ "./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js");
const plugin_paginate_rest_1 = __webpack_require__(/*! @octokit/plugin-paginate-rest */ "./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js");
exports.context = new Context.Context();
const baseUrl = Utils.getApiBaseUrl();
exports.defaults = {
    baseUrl,
    request: {
        agent: Utils.getProxyAgent(baseUrl)
    }
};
exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
/**
 * Convience function to correctly format Octokit Options to pass into the constructor.
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
    // Auth
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
        opts.auth = auth;
    }
    return opts;
}
exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@actions/http-client/lib/auth.js":
/*!*******************************************************!*\
  !*** ./node_modules/@actions/http-client/lib/auth.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ "./node_modules/@actions/http-client/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@actions/http-client/lib/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const https = __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
const pm = __importStar(__webpack_require__(/*! ./proxy */ "./node_modules/@actions/http-client/lib/proxy.js"));
const tunnel = __importStar(__webpack_require__(/*! tunnel */ "./node_modules/tunnel/index.js"));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@actions/http-client/lib/proxy.js":
/*!********************************************************!*\
  !*** ./node_modules/@actions/http-client/lib/proxy.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports.parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/@acuminous/bitsyntax/lib/parse.js").parse;
module.exports.match = __webpack_require__(/*! ./lib/interp */ "./node_modules/@acuminous/bitsyntax/lib/interp.js").match;
module.exports.build = __webpack_require__(/*! ./lib/constructor */ "./node_modules/@acuminous/bitsyntax/lib/constructor.js").build;
module.exports.write = __webpack_require__(/*! ./lib/constructor */ "./node_modules/@acuminous/bitsyntax/lib/constructor.js").write;

module.exports.matcher = module.exports.compile = __webpack_require__(/*! ./lib/compile */ "./node_modules/@acuminous/bitsyntax/lib/compile.js").compile;
module.exports.builder = __webpack_require__(/*! ./lib/compile */ "./node_modules/@acuminous/bitsyntax/lib/compile.js").compile_builder;


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/compile.js":
/*!**********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/compile.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Compile patterns to recognisers and constructors



__webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js");
var $ = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

var parse = (__webpack_require__(/*! ./parse */ "./node_modules/@acuminous/bitsyntax/lib/parse.js").parse);
var interp = __webpack_require__(/*! ./interp */ "./node_modules/@acuminous/bitsyntax/lib/interp.js"),
  parse_int = interp.parse_int,
  parse_float = interp.parse_float;
var construct = __webpack_require__(/*! ./constructor */ "./node_modules/@acuminous/bitsyntax/lib/constructor.js"),
  write_int = construct.write_int,
  write_float = construct.write_float;

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);

var lines = [];
function $start() {
  lines = [];
}
function $line(/* format , args */) {
  lines.push($.apply(null, arguments));
}
function $result() {
  return lines.join('\n');
}

function bits_expr(segment) {
  if (typeof segment.size === 'string') {
    return $('%s * %d', var_name(segment.size), segment.unit);
  }
  else {
    return (segment.size * segment.unit).toString();
  }
}

function get_number(segment) {
  $line('bits = %s;\n', bits_expr(segment));
  var parser = (segment.type === 'integer') ?
    'parse_int' : 'parse_float';
  var be = segment.bigendian, sg = segment.signed;
  $line("byteoffset = offset / 8; offset += bits");
  $line("if (offset > binsize) { return false; }");
  $line("else { result = %s(bin, byteoffset, bits / 8, %s, %s); }",
        parser, be, sg);
}

function get_binary(segment) {
  $line("byteoffset = offset / 8;");
  if (segment.size === true) {
    $line("offset = binsize;");
    $line("result = bin.slice(byteoffset);");
  }
  else {
    $line("bits = %s;", bits_expr(segment));
    $line("offset += bits;");
    $line("if (offset > binsize) { return false; }");
    $line("else { result = bin.slice(byteoffset,",
          "byteoffset + bits / 8); }");
  }
}

function get_string(segment) {
  $line("byteoffset = offset / 8;");
  var strlen = segment.value.length;
  var strlenbits = strlen * 8;
  $line("offset += %d;", strlenbits);
  $line("if (offset > binsize) { return false; }");
  $line("else { result = bin.toString(byteoffset,",
        $("byteoffset + %d); }", strlen));
}

function skip_bits(segment) {
  if (typeof segment.size === 'string') {
    // Damn. Have to look up the size.
    $line("var skipbits = %s * %d;",
          var_name(segment.size), segment.unit);
    $line("if (offset + skipbits > binsize) { return false; }");
    $line("else { offset += skipbits; }");
  }
  else if (segment.size === true) {
    $line("if (offset % 8 === 0) { offset = binsize; }");
    $line("else { return false; }");
  }
  else {
    var bits = segment.unit * segment.size;
    $line("if (offset + %d > binsize) { return false; }", bits);
    $line("else { offset += %d; }", bits);
  }
}

function match_seg(segment) {
  if (segment.name === '_') {
    skip_bits(segment);
  }
  else {
    var assign_result;
    switch (segment.type) {
    case 'integer':
    case 'float':
      get_number(segment);
      break;
    case 'binary':
      get_binary(segment);
      break;
    case 'string':
      get_string(segment);
      break;
    }
    $line("if (result === false) return false;");
    if (segment.name) {
      // variable is given a value in the environment
      $line("else if (%s !== undefined) {", var_name(segment.name));
      // .. and it is not the same as that matched
      $line("if (%s != result) return false;",
            var_name(segment.name));
      $line("}");
      // variable is free
      $line('else %s = result;', var_name(segment.name));
    }
    else {
      var repr = JSON.stringify(segment.value);
      $line("else if (result != %s) return false;", repr);
    }
  }
}

function var_name(name) {
  return  'var_' + name;
}

function variables(segments) {
  var names = {};
  for (var i = 0; i < segments.length; i++) {
    var name = segments[i].name;
    if (name && name !== '_') {
      names[name] = true;
    }
    name = segments[i].size;
    if (typeof name === 'string') {
      names[name] = true;
    }
  }
  return Object.keys(names);
}

function compile_pattern(segments) {
  $start();
  $line("return function(binary, env) {");
  $line("'use strict';");
  $line("var bin = binary, env = env || {};");
  $line("var offset = 0, binsize = bin.length * 8;");
  $line("var bits, result, byteoffset;");
  var varnames = variables(segments);
  for (var v = 0; v < varnames.length; v++) {
    var name = varnames[v];
    $line("var %s = env['%s'];", var_name(name), name);
  }

  var len = segments.length;
  for (var i = 0; i < len; i++) {
    var segment = segments[i];
    $line("// " + JSON.stringify(segment));
    match_seg(segment);
  }

  $line("if (offset == binsize) {");
  $line("return {");
  for (var v = 0; v < varnames.length; v++) {
    var name = varnames[v];
    $line("%s: %s,", name, var_name(name));
  }
  $line('};');
  $line('}'); // if offset == binsize
  $line("else return false;");
  $line("}"); // end function

  var fn = new Function('parse_int', 'parse_float', $result());
  return fn(parse_int, parse_float);
}


function write_seg(segment) {
  switch (segment.type) {
  case 'string':
    $line("offset += buf.write(%s, offset, 'utf8');",
          JSON.stringify(segment.value));
    break;
  case 'binary':
    $line("val = bindings['%s'];", segment.name);
    if (segment.size === true) {
      $line('size = val.length;');
    }
    else if (typeof segment.size === 'string') {
      $line("size = (bindings['%s'] * %d) / 8;",
            segment.size, segment.unit);
    }
    else {
      $line("size = %d;", (segment.size * segment.unit) / 8);
    }
    $line('val.copy(buf, offset, 0, size);');
    $line('offset += size;');
    break;
  case 'integer':
  case 'float':
    write_number(segment);
    break;
  }
}

function write_number(segment) {
  if (segment.name) {
    $line("val = bindings['%s'];", segment.name);
  }
  else {
    $line("val = %d", segment.value);
  }
  var writer = (segment.type === 'integer') ?
    'write_int' : 'write_float';
  if (typeof segment.size === 'string') {
    $line("size = (bindings['%s'] * %d) / 8;",
          segment.size, segment.unit);
  }
  else {
    $line('size = %d;', (segment.size * segment.unit) / 8);
  }
  $line('%s(buf, val, offset, size, %s);',
        writer, segment.bigendian);
  $line('offset += size;');
}

function size_of(segments) {
  var variable = [];
  var fixed = 0;

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (typeof segment.size === 'string' ||
        segment.size === true) {
      variable.push(segment);
    }
    else if (segment.type === 'string') {
      fixed += Buffer.byteLength(segment.value);
    }
    else {
      fixed += (segment.size * segment.unit) / 8;
    }
  }

  $line('var buffersize = %d;', fixed);

  if (variable.length > 0) {
    for (var j = 0; j < variable.length; j++) {
      var segment = variable[j];
      if (segment.size === true) {
        $line("buffersize += bindings['%s'].length;", segment.name);
      }
      else {
        $line("buffersize += (bindings['%s'] * %d) / 8;",
              segment.size, segment.unit);
      }
    }
  }
}

function emit_write(segments) {
  $line('var val, size;');

  var len = segments.length;
  for (var i = 0; i < len; i++) {
    var segment = segments[i];
    $line('// %s', JSON.stringify(segment));
    write_seg(segment);
  }
}

function compile_ctor(segments) {
  $start();
  $line('return function(bindings) {');
  $line("'use strict';");
  size_of(segments);
  $line('var buf = Buffer.alloc(buffersize);');
  $line('var offset = 0;');
  emit_write(segments);
  $line('return buf;');
  $line('}'); // end function

  return new Function('write_int', 'write_float', 'Buffer',
                      $result())(write_int, write_float, Buffer);
}

module.exports.compile_pattern = compile_pattern;
module.exports.compile = function() {
  var str = [].join.call(arguments, ',');
  var p = parse(str);
  return compile_pattern(p);
};
module.exports.compile_builder = function() {
  var str = [].join.call(arguments, ',');
  var p = parse(str);
  return compile_ctor(p);
};


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/constructor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// -*- js-indent-level: 2 -*-

// Constructors given patterns



var ints = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js");
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);

// Interpret the pattern, writing values into a buffer
function write(buf, offset, pattern, bindings) {
  for (var i=0, len = pattern.length; i < len; i++) {
    var segment = pattern[i];
    switch (segment.type) {
    case 'string':
      offset += buf.write(segment.value, offset, 'utf8');
      break;
    case 'binary':
      offset += writeBinary(segment, buf, offset, bindings);
      break;
    case 'integer':
      offset += writeInteger(segment, buf, offset, bindings);
      break;
    case 'float':
      offset += writeFloat(segment, buf, offset, bindings);
      break;
    }
  }
  return offset;
}

function build(pattern, bindings) {
  var bufsize = size_of(pattern, bindings);
  var buf = Buffer.alloc(bufsize);
  write(buf, 0, pattern, bindings);
  return buf;
}

// In bytes
function size_of_segment(segment, bindings) {
  // size refers to a variable
  if (typeof segment.size === 'string') {
    return (bindings[segment.size] * segment.unit) / 8;
  }
  if (segment.type === 'string') {
    return Buffer.byteLength(segment.value, 'utf8');
  }
  if (segment.type === 'binary' && segment.size === true) {
    var val = bindings[segment.name];
    return val.length;
  }
  return (segment.size * segment.unit) / 8;
}

// size of the to-be-constructed binary, in bytes
function size_of(segments, bindings) {
  var size = 0;
  for (var i=0, len = segments.length; i < len; i++) {
    size += size_of_segment(segments[i], bindings);
  }
  return size;
}

function writeBinary(segment, buf, offset, bindings) {
  var bin = bindings[segment.name];
  var size = size_of_segment(segment, bindings);
  bin.copy(buf, offset, 0, size);
  return size;
}

// TODO in ff might use the noAssert argument to Buffer.write*() but
// need to check that it does the right thing wrt little-endian

function writeInteger(segment, buf, offset, bindings) {
  var value = (segment.name) ? bindings[segment.name] : segment.value;
  var size = size_of_segment(segment, bindings);
  return write_int(buf, value, offset, size, segment.bigendian);
}

function write_int(buf, value, offset, size, bigendian) {
  switch (size) {
  case 1:
    buf.writeUInt8(value, offset);
    break;
  case 2:
    (bigendian) ?
      buf.writeUInt16BE(value, offset) :
      buf.writeUInt16LE(value, offset);
    break;
  case 4:
    (bigendian) ?
      buf.writeUInt32BE(value, offset) :
      buf.writeUInt32LE(value, offset);
    break;
  case 8:
    (bigendian) ?
      ints.writeUInt64BE(buf, value, offset) :
      ints.writeUInt64LE(buf, value, offset);
    break;
  default:
    throw new Error("integer size * unit must be 8, 16, 32 or 64");
  }
  return size;
}

function writeFloat(segment, buf, offset, bindings) {
  var value = (segment.name) ? bindings[segment.name] : segment.value;
  var size = size_of_segment(segment, bindings);
  return write_float(buf, value, offset, size, segment.bigendian);
}

function write_float(buf, value, offset, size, bigendian) {
  if (size === 4) {
    (bigendian) ?
      buf.writeFloatBE(value, offset) :
      buf.writeFloatLE(value, offset);
  }
  else if (size === 8) {
    (bigendian) ?
      buf.writeDoubleBE(value, offset) :
      buf.writeDoubleLE(value, offset);
  }
  else {
    throw new Error("float size * unit must be 32 or 64");
  }
  return size;
}

var parse = (__webpack_require__(/*! ./parse */ "./node_modules/@acuminous/bitsyntax/lib/parse.js").parse);

module.exports.write = write;
module.exports.build = build;
module.exports.write_int = write_int;
module.exports.write_float = write_float;

module.exports.builder = function(pstr) {
  pstr = (arguments.length > 1) ? [].join.call(arguments, ',') : pstr;
  var pattern = parse(pstr);
  return function(vars) {
    return build(pattern, vars);
  };
};


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/interp.js":
/*!*********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/interp.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// -*- js-indent: 2 -*-
// Interpreter for bit syntax AST.
// Grammar:
//
// pattern   := segment ("," segment)*
// segment   := (value | var) (":" size)? ("/" specifier ("-" specifier)*)? | string
// var       := "_" | identifier
// size      := integer | var
// specifier := "little" | "big" | "signed" | "unsigned" | "unit" ":" 0..256 | type
// type      := "integer" | "binary" | "float"
//
// where integer has the obvious meaning, and identifier is anything
// other than "_" that fits the JavaScript identifier specification.
//

// We'll use an object to represent each segment, and an array of
// segments for a pattern. We won't try to optimise for groups of
// patterns; we'll just step through each to see if it works. We rely
// a hypothetical prior step to check that it's a valid pattern.

// ? compile to intermediate instructions ?

// A segment looks like
// {
//    type: string, // 'string' is special case
//    size: integer | true, // true means 'all remaining'
//    name: string | null, // (may be '_')
//    value: value | null, // either name OR value
//    unit: integer,
//    signed: boolean,
//    bigendian: boolean
// }



var ints    = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js"),
    debug   = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('bitsyntax-Interpreter');

function parse_int(bin, off, sizeInBytes, bigendian, signed) {
  switch (sizeInBytes) {
  case 1:
    return (signed) ? bin.readInt8(off) : bin.readUInt8(off);
  case 2:
    return (bigendian) ?
      (signed) ? bin.readInt16BE(off) : bin.readUInt16BE(off) :
      (signed) ? bin.readInt16LE(off) : bin.readUInt16LE(off);
  case 4:
    return (bigendian) ?
      (signed) ? bin.readInt32BE(off) : bin.readUInt32BE(off) :
      (signed) ? bin.readInt32LE(off) : bin.readUInt32LE(off);
  case 8:
    return (bigendian) ?
      ((signed) ? ints.readInt64BE : ints.readUInt64BE)(bin, off) :
      ((signed) ? ints.readInt64LE : ints.readUInt64LE)(bin, off);
  default:
    throw "Integers must be 8-, 16-, 32- or 64-bit";
  }
}

function parse_float(bin, off, sizeInBytes, bigendian) {
  switch (sizeInBytes) {
  case 4:
    return (bigendian) ? bin.readFloatBE(off) : bin.readFloatLE(off);
  case 8:
    return (bigendian) ? bin.readDoubleBE(off) : bin.readDoubleLE(off);
  default:
    throw "Floats must be 32- or 64-bit";
  }
}

function size_of(segment, bound) {
  var size = segment.size;
  if (typeof size === 'string') {
    return bound[size];
  }
  else {
    return size;
  }
}

function new_scope(env) {
  function scope() {};
  scope.prototype = env;
  return new scope();
}

function bindings(scope) {
  var s = {};
  for (var k in scope) {
    if (scope.hasOwnProperty(k)) {
      s[k] = scope[k];
    }
  }
  return s;
}

function match(pattern, binary, boundvars) {
  var offset = 0, vars = new_scope(boundvars);
  var binsize = binary.length * 8;

  function skip_bits(segment) {
    debug("skip bits"); debug(segment);
    var size = size_of(segment, vars);
    if (size === true) {
      if (offset % 8 === 0) {
        offset = binsize;
        return true;
      }
      else {
        return false;
      }
    }

    var bits = segment.unit * size;
    if (offset + bits > binsize) {
      return false;
    }
    else {
      offset += bits;
    }
  }

  function get_integer(segment) {
    debug("get_integer"); debug(segment);
    // let's do only multiples of eight bits for now
    var unit = segment.unit, size = size_of(segment, vars);
    var bitsize = size * unit;
    var byteoffset = offset / 8; // NB assumes aligned
    offset += bitsize;
    if (bitsize % 8 > 0 || (offset > binsize)) {
      return false;
    }
    else {
      return parse_int(binary, byteoffset, bitsize / 8,
                       segment.bigendian, segment.signed);
    }
  }

  function get_float(segment) {
    debug("get_float"); debug(segment);
    var unit = segment.unit; var size = size_of(segment, vars);
    var bitsize = size * unit;
    var byteoffset = offset / 8; // assume aligned
    offset += bitsize;
    if (offset > binsize) {
      return false;
    }
    else {
      return parse_float(binary, byteoffset,
                         bitsize / 8, segment.bigendian);
    }
  }

  function get_binary(segment) {
    debug("get_binary"); debug(segment);
    var unit = segment.unit, size = size_of(segment, vars);
    var byteoffset = offset / 8; // NB alignment

    if (size === true) {
      offset = binsize;
      return binary.slice(byteoffset);
    }
    else {
      var bitsize = size * unit;
      if (bitsize % 8 > 0 || (offset + bitsize) > binsize) {
        return false;
      }
      else {
        offset += bitsize;
        return binary.slice(byteoffset, byteoffset + bitsize / 8);
      }
    }
  }

  function get_string(segment) {
    debug("get_string"); debug(segment);
    var len = segment.value.length;
    var byteoffset = offset / 8;

    offset += len * 8;
    if (offset > binsize) {
      return false;
    }
    // FIXME bytes vs UTF8 characters
    return binary.slice(byteoffset, byteoffset + len).toString('utf8');
  }

  var patternlen = pattern.length;
  for (var i = 0;  i < patternlen; i++) {
    var segment = pattern[i];
    var result = false;
    if (segment.name === '_') {
      result = skip_bits(segment);
    }
    else {
      switch (segment.type) {
      case 'string':
        result = get_string(segment);
        break;
      case 'integer':
        result = get_integer(segment);
        break;
      case 'float':
        result = get_float(segment);
        break;
      case 'binary':
        result = get_binary(segment);
        break;
      }

      if (result === false) {
        return false;
      }
      else if (segment.name) {
        vars[segment.name] = result;
      }
      else if (segment.value != result) {
        return false;
      }
    }
  }
  if (offset == binsize) {
    return bindings(vars);
  }
  else {
    return false;
  }
}

module.exports.match = match;
module.exports.parse_int = parse_int;
module.exports.parse_float = parse_float;


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/parse.js":
/*!********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/parse.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parse patterns in string form into the form we use for interpreting
// (and later, for compiling).



var ast = __webpack_require__(/*! ./pattern */ "./node_modules/@acuminous/bitsyntax/lib/pattern.js");
var parser = __webpack_require__(/*! ./parser */ "./node_modules/@acuminous/bitsyntax/lib/parser.js");

function parse_pattern(string) {
  var segments = parser.parse(string);
  for (var i=0, len = segments.length; i < len; i++) {
    var s = segments[i];
    if (s.string != undefined) {
      segments[i] = ast.string(s.string);
    }
    else if (s.value != undefined) {
      segments[i] = ast.value(s.value, s.size, s.specifiers);
    }
    else if (s.name != undefined) {
      segments[i] = ast.variable(s.name, s.size, s.specifiers);
    }
    else {
      throw "Unknown segment " + s;
    }
  }
  return segments;
}

module.exports.parse = function() {
  var str = [].join.call(arguments, ',');
  return parse_pattern(str);
};


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/parser.js ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "segmentTail": parse_segmentTail,
        "segment": parse_segment,
        "string": parse_string,
        "chars": parse_chars,
        "char": parse_char,
        "hexDigit": parse_hexDigit,
        "identifier": parse_identifier,
        "number": parse_number,
        "size": parse_size,
        "specifierList": parse_specifierList,
        "specifierTail": parse_specifierTail,
        "specifier": parse_specifier,
        "unit": parse_unit,
        "ws": parse_ws
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ws();
        if (result0 !== null) {
          result1 = parse_segment();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_segmentTail();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_segmentTail();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segmentTail() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ws();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_ws();
            if (result2 !== null) {
              result3 = parse_segment();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, seg) { return seg; })(pos0, result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_string();
        if (result0 !== null) {
          result0 = (function(offset, str) { return {string: str}; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_identifier();
          if (result0 !== null) {
            result1 = parse_size();
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result2 = parse_specifierList();
              result2 = result2 !== null ? result2 : "";
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, v, size, specs) { return {name: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_number();
            if (result0 !== null) {
              result1 = parse_size();
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                result2 = parse_specifierList();
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, v, size, specs) { return {value: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_string() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 34) {
            result1 = "\"";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "";    })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 34) {
            result0 = "\"";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_chars();
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 34) {
                result2 = "\"";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, chars) { return chars; })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_chars() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_char();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_char();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_char() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        if (/^[^"\\\0-\x1F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\"\\\\\\0-\\x1F]");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 2) === "\\\"") {
            result0 = "\\\"";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\\\"\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return '"';  })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 2) === "\\\\") {
              result0 = "\\\\";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\\\\\\\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) { return "\\"; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 2) === "\\/") {
                result0 = "\\/";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\/\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) { return "/";  })(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 2) === "\\b") {
                  result0 = "\\b";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\\b\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) { return "\b"; })(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  if (input.substr(pos, 2) === "\\f") {
                    result0 = "\\f";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\\f\"");
                    }
                  }
                  if (result0 !== null) {
                    result0 = (function(offset) { return "\f"; })(pos0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                  if (result0 === null) {
                    pos0 = pos;
                    if (input.substr(pos, 2) === "\\n") {
                      result0 = "\\n";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\\n\"");
                      }
                    }
                    if (result0 !== null) {
                      result0 = (function(offset) { return "\n"; })(pos0);
                    }
                    if (result0 === null) {
                      pos = pos0;
                    }
                    if (result0 === null) {
                      pos0 = pos;
                      if (input.substr(pos, 2) === "\\r") {
                        result0 = "\\r";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\\r\"");
                        }
                      }
                      if (result0 !== null) {
                        result0 = (function(offset) { return "\r"; })(pos0);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                      if (result0 === null) {
                        pos0 = pos;
                        if (input.substr(pos, 2) === "\\t") {
                          result0 = "\\t";
                          pos += 2;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\t\"");
                          }
                        }
                        if (result0 !== null) {
                          result0 = (function(offset) { return "\t"; })(pos0);
                        }
                        if (result0 === null) {
                          pos = pos0;
                        }
                        if (result0 === null) {
                          pos0 = pos;
                          pos1 = pos;
                          if (input.substr(pos, 2) === "\\u") {
                            result0 = "\\u";
                            pos += 2;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\\u\"");
                            }
                          }
                          if (result0 !== null) {
                            result1 = parse_hexDigit();
                            if (result1 !== null) {
                              result2 = parse_hexDigit();
                              if (result2 !== null) {
                                result3 = parse_hexDigit();
                                if (result3 !== null) {
                                  result4 = parse_hexDigit();
                                  if (result4 !== null) {
                                    result0 = [result0, result1, result2, result3, result4];
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                          if (result0 !== null) {
                            result0 = (function(offset, h1, h2, h3, h4) {
                                return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                              })(pos0, result0[1], result0[2], result0[3], result0[4]);
                          }
                          if (result0 === null) {
                            pos = pos0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_hexDigit() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[_a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[_a-zA-Z]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[_a-zA-Z0-9]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[_a-zA-Z0-9]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) { return head + tail.join(''); })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return 0; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, head, tail) { return parseInt(head + tail.join('')); })(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_size() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_number();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, num) { return num; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result0 = ":";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_identifier();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, id) { return id; })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_specifierList() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_specifier();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_specifierTail();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_specifierTail();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_specifierTail() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_specifier();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, spec) { return spec; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_specifier() {
        var result0;
        
        if (input.substr(pos, 6) === "little") {
          result0 = "little";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"little\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 3) === "big") {
            result0 = "big";
            pos += 3;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"big\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 6) === "signed") {
              result0 = "signed";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"signed\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 8) === "unsigned") {
                result0 = "unsigned";
                pos += 8;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"unsigned\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 7) === "integer") {
                  result0 = "integer";
                  pos += 7;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"integer\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 6) === "binary") {
                    result0 = "binary";
                    pos += 6;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"binary\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 5) === "float") {
                      result0 = "float";
                      pos += 5;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"float\"");
                      }
                    }
                    if (result0 === null) {
                      result0 = parse_unit();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_unit() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5) === "unit:") {
          result0 = "unit:";
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"unit:\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_number();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, num) { return 'unit:' + num; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ws() {
        var result0, result1;
        
        result0 = [];
        if (/^[ \t\n]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[ \\t\\n]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[ \t\n]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[ \\t\\n]");
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();


/***/ }),

/***/ "./node_modules/@acuminous/bitsyntax/lib/pattern.js":
/*!**********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/pattern.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
// -*- js-indent-level: 2 -*-
// Constructing patterns



function set(values) {
  var s = {};
  for (var i in values) {
    if (!Object.prototype.hasOwnProperty.call(values, i)) continue;
    s[values[i]] = 1;
  }
  return s;
}

// Construct a segment bound to a variable, e.g., from a segment like
// "Len:32/unsigned-big". `specifiers0` is an array.
function variable(name, size, specifiers0) {
  var specifiers = set(specifiers0);
  var segment = {name: name};
  segment.type = type_in(specifiers);
  specs(segment, segment.type, specifiers);
  segment.size = size_of(segment, segment.type, size, segment.unit);
  return segment;
}

module.exports.variable = variable;
module.exports.rest = function() {
  return variable('_', true, ['binary']);
}

// Construct a segment with a literal value, e.g., from a segment like
// "206". `specifiers0` is an array.

function value(val, size, specifiers0) {
  var specifiers = set(specifiers0);
  var segment = {value: val};
  segment.type = type_in(specifiers);
  // TODO check type v. value ..
  specs(segment, segment.type, specifiers);
  segment.size = size_of(segment, segment.type, size, segment.unit);
  return segment;
}

module.exports.value = value;

// A string can appear as a literal, but it must appear without
// specifiers.
function string(val) {
  return {value: val, type: 'string'};
}
module.exports.string = string;

var TYPES = {'integer': 1, 'binary': 1, 'float': 1};
function type_in(specifiers) {
  for (var t in specifiers) {
    if (!Object.prototype.hasOwnProperty.call(specifiers, t)) continue;
    if (TYPES[t]) { return t; }
  }
  return 'integer';
}

function specs(segment, type, specifiers) {
  switch (type) {
  case 'integer':
    segment.signed = signed_in(specifiers);
    // fall through
  case 'float':
    segment.bigendian = endian_in(specifiers);
    // fall through
  default:
    segment.unit = unit_in(specifiers, segment.type);
  }
  return segment;
}

function endian_in(specifiers) {
  // default is big, but I have chosen true = bigendian
  return !specifiers['little'];
}

function signed_in(specifiers) {
  // this time I got it right; default is unsigned
  return specifiers['signed'];
}

function unit_in(specifiers, type) {
  for (var s in specifiers) {
    if (!Object.prototype.hasOwnProperty.call(specifiers, s)) continue;
    if (s.substr(0, 5) == 'unit:') {
      var unit = parseInt(s.substr(5));
      // TODO check sane for type
      return unit;
    }
  }
  // OK defaults then
  switch (type) {
  case 'binary':
    return 8;
  case 'integer':
  case 'float':
    return 1;
  }
}

function size_of(segment, type, size, unit) {
  if (size !== undefined && size !== '') {
    return size;
  }
  else {
    switch (type) {
    case 'integer':
      return 8;
    case 'float':
      return 64;
    case 'binary':
      return true;
    }
  }
}


/***/ }),

/***/ "./node_modules/@octokit/auth-token/dist-web/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@octokit/auth-token/dist-web/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTokenAuth": () => (/* binding */ createTokenAuth)
/* harmony export */ });
const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) ||
        REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp
        ? "app"
        : isInstallation
            ? "installation"
            : isUserToServer
                ? "user-to-server"
                : "oauth";
    return {
        type: "token",
        token: token,
        tokenType,
    };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
    }
    return `token ${token}`;
}

async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
    if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token),
    });
};


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/core/dist-web/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@octokit/core/dist-web/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Octokit": () => (/* binding */ Octokit)
/* harmony export */ });
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");
/* harmony import */ var before_after_hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! before-after-hook */ "./node_modules/before-after-hook/index.js");
/* harmony import */ var before_after_hook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(before_after_hook__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _octokit_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @octokit/request */ "./node_modules/@octokit/request/dist-web/index.js");
/* harmony import */ var _octokit_graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/graphql */ "./node_modules/@octokit/graphql/dist-web/index.js");
/* harmony import */ var _octokit_auth_token__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @octokit/auth-token */ "./node_modules/@octokit/auth-token/dist-web/index.js");






const VERSION = "3.6.0";

class Octokit {
    constructor(options = {}) {
        const hook = new before_after_hook__WEBPACK_IMPORTED_MODULE_0__.Collection();
        const requestDefaults = {
            baseUrl: _octokit_request__WEBPACK_IMPORTED_MODULE_1__.request.endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
                // @ts-ignore internal usage only, no need to type
                hook: hook.bind(null, "request"),
            }),
            mediaType: {
                previews: [],
                format: "",
            },
        };
        // prepend default user agent with `options.userAgent` if set
        requestDefaults.headers["user-agent"] = [
            options.userAgent,
            `octokit-core.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_2__.getUserAgent)()}`,
        ]
            .filter(Boolean)
            .join(" ");
        if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = _octokit_request__WEBPACK_IMPORTED_MODULE_1__.request.defaults(requestDefaults);
        this.graphql = (0,_octokit_graphql__WEBPACK_IMPORTED_MODULE_3__.withCustomRequest)(this.request).defaults(requestDefaults);
        this.log = Object.assign({
            debug: () => { },
            info: () => { },
            warn: console.warn.bind(console),
            error: console.error.bind(console),
        }, options.log);
        this.hook = hook;
        // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
        //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
        // (2) If only `options.auth` is set, use the default token authentication strategy.
        // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
        // TODO: type `options.auth` based on `options.authStrategy`.
        if (!options.authStrategy) {
            if (!options.auth) {
                // (1)
                this.auth = async () => ({
                    type: "unauthenticated",
                });
            }
            else {
                // (2)
                const auth = (0,_octokit_auth_token__WEBPACK_IMPORTED_MODULE_4__.createTokenAuth)(options.auth);
                // @ts-ignore  ¯\_(ツ)_/¯
                hook.wrap("request", auth.hook);
                this.auth = auth;
            }
        }
        else {
            const { authStrategy, ...otherOptions } = options;
            const auth = authStrategy(Object.assign({
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions,
            }, options.auth));
            // @ts-ignore  ¯\_(ツ)_/¯
            hook.wrap("request", auth.hook);
            this.auth = auth;
        }
        // apply plugins
        // https://stackoverflow.com/a/16345172
        const classConstructor = this.constructor;
        classConstructor.plugins.forEach((plugin) => {
            Object.assign(this, plugin(this, options));
        });
    }
    static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
            constructor(...args) {
                const options = args[0] || {};
                if (typeof defaults === "function") {
                    super(defaults(options));
                    return;
                }
                super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent
                    ? {
                        userAgent: `${options.userAgent} ${defaults.userAgent}`,
                    }
                    : null));
            }
        };
        return OctokitWithDefaults;
    }
    /**
     * Attach a plugin (or many) to your Octokit instance.
     *
     * @example
     * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
     */
    static plugin(...newPlugins) {
        var _a;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a = class extends this {
            },
            _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))),
            _a);
        return NewOctokit;
    }
}
Octokit.VERSION = VERSION;
Octokit.plugins = [];


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/endpoint/dist-web/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@octokit/endpoint/dist-web/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "endpoint": () => (/* binding */ endpoint)
/* harmony export */ });
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "./node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");



function lowercaseKeys(object) {
    if (!object) {
        return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
    }, {});
}

function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(options[key])) {
            if (!(key in defaults))
                Object.assign(result, { [key]: options[key] });
            else
                result[key] = mergeDeep(defaults[key], options[key]);
        }
        else {
            Object.assign(result, { [key]: options[key] });
        }
    });
    return result;
}

function removeUndefinedProperties(obj) {
    for (const key in obj) {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    }
    return obj;
}

function merge(defaults, route, options) {
    if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? { method, url } : { url: method }, options);
    }
    else {
        options = Object.assign({}, route);
    }
    // lowercase header names before merging with defaults to avoid duplicates
    options.headers = lowercaseKeys(options.headers);
    // remove properties with undefined values before merging
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    // mediaType.previews arrays are merged, instead of overwritten
    if (defaults && defaults.mediaType.previews.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews
            .filter((preview) => !mergedOptions.mediaType.previews.includes(preview))
            .concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
    return mergedOptions;
}

function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
        return url;
    }
    return (url +
        separator +
        names
            .map((name) => {
            if (name === "q") {
                return ("q=" + parameters.q.split("+").map(encodeURIComponent).join("+"));
            }
            return `${name}=${encodeURIComponent(parameters[name])}`;
        })
            .join("&"));
}

const urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
        return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
    return Object.keys(object)
        .filter((option) => !keysToOmit.includes(option))
        .reduce((obj, key) => {
        obj[key] = object[key];
        return obj;
    }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/* istanbul ignore file */
function encodeReserved(str) {
    return str
        .split(/(%[0-9A-Fa-f]{2})/g)
        .map(function (part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
    })
        .join("");
}
function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
function encodeValue(operator, value, key) {
    value =
        operator === "+" || operator === "#"
            ? encodeReserved(value)
            : encodeUnreserved(value);
    if (key) {
        return encodeUnreserved(key) + "=" + value;
    }
    else {
        return value;
    }
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
        if (typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
                value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        }
        else {
            if (modifier === "*") {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                    });
                }
                else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            }
            else {
                const tmp = [];
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        tmp.push(encodeValue(operator, value));
                    });
                }
                else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeUnreserved(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }
                if (isKeyOperator(operator)) {
                    result.push(encodeUnreserved(key) + "=" + tmp.join(","));
                }
                else if (tmp.length !== 0) {
                    result.push(tmp.join(","));
                }
            }
        }
    }
    else {
        if (operator === ";") {
            if (isDefined(value)) {
                result.push(encodeUnreserved(key));
            }
        }
        else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(encodeUnreserved(key) + "=");
        }
        else if (value === "") {
            result.push("");
        }
    }
    return result;
}
function parseUrl(template) {
    return {
        expand: expand.bind(null, template),
    };
}
function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
        if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function (variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
                var separator = ",";
                if (operator === "?") {
                    separator = "&";
                }
                else if (operator !== "#") {
                    separator = operator;
                }
                return (values.length !== 0 ? operator : "") + values.join(separator);
            }
            else {
                return values.join(",");
            }
        }
        else {
            return encodeReserved(literal);
        }
    });
}

function parse(options) {
    // https://fetch.spec.whatwg.org/#methods
    let method = options.method.toUpperCase();
    // replace :varname with {varname} to make it RFC 6570 compatible
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType",
    ]);
    // extract variable names from URL to calculate remaining variables later
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
        url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options)
        .filter((option) => urlVariableNames.includes(option))
        .concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
        if (options.mediaType.format) {
            // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
            headers.accept = headers.accept
                .split(/,/)
                .map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`))
                .join(",");
        }
        if (options.mediaType.previews.length) {
            const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
            headers.accept = previewsFromAcceptHeader
                .concat(options.mediaType.previews)
                .map((preview) => {
                const format = options.mediaType.format
                    ? `.${options.mediaType.format}`
                    : "+json";
                return `application/vnd.github.${preview}-preview${format}`;
            })
                .join(",");
        }
    }
    // for GET/HEAD requests, set URL query parameters from remaining parameters
    // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters
    if (["GET", "HEAD"].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
    }
    else {
        if ("data" in remainingParameters) {
            body = remainingParameters.data;
        }
        else {
            if (Object.keys(remainingParameters).length) {
                body = remainingParameters;
            }
            else {
                headers["content-length"] = 0;
            }
        }
    }
    // default content-type for JSON if body is set
    if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
    }
    // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
    // fetch does not allow to set `content-length` header, but we can set body to an empty string
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
    }
    // Only return body/request keys if present
    return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}

function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS = merge(oldDefaults, newDefaults);
    const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
    return Object.assign(endpoint, {
        DEFAULTS,
        defaults: withDefaults.bind(null, DEFAULTS),
        merge: merge.bind(null, DEFAULTS),
        parse,
    });
}

const VERSION = "6.0.12";

const userAgent = `octokit-endpoint.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_1__.getUserAgent)()}`;
// DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.
const DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent,
    },
    mediaType: {
        format: "",
        previews: [],
    },
};

const endpoint = withDefaults(null, DEFAULTS);


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/graphql/dist-web/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@octokit/graphql/dist-web/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphqlResponseError": () => (/* binding */ GraphqlResponseError),
/* harmony export */   "graphql": () => (/* binding */ graphql$1),
/* harmony export */   "withCustomRequest": () => (/* binding */ withCustomRequest)
/* harmony export */ });
/* harmony import */ var _octokit_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @octokit/request */ "./node_modules/@octokit/request/dist-web/index.js");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");



const VERSION = "4.8.0";

function _buildMessageForResponseErrors(data) {
    return (`Request failed due to following response errors:\n` +
        data.errors.map((e) => ` - ${e.message}`).join("\n"));
}
class GraphqlResponseError extends Error {
    constructor(request, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        // Expose the errors and response data in their shorthand properties.
        this.errors = response.errors;
        this.data = response.data;
        // Maintains proper stack trace (only available on V8)
        /* istanbul ignore next */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}

const NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType",
];
const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
    if (options) {
        if (typeof query === "string" && "query" in options) {
            return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for (const key in options) {
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
                continue;
            return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
        }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS.includes(key)) {
            result[key] = parsedOptions[key];
            return result;
        }
        if (!result.variables) {
            result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
    }, {});
    // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
    // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451
    const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request(requestOptions).then((response) => {
        if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)) {
                headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(requestOptions, headers, response.data);
        }
        return response.data.data;
    });
}

function withDefaults(request$1, newDefaults) {
    const newRequest = request$1.defaults(newDefaults);
    const newApi = (query, options) => {
        return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: _octokit_request__WEBPACK_IMPORTED_MODULE_0__.request.endpoint,
    });
}

const graphql$1 = withDefaults(_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request, {
    headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_1__.getUserAgent)()}`,
    },
    method: "POST",
    url: "/graphql",
});
function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql",
    });
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "composePaginateRest": () => (/* binding */ composePaginateRest),
/* harmony export */   "isPaginatingEndpoint": () => (/* binding */ isPaginatingEndpoint),
/* harmony export */   "paginateRest": () => (/* binding */ paginateRest),
/* harmony export */   "paginatingEndpoints": () => (/* binding */ paginatingEndpoints)
/* harmony export */ });
const VERSION = "2.21.3";

/**
 * Some “list” response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
    // endpoints can respond with 204 if repository is empty
    if (!response.data) {
        return {
            ...response,
            data: [],
        };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization)
        return response;
    // keep the additional properties intact as there is currently no other way
    // to retrieve the same information.
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
}

function iterator(octokit, route, parameters) {
    const options = typeof route === "function"
        ? route.endpoint(parameters)
        : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
        [Symbol.asyncIterator]: () => ({
            async next() {
                if (!url)
                    return { done: true };
                try {
                    const response = await requestMethod({ method, url, headers });
                    const normalizedResponse = normalizePaginatedListResponse(response);
                    // `response.headers.link` format:
                    // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
                    // sets `url` to undefined if "next" URL is not present or `link` header is not set
                    url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
                    return { value: normalizedResponse };
                }
                catch (error) {
                    if (error.status !== 409)
                        throw error;
                    url = "";
                    return {
                        value: {
                            status: 200,
                            headers: {},
                            data: [],
                        },
                    };
                }
            },
        }),
    };
}

function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = undefined;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator, mapFn) {
    return iterator.next().then((result) => {
        if (result.done) {
            return results;
        }
        let earlyExit = false;
        function done() {
            earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
            return results;
        }
        return gather(octokit, results, iterator, mapFn);
    });
}

const composePaginateRest = Object.assign(paginate, {
    iterator,
});

const paginatingEndpoints = [
    "GET /app/hook/deliveries",
    "GET /app/installations",
    "GET /applications/grants",
    "GET /authorizations",
    "GET /enterprises/{enterprise}/actions/permissions/organizations",
    "GET /enterprises/{enterprise}/actions/runner-groups",
    "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations",
    "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners",
    "GET /enterprises/{enterprise}/actions/runners",
    "GET /enterprises/{enterprise}/audit-log",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /enterprises/{enterprise}/settings/billing/advanced-security",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runner-groups",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/audit-log",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/credential-authorizations",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/external-groups",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/settings/billing/advanced-security",
    "GET /orgs/{org}/team-sync/groups",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/git/matching-refs/{ref}",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions",
];

function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
    }
    else {
        return false;
    }
}

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */
function paginateRest(octokit) {
    return {
        paginate: Object.assign(paginate.bind(null, octokit), {
            iterator: iterator.bind(null, octokit),
        }),
    };
}
paginateRest.VERSION = VERSION;


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "legacyRestEndpointMethods": () => (/* binding */ legacyRestEndpointMethods),
/* harmony export */   "restEndpointMethods": () => (/* binding */ restEndpointMethods)
/* harmony export */ });
const Endpoints = {
    actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
        ],
        approveWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve",
        ],
        cancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel",
        ],
        createOrUpdateEnvironmentSecret: [
            "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}",
        ],
        createRegistrationTokenForOrg: [
            "POST /orgs/{org}/actions/runners/registration-token",
        ],
        createRegistrationTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/registration-token",
        ],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/remove-token",
        ],
        createWorkflowDispatch: [
            "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
        ],
        deleteActionsCacheById: [
            "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}",
        ],
        deleteActionsCacheByKey: [
            "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}",
        ],
        deleteArtifact: [
            "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
        ],
        deleteEnvironmentSecret: [
            "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}",
        ],
        deleteSelfHostedRunnerFromOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}",
        ],
        deleteSelfHostedRunnerFromRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}",
        ],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
            "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}",
        ],
        disableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable",
        ],
        downloadArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}",
        ],
        downloadJobLogsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs",
        ],
        downloadWorkflowRunAttemptLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs",
        ],
        downloadWorkflowRunLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}",
        ],
        enableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable",
        ],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: [
            "GET /orgs/{org}/actions/cache/usage-by-repository",
        ],
        getActionsCacheUsageForEnterprise: [
            "GET /enterprises/{enterprise}/actions/cache/usage",
        ],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/selected-actions",
        ],
        getAllowedActionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/selected-actions",
        ],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getEnvironmentPublicKey: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key",
        ],
        getEnvironmentSecret: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        getGithubActionsDefaultWorkflowPermissionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions/workflow",
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions/workflow",
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/workflow",
        ],
        getGithubActionsPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions",
        ],
        getGithubActionsPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions",
        ],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getPendingDeploymentsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
        ],
        getRepoPermissions: [
            "GET /repos/{owner}/{repo}/actions/permissions",
            {},
            { renamed: ["actions", "getGithubActionsPermissionsRepository"] },
        ],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getReviewsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals",
        ],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}",
        ],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/access",
        ],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}",
        ],
        getWorkflowRunUsage: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing",
        ],
        getWorkflowUsage: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing",
        ],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
        ],
        listJobsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
        ],
        listJobsForWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
        ],
        listLabelsForSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        listLabelsForSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/downloads",
        ],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/repositories",
        ],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
        ],
        listWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
        ],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun",
        ],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}",
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
        ],
        reviewPendingDeploymentsForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
        ],
        setAllowedActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/selected-actions",
        ],
        setAllowedActionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions",
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
            "PUT /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
            "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        setGithubActionsDefaultWorkflowPermissionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/workflow",
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/workflow",
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/workflow",
        ],
        setGithubActionsPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions",
        ],
        setGithubActionsPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories",
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories",
        ],
        setWorkflowAccessToRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/access",
        ],
    },
    activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: [
            "DELETE /notifications/threads/{thread_id}/subscription",
        ],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: [
            "GET /notifications/threads/{thread_id}/subscription",
        ],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: [
            "GET /users/{username}/events/orgs/{org}",
        ],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: [
            "GET /users/{username}/received_events/public",
        ],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/notifications",
        ],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: [
            "PUT /notifications/threads/{thread_id}/subscription",
        ],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"],
    },
    apps: {
        addRepoToInstallation: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
        ],
        addRepoToInstallationForAuthenticatedUser: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        ],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: [
            "POST /app/installations/{installation_id}/access_tokens",
        ],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: [
            "GET /marketplace_listing/accounts/{account_id}",
        ],
        getSubscriptionPlanForAccountStubbed: [
            "GET /marketplace_listing/stubbed/accounts/{account_id}",
        ],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: [
            "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
        ],
        listInstallationReposForAuthenticatedUser: [
            "GET /user/installations/{installation_id}/repositories",
        ],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: [
            "GET /user/marketplace_purchases/stubbed",
        ],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: [
            "POST /app/hook/deliveries/{delivery_id}/attempts",
        ],
        removeRepoFromInstallation: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] },
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        ],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: [
            "DELETE /app/installations/{installation_id}/suspended",
        ],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"],
    },
    billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: [
            "GET /users/{username}/settings/billing/actions",
        ],
        getGithubAdvancedSecurityBillingGhe: [
            "GET /enterprises/{enterprise}/settings/billing/advanced-security",
        ],
        getGithubAdvancedSecurityBillingOrg: [
            "GET /orgs/{org}/settings/billing/advanced-security",
        ],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: [
            "GET /users/{username}/settings/billing/packages",
        ],
        getSharedStorageBillingOrg: [
            "GET /orgs/{org}/settings/billing/shared-storage",
        ],
        getSharedStorageBillingUser: [
            "GET /users/{username}/settings/billing/shared-storage",
        ],
    },
    checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
        ],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
        ],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: [
            "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest",
        ],
        rerequestSuite: [
            "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest",
        ],
        setSuitesPreferences: [
            "PATCH /repos/{owner}/{repo}/check-suites/preferences",
        ],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    },
    codeScanning: {
        deleteAnalysis: [
            "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}",
        ],
        getAlert: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
            {},
            { renamedParameters: { alert_id: "alert_number" } },
        ],
        getAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}",
        ],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
            {},
            { renamed: ["codeScanning", "listAlertInstances"] },
        ],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        ],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
    },
    codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"],
    },
    codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        codespaceMachinesForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/machines",
        ],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        createOrUpdateSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}",
        ],
        createWithPrForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces",
        ],
        createWithRepoForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/codespaces",
        ],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: [
            "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}",
        ],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        deleteSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}",
        ],
        exportForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/exports",
        ],
        getExportDetailsForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/exports/{export_id}",
        ],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getPublicKeyForAuthenticatedUser: [
            "GET /user/codespaces/secrets/public-key",
        ],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/public-key",
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        getSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}",
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/devcontainers",
        ],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: [
            "GET /orgs/{org}/codespaces",
            {},
            { renamedParameters: { org_id: "org" } },
        ],
        listInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces",
        ],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}/repositories",
        ],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        removeRepositoryForSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        repoMachinesForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/machines",
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories",
        ],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: [
            "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop",
        ],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"],
    },
    dependabot: {
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
        ],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}",
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/public-key",
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        ],
    },
    dependencyGraph: {
        createRepositorySnapshot: [
            "POST /repos/{owner}/{repo}/dependency-graph/snapshots",
        ],
        diffRange: [
            "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}",
        ],
    },
    emojis: { get: ["GET /emojis"] },
    enterpriseAdmin: {
        addCustomLabelsToSelfHostedRunnerForEnterprise: [
            "POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        disableSelectedOrganizationGithubActionsEnterprise: [
            "DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
        ],
        enableSelectedOrganizationGithubActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
        ],
        getAllowedActionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions/selected-actions",
        ],
        getGithubActionsPermissionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions",
        ],
        getServerStatistics: [
            "GET /enterprise-installation/{enterprise_or_org}/server-statistics",
        ],
        listLabelsForSelfHostedRunnerForEnterprise: [
            "GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        listSelectedOrganizationsEnabledGithubActionsEnterprise: [
            "GET /enterprises/{enterprise}/actions/permissions/organizations",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: [
            "DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        removeCustomLabelFromSelfHostedRunnerForEnterprise: [
            "DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}",
        ],
        setAllowedActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/selected-actions",
        ],
        setCustomLabelsForSelfHostedRunnerForEnterprise: [
            "PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        setGithubActionsPermissionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions",
        ],
        setSelectedOrganizationsEnabledGithubActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/organizations",
        ],
    },
    gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
    },
    git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
    },
    gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"],
    },
    interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: [
            "GET /user/interaction-limits",
            {},
            { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] },
        ],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: [
            "DELETE /repos/{owner}/{repo}/interaction-limits",
        ],
        removeRestrictionsForYourPublicRepos: [
            "DELETE /user/interaction-limits",
            {},
            { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] },
        ],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: [
            "PUT /user/interaction-limits",
            {},
            { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] },
        ],
    },
    issues: {
        addAssignees: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees",
        ],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
        ],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}",
        ],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: [
            "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}",
        ],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
        ],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
        ],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
        ],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels",
        ],
        removeAssignees: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees",
        ],
        removeLabel: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
        ],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: [
            "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}",
        ],
    },
    licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"],
    },
    markdown: {
        render: ["POST /markdown"],
        renderRaw: [
            "POST /markdown/raw",
            { headers: { "content-type": "text/plain; charset=utf-8" } },
        ],
    },
    meta: {
        get: ["GET /meta"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"],
    },
    migrations: {
        cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
        deleteArchiveForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/archive",
        ],
        deleteArchiveForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/archive",
        ],
        downloadArchiveForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/archive",
        ],
        getArchiveForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/archive",
        ],
        getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
        getImportStatus: ["GET /repos/{owner}/{repo}/import"],
        getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/repositories",
        ],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: [
            "GET /user/migrations/{migration_id}/repositories",
            {},
            { renamed: ["migrations", "listReposForAuthenticatedUser"] },
        ],
        mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
        setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: ["PUT /repos/{owner}/{repo}/import"],
        unlockRepoForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock",
        ],
        unlockRepoForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock",
        ],
        updateImport: ["PATCH /repos/{owner}/{repo}/import"],
    },
    orgs: {
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: [
            "PUT /orgs/{org}/outside_collaborators/{username}",
        ],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        get: ["GET /orgs/{org}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}",
        ],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomRoles: ["GET /organizations/{organization_id}/custom_roles"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
            "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
        ],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: [
            "DELETE /orgs/{org}/outside_collaborators/{username}",
        ],
        removePublicMembershipForAuthenticatedUser: [
            "DELETE /orgs/{org}/public_members/{username}",
        ],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: [
            "PUT /orgs/{org}/public_members/{username}",
        ],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: [
            "PATCH /user/memberships/orgs/{org}",
        ],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"],
    },
    packages: {
        deletePackageForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}",
        ],
        deletePackageForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}",
        ],
        deletePackageForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}",
        ],
        deletePackageVersionForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        deletePackageVersionForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        deletePackageVersionForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
            {},
            { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] },
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
            {},
            {
                renamed: [
                    "packages",
                    "getAllPackageVersionsForPackageOwnedByAuthenticatedUser",
                ],
            },
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions",
        ],
        getPackageForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}",
        ],
        getPackageForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}",
        ],
        getPackageForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}",
        ],
        getPackageVersionForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getPackageVersionForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getPackageVersionForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageVersionForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
        restorePackageVersionForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
        restorePackageVersionForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
    },
    projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: [
            "GET /projects/{project_id}/collaborators/{username}/permission",
        ],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: [
            "DELETE /projects/{project_id}/collaborators/{username}",
        ],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"],
    },
    pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
        ],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        ],
        deletePendingReview: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        deleteReviewComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}",
        ],
        dismissReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals",
        ],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
        ],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        listReviewComments: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        ],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        requestReviewers: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        submitReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events",
        ],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch",
        ],
        updateReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        updateReviewComment: [
            "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}",
        ],
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
        createForCommitComment: [
            "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        ],
        createForIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions",
        ],
        createForIssueComment: [
            "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        ],
        createForPullRequestReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        ],
        createForRelease: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/reactions",
        ],
        createForTeamDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        ],
        createForTeamDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        ],
        deleteForCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}",
        ],
        deleteForIssueComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForPullRequestComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}",
        ],
        deleteForTeamDiscussion: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}",
        ],
        deleteForTeamDiscussionComment: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
        ],
        listForCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        ],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        ],
        listForPullRequestReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        ],
        listForRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
        ],
        listForTeamDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        ],
        listForTeamDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        ],
    },
    repos: {
        acceptInvitation: [
            "PATCH /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] },
        ],
        acceptInvitationForAuthenticatedUser: [
            "PATCH /user/repository_invitations/{invitation_id}",
        ],
        addAppAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        addTeamAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        addUserAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: [
            "GET /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: [
            "GET /repos/{owner}/{repo}/compare/{basehead}",
        ],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: [
            "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        ],
        createCommitSignatureProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentStatus: [
            "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        ],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateEnvironment: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: [
            "POST /repos/{template_owner}/{template_repo}/generate",
        ],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: [
            "DELETE /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "declineInvitationForAuthenticatedUser"] },
        ],
        declineInvitationForAuthenticatedUser: [
            "DELETE /user/repository_invitations/{invitation_id}",
        ],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
        ],
        deleteAdminBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        deleteAnEnvironment: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: [
            "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}",
        ],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: [
            "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}",
        ],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: [
            "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}",
        ],
        deleteTagProtection: [
            "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}",
        ],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: [
            "DELETE /repos/{owner}/{repo}/automated-security-fixes",
        ],
        disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
        disableVulnerabilityAlerts: [
            "DELETE /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        downloadArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}",
            {},
            { renamed: ["repos", "downloadZipballArchive"] },
        ],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: [
            "PUT /repos/{owner}/{repo}/automated-security-fixes",
        ],
        enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
        enableVulnerabilityAlerts: [
            "PUT /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        generateReleaseNotes: [
            "POST /repos/{owner}/{repo}/releases/generate-notes",
        ],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
        ],
        getAdminBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        ],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        ],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: [
            "GET /repos/{owner}/{repo}/collaborators/{username}/permission",
        ],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentStatus: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}",
        ],
        getEnvironment: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getStatusChecksProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        getTeamsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        ],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        ],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/config",
        ],
        getWebhookDelivery: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}",
        ],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
        ],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        ],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
        ],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentStatuses: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        ],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
        ],
        listReleaseAssets: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
        ],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
        ],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
        ],
        removeAppAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        removeCollaborator: [
            "DELETE /repos/{owner}/{repo}/collaborators/{username}",
        ],
        removeStatusCheckContexts: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        removeStatusCheckProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        removeTeamAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        removeUserAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        setAppAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        setStatusCheckContexts: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        setTeamAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        setUserAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: [
            "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}",
        ],
        updatePullRequestReviewProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: [
            "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}",
        ],
        updateStatusCheckPotection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
            {},
            { renamed: ["repos", "updateStatusCheckProtection"] },
        ],
        updateStatusCheckProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config",
        ],
        uploadReleaseAsset: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
            { baseUrl: "https://uploads.github.com" },
        ],
    },
    search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"],
    },
    secretScanning: {
        getAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
        ],
        listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/secret-scanning/alerts",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
        ],
    },
    teams: {
        addOrUpdateMembershipForUserInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        addOrUpdateProjectPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        addOrUpdateRepoPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        checkPermissionsForProjectInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        checkPermissionsForRepoInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        ],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        deleteDiscussionInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        getDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        getMembershipForUserInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        ],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/invitations",
        ],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        removeProjectInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        removeRepoInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        updateDiscussionCommentInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        updateDiscussionInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
    },
    users: {
        addEmailForAuthenticated: [
            "POST /user/emails",
            {},
            { renamed: ["users", "addEmailForAuthenticatedUser"] },
        ],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: [
            "POST /user/gpg_keys",
            {},
            { renamed: ["users", "createGpgKeyForAuthenticatedUser"] },
        ],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: [
            "POST /user/keys",
            {},
            { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] },
        ],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        deleteEmailForAuthenticated: [
            "DELETE /user/emails",
            {},
            { renamed: ["users", "deleteEmailForAuthenticatedUser"] },
        ],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] },
        ],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: [
            "DELETE /user/keys/{key_id}",
            {},
            { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] },
        ],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: [
            "GET /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "getGpgKeyForAuthenticatedUser"] },
        ],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: [
            "GET /user/keys/{key_id}",
            {},
            { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] },
        ],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        list: ["GET /users"],
        listBlockedByAuthenticated: [
            "GET /user/blocks",
            {},
            { renamed: ["users", "listBlockedByAuthenticatedUser"] },
        ],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: [
            "GET /user/emails",
            {},
            { renamed: ["users", "listEmailsForAuthenticatedUser"] },
        ],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: [
            "GET /user/following",
            {},
            { renamed: ["users", "listFollowedByAuthenticatedUser"] },
        ],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: [
            "GET /user/gpg_keys",
            {},
            { renamed: ["users", "listGpgKeysForAuthenticatedUser"] },
        ],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: [
            "GET /user/public_emails",
            {},
            { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] },
        ],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: [
            "GET /user/keys",
            {},
            { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] },
        ],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
            "PATCH /user/email/visibility",
            {},
            { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] },
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
            "PATCH /user/email/visibility",
        ],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"],
    },
};

const VERSION = "5.16.2";

function endpointsToMethods(octokit, endpointsMap) {
    const newMethods = {};
    for (const [scope, endpoints] of Object.entries(endpointsMap)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
            const [route, defaults, decorations] = endpoint;
            const [method, url] = route.split(/ /);
            const endpointDefaults = Object.assign({ method, url }, defaults);
            if (!newMethods[scope]) {
                newMethods[scope] = {};
            }
            const scopeMethods = newMethods[scope];
            if (decorations) {
                scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
                continue;
            }
            scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
        }
    }
    return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    /* istanbul ignore next */
    function withDecorations(...args) {
        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
        let options = requestWithDefaults.endpoint.merge(...args);
        // There are currently no other decorations than `.mapToData`
        if (decorations.mapToData) {
            options = Object.assign({}, options, {
                data: options[decorations.mapToData],
                [decorations.mapToData]: undefined,
            });
            return requestWithDefaults(options);
        }
        if (decorations.renamed) {
            const [newScope, newMethodName] = decorations.renamed;
            octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
        }
        if (decorations.deprecated) {
            octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
            // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
            const options = requestWithDefaults.endpoint.merge(...args);
            for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
                if (name in options) {
                    octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
                    if (!(alias in options)) {
                        options[alias] = options[name];
                    }
                    delete options[name];
                }
            }
            return requestWithDefaults(options);
        }
        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
        return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit, Endpoints);
    return {
        rest: api,
    };
}
restEndpointMethods.VERSION = VERSION;
function legacyRestEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit, Endpoints);
    return {
        ...api,
        rest: api,
    };
}
legacyRestEndpointMethods.VERSION = VERSION;


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/request-error/dist-web/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@octokit/request-error/dist-web/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestError": () => (/* binding */ RequestError)
/* harmony export */ });
/* harmony import */ var deprecation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deprecation */ "./node_modules/deprecation/dist-web/index.js");
/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! once */ "./node_modules/once/once.js");
/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_0__);



const logOnceCode = once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation) => console.warn(deprecation));
const logOnceHeaders = once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation) => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */
class RequestError extends Error {
    constructor(message, statusCode, options) {
        super(message);
        // Maintains proper stack trace (only available on V8)
        /* istanbul ignore next */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
            headers = options.headers;
        }
        if ("response" in options) {
            this.response = options.response;
            headers = options.response.headers;
        }
        // redact request credentials without mutating original request options
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
                authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]"),
            });
        }
        requestCopy.url = requestCopy.url
            // client_id & client_secret can be passed as URL query parameters to increase rate limit
            // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
            .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
            // OAuth tokens can be passed as URL query parameters, although it is not recommended
            // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
            .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        // deprecations
        Object.defineProperty(this, "code", {
            get() {
                logOnceCode(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
                return statusCode;
            },
        });
        Object.defineProperty(this, "headers", {
            get() {
                logOnceHeaders(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
                return headers || {};
            },
        });
    }
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@octokit/request/dist-web/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@octokit/request/dist-web/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "request": () => (/* binding */ request)
/* harmony export */ });
/* harmony import */ var _octokit_endpoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/endpoint */ "./node_modules/@octokit/endpoint/dist-web/index.js");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-web/index.js");
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "./node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @octokit/request-error */ "./node_modules/@octokit/request-error/dist-web/index.js");






const VERSION = "5.6.3";

function getBufferResponse(response) {
    return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
    const log = requestOptions.request && requestOptions.request.log
        ? requestOptions.request.log
        : console;
    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(requestOptions.body) ||
        Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    const fetch = (requestOptions.request && requestOptions.request.fetch) || (node_fetch__WEBPACK_IMPORTED_MODULE_1___default());
    return fetch(requestOptions.url, Object.assign({
        method: requestOptions.method,
        body: requestOptions.body,
        headers: requestOptions.headers,
        redirect: requestOptions.redirect,
    }, 
    // `requestOptions.request.agent` type is incompatible
    // see https://github.com/octokit/types.ts/pull/264
    requestOptions.request))
        .then(async (response) => {
        url = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
            headers[keyAndValue[0]] = keyAndValue[1];
        }
        if ("deprecation" in headers) {
            const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
            const deprecationLink = matches && matches.pop();
            log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
        }
        if (status === 204 || status === 205) {
            return;
        }
        // GitHub API returns 200 for HEAD requests
        if (requestOptions.method === "HEAD") {
            if (status < 400) {
                return;
            }
            throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(response.statusText, status, {
                response: {
                    url,
                    status,
                    headers,
                    data: undefined,
                },
                request: requestOptions,
            });
        }
        if (status === 304) {
            throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError("Not modified", status, {
                response: {
                    url,
                    status,
                    headers,
                    data: await getResponseData(response),
                },
                request: requestOptions,
            });
        }
        if (status >= 400) {
            const data = await getResponseData(response);
            const error = new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(toErrorMessage(data), status, {
                response: {
                    url,
                    status,
                    headers,
                    data,
                },
                request: requestOptions,
            });
            throw error;
        }
        return getResponseData(response);
    })
        .then((data) => {
        return {
            status,
            url,
            headers,
            data,
        };
    })
        .catch((error) => {
        if (error instanceof _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError)
            throw error;
        throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(error.message, 500, {
            request: requestOptions,
        });
    });
}
async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
        return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
    }
    return getBufferResponse(response);
}
function toErrorMessage(data) {
    if (typeof data === "string")
        return data;
    // istanbul ignore else - just in case
    if ("message" in data) {
        if (Array.isArray(data.errors)) {
            return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
        }
        return data.message;
    }
    // istanbul ignore next - just in case
    return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults(oldEndpoint, newDefaults) {
    const endpoint = oldEndpoint.defaults(newDefaults);
    const newApi = function (route, parameters) {
        const endpointOptions = endpoint.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
            return fetchWrapper(endpoint.parse(endpointOptions));
        }
        const request = (route, parameters) => {
            return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
        };
        Object.assign(request, {
            endpoint,
            defaults: withDefaults.bind(null, endpoint),
        });
        return endpointOptions.request.hook(request, endpointOptions);
    };
    return Object.assign(newApi, {
        endpoint,
        defaults: withDefaults.bind(null, endpoint),
    });
}

const request = withDefaults(_octokit_endpoint__WEBPACK_IMPORTED_MODULE_3__.endpoint, {
    headers: {
        "user-agent": `octokit-request.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_4__.getUserAgent)()}`,
    },
});


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/amqplib/channel_api.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/channel_api.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var raw_connect = (__webpack_require__(/*! ./lib/connect */ "./node_modules/amqplib/lib/connect.js").connect);
var ChannelModel = (__webpack_require__(/*! ./lib/channel_model */ "./node_modules/amqplib/lib/channel_model.js").ChannelModel);
var promisify = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

function connect(url, connOptions) {
  return promisify(function(cb) {
    return raw_connect(url, connOptions, cb);
  })()
  .then(function(conn) {
    return new ChannelModel(conn);
  });
};

module.exports.connect = connect;
module.exports.credentials = __webpack_require__(/*! ./lib/credentials */ "./node_modules/amqplib/lib/credentials.js");
module.exports.IllegalOperationError = __webpack_require__(/*! ./lib/error */ "./node_modules/amqplib/lib/error.js").IllegalOperationError;


/***/ }),

/***/ "./node_modules/amqplib/lib/api_args.js":
/*!**********************************************!*\
  !*** ./node_modules/amqplib/lib/api_args.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
//
//
//



/*
The channel (promise) and callback APIs have similar signatures, and
in particular, both need AMQP fields prepared from the same arguments
and options. The arguments marshalling is done here. Each of the
procedures below takes arguments and options (the latter in an object)
particular to the operation it represents, and returns an object with
fields for handing to the encoder.
*/

// A number of AMQP methods have a table-typed field called
// `arguments`, that is intended to carry extension-specific
// values. RabbitMQ uses this in a number of places; e.g., to specify
// an 'alternate exchange'.
//
// Many of the methods in this API have an `options` argument, from
// which I take both values that have a default in AMQP (e.g.,
// autoDelete in QueueDeclare) *and* values that are specific to
// RabbitMQ (e.g., 'alternate-exchange'), which would normally be
// supplied in `arguments`. So that extensions I don't support yet can
// be used, I include `arguments` itself among the options.
//
// The upshot of this is that I often need to prepare an `arguments`
// value that has any values passed in `options.arguments` as well as
// any I've promoted to being options themselves. Since I don't want
// to mutate anything passed in, the general pattern is to create a
// fresh object with the `arguments` value given as its prototype; all
// fields in the supplied value will be serialised, as well as any I
// set on the fresh object. What I don't want to do, however, is set a
// field to undefined by copying possibly missing field values,
// because that will mask a value in the prototype.
//
// NB the `arguments` field already has a default value of `{}`, so
// there's no need to explicitly default it unless I'm setting values.
function setIfDefined(obj, prop, value) {
  if (value != undefined) obj[prop] = value;
}

var EMPTY_OPTIONS = Object.freeze({});

var Args = {};

Args.assertQueue = function(queue, options) {
  queue = queue || '';
  options = options || EMPTY_OPTIONS;

  var argt = Object.create(options.arguments || null);
  setIfDefined(argt, 'x-expires', options.expires);
  setIfDefined(argt, 'x-message-ttl', options.messageTtl);
  setIfDefined(argt, 'x-dead-letter-exchange',
               options.deadLetterExchange);
  setIfDefined(argt, 'x-dead-letter-routing-key',
               options.deadLetterRoutingKey);
  setIfDefined(argt, 'x-max-length', options.maxLength);
  setIfDefined(argt, 'x-max-priority', options.maxPriority);
  setIfDefined(argt, 'x-overflow', options.overflow);
  setIfDefined(argt, 'x-queue-mode', options.queueMode);

  return {
    queue: queue,
    exclusive: !!options.exclusive,
    durable: (options.durable === undefined) ? true : options.durable,
    autoDelete: !!options.autoDelete,
    arguments: argt,
    passive: false,
    // deprecated but we have to include it
    ticket: 0,
    nowait: false
  };
};

Args.checkQueue = function(queue) {
  return {
    queue: queue,
    passive: true, // switch to "completely different" mode
    nowait: false,
    durable: true, autoDelete: false, exclusive: false, // ignored
    ticket: 0,
  };
};

Args.deleteQueue = function(queue, options) {
  options = options || EMPTY_OPTIONS;
  return {
    queue: queue,
    ifUnused: !!options.ifUnused,
    ifEmpty: !!options.ifEmpty,
    ticket: 0, nowait: false
  };
};

Args.purgeQueue = function(queue) {
  return {
    queue: queue,
    ticket: 0, nowait: false
  };
};

Args.bindQueue = function(queue, source, pattern, argt) {
  return {
    queue: queue,
    exchange: source,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

Args.unbindQueue = function(queue, source, pattern, argt) {
  return {
    queue: queue,
    exchange: source,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

Args.assertExchange = function(exchange, type, options) {
  options = options || EMPTY_OPTIONS;
  var argt = Object.create(options.arguments || null);
  setIfDefined(argt, 'alternate-exchange', options.alternateExchange);
  return {
    exchange: exchange,
    ticket: 0,
    type: type,
    passive: false,
    durable: (options.durable === undefined) ? true : options.durable,
    autoDelete: !!options.autoDelete,
    internal: !!options.internal,
    nowait: false,
    arguments: argt
  };
};

Args.checkExchange = function(exchange) {
  return {
    exchange: exchange,
    passive: true, // switch to 'may as well be another method' mode
    nowait: false,
    // ff are ignored
    durable: true, internal: false,  type: '',  autoDelete: false,
    ticket: 0
  };
};

Args.deleteExchange = function(exchange, options) {
  options = options || EMPTY_OPTIONS;
  return {
    exchange: exchange,
    ifUnused: !!options.ifUnused,
    ticket: 0, nowait: false
  };
};

Args.bindExchange = function(dest, source, pattern, argt) {
  return {
    source: source,
    destination: dest,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

Args.unbindExchange = function(dest, source, pattern, argt) {
  return {
    source: source,
    destination: dest,
    routingKey: pattern,
    arguments: argt,
    ticket: 0, nowait: false
  };
};

// It's convenient to construct the properties and the method fields
// at the same time, since in the APIs, values for both can appear in
// `options`. Since the property or mthod field names don't overlap, I
// just return one big object that can be used for both purposes, and
// the encoder will pick out what it wants.
Args.publish = function(exchange, routingKey, options) {
  options = options || EMPTY_OPTIONS;

  // The CC and BCC fields expect an array of "longstr", which would
  // normally be buffer values in JavaScript; however, since a field
  // array (or table) cannot have shortstr values, the codec will
  // encode all strings as longstrs anyway.
  function convertCC(cc) {
    if (cc === undefined) {
      return undefined;
    }
    else if (Array.isArray(cc)) {
      return cc.map(String);
    }
    else return [String(cc)];
  }

  var headers = Object.create(options.headers || null);
  setIfDefined(headers, 'CC', convertCC(options.CC));
  setIfDefined(headers, 'BCC', convertCC(options.BCC));

  var deliveryMode; // undefined will default to 1 (non-persistent)

  // Previously I overloaded deliveryMode be a boolean meaning
  // 'persistent or not'; better is to name this option for what it
  // is, but I need to have backwards compatibility for applications
  // that either supply a numeric or boolean value.
  if (options.persistent !== undefined)
    deliveryMode = (options.persistent) ? 2 : 1;
  else if (typeof options.deliveryMode === 'number')
    deliveryMode = options.deliveryMode;
  else if (options.deliveryMode) // is supplied and truthy
    deliveryMode = 2;

  var expiration = options.expiration;
  if (expiration !== undefined) expiration = expiration.toString();

  return {
    // method fields
    exchange: exchange,
    routingKey: routingKey,
    mandatory: !!options.mandatory,
    immediate: false, // RabbitMQ doesn't implement this any more
    ticket: undefined,
    // properties
    contentType: options.contentType,
    contentEncoding: options.contentEncoding,
    headers: headers,
    deliveryMode: deliveryMode,
    priority: options.priority,
    correlationId: options.correlationId,
    replyTo: options.replyTo,
    expiration: expiration,
    messageId: options.messageId,
    timestamp: options.timestamp,
    type: options.type,
    userId: options.userId,
    appId: options.appId,
    clusterId: undefined
  };
};

Args.consume = function(queue, options) {
  options = options || EMPTY_OPTIONS;
  var argt = Object.create(options.arguments || null);
  setIfDefined(argt, 'x-priority', options.priority);
  return {
    ticket: 0,
    queue: queue,
    consumerTag: options.consumerTag || '',
    noLocal: !!options.noLocal,
    noAck: !!options.noAck,
    exclusive: !!options.exclusive,
    nowait: false,
    arguments: argt
  };
};

Args.cancel = function(consumerTag) {
  return {
    consumerTag: consumerTag,
    nowait: false
  };
};

Args.get = function(queue, options) {
  options = options || EMPTY_OPTIONS;
  return {
    ticket: 0,
    queue: queue,
    noAck: !!options.noAck
  };
};

Args.ack = function(tag, allUpTo) {
  return {
    deliveryTag: tag,
    multiple: !!allUpTo
  };
};

Args.nack = function(tag, allUpTo, requeue) {
  return {
    deliveryTag: tag,
    multiple: !!allUpTo,
    requeue: (requeue === undefined) ? true : requeue
  };
};

Args.reject = function(tag, requeue) {
  return {
    deliveryTag: tag,
    requeue: (requeue === undefined) ? true : requeue
  };
};

Args.prefetch = function(count, global) {
  return {
    prefetchCount: count || 0,
    prefetchSize: 0,
    global: !!global
  };
};

Args.recover = function() {
  return {requeue: true};
};

module.exports = Object.freeze(Args);


/***/ }),

/***/ "./node_modules/amqplib/lib/bitset.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/bitset.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
//
//
//



/**
 * A bitset implementation, after that in java.util.  Yes there
 * already exist such things, but none implement next{Clear|Set}Bit or
 * equivalent, and none involved me tooling about for an evening.
 */
class BitSet {
  /**
   * @param {number} [size]
   */
  constructor(size) {
    if (size) {
      const numWords = Math.ceil(size / 32);
      this.words = new Array(numWords);
    }
    else {
      this.words = [];
    }
    this.wordsInUse = 0; // = number, not index
  }

  /**
   * @param {number} numWords
   */
  ensureSize(numWords) {
    const wordsPresent = this.words.length;
    if (wordsPresent < numWords) {
      this.words = this.words.concat(new Array(numWords - wordsPresent));
    }
  }

  /**
   * @param {number} bitIndex
   */
  set(bitIndex) {
    const w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) {
      this.ensureSize(w + 1);
      this.wordsInUse = w + 1;
    }
    const bit = 1 << bitIndex;
    this.words[w] |= bit;
  }

  /**
   * @param {number} bitIndex
   */
  clear(bitIndex) {
    const w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) return;
    const mask = ~(1 << bitIndex);
    this.words[w] &= mask;
  }

  /**
   * @param {number} bitIndex
   */
  get(bitIndex) {
    const w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) return false; // >= since index vs size
    const bit = 1 << bitIndex;
    return !!(this.words[w] & bit);
  }

  /**
   * Give the next bit that is set on or after fromIndex, or -1 if no such bit
   *
   * @param {number} fromIndex
   */
  nextSetBit(fromIndex) {
    let w = wordIndex(fromIndex);
    if (w >= this.wordsInUse) return -1;

    // the right-hand side is shifted to only test the bits of the first
    // word that are > fromIndex
    let word = this.words[w] & (0xffffffff << fromIndex);
    while (true) {
      if (word) return (w * 32) + trailingZeros(word);
      w++;
      if (w === this.wordsInUse) return -1;
      word = this.words[w];
    }
  }

  /**
   * @param {number} fromIndex
   */
  nextClearBit(fromIndex) {
    let w = wordIndex(fromIndex);
    if (w >= this.wordsInUse) return fromIndex;

    let word = ~(this.words[w]) & (0xffffffff << fromIndex);
    while (true) {
      if (word) return (w * 32) + trailingZeros(word);
      w++;
      if (w == this.wordsInUse) return w * 32;
      word = ~(this.words[w]);
    }
  }
}

/**
 * @param {number} bitIndex
 */
function wordIndex(bitIndex) {
  return Math.floor(bitIndex / 32);
}

/**
 * @param {number} i
 */
function trailingZeros(i) {
  // From Hacker's Delight, via JDK. Probably far less effective here,
  // since bit ops are not necessarily the quick way to do things in
  // JS.
  if (i === 0) return 32;
  let y, n = 31;
  y = i << 16; if (y != 0) { n = n -16; i = y; }
  y = i << 8;  if (y != 0) { n = n - 8; i = y; }
  y = i << 4;  if (y != 0) { n = n - 4; i = y; }
  y = i << 2;  if (y != 0) { n = n - 2; i = y; }
  return n - ((i << 1) >>> 31);
}

module.exports.BitSet = BitSet;


/***/ }),

/***/ "./node_modules/amqplib/lib/channel.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/channel.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// Channel machinery.



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var closeMsg = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").closeMessage);
var inspect = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").inspect);
var methodName = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").methodName);
var assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'assert'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);
var fmt = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var IllegalOperationError = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").IllegalOperationError);
var stackCapture = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").stackCapture);
function Channel(connection) {
  EventEmitter.call( this );
  this.connection = connection;
  // for the presently outstanding RPC
  this.reply = null;
  // for the RPCs awaiting action
  this.pending = [];
  // for unconfirmed messages
  this.lwm = 1; // the least, unconfirmed deliveryTag
  this.unconfirmed = []; // rolling window of delivery callbacks
  this.on('ack', this.handleConfirm.bind(this, function(cb) {
    if (cb) cb(null);
  }));
  this.on('nack', this.handleConfirm.bind(this, function(cb) {
    if (cb) cb(new Error('message nacked'));
  }));
  this.on('close', function () {
    var cb;
    while (cb = this.unconfirmed.shift()) {
      if (cb) cb(new Error('channel closed'));
    }
  })
  // message frame state machine
  this.handleMessage = acceptDeliveryOrReturn;
}
inherits(Channel, EventEmitter);

module.exports.Channel = Channel;
module.exports.acceptMessage = acceptMessage;

var C = Channel.prototype;

C.allocate = function() {
  this.ch = this.connection.freshChannel(this);
  return this;
}

// Incoming frames are either notifications of e.g., message delivery,
// or replies to something we've sent. In general I deal with the
// former by emitting an event, and with the latter by keeping a track
// of what's expecting a reply.
//
// The AMQP specification implies that RPCs can't be pipelined; that
// is, you can have only one outstanding RPC on a channel at a
// time. Certainly that's what RabbitMQ and its clients assume. For
// this reason, I buffer RPCs if the channel is already waiting for a
// reply.

// Just send the damn frame.
C.sendImmediately = function(method, fields) {
  return this.connection.sendMethod(this.ch, method, fields);
};

// Invariant: !this.reply -> pending.length == 0. That is, whenever we
// clear a reply, we must send another RPC (and thereby fill
// this.reply) if there is one waiting. The invariant relevant here
// and in `accept`.
C.sendOrEnqueue = function(method, fields, reply) {
  if (!this.reply) { // if no reply waiting, we can go
    assert(this.pending.length === 0);
    this.reply = reply;
    this.sendImmediately(method, fields);
  }
  else {
    this.pending.push({method: method,
                       fields: fields,
                       reply: reply});
  }
};

C.sendMessage = function(fields, properties, content) {
  return this.connection.sendMessage(
    this.ch,
    defs.BasicPublish, fields,
    defs.BasicProperties, properties,
    content);
};

// Internal, synchronously resolved RPC; the return value is resolved
// with the whole frame.
C._rpc = function(method, fields, expect, cb) {
  var self = this;

  function reply(err, f) {
    if (err === null) {
      if (f.id === expect) {
        return cb(null, f);
      }
      else {
        // We have detected a problem, so it's up to us to close the
        // channel
        var expectedName = methodName(expect);

        var e = new Error(fmt("Expected %s; got %s",
                              expectedName, inspect(f, false)));
        self.closeWithError(f.id, fmt('Expected %s; got %s',
                                expectedName, methodName(f.id)),
                            defs.constants.UNEXPECTED_FRAME, e);
        return cb(e);
      }
    }
    // An error will be given if, for example, this is waiting to be
    // sent and the connection closes
    else if (err instanceof Error) return cb(err);
    // A close frame will be given if this is the RPC awaiting reply
    // and the channel is closed by the server
    else {
      // otherwise, it's a close frame
      var closeReason =
        (err.fields.classId << 16) + err.fields.methodId;
      var e = (method === closeReason)
        ? fmt("Operation failed: %s; %s",
              methodName(method), closeMsg(err))
        : fmt("Channel closed by server: %s", closeMsg(err));
      var closeFrameError = new Error(e);
      closeFrameError.code = err.fields.replyCode;
      closeFrameError.classId = err.fields.classId;
      closeFrameError.methodId = err.fields.methodId;
      return cb(closeFrameError);
    }
  }

  this.sendOrEnqueue(method, fields, reply);
};

// Shutdown protocol. There's three scenarios:
//
// 1. The application decides to shut the channel
// 2. The server decides to shut the channel, possibly because of
// something the application did
// 3. The connection is closing, so there won't be any more frames
// going back and forth.
//
// 1 and 2 involve an exchange of method frames (Close and CloseOk),
// while 3 doesn't; the connection simply says "shutdown" to the
// channel, which then acts as if it's closing, without going through
// the exchange.

function invalidOp(msg, stack) {
  return function() {
    throw new IllegalOperationError(msg, stack);
  };
}

function invalidateSend(ch, msg, stack) {
  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage =
    invalidOp(msg, stack);
}

// Move to entirely closed state.
C.toClosed = function(capturedStack) {
  this._rejectPending();
  invalidateSend(this, 'Channel closed', capturedStack);
  this.accept = invalidOp('Channel closed', capturedStack);
  this.connection.releaseChannel(this.ch);
  this.emit('close');
};

// Stop being able to send and receive methods and content. Used when
// we close the channel. Invokes the continuation once the server has
// acknowledged the close, but before the channel is moved to the
// closed state.
C.toClosing = function(capturedStack, k) {
  var send = this.sendImmediately.bind(this);
  invalidateSend(this, 'Channel closing', capturedStack);

  this.accept = function(f) {
    if (f.id === defs.ChannelCloseOk) {
      if (k) k();
      var s = stackCapture('ChannelCloseOk frame received');
      this.toClosed(s);
    }
    else if (f.id === defs.ChannelClose) {
      send(defs.ChannelCloseOk, {});
    }
    // else ignore frame
  };
};

C._rejectPending = function() {
  function rej(r) {
    r(new Error("Channel ended, no reply will be forthcoming"));
  }
  if (this.reply !== null) rej(this.reply);
  this.reply = null;

  var discard;
  while (discard = this.pending.shift()) rej(discard.reply);
  this.pending = null; // so pushes will break
};

C.closeBecause = function(reason, code, k) {
  this.sendImmediately(defs.ChannelClose, {
    replyText: reason,
    replyCode: code,
    methodId:0, classId: 0
  });
  var s = stackCapture('closeBecause called: ' + reason);
  this.toClosing(s, k);
};

// If we close because there's been an error, we need to distinguish
// between what we tell the server (`reason`) and what we report as
// the cause in the client (`error`).
C.closeWithError = function(id, reason, code, error) {
  var self = this;
  this.closeBecause(reason, code, function() {
    error.code = code;
    // content frames and consumer errors do not provide a method a class/method ID
    if (id) {
      error.classId = defs.info(id).classId;
      error.methodId = defs.info(id).methodId;
    }
    self.emit('error', error);
  });
};

// A trampolining state machine for message frames on a channel. A
// message arrives in at least two frames: first, a method announcing
// the message (either a BasicDeliver or BasicGetOk); then, a message
// header with the message properties; then, zero or more content
// frames.

// Keep the try/catch localised, in an attempt to avoid disabling
// optimisation
C.acceptMessageFrame = function(f) {
  try {
    this.handleMessage = this.handleMessage(f);
  }
  catch (msg) {
    if (typeof msg === 'string') {
      this.closeWithError(f.id, msg, defs.constants.UNEXPECTED_FRAME,
                          new Error(msg));
    }
    else if (msg instanceof Error) {
      this.closeWithError(f.id, 'Error while processing message',
                          defs.constants.INTERNAL_ERROR, msg);
    }
    else {
      this.closeWithError(f.id, 'Internal error while processing message',
                          defs.constants.INTERNAL_ERROR,
                          new Error(msg.toString()));
    }
  }
};

// Kick off a message delivery given a BasicDeliver or BasicReturn
// frame (BasicGet uses the RPC mechanism)
function acceptDeliveryOrReturn(f) {
  var event;
  if (f.id === defs.BasicDeliver) event = 'delivery';
  else if (f.id === defs.BasicReturn) event = 'return';
  else throw fmt("Expected BasicDeliver or BasicReturn; got %s",
                 inspect(f));

  var self = this;
  var fields = f.fields;
  return acceptMessage(function(message) {
    message.fields = fields;
    self.emit(event, message);
  });
}

// Move to the state of waiting for message frames (headers, then
// one or more content frames)
function acceptMessage(continuation) {
  var totalSize = 0, remaining = 0;
  var buffers = null;

  var message = {
    fields: null,
    properties: null,
    content: null
  };

  return headers;

  // expect a headers frame
  function headers(f) {
    if (f.id === defs.BasicProperties) {
      message.properties = f.fields;
      totalSize = remaining = f.size;

      // for zero-length messages, content frames aren't required.
      if (totalSize === 0) {
        message.content = Buffer.alloc(0);
        continuation(message);
        return acceptDeliveryOrReturn;
      }
      else {
        return content;
      }
    }
    else {
      throw "Expected headers frame after delivery";
    }
  }

  // expect a content frame
  // %%% TODO cancelled messages (sent as zero-length content frame)
  function content(f) {
    if (f.content) {
      var size = f.content.length;
      remaining -= size;
      if (remaining === 0) {
        if (buffers !== null) {
          buffers.push(f.content);
          message.content = Buffer.concat(buffers);
        }
        else {
          message.content = f.content;
        }
        continuation(message);
        return acceptDeliveryOrReturn;
      }
      else if (remaining < 0) {
        throw fmt("Too much content sent! Expected %d bytes",
                  totalSize);
      }
      else {
        if (buffers !== null)
          buffers.push(f.content);
        else
          buffers = [f.content];
        return content;
      }
    }
    else throw "Expected content frame after headers"
  }
}

C.handleConfirm = function(handle, f) {
  var tag = f.deliveryTag;
  var multi = f.multiple;

  if (multi) {
    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);
    this.lwm = tag + 1;
    confirmed.forEach(handle);
  }
  else {
    var c;
    if (tag === this.lwm) {
      c = this.unconfirmed.shift();
      this.lwm++;
      // Advance the LWM and the window to the next non-gap, or
      // possibly to the end
      while (this.unconfirmed[0] === null) {
        this.unconfirmed.shift();
        this.lwm++;
      }
    }
    else {
      c = this.unconfirmed[tag - this.lwm];
      this.unconfirmed[tag - this.lwm] = null;
    }
    // Technically, in the single-deliveryTag case, I should report a
    // protocol breach if it's already been confirmed.
    handle(c);
  }
};

C.pushConfirmCallback = function(cb) {
  // `null` is used specifically for marking already confirmed slots,
  // so I coerce `undefined` and `null` to false; functions are never
  // falsey.
  this.unconfirmed.push(cb || false);
};

// Interface for connection to use

C.accept = function(f) {

  switch (f.id) {

    // Message frames
  case undefined: // content frame!
  case defs.BasicDeliver:
  case defs.BasicReturn:
  case defs.BasicProperties:
    return this.acceptMessageFrame(f);

    // confirmations, need to do confirm.select first
  case defs.BasicAck:
    return this.emit('ack', f.fields);
  case defs.BasicNack:
    return this.emit('nack', f.fields);
  case defs.BasicCancel:
    // The broker can send this if e.g., the queue is deleted.
    return this.emit('cancel', f.fields);

  case defs.ChannelClose:
    // Any remote closure is an error to us. Reject the pending reply
    // with the close frame, so it can see whether it was that
    // operation that caused it to close.
    if (this.reply) {
      var reply = this.reply; this.reply = null;
      reply(f);
    }
    var emsg = "Channel closed by server: " + closeMsg(f);
    this.sendImmediately(defs.ChannelCloseOk, {});

    var error = new Error(emsg);
    error.code = f.fields.replyCode;
    error.classId = f.fields.classId;
    error.methodId = f.fields.methodId;
    this.emit('error', error);

    var s = stackCapture(emsg);
    this.toClosed(s);
    return;

  case defs.BasicFlow:
    // RabbitMQ doesn't send this, it just blocks the TCP socket
    return this.closeWithError(f.id, "Flow not implemented",
                               defs.constants.NOT_IMPLEMENTED,
                               new Error('Flow not implemented'));

  default: // assume all other things are replies
    // Resolving the reply may lead to another RPC; to make sure we
    // don't hold that up, clear this.reply
    var reply = this.reply; this.reply = null;
    // however, maybe there's an RPC waiting to go? If so, that'll
    // fill this.reply again, restoring the invariant. This does rely
    // on any response being recv'ed after resolving the promise,
    // below; hence, I use synchronous defer.
    if (this.pending.length > 0) {
      var send = this.pending.shift();
      this.reply = send.reply;
      this.sendImmediately(send.method, send.fields);
    }
    return reply(null, f);
  }
};

C.onBufferDrain = function() {
  this.emit('drain');
};


// This adds just a bit more stuff useful for the APIs, but not
// low-level machinery.
function BaseChannel(connection) {
  Channel.call(this, connection);
  this.consumers = new Map();
}
inherits(BaseChannel, Channel);

module.exports.BaseChannel = BaseChannel;

// Not sure I like the ff, it's going to be changing hidden classes
// all over the place. On the other hand, whaddya do.
BaseChannel.prototype.registerConsumer = function(tag, callback) {
  this.consumers.set(tag, callback);
};

BaseChannel.prototype.unregisterConsumer = function(tag) {
  this.consumers.delete(tag);
};

BaseChannel.prototype.dispatchMessage = function(fields, message) {
  var consumerTag = fields.consumerTag;
  var consumer = this.consumers.get(consumerTag);
  if (consumer) {
    return consumer(message);
  }
  else {
    // %%% Surely a race here
    throw new Error("Unknown consumer: " + consumerTag);
  }
};

BaseChannel.prototype.handleDelivery = function(message) {
  return this.dispatchMessage(message.fields, message);
};

BaseChannel.prototype.handleCancel = function(fields) {
  var result = this.dispatchMessage(fields, null);
  this.unregisterConsumer(fields.consumerTag);
  return result;
};


/***/ }),

/***/ "./node_modules/amqplib/lib/channel_model.js":
/*!***************************************************!*\
  !*** ./node_modules/amqplib/lib/channel_model.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//



const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const promisify = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
const defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
const {BaseChannel} = __webpack_require__(/*! ./channel */ "./node_modules/amqplib/lib/channel.js");
const {acceptMessage} = __webpack_require__(/*! ./channel */ "./node_modules/amqplib/lib/channel.js");
const Args = __webpack_require__(/*! ./api_args */ "./node_modules/amqplib/lib/api_args.js");
const {inspect} = __webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js");

class ChannelModel extends EventEmitter {
  constructor(connection) {
    super();
    this.connection = connection;

    ['error', 'close', 'blocked', 'unblocked'].forEach(ev => {
      connection.on(ev, this.emit.bind(this, ev));
    });
  }

  close() {
    return promisify(this.connection.close.bind(this.connection))();
  }

  async createChannel() {
    const channel = new Channel(this.connection);
    await channel.open();
    return channel;
  }

  async createConfirmChannel() {
    const channel = new ConfirmChannel(this.connection);
    await channel.open();
    await channel.rpc(defs.ConfirmSelect, {nowait: false}, defs.ConfirmSelectOk);
    return channel;
  }
}

// Channels

class Channel extends BaseChannel {
  constructor(connection) {
    super(connection);
    this.on('delivery', this.handleDelivery.bind(this));
    this.on('cancel', this.handleCancel.bind(this));
  }

  // An RPC that returns a 'proper' promise, which resolves to just the
  // response's fields; this is intended to be suitable for implementing
  // API procedures.
  async rpc(method, fields, expect) {
    const f = await promisify(cb => {
      return this._rpc(method, fields, expect, cb);
    })();

    return f.fields;
  }

  // Do the remarkably simple channel open handshake
  async open() {
    const ch = await this.allocate.bind(this)();
    return ch.rpc(defs.ChannelOpen, {outOfBand: ""},
                  defs.ChannelOpenOk);
  }

  close() {
    return promisify(cb => {
      return this.closeBecause("Goodbye", defs.constants.REPLY_SUCCESS,
                      cb);
    })();
  }

  // === Public API, declaring queues and stuff ===

  assertQueue(queue, options) {
    return this.rpc(defs.QueueDeclare,
                    Args.assertQueue(queue, options),
                    defs.QueueDeclareOk);
  }

  checkQueue(queue) {
    return this.rpc(defs.QueueDeclare,
                    Args.checkQueue(queue),
                    defs.QueueDeclareOk);
  }

  deleteQueue(queue, options) {
    return this.rpc(defs.QueueDelete,
                    Args.deleteQueue(queue, options),
                    defs.QueueDeleteOk);
  }

  purgeQueue(queue) {
    return this.rpc(defs.QueuePurge,
                    Args.purgeQueue(queue),
                    defs.QueuePurgeOk);
  }

  bindQueue(queue, source, pattern, argt) {
    return this.rpc(defs.QueueBind,
                    Args.bindQueue(queue, source, pattern, argt),
                    defs.QueueBindOk);
  }

  unbindQueue(queue, source, pattern, argt) {
    return this.rpc(defs.QueueUnbind,
                    Args.unbindQueue(queue, source, pattern, argt),
                    defs.QueueUnbindOk);
  }

  assertExchange(exchange, type, options) {
    // The server reply is an empty set of fields, but it's convenient
    // to have the exchange name handed to the continuation.
    return this.rpc(defs.ExchangeDeclare,
                    Args.assertExchange(exchange, type, options),
                    defs.ExchangeDeclareOk)
      .then(_ok => { return { exchange }; });
  }

  checkExchange(exchange) {
    return this.rpc(defs.ExchangeDeclare,
                    Args.checkExchange(exchange),
                    defs.ExchangeDeclareOk);
  }

  deleteExchange(name, options) {
    return this.rpc(defs.ExchangeDelete,
                    Args.deleteExchange(name, options),
                    defs.ExchangeDeleteOk);
  }

  bindExchange(dest, source, pattern, argt) {
    return this.rpc(defs.ExchangeBind,
                    Args.bindExchange(dest, source, pattern, argt),
                    defs.ExchangeBindOk);
  }

  unbindExchange(dest, source, pattern, argt) {
    return this.rpc(defs.ExchangeUnbind,
                    Args.unbindExchange(dest, source, pattern, argt),
                    defs.ExchangeUnbindOk);
  }

  // Working with messages

  publish(exchange, routingKey, content, options) {
    const fieldsAndProps = Args.publish(exchange, routingKey, options);
    return this.sendMessage(fieldsAndProps, fieldsAndProps, content);
  }

  sendToQueue(queue, content, options) {
    return this.publish('', queue, content, options);
  }

  consume(queue, callback, options) {
    // NB we want the callback to be run synchronously, so that we've
    // registered the consumerTag before any messages can arrive.
    const fields = Args.consume(queue, options);
    return new Promise((resolve, reject) => {
      this._rpc(defs.BasicConsume, fields, defs.BasicConsumeOk, (err, ok) => {
        if (err) return reject(err);
        this.registerConsumer(ok.fields.consumerTag, callback);
        resolve(ok.fields);
      });
    });
  }

  async cancel(consumerTag) {
    const ok = await promisify(cb => {
      this._rpc(defs.BasicCancel, Args.cancel(consumerTag),
            defs.BasicCancelOk,
            cb);
    })()
    .then(ok => {
      this.unregisterConsumer(consumerTag);
      return ok.fields;
    });
  }

  get(queue, options) {
    const fields = Args.get(queue, options);
    return new Promise((resolve, reject) => {
      this.sendOrEnqueue(defs.BasicGet, fields, (err, f) => {
        if (err) return reject(err);
        if (f.id === defs.BasicGetEmpty) {
          return resolve(false);
        }
        else if (f.id === defs.BasicGetOk) {
          const fields = f.fields;
          this.handleMessage = acceptMessage(m => {
            m.fields = fields;
            resolve(m);
          });
        }
        else {
          reject(new Error(`Unexpected response to BasicGet: ${inspect(f)}`));
        }
      });
    });
  }

  ack(message, allUpTo) {
    this.sendImmediately(
      defs.BasicAck,
      Args.ack(message.fields.deliveryTag, allUpTo));
  }

  ackAll() {
    this.sendImmediately(defs.BasicAck, Args.ack(0, true));
  }

  nack(message, allUpTo, requeue) {
    this.sendImmediately(
      defs.BasicNack,
      Args.nack(message.fields.deliveryTag, allUpTo, requeue));
  }

  nackAll(requeue) {
    this.sendImmediately(defs.BasicNack,
                         Args.nack(0, true, requeue));
  }

  // `Basic.Nack` is not available in older RabbitMQ versions (or in the
  // AMQP specification), so you have to use the one-at-a-time
  // `Basic.Reject`. This is otherwise synonymous with
  // `#nack(message, false, requeue)`.
  reject(message, requeue) {
    this.sendImmediately(
      defs.BasicReject,
      Args.reject(message.fields.deliveryTag, requeue));
  }

  recover() {
    return this.rpc(defs.BasicRecover,
                    Args.recover(),
                    defs.BasicRecoverOk);
  }

  qos(count, global) {
    return this.rpc(defs.BasicQos,
                    Args.prefetch(count, global),
                    defs.BasicQosOk);
  }
}

// There are more options in AMQP than exposed here; RabbitMQ only
// implements prefetch based on message count, and only for individual
// channels or consumers. RabbitMQ v3.3.0 and after treat prefetch
// (without `global` set) as per-consumer (for consumers following),
// and prefetch with `global` set as per-channel.
Channel.prototype.prefetch = Channel.prototype.qos

// Confirm channel. This is a channel with confirms 'switched on',
// meaning sent messages will provoke a responding 'ack' or 'nack'
// from the server. The upshot of this is that `publish` and
// `sendToQueue` both take a callback, which will be called either
// with `null` as its argument to signify 'ack', or an exception as
// its argument to signify 'nack'.

class ConfirmChannel extends Channel {
  publish(exchange, routingKey, content, options, cb) {
    this.pushConfirmCallback(cb);
    return Channel.prototype.publish.call(this, exchange, routingKey, content, options);
  }

  sendToQueue(queue, content, options, cb) {
    return this.publish('', queue, content, options, cb);
  }

  waitForConfirms() {
    const awaiting = [];
    const unconfirmed = this.unconfirmed;
    unconfirmed.forEach((val, index) => {
      if (val !== null) {
        const confirmed = new Promise((resolve, reject) => {
          unconfirmed[index] = err => {
            if (val) val(err);
            if (err === null) resolve();
            else reject(err);
          };
        });
        awaiting.push(confirmed);
      }
    });
    // Channel closed
    if (!this.pending) {
      var cb;
      while (cb = this.unconfirmed.shift()) {
        if (cb) cb(new Error('channel closed'));
      }
    }
    return Promise.all(awaiting);
  }
}

module.exports.ConfirmChannel = ConfirmChannel;
module.exports.Channel = Channel;
module.exports.ChannelModel = ChannelModel;


/***/ }),

/***/ "./node_modules/amqplib/lib/codec.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/codec.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

/*

The AMQP 0-9-1 is a mess when it comes to the types that can be
encoded on the wire.

There are four encoding schemes, and three overlapping sets of types:
frames, methods, (field-)tables, and properties.

Each *frame type* has a set layout in which values of given types are
concatenated along with sections of "raw binary" data.

In frames there are `shortstr`s, that is length-prefixed strings of
UTF8 chars, 8 bit unsigned integers (called `octet`), unsigned 16 bit
integers (called `short` or `short-uint`), unsigned 32 bit integers
(called `long` or `long-uint`), unsigned 64 bit integers (called
`longlong` or `longlong-uint`), and flags (called `bit`).

Methods are encoded as a frame giving a method ID and a sequence of
arguments of known types. The encoded method argument values are
concatenated (with some fun complications around "packing" consecutive
bit values into bytes).

Along with the types given in frames, method arguments may be long
byte strings (`longstr`, not required to be UTF8) or 64 bit unsigned
integers to be interpreted as timestamps (yeah I don't know why
either), or arbitrary sets of key-value pairs (called `field-table`).

Inside a field table the keys are `shortstr` and the values are
prefixed with a byte tag giving the type. The types are any of the
above except for bits (which are replaced by byte-wide `bool`), along
with a NULL value `void`, a special fixed-precision number encoding
(`decimal`), IEEE754 `float`s and `double`s, signed integers,
`field-array` (a sequence of tagged values), and nested field-tables.

RabbitMQ and QPid use a subset of the field-table types, and different
value tags, established before the AMQP 0-9-1 specification was
published. So far as I know, no-one uses the types and tags as
published. http://www.rabbitmq.com/amqp-0-9-1-errata.html gives the
list of field-table types.

Lastly, there are (sets of) properties, only one of which is given in
AMQP 0-9-1: `BasicProperties`. These are almost the same as methods,
except that they appear in content header frames, which include a
content size, and they carry a set of flags indicating which
properties are present. This scheme can save ones of bytes per message
(messages which take a minimum of three frames each to send).

*/



var ints = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js");

// JavaScript uses only doubles so what I'm testing for is whether
// it's *better* to encode a number as a float or double. This really
// just amounts to testing whether there's a fractional part to the
// number, except that see below. NB I don't use bitwise operations to
// do this 'efficiently' -- it would mask the number to 32 bits.
//
// At 2^50, doubles don't have sufficient precision to distinguish
// between floating point and integer numbers (`Math.pow(2, 50) + 0.1
// === Math.pow(2, 50)` (and, above 2^53, doubles cannot represent all
// integers (`Math.pow(2, 53) + 1 === Math.pow(2, 53)`)). Hence
// anything with a magnitude at or above 2^50 may as well be encoded
// as a 64-bit integer. Except that only signed integers are supported
// by RabbitMQ, so anything above 2^63 - 1 must be a double.
function isFloatingPoint(n) {
    return n >= 0x8000000000000000 ||
        (Math.abs(n) < 0x4000000000000
         && Math.floor(n) !== n);
}

function encodeTable(buffer, val, offset) {
    var start = offset;
    offset += 4; // leave room for the table length
    for (var key in val) {
        if (val[key] !== undefined) {
          var len = Buffer.byteLength(key);
          buffer.writeUInt8(len, offset); offset++;
          buffer.write(key, offset, 'utf8'); offset += len;
          offset += encodeFieldValue(buffer, val[key], offset);
        }
    }
    var size = offset - start;
    buffer.writeUInt32BE(size - 4, start);
    return size;
}

function encodeArray(buffer, val, offset) {
    var start = offset;
    offset += 4;
    for (var i=0, num=val.length; i < num; i++) {
        offset += encodeFieldValue(buffer, val[i], offset);
    }
    var size = offset - start;
    buffer.writeUInt32BE(size - 4, start);
    return size;
}

function encodeFieldValue(buffer, value, offset) {
    var start = offset;
    var type = typeof value, val = value;
    // A trapdoor for specifying a type, e.g., timestamp
    if (value && type === 'object' && value.hasOwnProperty('!')) {
        val = value.value;
        type = value['!'];
    }

    // If it's a JS number, we'll have to guess what type to encode it
    // as.
    if (type == 'number') {
        // Making assumptions about the kind of number (floating point
        // v integer, signed, unsigned, size) desired is dangerous in
        // general; however, in practice RabbitMQ uses only
        // longstrings and unsigned integers in its arguments, and
        // other clients generally conflate number types anyway. So
        // the only distinction we care about is floating point vs
        // integers, preferring integers since those can be promoted
        // if necessary. If floating point is required, we may as well
        // use double precision.
        if (isFloatingPoint(val)) {
            type = 'double';
        }
        else { // only signed values are used in tables by
               // RabbitMQ. It *used* to (< v3.3.0) treat the byte 'b'
               // type as unsigned, but most clients (and the spec)
               // think it's signed, and now RabbitMQ does too.
            if (val < 128 && val >= -128) {
                type = 'byte';
            }
            else if (val >= -0x8000 && val < 0x8000) {
                type = 'short'
            }
            else if (val >= -0x80000000 && val < 0x80000000) {
                type = 'int';
            }
            else {
                type = 'long';
            }
        }
    }

    function tag(t) { buffer.write(t, offset); offset++; }

    switch (type) {
    case 'string': // no shortstr in field tables
        var len = Buffer.byteLength(val, 'utf8');
        tag('S');
        buffer.writeUInt32BE(len, offset); offset += 4;
        buffer.write(val, offset, 'utf8'); offset += len;
        break;
    case 'object':
        if (val === null) {
            tag('V');
        }
        else if (Array.isArray(val)) {
            tag('A');
            offset += encodeArray(buffer, val, offset);
        }
        else if (Buffer.isBuffer(val)) {
            tag('x');
            buffer.writeUInt32BE(val.length, offset); offset += 4;
            val.copy(buffer, offset); offset += val.length;
        }
        else {
            tag('F');
            offset += encodeTable(buffer, val, offset);
        }
        break;
    case 'boolean':
        tag('t');
        buffer.writeUInt8((val) ? 1 : 0, offset); offset++;
        break;
    // These are the types that are either guessed above, or
    // explicitly given using the {'!': type} notation.
    case 'double':
    case 'float64':
        tag('d');
        buffer.writeDoubleBE(val, offset);
        offset += 8;
        break;
    case 'byte':
    case 'int8':
        tag('b');
        buffer.writeInt8(val, offset); offset++;
        break;
    case 'short':
    case 'int16':
        tag('s');
        buffer.writeInt16BE(val, offset); offset += 2;
        break;
    case 'int':
    case 'int32':
        tag('I');
        buffer.writeInt32BE(val, offset); offset += 4;
        break;
    case 'long':
    case 'int64':
        tag('l');
        ints.writeInt64BE(buffer, val, offset); offset += 8;
        break;

    // Now for exotic types, those can _only_ be denoted by using
    // `{'!': type, value: val}
    case 'timestamp':
        tag('T');
        ints.writeUInt64BE(buffer, val, offset); offset += 8;
        break;
    case 'float':
        tag('f');
        buffer.writeFloatBE(val, offset); offset += 4;
        break;
    case 'decimal':
        tag('D');
        if (val.hasOwnProperty('places') && val.hasOwnProperty('digits')
            && val.places >= 0 && val.places < 256) {
            buffer[offset] = val.places; offset++;
            buffer.writeUInt32BE(val.digits, offset); offset += 4;
        }
        else throw new TypeError(
            "Decimal value must be {'places': 0..255, 'digits': uint32}, " +
                "got " + JSON.stringify(val));
        break;
    default:
        throw new TypeError('Unknown type to encode: ' + type);
    }
    return offset - start;
}

// Assume we're given a slice of the buffer that contains just the
// fields.
function decodeFields(slice) {
    var fields = {}, offset = 0, size = slice.length;
    var len, key, val;

    function decodeFieldValue() {
        var tag = String.fromCharCode(slice[offset]); offset++;
        switch (tag) {
        case 'b':
            val = slice.readInt8(offset); offset++;
            break;
        case 'S':
            len = slice.readUInt32BE(offset); offset += 4;
            val = slice.toString('utf8', offset, offset + len);
            offset += len;
            break;
        case 'I':
            val = slice.readInt32BE(offset); offset += 4;
            break;
        case 'D': // only positive decimals, apparently.
            var places = slice[offset]; offset++;
            var digits = slice.readUInt32BE(offset); offset += 4;
            val = {'!': 'decimal', value: {places: places, digits: digits}};
            break;
        case 'T':
            val = ints.readUInt64BE(slice, offset); offset += 8;
            val = {'!': 'timestamp', value: val};
            break;
        case 'F':
            len = slice.readUInt32BE(offset); offset += 4;
            val = decodeFields(slice.slice(offset, offset + len));
            offset += len;
            break;
        case 'A':
            len = slice.readUInt32BE(offset); offset += 4;
            decodeArray(offset + len);
            // NB decodeArray will itself update offset and val
            break;
        case 'd':
            val = slice.readDoubleBE(offset); offset += 8;
            break;
        case 'f':
            val = slice.readFloatBE(offset); offset += 4;
            break;
        case 'l':
            val = ints.readInt64BE(slice, offset); offset += 8;
            break;
        case 's':
            val = slice.readInt16BE(offset); offset += 2;
            break;
        case 't':
            val = slice[offset] != 0; offset++;
            break;
        case 'V':
            val = null;
            break;
        case 'x':
            len = slice.readUInt32BE(offset); offset += 4;
            val = slice.slice(offset, offset + len);
            offset += len;
            break;
        default:
            throw new TypeError('Unexpected type tag "' + tag +'"');
        }
    }

    function decodeArray(until) {
        var vals = [];
        while (offset < until) {
            decodeFieldValue();
            vals.push(val);
        }
        val = vals;
    }

    while (offset < size) {
        len = slice.readUInt8(offset); offset++;
        key = slice.toString('utf8', offset, offset + len);
        offset += len;
        decodeFieldValue();
        fields[key] = val;
    }
    return fields;
}

module.exports.encodeTable = encodeTable;
module.exports.decodeFields = decodeFields;


/***/ }),

/***/ "./node_modules/amqplib/lib/connect.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/connect.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// General-purpose API for glueing everything together.



var URL = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");
var QS = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'querystring'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var Connection = (__webpack_require__(/*! ./connection */ "./node_modules/amqplib/lib/connection.js").Connection);
var fmt = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var credentials = __webpack_require__(/*! ./credentials */ "./node_modules/amqplib/lib/credentials.js");

function copyInto(obj, target) {
  var keys = Object.keys(obj);
  var i = keys.length;
  while (i--) {
    var k = keys[i];
    target[k] = obj[k];
  }
  return target;
}

// Adapted from util._extend, which is too fringe to use.
function clone(obj) {
  return copyInto(obj, {});
}

var CLIENT_PROPERTIES = {
  "product": "amqplib",
  "version": (__webpack_require__(/*! ../package.json */ "./node_modules/amqplib/package.json").version),
  "platform": fmt('Node.JS %s', process.version),
  "information": "http://squaremo.github.io/amqp.node",
  "capabilities": {
    "publisher_confirms": true,
    "exchange_exchange_bindings": true,
    "basic.nack": true,
    "consumer_cancel_notify": true,
    "connection.blocked": true,
    "authentication_failure_close": true
  }
};

// Construct the main frames used in the opening handshake
function openFrames(vhost, query, credentials, extraClientProperties) {
  if (!vhost)
    vhost = '/';
  else
    vhost = QS.unescape(vhost);

  var query = query || {};

  function intOrDefault(val, def) {
    return (val === undefined) ? def : parseInt(val);
  }

  var clientProperties = Object.create(CLIENT_PROPERTIES);

  return {
    // start-ok
    'clientProperties': copyInto(extraClientProperties, clientProperties),
    'mechanism': credentials.mechanism,
    'response': credentials.response(),
    'locale': query.locale || 'en_US',

    // tune-ok
    'channelMax': intOrDefault(query.channelMax, 0),
    'frameMax': intOrDefault(query.frameMax, 0x1000),
    'heartbeat': intOrDefault(query.heartbeat, 0),

    // open
    'virtualHost': vhost,
    'capabilities': '',
    'insist': 0
  };
}

// Decide on credentials based on what we're supplied.
function credentialsFromUrl(parts) {
  var user = 'guest', passwd = 'guest';
  if (parts.username != '' || parts.password != '') {
    user = (parts.username) ? unescape(parts.username) : '';
    passwd = (parts.password) ? unescape(parts.password) : '';
  }
  return credentials.plain(user, passwd);
}

function connect(url, socketOptions, openCallback) {
  // tls.connect uses `util._extend()` on the options given it, which
  // copies only properties mentioned in `Object.keys()`, when
  // processing the options. So I have to make copies too, rather
  // than using `Object.create()`.
  var sockopts = clone(socketOptions || {});
  url = url || 'amqp://localhost';

  var noDelay = !!sockopts.noDelay;
  var timeout = sockopts.timeout;
  var keepAlive = !!sockopts.keepAlive;
  // 0 is default for node
  var keepAliveDelay = sockopts.keepAliveDelay || 0;

  var extraClientProperties = sockopts.clientProperties || {};

  var protocol, fields;
  if (typeof url === 'object') {
    protocol = (url.protocol || 'amqp') + ':';
    sockopts.host = url.hostname;
    sockopts.servername = sockopts.servername || url.hostname;
    sockopts.port = url.port || ((protocol === 'amqp:') ? 5672 : 5671);

    var user, pass;
    // Only default if both are missing, to have the same behaviour as
    // the stringly URL.
    if (url.username == undefined && url.password == undefined) {
      user = 'guest'; pass = 'guest';
    } else {
      user = url.username || '';
      pass = url.password || '';
    }

    var config = {
      locale: url.locale,
      channelMax: url.channelMax,
      frameMax: url.frameMax,
      heartbeat: url.heartbeat,
    };

    fields = openFrames(url.vhost, config, sockopts.credentials || credentials.plain(user, pass), extraClientProperties);
  } else {
    var parts = URL(url, true); // yes, parse the query string
    protocol = parts.protocol;
    sockopts.host = parts.hostname;
    sockopts.servername = sockopts.servername || parts.hostname;
    sockopts.port = parseInt(parts.port) || ((protocol === 'amqp:') ? 5672 : 5671);
    var vhost = parts.pathname ? parts.pathname.substr(1) : null;
    fields = openFrames(vhost, parts.query, sockopts.credentials || credentialsFromUrl(parts), extraClientProperties);
  }

  var sockok = false;
  var sock;

  function onConnect() {
    sockok = true;
    sock.setNoDelay(noDelay);
    if (keepAlive) sock.setKeepAlive(keepAlive, keepAliveDelay);

    var c = new Connection(sock);
    c.open(fields, function(err, ok) {
      // disable timeout once the connection is open, we don't want
      // it fouling things
      if (timeout) sock.setTimeout(0);
      if (err === null) {
        openCallback(null, c);
      } else {
        // The connection isn't closed by the server on e.g. wrong password
        sock.end();
        sock.destroy();
        openCallback(err);
      }
    });
  }

  if (protocol === 'amqp:') {
    sock = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(sockopts, onConnect);
  }
  else if (protocol === 'amqps:') {
    sock = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(sockopts, onConnect);
  }
  else {
    throw new Error("Expected amqp: or amqps: as the protocol; got " + protocol);
  }

  if (timeout) {
    sock.setTimeout(timeout, function() {
      sock.end();
      sock.destroy();
      openCallback(new Error('connect ETIMEDOUT'));
    });
  }

  sock.once('error', function(err) {
    if (!sockok) openCallback(err);
  });

}

module.exports.connect = connect;
module.exports.credentialsFromUrl = credentialsFromUrl;


/***/ }),

/***/ "./node_modules/amqplib/lib/connection.js":
/*!************************************************!*\
  !*** ./node_modules/amqplib/lib/connection.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var constants = defs.constants;
var frame = __webpack_require__(/*! ./frame */ "./node_modules/amqplib/lib/frame.js");
var HEARTBEAT = frame.HEARTBEAT;
var Mux = (__webpack_require__(/*! ./mux */ "./node_modules/amqplib/lib/mux.js").Mux);

var Duplex =
  Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) ||
  __webpack_require__(/*! readable-stream/duplex */ "./node_modules/readable-stream/duplex.js");
var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);
var Heart = (__webpack_require__(/*! ./heartbeat */ "./node_modules/amqplib/lib/heartbeat.js").Heart);

var methodName = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").methodName);
var closeMsg = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").closeMessage);
var inspect = (__webpack_require__(/*! ./format */ "./node_modules/amqplib/lib/format.js").inspect);

var BitSet = (__webpack_require__(/*! ./bitset */ "./node_modules/amqplib/lib/bitset.js").BitSet);
var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var fmt = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var PassThrough = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) ||
  __webpack_require__(/*! readable-stream/passthrough */ "./node_modules/readable-stream/passthrough.js");
var IllegalOperationError = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").IllegalOperationError);
var stackCapture = (__webpack_require__(/*! ./error */ "./node_modules/amqplib/lib/error.js").stackCapture);

// High-water mark for channel write buffers, in 'objects' (which are
// encoded frames as buffers).
var DEFAULT_WRITE_HWM = 1024;
// If all the frames of a message (method, properties, content) total
// to less than this, copy them into a single buffer and write it all
// at once. Note that this is less than the minimum frame size: if it
// was greater, we might have to fragment the content.
var SINGLE_CHUNK_THRESHOLD = 2048;

function Connection(underlying) {
  EventEmitter.call( this );
  var stream = this.stream = wrapStream(underlying);
  this.muxer = new Mux(stream);

  // frames
  this.rest = Buffer.alloc(0);
  this.frameMax = constants.FRAME_MIN_SIZE;
  this.sentSinceLastCheck = false;
  this.recvSinceLastCheck = false;

  this.expectSocketClose = false;
  this.freeChannels = new BitSet();
  this.channels = [{channel: {accept: channel0(this)},
                    buffer: underlying}];
}
inherits(Connection, EventEmitter);

var C = Connection.prototype;

// Usual frame accept mode
function mainAccept(frame) {
  var rec = this.channels[frame.channel];
  if (rec) { return rec.channel.accept(frame); }
  // NB CHANNEL_ERROR may not be right, but I don't know what is ..
  else
    this.closeWithError(
      fmt('Frame on unknown channel %d', frame.channel),
      constants.CHANNEL_ERROR,
      new Error(fmt("Frame on unknown channel: %s",
                    inspect(frame, false))));
}

// Handle anything that comes through on channel 0, that's the
// connection control channel. This is only used once mainAccept is
// installed as the frame handler, after the opening handshake.
function channel0(connection) {
  return function(f) {
    // Once we get a 'close', we know 1. we'll get no more frames, and
    // 2. anything we send except close, or close-ok, will be
    // ignored. If we already sent 'close', this won't be invoked since
    // we're already in closing mode; if we didn't well we're not going
    // to send it now are we.
    if (f === HEARTBEAT); // ignore; it's already counted as activity
                          // on the socket, which is its purpose
    else if (f.id === defs.ConnectionClose) {
      // Oh. OK. I guess we're done here then.
      connection.sendMethod(0, defs.ConnectionCloseOk, {});
      var emsg = fmt('Connection closed: %s', closeMsg(f));
      var s = stackCapture(emsg);
      var e = new Error(emsg);
      e.code = f.fields.replyCode;
      if (isFatalError(e)) {
        connection.emit('error', e);
      }
      connection.toClosed(s, e);
    }
    else if (f.id === defs.ConnectionBlocked) {
      connection.emit('blocked', f.fields.reason);
    }
    else if (f.id === defs.ConnectionUnblocked) {
      connection.emit('unblocked');
    }
    else {
      connection.closeWithError(
        fmt("Unexpected frame on channel 0"),
        constants.UNEXPECTED_FRAME,
        new Error(fmt("Unexpected frame on channel 0: %s",
                      inspect(f, false))));
    }
  };
}

// This changed between versions, as did the codec, methods, etc. AMQP
// 0-9-1 is fairly similar to 0.8, but better, and nothing implements
// 0.8 that doesn't implement 0-9-1. In other words, it doesn't make
// much sense to generalise here.
C.sendProtocolHeader = function() {
  this.sendBytes(frame.PROTOCOL_HEADER);
};

/*
  The frighteningly complicated opening protocol (spec section 2.2.4):

     Client -> Server

       protocol header ->
         <- start
       start-ok ->
     .. next two zero or more times ..
         <- secure
       secure-ok ->
         <- tune
       tune-ok ->
       open ->
         <- open-ok

If I'm only supporting SASL's PLAIN mechanism (which I am for the time
being), it gets a bit easier since the server won't in general send
back a `secure`, it'll just send `tune` after the `start-ok`.
(SASL PLAIN: http://tools.ietf.org/html/rfc4616)

*/

C.open = function(allFields, openCallback0) {
  var self = this;
  var openCallback = openCallback0 || function() {};

  // This is where we'll put our negotiated values
  var tunedOptions = Object.create(allFields);

  function wait(k) {
    self.step(function(err, frame) {
      if (err !== null) bail(err);
      else if (frame.channel !== 0) {
        bail(new Error(
          fmt("Frame on channel != 0 during handshake: %s",
              inspect(frame, false))));
      }
      else k(frame);
    });
  }

  function expect(Method, k) {
    wait(function(frame) {
      if (frame.id === Method) k(frame);
      else {
        bail(new Error(
          fmt("Expected %s; got %s",
              methodName(Method), inspect(frame, false))));
      }
    });
  }

  function bail(err) {
    openCallback(err);
  }

  function send(Method) {
    // This can throw an exception if there's some problem with the
    // options; e.g., something is a string instead of a number.
    self.sendMethod(0, Method, tunedOptions);
  }

  function negotiate(server, desired) {
    // We get sent values for channelMax, frameMax and heartbeat,
    // which we may accept or lower (subject to a minimum for
    // frameMax, but we'll leave that to the server to enforce). In
    // all cases, `0` really means "no limit", or rather the highest
    // value in the encoding, e.g., unsigned short for channelMax.
    if (server === 0 || desired === 0) {
      // i.e., whichever places a limit, if either
      return Math.max(server, desired);
    }
    else {
      return Math.min(server, desired);
    }
  }

  function onStart(start) {
    var mechanisms = start.fields.mechanisms.toString().split(' ');
    if (mechanisms.indexOf(allFields.mechanism) < 0) {
      bail(new Error(fmt('SASL mechanism %s is not provided by the server',
                         allFields.mechanism)));
      return;
    }
    self.serverProperties = start.fields.serverProperties;
    try {
      send(defs.ConnectionStartOk);
    } catch (err) {
      bail(err);
      return;
    }
    wait(afterStartOk);
  }

  function afterStartOk(reply) {
    switch (reply.id) {
    case defs.ConnectionSecure:
      bail(new Error(
        "Wasn't expecting to have to go through secure"));
      break;
    case defs.ConnectionClose:
      bail(new Error(fmt("Handshake terminated by server: %s",
                         closeMsg(reply))));
      break;
    case defs.ConnectionTune:
      var fields = reply.fields;
      tunedOptions.frameMax =
        negotiate(fields.frameMax, allFields.frameMax);
      tunedOptions.channelMax =
        negotiate(fields.channelMax, allFields.channelMax);
      tunedOptions.heartbeat =
        negotiate(fields.heartbeat, allFields.heartbeat);
      try {
        send(defs.ConnectionTuneOk);
        send(defs.ConnectionOpen);
      } catch (err) {
        bail(err);
        return;
      }
      expect(defs.ConnectionOpenOk, onOpenOk);
      break;
    default:
      bail(new Error(
        fmt("Expected connection.secure, connection.close, " +
            "or connection.tune during handshake; got %s",
            inspect(reply, false))));
      break;
    }
  }

  function onOpenOk(openOk) {
    // Impose the maximum of the encoded value, if the negotiated
    // value is zero, meaning "no, no limits"
    self.channelMax = tunedOptions.channelMax || 0xffff;
    self.frameMax = tunedOptions.frameMax || 0xffffffff;
    // 0 means "no heartbeat", rather than "maximum period of
    // heartbeating"
    self.heartbeat = tunedOptions.heartbeat;
    self.heartbeater = self.startHeartbeater();
    self.accept = mainAccept;
    succeed(openOk);
  }

  // If the server closes the connection, it's probably because of
  // something we did
  function endWhileOpening(err) {
    bail(err || new Error('Socket closed abruptly ' +
                          'during opening handshake'));
  }

  this.stream.on('end', endWhileOpening);
  this.stream.on('error', endWhileOpening);

  function succeed(ok) {
    self.stream.removeListener('end', endWhileOpening);
    self.stream.removeListener('error', endWhileOpening);
    self.stream.on('error', self.onSocketError.bind(self));
    self.stream.on('end', self.onSocketError.bind(
      self, new Error('Unexpected close')));
    self.on('frameError', self.onSocketError.bind(self));
    self.acceptLoop();
    openCallback(null, ok);
  }

  // Now kick off the handshake by prompting the server
  this.sendProtocolHeader();
  expect(defs.ConnectionStart, onStart);
};

// Closing things: AMQP has a closing handshake that applies to
// closing both connects and channels. As the initiating party, I send
// Close, then ignore all frames until I see either CloseOK --
// which signifies that the other party has seen the Close and shut
// the connection or channel down, so it's fine to free resources; or
// Close, which means the other party also wanted to close the
// whatever, and I should send CloseOk so it can free resources,
// then go back to waiting for the CloseOk. If I receive a Close
// out of the blue, I should throw away any unsent frames (they will
// be ignored anyway) and send CloseOk, then clean up resources. In
// general, Close out of the blue signals an error (or a forced
// closure, which may as well be an error).
//
//  RUNNING [1] --- send Close ---> Closing [2] ---> recv Close --+
//     |                               |                         [3]
//     |                               +------ send CloseOk ------+
//  recv Close                   recv CloseOk
//     |                               |
//     V                               V
//  Ended [4] ---- send CloseOk ---> Closed [5]
//
// [1] All frames accepted; getting a Close frame from the server
// moves to Ended; client may initiate a close by sending Close
// itself.
// [2] Client has initiated a close; only CloseOk or (simulataneously
// sent) Close is accepted.
// [3] Simultaneous close
// [4] Server won't send any more frames; accept no more frames, send
// CloseOk.
// [5] Fully closed, client will send no more, server will send no
// more. Signal 'close' or 'error'.
//
// There are two signalling mechanisms used in the API. The first is
// that calling `close` will return a promise, that will either
// resolve once the connection or channel is cleanly shut down, or
// will reject if the shutdown times out.
//
// The second is the 'close' and 'error' events. These are
// emitted as above. The events will fire *before* promises are
// resolved.

// Close the connection without even giving a reason. Typical.
C.close = function(closeCallback) {
  var k = closeCallback && function() { closeCallback(null); };
  this.closeBecause("Cheers, thanks", constants.REPLY_SUCCESS, k);
};

// Close with a reason and a 'code'. I'm pretty sure RabbitMQ totally
// ignores these; maybe it logs them. The continuation will be invoked
// when the CloseOk has been received, and before the 'close' event.
C.closeBecause = function(reason, code, k) {
  this.sendMethod(0, defs.ConnectionClose, {
    replyText: reason,
    replyCode: code,
    methodId: 0, classId: 0
  });
  var s = stackCapture('closeBecause called: ' + reason);
  this.toClosing(s, k);
};

C.closeWithError = function(reason, code, error) {
  this.emit('error', error);
  this.closeBecause(reason, code);
};

C.onSocketError = function(err) {
  if (!this.expectSocketClose) {
    // forestall any more calls to onSocketError, since we're signed
    // up for `'error'` *and* `'end'`
    this.expectSocketClose = true;
    this.emit('error', err);
    var s = stackCapture('Socket error');
    this.toClosed(s, err);
  }
};

function invalidOp(msg, stack) {
  return function() {
    throw new IllegalOperationError(msg, stack);
  };
}

function invalidateSend(conn, msg, stack) {
  conn.sendMethod = conn.sendContent = conn.sendMessage =
    invalidOp(msg, stack);
}

// A close has been initiated. Repeat: a close has been initiated.
// This means we should not send more frames, anyway they will be
// ignored. We also have to shut down all the channels.
C.toClosing = function(capturedStack, k) {
  var send = this.sendMethod.bind(this);

  this.accept = function(f) {
    if (f.id === defs.ConnectionCloseOk) {
      if (k) k();
      var s = stackCapture('ConnectionCloseOk received');
      this.toClosed(s, undefined);
    }
    else if (f.id === defs.ConnectionClose) {
      send(0, defs.ConnectionCloseOk, {});
    }
    // else ignore frame
  };
  invalidateSend(this, 'Connection closing', capturedStack);
};

C._closeChannels = function(capturedStack) {
  for (var i = 1; i < this.channels.length; i++) {
    var ch = this.channels[i];
    if (ch !== null) {
      ch.channel.toClosed(capturedStack); // %%% or with an error? not clear
    }
  }
};

// A close has been confirmed. Cease all communication.
C.toClosed = function(capturedStack, maybeErr) {
  this._closeChannels(capturedStack);
  var info = fmt('Connection closed (%s)',
                 (maybeErr) ? maybeErr.toString() : 'by client');
  // Tidy up, invalidate enverything, dynamite the bridges.
  invalidateSend(this, info, capturedStack);
  this.accept = invalidOp(info, capturedStack);
  this.close = function(cb) {
    cb && cb(new IllegalOperationError(info, capturedStack));
  };
  if (this.heartbeater) this.heartbeater.clear();
  // This is certainly true now, if it wasn't before
  this.expectSocketClose = true;
  this.stream.end();
  this.emit('close', maybeErr);
};

// ===

C.startHeartbeater = function() {
  if (this.heartbeat === 0) return null;
  else {
    var self = this;
    var hb = new Heart(this.heartbeat,
                       this.checkSend.bind(this),
                       this.checkRecv.bind(this));
    hb.on('timeout', function() {
      var hberr = new Error("Heartbeat timeout");
      self.emit('error', hberr);
      var s = stackCapture('Heartbeat timeout');
      self.toClosed(s, hberr);
    });
    hb.on('beat', function() {
      self.sendHeartbeat();
    });
    return hb;
  }
};

// I use an array to keep track of the channels, rather than an
// object. The channel identifiers are numbers, and allocated by the
// connection. If I try to allocate low numbers when they are
// available (which I do, by looking from the start of the bitset),
// this ought to keep the array small, and out of 'sparse array
// storage'. I also set entries to null, rather than deleting them, in
// the expectation that the next channel allocation will fill the slot
// again rather than growing the array. See
// http://www.html5rocks.com/en/tutorials/speed/v8/
C.freshChannel = function(channel, options) {
  var next = this.freeChannels.nextClearBit(1);
  if (next < 0 || next > this.channelMax)
    throw new Error("No channels left to allocate");
  this.freeChannels.set(next);

  var hwm = (options && options.highWaterMark) || DEFAULT_WRITE_HWM;
  var writeBuffer = new PassThrough({
    objectMode: true, highWaterMark: hwm
  });
  this.channels[next] = {channel: channel, buffer: writeBuffer};
  writeBuffer.on('drain', function() {
    channel.onBufferDrain();
  });
  this.muxer.pipeFrom(writeBuffer);
  return next;
};

C.releaseChannel = function(channel) {
  this.freeChannels.clear(channel);
  var buffer = this.channels[channel].buffer;
  buffer.end(); // will also cause it to be unpiped
  this.channels[channel] = null;
};

C.acceptLoop = function() {
  var self = this;

  function go() {
    try {
      var f; while (f = self.recvFrame()) self.accept(f);
    }
    catch (e) {
      self.emit('frameError', e);
    }
  }
  self.stream.on('readable', go);
  go();
};

C.step = function(cb) {
  var self = this;
  function recv() {
    var f;
    try {
      f = self.recvFrame();
    }
    catch (e) {
      cb(e, null);
      return;
    }
    if (f) cb(null, f);
    else self.stream.once('readable', recv);
  }
  recv();
};

C.checkSend = function() {
  var check = this.sentSinceLastCheck;
  this.sentSinceLastCheck = false;
  return check;
}

C.checkRecv = function() {
  var check = this.recvSinceLastCheck;
  this.recvSinceLastCheck = false;
  return check;
}

C.sendBytes = function(bytes) {
  this.sentSinceLastCheck = true;
  this.stream.write(bytes);
};

C.sendHeartbeat = function() {
  return this.sendBytes(frame.HEARTBEAT_BUF);
};

var encodeMethod = defs.encodeMethod;
var encodeProperties = defs.encodeProperties;

C.sendMethod = function(channel, Method, fields) {
  var frame = encodeMethod(Method, channel, fields);
  this.sentSinceLastCheck = true;
  var buffer = this.channels[channel].buffer;
  return buffer.write(frame);
};

C.sendMessage = function(channel,
                         Method, fields,
                         Properties, props,
                         content) {
  if (!Buffer.isBuffer(content))
    throw new TypeError('content is not a buffer');

  var mframe = encodeMethod(Method, channel, fields);
  var pframe = encodeProperties(Properties, channel,
                                content.length, props);
  var buffer = this.channels[channel].buffer;
  this.sentSinceLastCheck = true;

  var methodHeaderLen = mframe.length + pframe.length;
  var bodyLen = (content.length > 0) ?
    content.length + FRAME_OVERHEAD : 0;
  var allLen = methodHeaderLen + bodyLen;

  if (allLen < SINGLE_CHUNK_THRESHOLD) {
    // Use `allocUnsafe` to avoid excessive allocations and CPU usage
    // from zeroing. The returned Buffer is not zeroed and so must be
    // completely filled to be used safely.
    // See https://github.com/amqp-node/amqplib/pull/695
    var all = Buffer.allocUnsafe(allLen);
    var offset = mframe.copy(all, 0);
    offset += pframe.copy(all, offset);

    if (bodyLen > 0)
      makeBodyFrame(channel, content).copy(all, offset);
    return buffer.write(all);
  }
  else {
    if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {
      // Use `allocUnsafe` to avoid excessive allocations and CPU usage
      // from zeroing. The returned Buffer is not zeroed and so must be
      // completely filled to be used safely.
      // See https://github.com/amqp-node/amqplib/pull/695
      var both = Buffer.allocUnsafe(methodHeaderLen);
      var offset = mframe.copy(both, 0);
      pframe.copy(both, offset);
      buffer.write(both);
    }
    else {
      buffer.write(mframe);
      buffer.write(pframe);
    }
    return this.sendContent(channel, content);
  }
};

var FRAME_OVERHEAD = defs.FRAME_OVERHEAD;
var makeBodyFrame = frame.makeBodyFrame;

C.sendContent = function(channel, body) {
  if (!Buffer.isBuffer(body)) {
    throw new TypeError(fmt("Expected buffer; got %s", body));
  }
  var writeResult = true;
  var buffer = this.channels[channel].buffer;

  var maxBody = this.frameMax - FRAME_OVERHEAD;

  for (var offset = 0; offset < body.length; offset += maxBody) {
    var end = offset + maxBody;
    var slice = (end > body.length) ? body.slice(offset) : body.slice(offset, end);
    var bodyFrame = makeBodyFrame(channel, slice);
    writeResult = buffer.write(bodyFrame);
  }
  this.sentSinceLastCheck = true;
  return writeResult;
};

var parseFrame = frame.parseFrame;
var decodeFrame = frame.decodeFrame;

C.recvFrame = function() {
  // %%% identifying invariants might help here?
  var frame = parseFrame(this.rest, this.frameMax);

  if (!frame) {
    var incoming = this.stream.read();
    if (incoming === null) {
      return false;
    }
    else {
      this.recvSinceLastCheck = true;
      this.rest = Buffer.concat([this.rest, incoming]);
      return this.recvFrame();
    }
  }
  else {
    this.rest = frame.rest;
    return decodeFrame(frame);
  }
};

function wrapStream(s) {
  if (s instanceof Duplex) return s;
  else {
    var ws = new Duplex();
    ws.wrap(s); //wraps the readable side of things
    ws._write = function(chunk, encoding, callback) {
      return s.write(chunk, encoding, callback);
    };
    return ws;
  }
}

function isFatalError(error) {
  switch (error && error.code) {
  case defs.constants.CONNECTION_FORCED:
  case defs.constants.REPLY_SUCCESS:
    return false;
  default:
    return true;
  }
}

module.exports.Connection = Connection;
module.exports.isFatalError = isFatalError;


/***/ }),

/***/ "./node_modules/amqplib/lib/credentials.js":
/*!*************************************************!*\
  !*** ./node_modules/amqplib/lib/credentials.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
//
//

// Different kind of credentials that can be supplied when opening a
// connection, corresponding to SASL mechanisms There's only two
// useful mechanisms that RabbitMQ implements:
//  * PLAIN (send username and password in the plain)
//  * EXTERNAL (assume the server will figure out who you are from
//    context, i.e., your SSL certificate)
var codec = __webpack_require__(/*! ./codec */ "./node_modules/amqplib/lib/codec.js")

module.exports.plain = function(user, passwd) {
  return {
    mechanism: 'PLAIN',
    response: function() {
      return Buffer.from(['', user, passwd].join(String.fromCharCode(0)))
    },
    username: user,
    password: passwd
  }
}

module.exports.amqplain = function(user, passwd) {
  return {
    mechanism: 'AMQPLAIN',
    response: function() {
      const buffer = Buffer.alloc(16384);
      const size = codec.encodeTable(buffer, { LOGIN: user, PASSWORD: passwd}, 0);
      return buffer.slice(4, size);
    },
    username: user,
    password: passwd
  }
}

module.exports.external = function() {
  return {
    mechanism: 'EXTERNAL',
    response: function() { return Buffer.from(''); }
  }
}


/***/ }),

/***/ "./node_modules/amqplib/lib/defs.js":
/*!******************************************!*\
  !*** ./node_modules/amqplib/lib/defs.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** @preserve This file is generated by the script
 * ../bin/generate-defs.js, which is not in general included in a
 * distribution, but is available in the source repository e.g. at
 * https://github.com/squaremo/amqp.node/
 */


function decodeConnectionStart(buffer) {
  var val, len, offset = 0, fields = {
    versionMajor: void 0,
    versionMinor: void 0,
    serverProperties: void 0,
    mechanisms: void 0,
    locales: void 0
  };
  val = buffer[offset];
  offset++;
  fields.versionMajor = val;
  val = buffer[offset];
  offset++;
  fields.versionMinor = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.serverProperties = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.mechanisms = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.locales = val;
  return fields;
}

function encodeConnectionStart(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
  val = fields.serverProperties;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'serverProperties'");
  if ("object" != typeof val) throw new TypeError("Field 'serverProperties' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var serverProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += serverProperties_encoded.length;
  val = fields.mechanisms;
  if (void 0 === val) val = Buffer.from("PLAIN"); else if (!Buffer.isBuffer(val)) throw new TypeError("Field 'mechanisms' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  val = fields.locales;
  if (void 0 === val) val = Buffer.from("en_US"); else if (!Buffer.isBuffer(val)) throw new TypeError("Field 'locales' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(22 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655370, 7);
  offset = 11;
  val = fields.versionMajor;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'versionMajor' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt8(val, offset);
  offset++;
  val = fields.versionMinor;
  if (void 0 === val) val = 9; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'versionMinor' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt8(val, offset);
  offset++;
  offset += serverProperties_encoded.copy(buffer, offset);
  val = fields.mechanisms;
  void 0 === val && (val = Buffer.from("PLAIN"));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  val = fields.locales;
  void 0 === val && (val = Buffer.from("en_US"));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionStartOk(buffer) {
  var val, len, offset = 0, fields = {
    clientProperties: void 0,
    mechanism: void 0,
    response: void 0,
    locale: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.clientProperties = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.mechanism = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.response = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.locale = val;
  return fields;
}

function encodeConnectionStartOk(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
  val = fields.clientProperties;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'clientProperties'");
  if ("object" != typeof val) throw new TypeError("Field 'clientProperties' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var clientProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += clientProperties_encoded.length;
  val = fields.mechanism;
  if (void 0 === val) val = "PLAIN"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'mechanism' is the wrong type; must be a string (up to 255 chars)");
  var mechanism_len = Buffer.byteLength(val, "utf8");
  varyingSize += mechanism_len;
  val = fields.response;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'response'");
  if (!Buffer.isBuffer(val)) throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  val = fields.locale;
  if (void 0 === val) val = "en_US"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'locale' is the wrong type; must be a string (up to 255 chars)");
  var locale_len = Buffer.byteLength(val, "utf8");
  varyingSize += locale_len;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655371, 7);
  offset = 11;
  offset += clientProperties_encoded.copy(buffer, offset);
  val = fields.mechanism;
  void 0 === val && (val = "PLAIN");
  buffer[offset] = mechanism_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += mechanism_len;
  val = fields.response;
  void 0 === val && (val = Buffer.from(void 0));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  val = fields.locale;
  void 0 === val && (val = "en_US");
  buffer[offset] = locale_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += locale_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionSecure(buffer) {
  var val, len, offset = 0, fields = {
    challenge: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.challenge = val;
  return fields;
}

function encodeConnectionSecure(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0;
  val = fields.challenge;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'challenge'");
  if (!Buffer.isBuffer(val)) throw new TypeError("Field 'challenge' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655380, 7);
  offset = 11;
  val = fields.challenge;
  void 0 === val && (val = Buffer.from(void 0));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionSecureOk(buffer) {
  var val, len, offset = 0, fields = {
    response: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.response = val;
  return fields;
}

function encodeConnectionSecureOk(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0;
  val = fields.response;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'response'");
  if (!Buffer.isBuffer(val)) throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655381, 7);
  offset = 11;
  val = fields.response;
  void 0 === val && (val = Buffer.from(void 0));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionTune(buffer) {
  var val, offset = 0, fields = {
    channelMax: void 0,
    frameMax: void 0,
    heartbeat: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.channelMax = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.frameMax = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.heartbeat = val;
  return fields;
}

function encodeConnectionTune(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(20);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655390, 7);
  offset = 11;
  val = fields.channelMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.frameMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.heartbeat;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionTuneOk(buffer) {
  var val, offset = 0, fields = {
    channelMax: void 0,
    frameMax: void 0,
    heartbeat: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.channelMax = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.frameMax = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.heartbeat = val;
  return fields;
}

function encodeConnectionTuneOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(20);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655391, 7);
  offset = 11;
  val = fields.channelMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.frameMax;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.heartbeat;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionOpen(buffer) {
  var val, len, offset = 0, fields = {
    virtualHost: void 0,
    capabilities: void 0,
    insist: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.virtualHost = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.capabilities = val;
  val = !!(1 & buffer[offset]);
  fields.insist = val;
  return fields;
}

function encodeConnectionOpen(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.virtualHost;
  if (void 0 === val) val = "/"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'virtualHost' is the wrong type; must be a string (up to 255 chars)");
  var virtualHost_len = Buffer.byteLength(val, "utf8");
  varyingSize += virtualHost_len;
  val = fields.capabilities;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'capabilities' is the wrong type; must be a string (up to 255 chars)");
  var capabilities_len = Buffer.byteLength(val, "utf8");
  varyingSize += capabilities_len;
  var buffer = Buffer.alloc(15 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655400, 7);
  offset = 11;
  val = fields.virtualHost;
  void 0 === val && (val = "/");
  buffer[offset] = virtualHost_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += virtualHost_len;
  val = fields.capabilities;
  void 0 === val && (val = "");
  buffer[offset] = capabilities_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += capabilities_len;
  val = fields.insist;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionOpenOk(buffer) {
  var val, len, offset = 0, fields = {
    knownHosts: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.knownHosts = val;
  return fields;
}

function encodeConnectionOpenOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.knownHosts;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'knownHosts' is the wrong type; must be a string (up to 255 chars)");
  var knownHosts_len = Buffer.byteLength(val, "utf8");
  varyingSize += knownHosts_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655401, 7);
  offset = 11;
  val = fields.knownHosts;
  void 0 === val && (val = "");
  buffer[offset] = knownHosts_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += knownHosts_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionClose(buffer) {
  var val, len, offset = 0, fields = {
    replyCode: void 0,
    replyText: void 0,
    classId: void 0,
    methodId: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.replyCode = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.replyText = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.classId = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.methodId = val;
  return fields;
}

function encodeConnectionClose(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.replyText;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
  var replyText_len = Buffer.byteLength(val, "utf8");
  varyingSize += replyText_len;
  var buffer = Buffer.alloc(19 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655410, 7);
  offset = 11;
  val = fields.replyCode;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'replyCode'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.replyText;
  void 0 === val && (val = "");
  buffer[offset] = replyText_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += replyText_len;
  val = fields.classId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'classId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.methodId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'methodId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionCloseOk(buffer) {
  return {};
}

function encodeConnectionCloseOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655411, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionBlocked(buffer) {
  var val, len, offset = 0, fields = {
    reason: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.reason = val;
  return fields;
}

function encodeConnectionBlocked(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.reason;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'reason' is the wrong type; must be a string (up to 255 chars)");
  var reason_len = Buffer.byteLength(val, "utf8");
  varyingSize += reason_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655420, 7);
  offset = 11;
  val = fields.reason;
  void 0 === val && (val = "");
  buffer[offset] = reason_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += reason_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConnectionUnblocked(buffer) {
  return {};
}

function encodeConnectionUnblocked(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(655421, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelOpen(buffer) {
  var val, len, offset = 0, fields = {
    outOfBand: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.outOfBand = val;
  return fields;
}

function encodeChannelOpen(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.outOfBand;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'outOfBand' is the wrong type; must be a string (up to 255 chars)");
  var outOfBand_len = Buffer.byteLength(val, "utf8");
  varyingSize += outOfBand_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310730, 7);
  offset = 11;
  val = fields.outOfBand;
  void 0 === val && (val = "");
  buffer[offset] = outOfBand_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += outOfBand_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelOpenOk(buffer) {
  var val, len, offset = 0, fields = {
    channelId: void 0
  };
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = buffer.slice(offset, offset + len);
  offset += len;
  fields.channelId = val;
  return fields;
}

function encodeChannelOpenOk(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0;
  val = fields.channelId;
  if (void 0 === val) val = Buffer.from(""); else if (!Buffer.isBuffer(val)) throw new TypeError("Field 'channelId' is the wrong type; must be a Buffer");
  varyingSize += val.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310731, 7);
  offset = 11;
  val = fields.channelId;
  void 0 === val && (val = Buffer.from(""));
  len = val.length;
  buffer.writeUInt32BE(len, offset);
  offset += 4;
  val.copy(buffer, offset);
  offset += len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelFlow(buffer) {
  var val, fields = {
    active: void 0
  };
  val = !!(1 & buffer[0]);
  fields.active = val;
  return fields;
}

function encodeChannelFlow(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310740, 7);
  offset = 11;
  val = fields.active;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'active'");
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelFlowOk(buffer) {
  var val, fields = {
    active: void 0
  };
  val = !!(1 & buffer[0]);
  fields.active = val;
  return fields;
}

function encodeChannelFlowOk(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310741, 7);
  offset = 11;
  val = fields.active;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'active'");
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelClose(buffer) {
  var val, len, offset = 0, fields = {
    replyCode: void 0,
    replyText: void 0,
    classId: void 0,
    methodId: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.replyCode = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.replyText = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.classId = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.methodId = val;
  return fields;
}

function encodeChannelClose(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.replyText;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
  var replyText_len = Buffer.byteLength(val, "utf8");
  varyingSize += replyText_len;
  var buffer = Buffer.alloc(19 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310760, 7);
  offset = 11;
  val = fields.replyCode;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'replyCode'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.replyText;
  void 0 === val && (val = "");
  buffer[offset] = replyText_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += replyText_len;
  val = fields.classId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'classId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.methodId;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'methodId'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeChannelCloseOk(buffer) {
  return {};
}

function encodeChannelCloseOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1310761, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeAccessRequest(buffer) {
  var val, len, offset = 0, fields = {
    realm: void 0,
    exclusive: void 0,
    passive: void 0,
    active: void 0,
    write: void 0,
    read: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.realm = val;
  val = !!(1 & buffer[offset]);
  fields.exclusive = val;
  val = !!(2 & buffer[offset]);
  fields.passive = val;
  val = !!(4 & buffer[offset]);
  fields.active = val;
  val = !!(8 & buffer[offset]);
  fields.write = val;
  val = !!(16 & buffer[offset]);
  fields.read = val;
  return fields;
}

function encodeAccessRequest(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.realm;
  if (void 0 === val) val = "/data"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'realm' is the wrong type; must be a string (up to 255 chars)");
  var realm_len = Buffer.byteLength(val, "utf8");
  varyingSize += realm_len;
  var buffer = Buffer.alloc(14 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1966090, 7);
  offset = 11;
  val = fields.realm;
  void 0 === val && (val = "/data");
  buffer[offset] = realm_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += realm_len;
  val = fields.exclusive;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.passive;
  void 0 === val && (val = !0);
  val && (bits += 2);
  val = fields.active;
  void 0 === val && (val = !0);
  val && (bits += 4);
  val = fields.write;
  void 0 === val && (val = !0);
  val && (bits += 8);
  val = fields.read;
  void 0 === val && (val = !0);
  val && (bits += 16);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeAccessRequestOk(buffer) {
  var val, offset = 0, fields = {
    ticket: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  return fields;
}

function encodeAccessRequestOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(14);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(1966091, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 1; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDeclare(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    exchange: void 0,
    type: void 0,
    passive: void 0,
    durable: void 0,
    autoDelete: void 0,
    internal: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.type = val;
  val = !!(1 & buffer[offset]);
  fields.passive = val;
  val = !!(2 & buffer[offset]);
  fields.durable = val;
  val = !!(4 & buffer[offset]);
  fields.autoDelete = val;
  val = !!(8 & buffer[offset]);
  fields.internal = val;
  val = !!(16 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeExchangeDeclare(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.type;
  if (void 0 === val) val = "direct"; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
  var type_len = Buffer.byteLength(val, "utf8");
  varyingSize += type_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621450, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.type;
  void 0 === val && (val = "direct");
  buffer[offset] = type_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += type_len;
  val = fields.passive;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.durable;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.autoDelete;
  void 0 === val && (val = !1);
  val && (bits += 4);
  val = fields.internal;
  void 0 === val && (val = !1);
  val && (bits += 8);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 16);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDeclareOk(buffer) {
  return {};
}

function encodeExchangeDeclareOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621451, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDelete(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    exchange: void 0,
    ifUnused: void 0,
    nowait: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  val = !!(1 & buffer[offset]);
  fields.ifUnused = val;
  val = !!(2 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeExchangeDelete(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621460, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.ifUnused;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 2);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeDeleteOk(buffer) {
  return {};
}

function encodeExchangeDeleteOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621461, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeBind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    destination: void 0,
    source: void 0,
    routingKey: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.destination = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.source = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeExchangeBind(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.destination;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'destination'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
  var destination_len = Buffer.byteLength(val, "utf8");
  varyingSize += destination_len;
  val = fields.source;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'source'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
  var source_len = Buffer.byteLength(val, "utf8");
  varyingSize += source_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621470, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.destination;
  void 0 === val && (val = void 0);
  buffer[offset] = destination_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += destination_len;
  val = fields.source;
  void 0 === val && (val = void 0);
  buffer[offset] = source_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += source_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeBindOk(buffer) {
  return {};
}

function encodeExchangeBindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621471, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeUnbind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    destination: void 0,
    source: void 0,
    routingKey: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.destination = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.source = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeExchangeUnbind(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.destination;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'destination'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
  var destination_len = Buffer.byteLength(val, "utf8");
  varyingSize += destination_len;
  val = fields.source;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'source'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
  var source_len = Buffer.byteLength(val, "utf8");
  varyingSize += source_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621480, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.destination;
  void 0 === val && (val = void 0);
  buffer[offset] = destination_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += destination_len;
  val = fields.source;
  void 0 === val && (val = void 0);
  buffer[offset] = source_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += source_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeExchangeUnbindOk(buffer) {
  return {};
}

function encodeExchangeUnbindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(2621491, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDeclare(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    passive: void 0,
    durable: void 0,
    exclusive: void 0,
    autoDelete: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.passive = val;
  val = !!(2 & buffer[offset]);
  fields.durable = val;
  val = !!(4 & buffer[offset]);
  fields.exclusive = val;
  val = !!(8 & buffer[offset]);
  fields.autoDelete = val;
  val = !!(16 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeQueueDeclare(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276810, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.passive;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.durable;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.exclusive;
  void 0 === val && (val = !1);
  val && (bits += 4);
  val = fields.autoDelete;
  void 0 === val && (val = !1);
  val && (bits += 8);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 16);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDeclareOk(buffer) {
  var val, len, offset = 0, fields = {
    queue: void 0,
    messageCount: void 0,
    consumerCount: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.consumerCount = val;
  return fields;
}

function encodeQueueDeclareOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'queue'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(21 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276811, 7);
  offset = 11;
  val = fields.queue;
  void 0 === val && (val = void 0);
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.consumerCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'consumerCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueBind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    exchange: void 0,
    routingKey: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeQueueBind(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(18 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276820, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueBindOk(buffer) {
  return {};
}

function encodeQueueBindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276821, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueuePurge(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    nowait: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeQueuePurge(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276830, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueuePurgeOk(buffer) {
  var val, offset = 0, fields = {
    messageCount: void 0
  };
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  return fields;
}

function encodeQueuePurgeOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(16);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276831, 7);
  offset = 11;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDelete(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    ifUnused: void 0,
    ifEmpty: void 0,
    nowait: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.ifUnused = val;
  val = !!(2 & buffer[offset]);
  fields.ifEmpty = val;
  val = !!(4 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeQueueDelete(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276840, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.ifUnused;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.ifEmpty;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 4);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueDeleteOk(buffer) {
  var val, offset = 0, fields = {
    messageCount: void 0
  };
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  return fields;
}

function encodeQueueDeleteOk(channel, fields) {
  var offset = 0, val = null, buffer = Buffer.alloc(16);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276841, 7);
  offset = 11;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueUnbind(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    exchange: void 0,
    routingKey: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeQueueUnbind(channel, fields) {
  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276850, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeQueueUnbindOk(buffer) {
  return {};
}

function encodeQueueUnbindOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3276851, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicQos(buffer) {
  var val, offset = 0, fields = {
    prefetchSize: void 0,
    prefetchCount: void 0,
    global: void 0
  };
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.prefetchSize = val;
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.prefetchCount = val;
  val = !!(1 & buffer[offset]);
  fields.global = val;
  return fields;
}

function encodeBasicQos(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(19);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932170, 7);
  offset = 11;
  val = fields.prefetchSize;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'prefetchSize' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  val = fields.prefetchCount;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'prefetchCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.global;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicQosOk(buffer) {
  return {};
}

function encodeBasicQosOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932171, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicConsume(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    consumerTag: void 0,
    noLocal: void 0,
    noAck: void 0,
    exclusive: void 0,
    nowait: void 0,
    arguments: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  val = !!(1 & buffer[offset]);
  fields.noLocal = val;
  val = !!(2 & buffer[offset]);
  fields.noAck = val;
  val = !!(4 & buffer[offset]);
  fields.exclusive = val;
  val = !!(8 & buffer[offset]);
  fields.nowait = val;
  offset++;
  len = buffer.readUInt32BE(offset);
  offset += 4;
  val = decodeFields(buffer.slice(offset, offset + len));
  offset += len;
  fields.arguments = val;
  return fields;
}

function encodeBasicConsume(channel, fields) {
  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  val = fields.consumerTag;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  val = fields.arguments;
  if (void 0 === val) val = {}; else if ("object" != typeof val) throw new TypeError("Field 'arguments' is the wrong type; must be an object");
  len = encodeTable(SCRATCH, val, scratchOffset);
  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
  scratchOffset += len;
  varyingSize += arguments_encoded.length;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932180, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.consumerTag;
  void 0 === val && (val = "");
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  val = fields.noLocal;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.noAck;
  void 0 === val && (val = !1);
  val && (bits += 2);
  val = fields.exclusive;
  void 0 === val && (val = !1);
  val && (bits += 4);
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 8);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  offset += arguments_encoded.copy(buffer, offset);
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicConsumeOk(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  return fields;
}

function encodeBasicConsumeOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932181, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicCancel(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0,
    nowait: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  val = !!(1 & buffer[offset]);
  fields.nowait = val;
  return fields;
}

function encodeBasicCancel(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  var buffer = Buffer.alloc(14 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932190, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicCancelOk(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  return fields;
}

function encodeBasicCancelOk(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932191, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicPublish(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    exchange: void 0,
    routingKey: void 0,
    mandatory: void 0,
    immediate: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = !!(1 & buffer[offset]);
  fields.mandatory = val;
  val = !!(2 & buffer[offset]);
  fields.immediate = val;
  return fields;
}

function encodeBasicPublish(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.exchange;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932200, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.exchange;
  void 0 === val && (val = "");
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = "");
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.mandatory;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.immediate;
  void 0 === val && (val = !1);
  val && (bits += 2);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicReturn(buffer) {
  var val, len, offset = 0, fields = {
    replyCode: void 0,
    replyText: void 0,
    exchange: void 0,
    routingKey: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.replyCode = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.replyText = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  return fields;
}

function encodeBasicReturn(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.replyText;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
  var replyText_len = Buffer.byteLength(val, "utf8");
  varyingSize += replyText_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'routingKey'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(17 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932210, 7);
  offset = 11;
  val = fields.replyCode;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'replyCode'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.replyText;
  void 0 === val && (val = "");
  buffer[offset] = replyText_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += replyText_len;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = void 0);
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicDeliver(buffer) {
  var val, len, offset = 0, fields = {
    consumerTag: void 0,
    deliveryTag: void 0,
    redelivered: void 0,
    exchange: void 0,
    routingKey: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.consumerTag = val;
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.redelivered = val;
  offset++;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  return fields;
}

function encodeBasicDeliver(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.consumerTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'consumerTag'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
  var consumerTag_len = Buffer.byteLength(val, "utf8");
  varyingSize += consumerTag_len;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'routingKey'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(24 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932220, 7);
  offset = 11;
  val = fields.consumerTag;
  void 0 === val && (val = void 0);
  buffer[offset] = consumerTag_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += consumerTag_len;
  val = fields.deliveryTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'deliveryTag'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.redelivered;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = void 0);
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicGet(buffer) {
  var val, len, offset = 0, fields = {
    ticket: void 0,
    queue: void 0,
    noAck: void 0
  };
  val = buffer.readUInt16BE(offset);
  offset += 2;
  fields.ticket = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.queue = val;
  val = !!(1 & buffer[offset]);
  fields.noAck = val;
  return fields;
}

function encodeBasicGet(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.queue;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
  var queue_len = Buffer.byteLength(val, "utf8");
  varyingSize += queue_len;
  var buffer = Buffer.alloc(16 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932230, 7);
  offset = 11;
  val = fields.ticket;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt16BE(val, offset);
  offset += 2;
  val = fields.queue;
  void 0 === val && (val = "");
  buffer[offset] = queue_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += queue_len;
  val = fields.noAck;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicGetOk(buffer) {
  var val, len, offset = 0, fields = {
    deliveryTag: void 0,
    redelivered: void 0,
    exchange: void 0,
    routingKey: void 0,
    messageCount: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.redelivered = val;
  offset++;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.exchange = val;
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.routingKey = val;
  val = buffer.readUInt32BE(offset);
  offset += 4;
  fields.messageCount = val;
  return fields;
}

function encodeBasicGetOk(channel, fields) {
  var offset = 0, val = null, bits = 0, varyingSize = 0;
  val = fields.exchange;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'exchange'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
  var exchange_len = Buffer.byteLength(val, "utf8");
  varyingSize += exchange_len;
  val = fields.routingKey;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'routingKey'");
  if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
  var routingKey_len = Buffer.byteLength(val, "utf8");
  varyingSize += routingKey_len;
  var buffer = Buffer.alloc(27 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932231, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'deliveryTag'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.redelivered;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  bits = 0;
  val = fields.exchange;
  void 0 === val && (val = void 0);
  buffer[offset] = exchange_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += exchange_len;
  val = fields.routingKey;
  void 0 === val && (val = void 0);
  buffer[offset] = routingKey_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += routingKey_len;
  val = fields.messageCount;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'messageCount'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
  buffer.writeUInt32BE(val, offset);
  offset += 4;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicGetEmpty(buffer) {
  var val, len, offset = 0, fields = {
    clusterId: void 0
  };
  len = buffer.readUInt8(offset);
  offset++;
  val = buffer.toString("utf8", offset, offset + len);
  offset += len;
  fields.clusterId = val;
  return fields;
}

function encodeBasicGetEmpty(channel, fields) {
  var offset = 0, val = null, varyingSize = 0;
  val = fields.clusterId;
  if (void 0 === val) val = ""; else if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
  var clusterId_len = Buffer.byteLength(val, "utf8");
  varyingSize += clusterId_len;
  var buffer = Buffer.alloc(13 + varyingSize);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932232, 7);
  offset = 11;
  val = fields.clusterId;
  void 0 === val && (val = "");
  buffer[offset] = clusterId_len;
  offset++;
  buffer.write(val, offset, "utf8");
  offset += clusterId_len;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicAck(buffer) {
  var val, offset = 0, fields = {
    deliveryTag: void 0,
    multiple: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.multiple = val;
  return fields;
}

function encodeBasicAck(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932240, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.multiple;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicReject(buffer) {
  var val, offset = 0, fields = {
    deliveryTag: void 0,
    requeue: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.requeue = val;
  return fields;
}

function encodeBasicReject(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932250, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) throw new Error("Missing value for mandatory field 'deliveryTag'");
  if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.requeue;
  void 0 === val && (val = !0);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicRecoverAsync(buffer) {
  var val, fields = {
    requeue: void 0
  };
  val = !!(1 & buffer[0]);
  fields.requeue = val;
  return fields;
}

function encodeBasicRecoverAsync(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932260, 7);
  offset = 11;
  val = fields.requeue;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicRecover(buffer) {
  var val, fields = {
    requeue: void 0
  };
  val = !!(1 & buffer[0]);
  fields.requeue = val;
  return fields;
}

function encodeBasicRecover(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932270, 7);
  offset = 11;
  val = fields.requeue;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicRecoverOk(buffer) {
  return {};
}

function encodeBasicRecoverOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932271, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeBasicNack(buffer) {
  var val, offset = 0, fields = {
    deliveryTag: void 0,
    multiple: void 0,
    requeue: void 0
  };
  val = ints.readUInt64BE(buffer, offset);
  offset += 8;
  fields.deliveryTag = val;
  val = !!(1 & buffer[offset]);
  fields.multiple = val;
  val = !!(2 & buffer[offset]);
  fields.requeue = val;
  return fields;
}

function encodeBasicNack(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932280, 7);
  offset = 11;
  val = fields.deliveryTag;
  if (void 0 === val) val = 0; else if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
  ints.writeUInt64BE(buffer, val, offset);
  offset += 8;
  val = fields.multiple;
  void 0 === val && (val = !1);
  val && (bits += 1);
  val = fields.requeue;
  void 0 === val && (val = !0);
  val && (bits += 2);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxSelect(buffer) {
  return {};
}

function encodeTxSelect(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898250, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxSelectOk(buffer) {
  return {};
}

function encodeTxSelectOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898251, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxCommit(buffer) {
  return {};
}

function encodeTxCommit(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898260, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxCommitOk(buffer) {
  return {};
}

function encodeTxCommitOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898261, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxRollback(buffer) {
  return {};
}

function encodeTxRollback(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898270, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeTxRollbackOk(buffer) {
  return {};
}

function encodeTxRollbackOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5898271, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConfirmSelect(buffer) {
  var val, fields = {
    nowait: void 0
  };
  val = !!(1 & buffer[0]);
  fields.nowait = val;
  return fields;
}

function encodeConfirmSelect(channel, fields) {
  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5570570, 7);
  offset = 11;
  val = fields.nowait;
  void 0 === val && (val = !1);
  val && (bits += 1);
  buffer[offset] = bits;
  offset++;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function decodeConfirmSelectOk(buffer) {
  return {};
}

function encodeConfirmSelectOk(channel, fields) {
  var offset = 0, buffer = Buffer.alloc(12);
  buffer[0] = 1;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(5570571, 7);
  offset = 11;
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  return buffer;
}

function encodeBasicProperties(channel, size, fields) {
  var val, len, offset = 0, flags = 0, scratchOffset = 0, varyingSize = 0;
  val = fields.contentType;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'contentType' is the wrong type; must be a string (up to 255 chars)");
    var contentType_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += contentType_len;
  }
  val = fields.contentEncoding;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'contentEncoding' is the wrong type; must be a string (up to 255 chars)");
    var contentEncoding_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += contentEncoding_len;
  }
  val = fields.headers;
  if (void 0 != val) {
    if ("object" != typeof val) throw new TypeError("Field 'headers' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var headers_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += headers_encoded.length;
  }
  val = fields.deliveryMode;
  if (void 0 != val) {
    if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'deliveryMode' is the wrong type; must be a number (but not NaN)");
    varyingSize += 1;
  }
  val = fields.priority;
  if (void 0 != val) {
    if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'priority' is the wrong type; must be a number (but not NaN)");
    varyingSize += 1;
  }
  val = fields.correlationId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'correlationId' is the wrong type; must be a string (up to 255 chars)");
    var correlationId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += correlationId_len;
  }
  val = fields.replyTo;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'replyTo' is the wrong type; must be a string (up to 255 chars)");
    var replyTo_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += replyTo_len;
  }
  val = fields.expiration;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'expiration' is the wrong type; must be a string (up to 255 chars)");
    var expiration_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += expiration_len;
  }
  val = fields.messageId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'messageId' is the wrong type; must be a string (up to 255 chars)");
    var messageId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += messageId_len;
  }
  val = fields.timestamp;
  if (void 0 != val) {
    if ("number" != typeof val || isNaN(val)) throw new TypeError("Field 'timestamp' is the wrong type; must be a number (but not NaN)");
    varyingSize += 8;
  }
  val = fields.type;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
    var type_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += type_len;
  }
  val = fields.userId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'userId' is the wrong type; must be a string (up to 255 chars)");
    var userId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += userId_len;
  }
  val = fields.appId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'appId' is the wrong type; must be a string (up to 255 chars)");
    var appId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += appId_len;
  }
  val = fields.clusterId;
  if (void 0 != val) {
    if (!("string" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
    var clusterId_len = Buffer.byteLength(val, "utf8");
    varyingSize += 1;
    varyingSize += clusterId_len;
  }
  var buffer = Buffer.alloc(22 + varyingSize);
  buffer[0] = 2;
  buffer.writeUInt16BE(channel, 1);
  buffer.writeUInt32BE(3932160, 7);
  ints.writeUInt64BE(buffer, size, 11);
  flags = 0;
  offset = 21;
  val = fields.contentType;
  if (void 0 != val) {
    flags += 32768;
    buffer[offset] = contentType_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += contentType_len;
  }
  val = fields.contentEncoding;
  if (void 0 != val) {
    flags += 16384;
    buffer[offset] = contentEncoding_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += contentEncoding_len;
  }
  val = fields.headers;
  if (void 0 != val) {
    flags += 8192;
    offset += headers_encoded.copy(buffer, offset);
  }
  val = fields.deliveryMode;
  if (void 0 != val) {
    flags += 4096;
    buffer.writeUInt8(val, offset);
    offset++;
  }
  val = fields.priority;
  if (void 0 != val) {
    flags += 2048;
    buffer.writeUInt8(val, offset);
    offset++;
  }
  val = fields.correlationId;
  if (void 0 != val) {
    flags += 1024;
    buffer[offset] = correlationId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += correlationId_len;
  }
  val = fields.replyTo;
  if (void 0 != val) {
    flags += 512;
    buffer[offset] = replyTo_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += replyTo_len;
  }
  val = fields.expiration;
  if (void 0 != val) {
    flags += 256;
    buffer[offset] = expiration_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += expiration_len;
  }
  val = fields.messageId;
  if (void 0 != val) {
    flags += 128;
    buffer[offset] = messageId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += messageId_len;
  }
  val = fields.timestamp;
  if (void 0 != val) {
    flags += 64;
    ints.writeUInt64BE(buffer, val, offset);
    offset += 8;
  }
  val = fields.type;
  if (void 0 != val) {
    flags += 32;
    buffer[offset] = type_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += type_len;
  }
  val = fields.userId;
  if (void 0 != val) {
    flags += 16;
    buffer[offset] = userId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += userId_len;
  }
  val = fields.appId;
  if (void 0 != val) {
    flags += 8;
    buffer[offset] = appId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += appId_len;
  }
  val = fields.clusterId;
  if (void 0 != val) {
    flags += 4;
    buffer[offset] = clusterId_len;
    offset++;
    buffer.write(val, offset, "utf8");
    offset += clusterId_len;
  }
  buffer[offset] = 206;
  buffer.writeUInt32BE(offset - 7, 3);
  buffer.writeUInt16BE(flags, 19);
  return buffer.slice(0, offset + 1);
}

function decodeBasicProperties(buffer) {
  var flags, val, len, offset = 2;
  flags = buffer.readUInt16BE(0);
  if (0 === flags) return {};
  var fields = {
    contentType: void 0,
    contentEncoding: void 0,
    headers: void 0,
    deliveryMode: void 0,
    priority: void 0,
    correlationId: void 0,
    replyTo: void 0,
    expiration: void 0,
    messageId: void 0,
    timestamp: void 0,
    type: void 0,
    userId: void 0,
    appId: void 0,
    clusterId: void 0
  };
  if (32768 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.contentType = val;
  }
  if (16384 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.contentEncoding = val;
  }
  if (8192 & flags) {
    len = buffer.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer.slice(offset, offset + len));
    offset += len;
    fields.headers = val;
  }
  if (4096 & flags) {
    val = buffer[offset];
    offset++;
    fields.deliveryMode = val;
  }
  if (2048 & flags) {
    val = buffer[offset];
    offset++;
    fields.priority = val;
  }
  if (1024 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.correlationId = val;
  }
  if (512 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.replyTo = val;
  }
  if (256 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.expiration = val;
  }
  if (128 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.messageId = val;
  }
  if (64 & flags) {
    val = ints.readUInt64BE(buffer, offset);
    offset += 8;
    fields.timestamp = val;
  }
  if (32 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.type = val;
  }
  if (16 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.userId = val;
  }
  if (8 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.appId = val;
  }
  if (4 & flags) {
    len = buffer.readUInt8(offset);
    offset++;
    val = buffer.toString("utf8", offset, offset + len);
    offset += len;
    fields.clusterId = val;
  }
  return fields;
}

var codec = __webpack_require__(/*! ./codec */ "./node_modules/amqplib/lib/codec.js"), ints = __webpack_require__(/*! buffer-more-ints */ "./node_modules/buffer-more-ints/buffer-more-ints.js"), encodeTable = codec.encodeTable, decodeFields = codec.decodeFields, SCRATCH = Buffer.alloc(65536), EMPTY_OBJECT = Object.freeze({});

module.exports.constants = {
  FRAME_METHOD: 1,
  FRAME_HEADER: 2,
  FRAME_BODY: 3,
  FRAME_HEARTBEAT: 8,
  FRAME_MIN_SIZE: 4096,
  FRAME_END: 206,
  REPLY_SUCCESS: 200,
  CONTENT_TOO_LARGE: 311,
  NO_ROUTE: 312,
  NO_CONSUMERS: 313,
  ACCESS_REFUSED: 403,
  NOT_FOUND: 404,
  RESOURCE_LOCKED: 405,
  PRECONDITION_FAILED: 406,
  CONNECTION_FORCED: 320,
  INVALID_PATH: 402,
  FRAME_ERROR: 501,
  SYNTAX_ERROR: 502,
  COMMAND_INVALID: 503,
  CHANNEL_ERROR: 504,
  UNEXPECTED_FRAME: 505,
  RESOURCE_ERROR: 506,
  NOT_ALLOWED: 530,
  NOT_IMPLEMENTED: 540,
  INTERNAL_ERROR: 541
};

module.exports.constant_strs = {
  "1": "FRAME-METHOD",
  "2": "FRAME-HEADER",
  "3": "FRAME-BODY",
  "8": "FRAME-HEARTBEAT",
  "200": "REPLY-SUCCESS",
  "206": "FRAME-END",
  "311": "CONTENT-TOO-LARGE",
  "312": "NO-ROUTE",
  "313": "NO-CONSUMERS",
  "320": "CONNECTION-FORCED",
  "402": "INVALID-PATH",
  "403": "ACCESS-REFUSED",
  "404": "NOT-FOUND",
  "405": "RESOURCE-LOCKED",
  "406": "PRECONDITION-FAILED",
  "501": "FRAME-ERROR",
  "502": "SYNTAX-ERROR",
  "503": "COMMAND-INVALID",
  "504": "CHANNEL-ERROR",
  "505": "UNEXPECTED-FRAME",
  "506": "RESOURCE-ERROR",
  "530": "NOT-ALLOWED",
  "540": "NOT-IMPLEMENTED",
  "541": "INTERNAL-ERROR",
  "4096": "FRAME-MIN-SIZE"
};

module.exports.FRAME_OVERHEAD = 8;

module.exports.decode = function(id, buf) {
  switch (id) {
   case 655370:
    return decodeConnectionStart(buf);

   case 655371:
    return decodeConnectionStartOk(buf);

   case 655380:
    return decodeConnectionSecure(buf);

   case 655381:
    return decodeConnectionSecureOk(buf);

   case 655390:
    return decodeConnectionTune(buf);

   case 655391:
    return decodeConnectionTuneOk(buf);

   case 655400:
    return decodeConnectionOpen(buf);

   case 655401:
    return decodeConnectionOpenOk(buf);

   case 655410:
    return decodeConnectionClose(buf);

   case 655411:
    return decodeConnectionCloseOk(buf);

   case 655420:
    return decodeConnectionBlocked(buf);

   case 655421:
    return decodeConnectionUnblocked(buf);

   case 1310730:
    return decodeChannelOpen(buf);

   case 1310731:
    return decodeChannelOpenOk(buf);

   case 1310740:
    return decodeChannelFlow(buf);

   case 1310741:
    return decodeChannelFlowOk(buf);

   case 1310760:
    return decodeChannelClose(buf);

   case 1310761:
    return decodeChannelCloseOk(buf);

   case 1966090:
    return decodeAccessRequest(buf);

   case 1966091:
    return decodeAccessRequestOk(buf);

   case 2621450:
    return decodeExchangeDeclare(buf);

   case 2621451:
    return decodeExchangeDeclareOk(buf);

   case 2621460:
    return decodeExchangeDelete(buf);

   case 2621461:
    return decodeExchangeDeleteOk(buf);

   case 2621470:
    return decodeExchangeBind(buf);

   case 2621471:
    return decodeExchangeBindOk(buf);

   case 2621480:
    return decodeExchangeUnbind(buf);

   case 2621491:
    return decodeExchangeUnbindOk(buf);

   case 3276810:
    return decodeQueueDeclare(buf);

   case 3276811:
    return decodeQueueDeclareOk(buf);

   case 3276820:
    return decodeQueueBind(buf);

   case 3276821:
    return decodeQueueBindOk(buf);

   case 3276830:
    return decodeQueuePurge(buf);

   case 3276831:
    return decodeQueuePurgeOk(buf);

   case 3276840:
    return decodeQueueDelete(buf);

   case 3276841:
    return decodeQueueDeleteOk(buf);

   case 3276850:
    return decodeQueueUnbind(buf);

   case 3276851:
    return decodeQueueUnbindOk(buf);

   case 3932170:
    return decodeBasicQos(buf);

   case 3932171:
    return decodeBasicQosOk(buf);

   case 3932180:
    return decodeBasicConsume(buf);

   case 3932181:
    return decodeBasicConsumeOk(buf);

   case 3932190:
    return decodeBasicCancel(buf);

   case 3932191:
    return decodeBasicCancelOk(buf);

   case 3932200:
    return decodeBasicPublish(buf);

   case 3932210:
    return decodeBasicReturn(buf);

   case 3932220:
    return decodeBasicDeliver(buf);

   case 3932230:
    return decodeBasicGet(buf);

   case 3932231:
    return decodeBasicGetOk(buf);

   case 3932232:
    return decodeBasicGetEmpty(buf);

   case 3932240:
    return decodeBasicAck(buf);

   case 3932250:
    return decodeBasicReject(buf);

   case 3932260:
    return decodeBasicRecoverAsync(buf);

   case 3932270:
    return decodeBasicRecover(buf);

   case 3932271:
    return decodeBasicRecoverOk(buf);

   case 3932280:
    return decodeBasicNack(buf);

   case 5898250:
    return decodeTxSelect(buf);

   case 5898251:
    return decodeTxSelectOk(buf);

   case 5898260:
    return decodeTxCommit(buf);

   case 5898261:
    return decodeTxCommitOk(buf);

   case 5898270:
    return decodeTxRollback(buf);

   case 5898271:
    return decodeTxRollbackOk(buf);

   case 5570570:
    return decodeConfirmSelect(buf);

   case 5570571:
    return decodeConfirmSelectOk(buf);

   case 60:
    return decodeBasicProperties(buf);

   default:
    throw new Error("Unknown class/method ID");
  }
};

module.exports.encodeMethod = function(id, channel, fields) {
  switch (id) {
   case 655370:
    return encodeConnectionStart(channel, fields);

   case 655371:
    return encodeConnectionStartOk(channel, fields);

   case 655380:
    return encodeConnectionSecure(channel, fields);

   case 655381:
    return encodeConnectionSecureOk(channel, fields);

   case 655390:
    return encodeConnectionTune(channel, fields);

   case 655391:
    return encodeConnectionTuneOk(channel, fields);

   case 655400:
    return encodeConnectionOpen(channel, fields);

   case 655401:
    return encodeConnectionOpenOk(channel, fields);

   case 655410:
    return encodeConnectionClose(channel, fields);

   case 655411:
    return encodeConnectionCloseOk(channel, fields);

   case 655420:
    return encodeConnectionBlocked(channel, fields);

   case 655421:
    return encodeConnectionUnblocked(channel, fields);

   case 1310730:
    return encodeChannelOpen(channel, fields);

   case 1310731:
    return encodeChannelOpenOk(channel, fields);

   case 1310740:
    return encodeChannelFlow(channel, fields);

   case 1310741:
    return encodeChannelFlowOk(channel, fields);

   case 1310760:
    return encodeChannelClose(channel, fields);

   case 1310761:
    return encodeChannelCloseOk(channel, fields);

   case 1966090:
    return encodeAccessRequest(channel, fields);

   case 1966091:
    return encodeAccessRequestOk(channel, fields);

   case 2621450:
    return encodeExchangeDeclare(channel, fields);

   case 2621451:
    return encodeExchangeDeclareOk(channel, fields);

   case 2621460:
    return encodeExchangeDelete(channel, fields);

   case 2621461:
    return encodeExchangeDeleteOk(channel, fields);

   case 2621470:
    return encodeExchangeBind(channel, fields);

   case 2621471:
    return encodeExchangeBindOk(channel, fields);

   case 2621480:
    return encodeExchangeUnbind(channel, fields);

   case 2621491:
    return encodeExchangeUnbindOk(channel, fields);

   case 3276810:
    return encodeQueueDeclare(channel, fields);

   case 3276811:
    return encodeQueueDeclareOk(channel, fields);

   case 3276820:
    return encodeQueueBind(channel, fields);

   case 3276821:
    return encodeQueueBindOk(channel, fields);

   case 3276830:
    return encodeQueuePurge(channel, fields);

   case 3276831:
    return encodeQueuePurgeOk(channel, fields);

   case 3276840:
    return encodeQueueDelete(channel, fields);

   case 3276841:
    return encodeQueueDeleteOk(channel, fields);

   case 3276850:
    return encodeQueueUnbind(channel, fields);

   case 3276851:
    return encodeQueueUnbindOk(channel, fields);

   case 3932170:
    return encodeBasicQos(channel, fields);

   case 3932171:
    return encodeBasicQosOk(channel, fields);

   case 3932180:
    return encodeBasicConsume(channel, fields);

   case 3932181:
    return encodeBasicConsumeOk(channel, fields);

   case 3932190:
    return encodeBasicCancel(channel, fields);

   case 3932191:
    return encodeBasicCancelOk(channel, fields);

   case 3932200:
    return encodeBasicPublish(channel, fields);

   case 3932210:
    return encodeBasicReturn(channel, fields);

   case 3932220:
    return encodeBasicDeliver(channel, fields);

   case 3932230:
    return encodeBasicGet(channel, fields);

   case 3932231:
    return encodeBasicGetOk(channel, fields);

   case 3932232:
    return encodeBasicGetEmpty(channel, fields);

   case 3932240:
    return encodeBasicAck(channel, fields);

   case 3932250:
    return encodeBasicReject(channel, fields);

   case 3932260:
    return encodeBasicRecoverAsync(channel, fields);

   case 3932270:
    return encodeBasicRecover(channel, fields);

   case 3932271:
    return encodeBasicRecoverOk(channel, fields);

   case 3932280:
    return encodeBasicNack(channel, fields);

   case 5898250:
    return encodeTxSelect(channel, fields);

   case 5898251:
    return encodeTxSelectOk(channel, fields);

   case 5898260:
    return encodeTxCommit(channel, fields);

   case 5898261:
    return encodeTxCommitOk(channel, fields);

   case 5898270:
    return encodeTxRollback(channel, fields);

   case 5898271:
    return encodeTxRollbackOk(channel, fields);

   case 5570570:
    return encodeConfirmSelect(channel, fields);

   case 5570571:
    return encodeConfirmSelectOk(channel, fields);

   default:
    throw new Error("Unknown class/method ID");
  }
};

module.exports.encodeProperties = function(id, channel, size, fields) {
  switch (id) {
   case 60:
    return encodeBasicProperties(channel, size, fields);

   default:
    throw new Error("Unknown class/properties ID");
  }
};

module.exports.info = function(id) {
  switch (id) {
   case 655370:
    return methodInfoConnectionStart;

   case 655371:
    return methodInfoConnectionStartOk;

   case 655380:
    return methodInfoConnectionSecure;

   case 655381:
    return methodInfoConnectionSecureOk;

   case 655390:
    return methodInfoConnectionTune;

   case 655391:
    return methodInfoConnectionTuneOk;

   case 655400:
    return methodInfoConnectionOpen;

   case 655401:
    return methodInfoConnectionOpenOk;

   case 655410:
    return methodInfoConnectionClose;

   case 655411:
    return methodInfoConnectionCloseOk;

   case 655420:
    return methodInfoConnectionBlocked;

   case 655421:
    return methodInfoConnectionUnblocked;

   case 1310730:
    return methodInfoChannelOpen;

   case 1310731:
    return methodInfoChannelOpenOk;

   case 1310740:
    return methodInfoChannelFlow;

   case 1310741:
    return methodInfoChannelFlowOk;

   case 1310760:
    return methodInfoChannelClose;

   case 1310761:
    return methodInfoChannelCloseOk;

   case 1966090:
    return methodInfoAccessRequest;

   case 1966091:
    return methodInfoAccessRequestOk;

   case 2621450:
    return methodInfoExchangeDeclare;

   case 2621451:
    return methodInfoExchangeDeclareOk;

   case 2621460:
    return methodInfoExchangeDelete;

   case 2621461:
    return methodInfoExchangeDeleteOk;

   case 2621470:
    return methodInfoExchangeBind;

   case 2621471:
    return methodInfoExchangeBindOk;

   case 2621480:
    return methodInfoExchangeUnbind;

   case 2621491:
    return methodInfoExchangeUnbindOk;

   case 3276810:
    return methodInfoQueueDeclare;

   case 3276811:
    return methodInfoQueueDeclareOk;

   case 3276820:
    return methodInfoQueueBind;

   case 3276821:
    return methodInfoQueueBindOk;

   case 3276830:
    return methodInfoQueuePurge;

   case 3276831:
    return methodInfoQueuePurgeOk;

   case 3276840:
    return methodInfoQueueDelete;

   case 3276841:
    return methodInfoQueueDeleteOk;

   case 3276850:
    return methodInfoQueueUnbind;

   case 3276851:
    return methodInfoQueueUnbindOk;

   case 3932170:
    return methodInfoBasicQos;

   case 3932171:
    return methodInfoBasicQosOk;

   case 3932180:
    return methodInfoBasicConsume;

   case 3932181:
    return methodInfoBasicConsumeOk;

   case 3932190:
    return methodInfoBasicCancel;

   case 3932191:
    return methodInfoBasicCancelOk;

   case 3932200:
    return methodInfoBasicPublish;

   case 3932210:
    return methodInfoBasicReturn;

   case 3932220:
    return methodInfoBasicDeliver;

   case 3932230:
    return methodInfoBasicGet;

   case 3932231:
    return methodInfoBasicGetOk;

   case 3932232:
    return methodInfoBasicGetEmpty;

   case 3932240:
    return methodInfoBasicAck;

   case 3932250:
    return methodInfoBasicReject;

   case 3932260:
    return methodInfoBasicRecoverAsync;

   case 3932270:
    return methodInfoBasicRecover;

   case 3932271:
    return methodInfoBasicRecoverOk;

   case 3932280:
    return methodInfoBasicNack;

   case 5898250:
    return methodInfoTxSelect;

   case 5898251:
    return methodInfoTxSelectOk;

   case 5898260:
    return methodInfoTxCommit;

   case 5898261:
    return methodInfoTxCommitOk;

   case 5898270:
    return methodInfoTxRollback;

   case 5898271:
    return methodInfoTxRollbackOk;

   case 5570570:
    return methodInfoConfirmSelect;

   case 5570571:
    return methodInfoConfirmSelectOk;

   case 60:
    return propertiesInfoBasicProperties;

   default:
    throw new Error("Unknown class/method ID");
  }
};

module.exports.ConnectionStart = 655370;

var methodInfoConnectionStart = module.exports.methodInfoConnectionStart = {
  id: 655370,
  classId: 10,
  methodId: 10,
  name: "ConnectionStart",
  args: [ {
    type: "octet",
    name: "versionMajor",
    default: 0
  }, {
    type: "octet",
    name: "versionMinor",
    default: 9
  }, {
    type: "table",
    name: "serverProperties"
  }, {
    type: "longstr",
    name: "mechanisms",
    default: "PLAIN"
  }, {
    type: "longstr",
    name: "locales",
    default: "en_US"
  } ]
};

module.exports.ConnectionStartOk = 655371;

var methodInfoConnectionStartOk = module.exports.methodInfoConnectionStartOk = {
  id: 655371,
  classId: 10,
  methodId: 11,
  name: "ConnectionStartOk",
  args: [ {
    type: "table",
    name: "clientProperties"
  }, {
    type: "shortstr",
    name: "mechanism",
    default: "PLAIN"
  }, {
    type: "longstr",
    name: "response"
  }, {
    type: "shortstr",
    name: "locale",
    default: "en_US"
  } ]
};

module.exports.ConnectionSecure = 655380;

var methodInfoConnectionSecure = module.exports.methodInfoConnectionSecure = {
  id: 655380,
  classId: 10,
  methodId: 20,
  name: "ConnectionSecure",
  args: [ {
    type: "longstr",
    name: "challenge"
  } ]
};

module.exports.ConnectionSecureOk = 655381;

var methodInfoConnectionSecureOk = module.exports.methodInfoConnectionSecureOk = {
  id: 655381,
  classId: 10,
  methodId: 21,
  name: "ConnectionSecureOk",
  args: [ {
    type: "longstr",
    name: "response"
  } ]
};

module.exports.ConnectionTune = 655390;

var methodInfoConnectionTune = module.exports.methodInfoConnectionTune = {
  id: 655390,
  classId: 10,
  methodId: 30,
  name: "ConnectionTune",
  args: [ {
    type: "short",
    name: "channelMax",
    default: 0
  }, {
    type: "long",
    name: "frameMax",
    default: 0
  }, {
    type: "short",
    name: "heartbeat",
    default: 0
  } ]
};

module.exports.ConnectionTuneOk = 655391;

var methodInfoConnectionTuneOk = module.exports.methodInfoConnectionTuneOk = {
  id: 655391,
  classId: 10,
  methodId: 31,
  name: "ConnectionTuneOk",
  args: [ {
    type: "short",
    name: "channelMax",
    default: 0
  }, {
    type: "long",
    name: "frameMax",
    default: 0
  }, {
    type: "short",
    name: "heartbeat",
    default: 0
  } ]
};

module.exports.ConnectionOpen = 655400;

var methodInfoConnectionOpen = module.exports.methodInfoConnectionOpen = {
  id: 655400,
  classId: 10,
  methodId: 40,
  name: "ConnectionOpen",
  args: [ {
    type: "shortstr",
    name: "virtualHost",
    default: "/"
  }, {
    type: "shortstr",
    name: "capabilities",
    default: ""
  }, {
    type: "bit",
    name: "insist",
    default: !1
  } ]
};

module.exports.ConnectionOpenOk = 655401;

var methodInfoConnectionOpenOk = module.exports.methodInfoConnectionOpenOk = {
  id: 655401,
  classId: 10,
  methodId: 41,
  name: "ConnectionOpenOk",
  args: [ {
    type: "shortstr",
    name: "knownHosts",
    default: ""
  } ]
};

module.exports.ConnectionClose = 655410;

var methodInfoConnectionClose = module.exports.methodInfoConnectionClose = {
  id: 655410,
  classId: 10,
  methodId: 50,
  name: "ConnectionClose",
  args: [ {
    type: "short",
    name: "replyCode"
  }, {
    type: "shortstr",
    name: "replyText",
    default: ""
  }, {
    type: "short",
    name: "classId"
  }, {
    type: "short",
    name: "methodId"
  } ]
};

module.exports.ConnectionCloseOk = 655411;

var methodInfoConnectionCloseOk = module.exports.methodInfoConnectionCloseOk = {
  id: 655411,
  classId: 10,
  methodId: 51,
  name: "ConnectionCloseOk",
  args: []
};

module.exports.ConnectionBlocked = 655420;

var methodInfoConnectionBlocked = module.exports.methodInfoConnectionBlocked = {
  id: 655420,
  classId: 10,
  methodId: 60,
  name: "ConnectionBlocked",
  args: [ {
    type: "shortstr",
    name: "reason",
    default: ""
  } ]
};

module.exports.ConnectionUnblocked = 655421;

var methodInfoConnectionUnblocked = module.exports.methodInfoConnectionUnblocked = {
  id: 655421,
  classId: 10,
  methodId: 61,
  name: "ConnectionUnblocked",
  args: []
};

module.exports.ChannelOpen = 1310730;

var methodInfoChannelOpen = module.exports.methodInfoChannelOpen = {
  id: 1310730,
  classId: 20,
  methodId: 10,
  name: "ChannelOpen",
  args: [ {
    type: "shortstr",
    name: "outOfBand",
    default: ""
  } ]
};

module.exports.ChannelOpenOk = 1310731;

var methodInfoChannelOpenOk = module.exports.methodInfoChannelOpenOk = {
  id: 1310731,
  classId: 20,
  methodId: 11,
  name: "ChannelOpenOk",
  args: [ {
    type: "longstr",
    name: "channelId",
    default: ""
  } ]
};

module.exports.ChannelFlow = 1310740;

var methodInfoChannelFlow = module.exports.methodInfoChannelFlow = {
  id: 1310740,
  classId: 20,
  methodId: 20,
  name: "ChannelFlow",
  args: [ {
    type: "bit",
    name: "active"
  } ]
};

module.exports.ChannelFlowOk = 1310741;

var methodInfoChannelFlowOk = module.exports.methodInfoChannelFlowOk = {
  id: 1310741,
  classId: 20,
  methodId: 21,
  name: "ChannelFlowOk",
  args: [ {
    type: "bit",
    name: "active"
  } ]
};

module.exports.ChannelClose = 1310760;

var methodInfoChannelClose = module.exports.methodInfoChannelClose = {
  id: 1310760,
  classId: 20,
  methodId: 40,
  name: "ChannelClose",
  args: [ {
    type: "short",
    name: "replyCode"
  }, {
    type: "shortstr",
    name: "replyText",
    default: ""
  }, {
    type: "short",
    name: "classId"
  }, {
    type: "short",
    name: "methodId"
  } ]
};

module.exports.ChannelCloseOk = 1310761;

var methodInfoChannelCloseOk = module.exports.methodInfoChannelCloseOk = {
  id: 1310761,
  classId: 20,
  methodId: 41,
  name: "ChannelCloseOk",
  args: []
};

module.exports.AccessRequest = 1966090;

var methodInfoAccessRequest = module.exports.methodInfoAccessRequest = {
  id: 1966090,
  classId: 30,
  methodId: 10,
  name: "AccessRequest",
  args: [ {
    type: "shortstr",
    name: "realm",
    default: "/data"
  }, {
    type: "bit",
    name: "exclusive",
    default: !1
  }, {
    type: "bit",
    name: "passive",
    default: !0
  }, {
    type: "bit",
    name: "active",
    default: !0
  }, {
    type: "bit",
    name: "write",
    default: !0
  }, {
    type: "bit",
    name: "read",
    default: !0
  } ]
};

module.exports.AccessRequestOk = 1966091;

var methodInfoAccessRequestOk = module.exports.methodInfoAccessRequestOk = {
  id: 1966091,
  classId: 30,
  methodId: 11,
  name: "AccessRequestOk",
  args: [ {
    type: "short",
    name: "ticket",
    default: 1
  } ]
};

module.exports.ExchangeDeclare = 2621450;

var methodInfoExchangeDeclare = module.exports.methodInfoExchangeDeclare = {
  id: 2621450,
  classId: 40,
  methodId: 10,
  name: "ExchangeDeclare",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "type",
    default: "direct"
  }, {
    type: "bit",
    name: "passive",
    default: !1
  }, {
    type: "bit",
    name: "durable",
    default: !1
  }, {
    type: "bit",
    name: "autoDelete",
    default: !1
  }, {
    type: "bit",
    name: "internal",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.ExchangeDeclareOk = 2621451;

var methodInfoExchangeDeclareOk = module.exports.methodInfoExchangeDeclareOk = {
  id: 2621451,
  classId: 40,
  methodId: 11,
  name: "ExchangeDeclareOk",
  args: []
};

module.exports.ExchangeDelete = 2621460;

var methodInfoExchangeDelete = module.exports.methodInfoExchangeDelete = {
  id: 2621460,
  classId: 40,
  methodId: 20,
  name: "ExchangeDelete",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "bit",
    name: "ifUnused",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.ExchangeDeleteOk = 2621461;

var methodInfoExchangeDeleteOk = module.exports.methodInfoExchangeDeleteOk = {
  id: 2621461,
  classId: 40,
  methodId: 21,
  name: "ExchangeDeleteOk",
  args: []
};

module.exports.ExchangeBind = 2621470;

var methodInfoExchangeBind = module.exports.methodInfoExchangeBind = {
  id: 2621470,
  classId: 40,
  methodId: 30,
  name: "ExchangeBind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "destination"
  }, {
    type: "shortstr",
    name: "source"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.ExchangeBindOk = 2621471;

var methodInfoExchangeBindOk = module.exports.methodInfoExchangeBindOk = {
  id: 2621471,
  classId: 40,
  methodId: 31,
  name: "ExchangeBindOk",
  args: []
};

module.exports.ExchangeUnbind = 2621480;

var methodInfoExchangeUnbind = module.exports.methodInfoExchangeUnbind = {
  id: 2621480,
  classId: 40,
  methodId: 40,
  name: "ExchangeUnbind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "destination"
  }, {
    type: "shortstr",
    name: "source"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.ExchangeUnbindOk = 2621491;

var methodInfoExchangeUnbindOk = module.exports.methodInfoExchangeUnbindOk = {
  id: 2621491,
  classId: 40,
  methodId: 51,
  name: "ExchangeUnbindOk",
  args: []
};

module.exports.QueueDeclare = 3276810;

var methodInfoQueueDeclare = module.exports.methodInfoQueueDeclare = {
  id: 3276810,
  classId: 50,
  methodId: 10,
  name: "QueueDeclare",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "passive",
    default: !1
  }, {
    type: "bit",
    name: "durable",
    default: !1
  }, {
    type: "bit",
    name: "exclusive",
    default: !1
  }, {
    type: "bit",
    name: "autoDelete",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.QueueDeclareOk = 3276811;

var methodInfoQueueDeclareOk = module.exports.methodInfoQueueDeclareOk = {
  id: 3276811,
  classId: 50,
  methodId: 11,
  name: "QueueDeclareOk",
  args: [ {
    type: "shortstr",
    name: "queue"
  }, {
    type: "long",
    name: "messageCount"
  }, {
    type: "long",
    name: "consumerCount"
  } ]
};

module.exports.QueueBind = 3276820;

var methodInfoQueueBind = module.exports.methodInfoQueueBind = {
  id: 3276820,
  classId: 50,
  methodId: 20,
  name: "QueueBind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.QueueBindOk = 3276821;

var methodInfoQueueBindOk = module.exports.methodInfoQueueBindOk = {
  id: 3276821,
  classId: 50,
  methodId: 21,
  name: "QueueBindOk",
  args: []
};

module.exports.QueuePurge = 3276830;

var methodInfoQueuePurge = module.exports.methodInfoQueuePurge = {
  id: 3276830,
  classId: 50,
  methodId: 30,
  name: "QueuePurge",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.QueuePurgeOk = 3276831;

var methodInfoQueuePurgeOk = module.exports.methodInfoQueuePurgeOk = {
  id: 3276831,
  classId: 50,
  methodId: 31,
  name: "QueuePurgeOk",
  args: [ {
    type: "long",
    name: "messageCount"
  } ]
};

module.exports.QueueDelete = 3276840;

var methodInfoQueueDelete = module.exports.methodInfoQueueDelete = {
  id: 3276840,
  classId: 50,
  methodId: 40,
  name: "QueueDelete",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "ifUnused",
    default: !1
  }, {
    type: "bit",
    name: "ifEmpty",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.QueueDeleteOk = 3276841;

var methodInfoQueueDeleteOk = module.exports.methodInfoQueueDeleteOk = {
  id: 3276841,
  classId: 50,
  methodId: 41,
  name: "QueueDeleteOk",
  args: [ {
    type: "long",
    name: "messageCount"
  } ]
};

module.exports.QueueUnbind = 3276850;

var methodInfoQueueUnbind = module.exports.methodInfoQueueUnbind = {
  id: 3276850,
  classId: 50,
  methodId: 50,
  name: "QueueUnbind",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.QueueUnbindOk = 3276851;

var methodInfoQueueUnbindOk = module.exports.methodInfoQueueUnbindOk = {
  id: 3276851,
  classId: 50,
  methodId: 51,
  name: "QueueUnbindOk",
  args: []
};

module.exports.BasicQos = 3932170;

var methodInfoBasicQos = module.exports.methodInfoBasicQos = {
  id: 3932170,
  classId: 60,
  methodId: 10,
  name: "BasicQos",
  args: [ {
    type: "long",
    name: "prefetchSize",
    default: 0
  }, {
    type: "short",
    name: "prefetchCount",
    default: 0
  }, {
    type: "bit",
    name: "global",
    default: !1
  } ]
};

module.exports.BasicQosOk = 3932171;

var methodInfoBasicQosOk = module.exports.methodInfoBasicQosOk = {
  id: 3932171,
  classId: 60,
  methodId: 11,
  name: "BasicQosOk",
  args: []
};

module.exports.BasicConsume = 3932180;

var methodInfoBasicConsume = module.exports.methodInfoBasicConsume = {
  id: 3932180,
  classId: 60,
  methodId: 20,
  name: "BasicConsume",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "shortstr",
    name: "consumerTag",
    default: ""
  }, {
    type: "bit",
    name: "noLocal",
    default: !1
  }, {
    type: "bit",
    name: "noAck",
    default: !1
  }, {
    type: "bit",
    name: "exclusive",
    default: !1
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  }, {
    type: "table",
    name: "arguments",
    default: {}
  } ]
};

module.exports.BasicConsumeOk = 3932181;

var methodInfoBasicConsumeOk = module.exports.methodInfoBasicConsumeOk = {
  id: 3932181,
  classId: 60,
  methodId: 21,
  name: "BasicConsumeOk",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  } ]
};

module.exports.BasicCancel = 3932190;

var methodInfoBasicCancel = module.exports.methodInfoBasicCancel = {
  id: 3932190,
  classId: 60,
  methodId: 30,
  name: "BasicCancel",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  }, {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.BasicCancelOk = 3932191;

var methodInfoBasicCancelOk = module.exports.methodInfoBasicCancelOk = {
  id: 3932191,
  classId: 60,
  methodId: 31,
  name: "BasicCancelOk",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  } ]
};

module.exports.BasicPublish = 3932200;

var methodInfoBasicPublish = module.exports.methodInfoBasicPublish = {
  id: 3932200,
  classId: 60,
  methodId: 40,
  name: "BasicPublish",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "exchange",
    default: ""
  }, {
    type: "shortstr",
    name: "routingKey",
    default: ""
  }, {
    type: "bit",
    name: "mandatory",
    default: !1
  }, {
    type: "bit",
    name: "immediate",
    default: !1
  } ]
};

module.exports.BasicReturn = 3932210;

var methodInfoBasicReturn = module.exports.methodInfoBasicReturn = {
  id: 3932210,
  classId: 60,
  methodId: 50,
  name: "BasicReturn",
  args: [ {
    type: "short",
    name: "replyCode"
  }, {
    type: "shortstr",
    name: "replyText",
    default: ""
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey"
  } ]
};

module.exports.BasicDeliver = 3932220;

var methodInfoBasicDeliver = module.exports.methodInfoBasicDeliver = {
  id: 3932220,
  classId: 60,
  methodId: 60,
  name: "BasicDeliver",
  args: [ {
    type: "shortstr",
    name: "consumerTag"
  }, {
    type: "longlong",
    name: "deliveryTag"
  }, {
    type: "bit",
    name: "redelivered",
    default: !1
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey"
  } ]
};

module.exports.BasicGet = 3932230;

var methodInfoBasicGet = module.exports.methodInfoBasicGet = {
  id: 3932230,
  classId: 60,
  methodId: 70,
  name: "BasicGet",
  args: [ {
    type: "short",
    name: "ticket",
    default: 0
  }, {
    type: "shortstr",
    name: "queue",
    default: ""
  }, {
    type: "bit",
    name: "noAck",
    default: !1
  } ]
};

module.exports.BasicGetOk = 3932231;

var methodInfoBasicGetOk = module.exports.methodInfoBasicGetOk = {
  id: 3932231,
  classId: 60,
  methodId: 71,
  name: "BasicGetOk",
  args: [ {
    type: "longlong",
    name: "deliveryTag"
  }, {
    type: "bit",
    name: "redelivered",
    default: !1
  }, {
    type: "shortstr",
    name: "exchange"
  }, {
    type: "shortstr",
    name: "routingKey"
  }, {
    type: "long",
    name: "messageCount"
  } ]
};

module.exports.BasicGetEmpty = 3932232;

var methodInfoBasicGetEmpty = module.exports.methodInfoBasicGetEmpty = {
  id: 3932232,
  classId: 60,
  methodId: 72,
  name: "BasicGetEmpty",
  args: [ {
    type: "shortstr",
    name: "clusterId",
    default: ""
  } ]
};

module.exports.BasicAck = 3932240;

var methodInfoBasicAck = module.exports.methodInfoBasicAck = {
  id: 3932240,
  classId: 60,
  methodId: 80,
  name: "BasicAck",
  args: [ {
    type: "longlong",
    name: "deliveryTag",
    default: 0
  }, {
    type: "bit",
    name: "multiple",
    default: !1
  } ]
};

module.exports.BasicReject = 3932250;

var methodInfoBasicReject = module.exports.methodInfoBasicReject = {
  id: 3932250,
  classId: 60,
  methodId: 90,
  name: "BasicReject",
  args: [ {
    type: "longlong",
    name: "deliveryTag"
  }, {
    type: "bit",
    name: "requeue",
    default: !0
  } ]
};

module.exports.BasicRecoverAsync = 3932260;

var methodInfoBasicRecoverAsync = module.exports.methodInfoBasicRecoverAsync = {
  id: 3932260,
  classId: 60,
  methodId: 100,
  name: "BasicRecoverAsync",
  args: [ {
    type: "bit",
    name: "requeue",
    default: !1
  } ]
};

module.exports.BasicRecover = 3932270;

var methodInfoBasicRecover = module.exports.methodInfoBasicRecover = {
  id: 3932270,
  classId: 60,
  methodId: 110,
  name: "BasicRecover",
  args: [ {
    type: "bit",
    name: "requeue",
    default: !1
  } ]
};

module.exports.BasicRecoverOk = 3932271;

var methodInfoBasicRecoverOk = module.exports.methodInfoBasicRecoverOk = {
  id: 3932271,
  classId: 60,
  methodId: 111,
  name: "BasicRecoverOk",
  args: []
};

module.exports.BasicNack = 3932280;

var methodInfoBasicNack = module.exports.methodInfoBasicNack = {
  id: 3932280,
  classId: 60,
  methodId: 120,
  name: "BasicNack",
  args: [ {
    type: "longlong",
    name: "deliveryTag",
    default: 0
  }, {
    type: "bit",
    name: "multiple",
    default: !1
  }, {
    type: "bit",
    name: "requeue",
    default: !0
  } ]
};

module.exports.TxSelect = 5898250;

var methodInfoTxSelect = module.exports.methodInfoTxSelect = {
  id: 5898250,
  classId: 90,
  methodId: 10,
  name: "TxSelect",
  args: []
};

module.exports.TxSelectOk = 5898251;

var methodInfoTxSelectOk = module.exports.methodInfoTxSelectOk = {
  id: 5898251,
  classId: 90,
  methodId: 11,
  name: "TxSelectOk",
  args: []
};

module.exports.TxCommit = 5898260;

var methodInfoTxCommit = module.exports.methodInfoTxCommit = {
  id: 5898260,
  classId: 90,
  methodId: 20,
  name: "TxCommit",
  args: []
};

module.exports.TxCommitOk = 5898261;

var methodInfoTxCommitOk = module.exports.methodInfoTxCommitOk = {
  id: 5898261,
  classId: 90,
  methodId: 21,
  name: "TxCommitOk",
  args: []
};

module.exports.TxRollback = 5898270;

var methodInfoTxRollback = module.exports.methodInfoTxRollback = {
  id: 5898270,
  classId: 90,
  methodId: 30,
  name: "TxRollback",
  args: []
};

module.exports.TxRollbackOk = 5898271;

var methodInfoTxRollbackOk = module.exports.methodInfoTxRollbackOk = {
  id: 5898271,
  classId: 90,
  methodId: 31,
  name: "TxRollbackOk",
  args: []
};

module.exports.ConfirmSelect = 5570570;

var methodInfoConfirmSelect = module.exports.methodInfoConfirmSelect = {
  id: 5570570,
  classId: 85,
  methodId: 10,
  name: "ConfirmSelect",
  args: [ {
    type: "bit",
    name: "nowait",
    default: !1
  } ]
};

module.exports.ConfirmSelectOk = 5570571;

var methodInfoConfirmSelectOk = module.exports.methodInfoConfirmSelectOk = {
  id: 5570571,
  classId: 85,
  methodId: 11,
  name: "ConfirmSelectOk",
  args: []
};

module.exports.BasicProperties = 60;

var propertiesInfoBasicProperties = module.exports.propertiesInfoBasicProperties = {
  id: 60,
  name: "BasicProperties",
  args: [ {
    type: "shortstr",
    name: "contentType"
  }, {
    type: "shortstr",
    name: "contentEncoding"
  }, {
    type: "table",
    name: "headers"
  }, {
    type: "octet",
    name: "deliveryMode"
  }, {
    type: "octet",
    name: "priority"
  }, {
    type: "shortstr",
    name: "correlationId"
  }, {
    type: "shortstr",
    name: "replyTo"
  }, {
    type: "shortstr",
    name: "expiration"
  }, {
    type: "shortstr",
    name: "messageId"
  }, {
    type: "timestamp",
    name: "timestamp"
  }, {
    type: "shortstr",
    name: "type"
  }, {
    type: "shortstr",
    name: "userId"
  }, {
    type: "shortstr",
    name: "appId"
  }, {
    type: "shortstr",
    name: "clusterId"
  } ]
};

/***/ }),

/***/ "./node_modules/amqplib/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/error.js ***!
  \*******************************************/
/***/ ((module) => {

var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

function trimStack(stack, num) {
  return stack && stack.split('\n').slice(num).join('\n');
}

function IllegalOperationError(msg, stack) {
  var tmp = new Error();
  this.message = msg;
  this.stack = this.toString() + '\n' + trimStack(tmp.stack, 2);
  this.stackAtStateChange = stack;
}
inherits(IllegalOperationError, Error);

IllegalOperationError.prototype.name = 'IllegalOperationError';

function stackCapture(reason) {
  var e = new Error();
  return 'Stack capture: ' + reason + '\n' +
    trimStack(e.stack, 2);
}

module.exports.IllegalOperationError = IllegalOperationError;
module.exports.stackCapture = stackCapture;


/***/ }),

/***/ "./node_modules/amqplib/lib/format.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/format.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// Stringifying various things



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var format = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var HEARTBEAT = (__webpack_require__(/*! ./frame */ "./node_modules/amqplib/lib/frame.js").HEARTBEAT);

module.exports.closeMessage = function(close) {
  var code = close.fields.replyCode;
  return format('%d (%s) with message "%s"',
                code, defs.constant_strs[code],
                close.fields.replyText);
}

module.exports.methodName = function(id) {
  return defs.info(id).name;
};

module.exports.inspect = function(frame, showFields) {
  if (frame === HEARTBEAT) {
    return '<Heartbeat>';
  }
  else if (!frame.id) {
    return format('<Content channel:%d size:%d>',
                  frame.channel, frame.size);
  }
  else {
    var info = defs.info(frame.id);
    return format('<%s channel:%d%s>', info.name, frame.channel,
                  (showFields)
                  ? ' ' + JSON.stringify(frame.fields, undefined, 2)
                  : '');
  }
}


/***/ }),

/***/ "./node_modules/amqplib/lib/frame.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/frame.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// The river sweeps through
// Silt and twigs, gravel and leaves
// Driving the wheel on



var defs = __webpack_require__(/*! ./defs */ "./node_modules/amqplib/lib/defs.js");
var constants = defs.constants;
var decode = defs.decode;

var Bits = __webpack_require__(/*! @acuminous/bitsyntax */ "./node_modules/@acuminous/bitsyntax/index.js");

module.exports.PROTOCOL_HEADER = "AMQP" + String.fromCharCode(0, 0, 9, 1);

/*
  Frame format:

  0      1         3             7                size+7 size+8
  +------+---------+-------------+ +------------+ +-----------+
  | type | channel | size        | | payload    | | frame-end |
  +------+---------+-------------+ +------------+ +-----------+
  octet   short     long            size octets    octet

  In general I want to know those first three things straight away, so I
  can discard frames early.

*/

// framing constants
var FRAME_METHOD = constants.FRAME_METHOD,
FRAME_HEARTBEAT = constants.FRAME_HEARTBEAT,
FRAME_HEADER = constants.FRAME_HEADER,
FRAME_BODY = constants.FRAME_BODY,
FRAME_END = constants.FRAME_END;

var bodyCons =
  Bits.builder(FRAME_BODY,
               'channel:16, size:32, payload:size/binary',
               FRAME_END);

// %%% TESTME possibly better to cons the first bit and write the
// second directly, in the absence of IO lists
module.exports.makeBodyFrame = function(channel, payload) {
  return bodyCons({channel: channel, size: payload.length, payload: payload});
};

var frameHeaderPattern = Bits.matcher('type:8', 'channel:16',
                                      'size:32', 'rest/binary');

function parseFrame(bin, max) {
  var fh = frameHeaderPattern(bin);
  if (fh) {
    var size = fh.size, rest = fh.rest;
    if (size > max) {
      throw new Error('Frame size exceeds frame max');
    }
    else if (rest.length > size) {
      if (rest[size] !== FRAME_END)
        throw new Error('Invalid frame');

      return {
        type: fh.type,
        channel: fh.channel,
        size: size,
        payload: rest.slice(0, size),
        rest: rest.slice(size + 1)
      };
    }
  }
  return false;
}

module.exports.parseFrame = parseFrame;

var headerPattern = Bits.matcher('class:16',
                                 '_weight:16',
                                 'size:64',
                                 'flagsAndfields/binary');

var methodPattern = Bits.matcher('id:32, args/binary');

var HEARTBEAT = {channel: 0};

module.exports.decodeFrame = function(frame) {
  var payload = frame.payload;
  switch (frame.type) {
  case FRAME_METHOD:
    var idAndArgs = methodPattern(payload);
    var id = idAndArgs.id;
    var fields = decode(id, idAndArgs.args);
    return {id: id, channel: frame.channel, fields: fields};
  case FRAME_HEADER:
    var parts = headerPattern(payload);
    var id = parts['class'];
    var fields = decode(id, parts.flagsAndfields);
    return {id: id, channel: frame.channel,
            size: parts.size, fields: fields};
  case FRAME_BODY:
    return {channel: frame.channel, content: frame.payload};
  case FRAME_HEARTBEAT:
    return HEARTBEAT;
  default:
    throw new Error('Unknown frame type ' + frame.type);
  }
}

// encoded heartbeat
module.exports.HEARTBEAT_BUF = Buffer.from([constants.FRAME_HEARTBEAT,
                                           0, 0, 0, 0, // size = 0
                                           0, 0, // channel = 0
                                           constants.FRAME_END]);

module.exports.HEARTBEAT = HEARTBEAT;


/***/ }),

/***/ "./node_modules/amqplib/lib/heartbeat.js":
/*!***********************************************!*\
  !*** ./node_modules/amqplib/lib/heartbeat.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//

// Heartbeats. In AMQP both clients and servers may expect a heartbeat
// frame if there is no activity on the connection for a negotiated
// period of time. If there's no activity for two such intervals, the
// server or client is allowed to close the connection on the
// presumption that the other party is dead.
//
// The client has two jobs here: the first is to send a heartbeat
// frame if it's not sent any frames for a while, so that the server
// doesn't think it's dead; the second is to check periodically that
// it's seen activity from the server, and to advise if there doesn't
// appear to have been any for over two intervals.
//
// Node.JS timers are a bit unreliable, in that they endeavour only to
// fire at some indeterminate point *after* the given time (rather
// gives the lie to 'realtime', dunnit). Because the scheduler is just
// an event loop, it's quite easy to delay timers indefinitely by
// reacting to some I/O with a lot of computation.
//
// To mitigate this I need a bit of creative interpretation:
//
//  - I'll schedule a server activity check for every `interval`, and
//    check just how much time has passed. It will overshoot by at
//    least a small margin; modulo missing timer deadlines, it'll
//    notice between two and three intervals after activity actually
//    stops (otherwise, at some point after two intervals).
//
//  - Every `interval / 2` I'll check that we've sent something since
//    the last check, and if not, send a heartbeat frame. If we're
//    really too busy to even run the check for two whole heartbeat
//    intervals, there must be a lot of I (but not O, at least not on
//    the connection), or computation, in which case perhaps it's best
//    the server cuts us off anyway. Why `interval / 2`? Because the
//    edge case is that the client sent a frame just after a
//    heartbeat, which would mean I only send one after almost two
//    intervals. (NB a heartbeat counts as a send, so it'll be checked
//    at least twice before sending another)
//
// This design is based largely on RabbitMQ's heartbeating:
// https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_heartbeat.erl

// %% Yes, I could apply the same 'actually passage of time' thing to
// %% send as well as to recv.



var inherits = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

// Exported so that we can mess with it in tests
module.exports.UNITS_TO_MS = 1000;

function Heart(interval, checkSend, checkRecv) {
  EventEmitter.call(this);
  this.interval = interval;

  var intervalMs = interval * module.exports.UNITS_TO_MS;
  // Function#bind is my new best friend
  var beat = this.emit.bind(this, 'beat');
  var timeout = this.emit.bind(this, 'timeout');

  this.sendTimer = setInterval(
    this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);

  // A timeout occurs if I see nothing for *two consecutive* intervals
  var recvMissed = 0;
  function missedTwo() {
    if (!checkRecv()) return (++recvMissed < 2);
    else { recvMissed = 0; return true; }
  }
  this.recvTimer = setInterval(
    this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);
}
inherits(Heart, EventEmitter);

module.exports.Heart = Heart;

Heart.prototype.clear = function() {
  clearInterval(this.sendTimer);
  clearInterval(this.recvTimer);
};

Heart.prototype.runHeartbeat = function(check, fail) {
  // Have we seen activity?
  if (!check()) fail();
};


/***/ }),

/***/ "./node_modules/amqplib/lib/mux.js":
/*!*****************************************!*\
  !*** ./node_modules/amqplib/lib/mux.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
//
//



// A Mux is an object into which other readable streams may be piped;
// it then writes 'packets' from the upstreams to the given
// downstream.

var assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'assert'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var schedule = (typeof setImmediate === 'function') ?
  setImmediate : process.nextTick;

function Mux(downstream) {
  this.newStreams = [];
  this.oldStreams = [];
  this.blocked = false;
  this.scheduledRead = false;

  this.out = downstream;
  var self = this;
  downstream.on('drain', function() {
    self.blocked = false;
    self._readIncoming();
  });
}

// There are 2 states we can be in:

// - waiting for outbound capacity, which will be signalled by a
// - 'drain' event on the downstream; or,

// - no packets to send, waiting for an inbound buffer to have
//   packets, which will be signalled by a 'readable' event

// If we write all packets available whenever there is outbound
// capacity, we will either run out of outbound capacity (`#write`
// returns false), or run out of packets (all calls to an
// `inbound.read()` have returned null).

Mux.prototype._readIncoming = function() {

  // We may be sent here speculatively, if an incoming stream has
  // become readable
  if (this.blocked) return;

  var accepting = true;
  var out = this.out;

  // Try to read a chunk from each stream in turn, until all streams
  // are empty, or we exhaust our ability to accept chunks.
  function roundrobin(streams) {
    var s;
    while (accepting && (s = streams.shift())) {
      var chunk = s.read();
      if (chunk !== null) {
        accepting = out.write(chunk);
        streams.push(s);
      }
    }
  }

  roundrobin(this.newStreams);

  // Either we exhausted the new queues, or we ran out of capacity. If
  // we ran out of capacity, all the remaining new streams (i.e.,
  // those with packets left) become old streams. This effectively
  // prioritises streams that keep their buffers close to empty over
  // those that are constantly near full.

  if (accepting) { // all new queues are exhausted, write as many as
                   // we can from the old streams
    assert.equal(0, this.newStreams.length);
    roundrobin(this.oldStreams);
  }
  else { // ran out of room
    assert(this.newStreams.length > 0, "Expect some new streams to remain");
    Array.prototype.push.apply(this.oldStreams, this.newStreams);
    this.newStreams = [];
  }
  // We may have exhausted all the old queues, or run out of room;
  // either way, all we need to do is record whether we have capacity
  // or not, so any speculative reads will know
  this.blocked = !accepting;
};

Mux.prototype._scheduleRead = function() {
  var self = this;

  if (!self.scheduledRead) {
    schedule(function() {
      self.scheduledRead = false;
      self._readIncoming();
    });
    self.scheduledRead = true;
  }
};

Mux.prototype.pipeFrom = function(readable) {
  var self = this;

  function enqueue() {
    self.newStreams.push(readable);
    self._scheduleRead();
  }

  function cleanup() {
    readable.removeListener('readable', enqueue);
    readable.removeListener('error', cleanup);
    readable.removeListener('end', cleanup);
    readable.removeListener('unpipeFrom', cleanupIfMe);
  }
  function cleanupIfMe(dest) {
    if (dest === self) cleanup();
  }

  readable.on('unpipeFrom', cleanupIfMe);
  readable.on('end', cleanup);
  readable.on('error', cleanup);
  readable.on('readable', enqueue);
};

Mux.prototype.unpipeFrom = function(readable) {
  readable.emit('unpipeFrom', this);
};

module.exports.Mux = Mux;


/***/ }),

/***/ "./node_modules/before-after-hook/index.js":
/*!*************************************************!*\
  !*** ./node_modules/before-after-hook/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var register = __webpack_require__(/*! ./lib/register */ "./node_modules/before-after-hook/lib/register.js");
var addHook = __webpack_require__(/*! ./lib/add */ "./node_modules/before-after-hook/lib/add.js");
var removeHook = __webpack_require__(/*! ./lib/remove */ "./node_modules/before-after-hook/lib/remove.js");

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind;
var bindable = bind.bind(bind);

function bindApi(hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook.api = { remove: removeHookRef };
  hook.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind];
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
  });
}

function HookSingular() {
  var singularHookName = "h";
  var singularHookState = {
    registry: {},
  };
  var singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}

function HookCollection() {
  var state = {
    registry: {},
  };

  var hook = register.bind(null, state);
  bindApi(hook, state);

  return hook;
}

var collectionHookDeprecationMessageDisplayed = false;
function Hook() {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn(
      '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
    );
    collectionHookDeprecationMessageDisplayed = true;
  }
  return HookCollection();
}

Hook.Singular = HookSingular.bind();
Hook.Collection = HookCollection.bind();

module.exports = Hook;
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook;
module.exports.Singular = Hook.Singular;
module.exports.Collection = Hook.Collection;


/***/ }),

/***/ "./node_modules/before-after-hook/lib/add.js":
/*!***************************************************!*\
  !*** ./node_modules/before-after-hook/lib/add.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ "./node_modules/before-after-hook/lib/register.js":
/*!********************************************************!*\
  !*** ./node_modules/before-after-hook/lib/register.js ***!
  \********************************************************/
/***/ ((module) => {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ "./node_modules/before-after-hook/lib/remove.js":
/*!******************************************************!*\
  !*** ./node_modules/before-after-hook/lib/remove.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ "./node_modules/buffer-more-ints/buffer-more-ints.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer-more-ints/buffer-more-ints.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


// JavaScript is numerically challenged
var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

// The maximum contiguous integer that can be held in a IEEE754 double
var MAX_INT = 0x1fffffffffffff;

function isContiguousInt(val) {
    return val <= MAX_INT && val >= -MAX_INT;
}

function assertContiguousInt(val) {
    if (!isContiguousInt(val)) {
        throw new TypeError("number cannot be represented as a contiguous integer");
    }
}

module.exports.isContiguousInt = isContiguousInt;
module.exports.assertContiguousInt = assertContiguousInt;

// Fill in the regular procedures
['UInt', 'Int'].forEach(function (sign) {
  var suffix = sign + '8';
  module.exports['read' + suffix] =
    Buffer.prototype['read' + suffix].call;
  module.exports['write' + suffix] =
    Buffer.prototype['write' + suffix].call;

  ['16', '32'].forEach(function (size) {
    ['LE', 'BE'].forEach(function (endian) {
      var suffix = sign + size + endian;
      var read = Buffer.prototype['read' + suffix];
      module.exports['read' + suffix] =
        function (buf, offset) {
          return read.call(buf, offset);
        };
      var write = Buffer.prototype['write' + suffix];
      module.exports['write' + suffix] =
        function (buf, val, offset) {
          return write.call(buf, val, offset);
        };
    });
  });
});

// Check that a value is an integer within the given range
function check_value(val, min, max) {
    val = +val;
    if (typeof(val) != 'number' || val < min || val > max || Math.floor(val) !== val) {
        throw new TypeError("\"value\" argument is out of bounds");
    }
    return val;
}

// Check that something is within the Buffer bounds
function check_bounds(buf, offset, len) {
    if (offset < 0 || offset + len > buf.length) {
        throw new RangeError("Index out of range");
    }
}

function readUInt24BE(buf, offset) {
  return buf.readUInt8(offset) << 16 | buf.readUInt16BE(offset + 1);
}
module.exports.readUInt24BE = readUInt24BE;

function writeUInt24BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffff);
    check_bounds(buf, offset, 3);
    buf.writeUInt8(val >>> 16, offset);
    buf.writeUInt16BE(val & 0xffff, offset + 1);
}
module.exports.writeUInt24BE = writeUInt24BE;

function readUInt40BE(buf, offset) {
    return (buf.readUInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
}
module.exports.readUInt40BE = readUInt40BE;

function writeUInt40BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffff);
    check_bounds(buf, offset, 5);
    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 1);
}
module.exports.writeUInt40BE = writeUInt40BE;

function readUInt48BE(buf, offset) {
    return buf.readUInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
}
module.exports.readUInt48BE = readUInt48BE;

function writeUInt48BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 2);
}
module.exports.writeUInt48BE = writeUInt48BE;

function readUInt56BE(buf, offset) {
    return ((buf.readUInt8(offset) || 0) << 16 | buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
}
module.exports.readUInt56BE = readUInt56BE;

function writeUInt56BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x100000000000000) {
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt8(hi >>> 16, offset);
        buf.writeUInt16BE(hi & 0xffff, offset + 1);
        buf.writeInt32BE(val & -1, offset + 3);
    } else {
        // Special case because 2^56-1 gets rounded up to 2^56
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
    }
}
module.exports.writeUInt56BE = writeUInt56BE;

function readUInt64BE(buf, offset) {
    return buf.readUInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
}
module.exports.readUInt64BE = readUInt64BE;

function writeUInt64BE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x10000000000000000) {
        buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
        buf.writeInt32BE(val & -1, offset + 4);
    } else {
        // Special case because 2^64-1 gets rounded up to 2^64
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0xff;
    }
}
module.exports.writeUInt64BE = writeUInt64BE;

function readUInt24LE(buf, offset) {
    return buf.readUInt8(offset + 2) << 16 | buf.readUInt16LE(offset);
}
module.exports.readUInt24LE = readUInt24LE;

function writeUInt24LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffff);
    check_bounds(buf, offset, 3);

    buf.writeUInt16LE(val & 0xffff, offset);
    buf.writeUInt8(val >>> 16, offset + 2);
}
module.exports.writeUInt24LE = writeUInt24LE;

function readUInt40LE(buf, offset) {
    return (buf.readUInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt40LE = readUInt40LE;

function writeUInt40LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffff);
    check_bounds(buf, offset, 5);
    buf.writeInt32LE(val & -1, offset);
    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeUInt40LE = writeUInt40LE;

function readUInt48LE(buf, offset) {
    return buf.readUInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt48LE = readUInt48LE;

function writeUInt48LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeInt32LE(val & -1, offset);
    buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeUInt48LE = writeUInt48LE;

function readUInt56LE(buf, offset) {
    return ((buf.readUInt8(offset + 6) || 0) << 16 | buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt56LE = readUInt56LE;

function writeUInt56LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x100000000000000) {
        buf.writeInt32LE(val & -1, offset);
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt16LE(hi & 0xffff, offset + 4);
        buf.writeUInt8(hi >>> 16, offset + 6);
    } else {
        // Special case because 2^56-1 gets rounded up to 2^56
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
    }
}
module.exports.writeUInt56LE = writeUInt56LE;

function readUInt64LE(buf, offset) {
    return buf.readUInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readUInt64LE = readUInt64LE;

function writeUInt64LE(buf, val, offset) {
    val = check_value(val, 0, 0xffffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x10000000000000000) {
        buf.writeInt32LE(val & -1, offset);
        buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    } else {
        // Special case because 2^64-1 gets rounded up to 2^64
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0xff;
    }
}
module.exports.writeUInt64LE = writeUInt64LE;


function readInt24BE(buf, offset) {
    return (buf.readInt8(offset) << 16) + buf.readUInt16BE(offset + 1);
}
module.exports.readInt24BE = readInt24BE;

function writeInt24BE(buf, val, offset) {
    val = check_value(val, -0x800000, 0x7fffff);
    check_bounds(buf, offset, 3);
    buf.writeInt8(val >> 16, offset);
    buf.writeUInt16BE(val & 0xffff, offset + 1);
}
module.exports.writeInt24BE = writeInt24BE;

function readInt40BE(buf, offset) {
    return (buf.readInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
}
module.exports.readInt40BE = readInt40BE;

function writeInt40BE(buf, val, offset) {
    val = check_value(val, -0x8000000000, 0x7fffffffff);
    check_bounds(buf, offset, 5);
    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 1);
}
module.exports.writeInt40BE = writeInt40BE;

function readInt48BE(buf, offset) {
    return buf.readInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
}
module.exports.readInt48BE = readInt48BE;

function writeInt48BE(buf, val, offset) {
    val = check_value(val, -0x800000000000, 0x7fffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 2);
}
module.exports.writeInt48BE = writeInt48BE;

function readInt56BE(buf, offset) {
    return (((buf.readInt8(offset) || 0) << 16) + buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
}
module.exports.readInt56BE = readInt56BE;

function writeInt56BE(buf, val, offset) {
    val = check_value(val, -0x800000000000000, 0x7fffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x80000000000000) {
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeInt8(hi >> 16, offset);
        buf.writeUInt16BE(hi & 0xffff, offset + 1);
        buf.writeInt32BE(val & -1, offset + 3);
    } else {
        // Special case because 2^55-1 gets rounded up to 2^55
        buf[offset] = 0x7f;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
    }
}
module.exports.writeInt56BE = writeInt56BE;

function readInt64BE(buf, offset) {
    return buf.readInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
}
module.exports.readInt64BE = readInt64BE;

function writeInt64BE(buf, val, offset) {
    val = check_value(val, -0x800000000000000000, 0x7fffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x8000000000000000) {
        buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
        buf.writeInt32BE(val & -1, offset + 4);
    } else {
        // Special case because 2^63-1 gets rounded up to 2^63
        buf[offset] = 0x7f;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0xff;
    }
}
module.exports.writeInt64BE = writeInt64BE;

function readInt24LE(buf, offset) {
    return (buf.readInt8(offset + 2) << 16) + buf.readUInt16LE(offset);
}
module.exports.readInt24LE = readInt24LE;

function writeInt24LE(buf, val, offset) {
    val = check_value(val, -0x800000, 0x7fffff);
    check_bounds(buf, offset, 3);
    buf.writeUInt16LE(val & 0xffff, offset);
    buf.writeInt8(val >> 16, offset + 2);
}
module.exports.writeInt24LE = writeInt24LE;

function readInt40LE(buf, offset) {
    return (buf.readInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt40LE = readInt40LE;

function writeInt40LE(buf, val, offset) {
    val = check_value(val, -0x8000000000, 0x7fffffffff);
    check_bounds(buf, offset, 5);
    buf.writeInt32LE(val & -1, offset);
    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeInt40LE = writeInt40LE;

function readInt48LE(buf, offset) {
    return buf.readInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt48LE = readInt48LE;

function writeInt48LE(buf, val, offset) {
    val = check_value(val, -0x800000000000, 0x7fffffffffff);
    check_bounds(buf, offset, 6);
    buf.writeInt32LE(val & -1, offset);
    buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
}
module.exports.writeInt48LE = writeInt48LE;

function readInt56LE(buf, offset) {
    return (((buf.readInt8(offset + 6) || 0) << 16) + buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt56LE = readInt56LE;

function writeInt56LE(buf, val, offset) {
    val = check_value(val, -0x80000000000000, 0x7fffffffffffff);
    check_bounds(buf, offset, 7);

    if (val < 0x80000000000000) {
        buf.writeInt32LE(val & -1, offset);
        var hi = Math.floor(val * SHIFT_RIGHT_32);
        buf.writeUInt16LE(hi & 0xffff, offset + 4);
        buf.writeInt8(hi >> 16, offset + 6);
    } else {
        // Special case because 2^55-1 gets rounded up to 2^55
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0x7f;
    }
}
module.exports.writeInt56LE = writeInt56LE;

function readInt64LE(buf, offset) {
    return buf.readInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
}
module.exports.readInt64LE = readInt64LE;

function writeInt64LE(buf, val, offset) {
    val = check_value(val, -0x8000000000000000, 0x7fffffffffffffff);
    check_bounds(buf, offset, 8);

    if (val < 0x8000000000000000) {
        buf.writeInt32LE(val & -1, offset);
        buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    } else {
        // Special case because 2^55-1 gets rounded up to 2^55
        buf[offset] = 0xff;
        buf[offset+1] = 0xff;
        buf[offset+2] = 0xff;
        buf[offset+3] = 0xff;
        buf[offset+4] = 0xff;
        buf[offset+5] = 0xff;
        buf[offset+6] = 0xff;
        buf[offset+7] = 0x7f;
    }
}
module.exports.writeInt64LE = writeInt64LE;


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/deprecation/dist-web/index.js":
/*!****************************************************!*\
  !*** ./node_modules/deprecation/dist-web/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deprecation": () => (/* binding */ Deprecation)
/* harmony export */ });
class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}




/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports["default"] = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;


/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/readable-stream/duplex.js":
/*!************************************************!*\
  !*** ./node_modules/readable-stream/duplex.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js")


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/


/*<replacement>*/
var Buffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = __webpack_require__(/*! util */ "?d17e");
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/index.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/index.js").StringDecoder);
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}


/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js")


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/string_decoder/index.js":
/*!**********************************************!*\
  !*** ./node_modules/string_decoder/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'buffer'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const amqplib_1 = __importDefault(__webpack_require__(/*! amqplib */ "./node_modules/amqplib/channel_api.js"));
const core_1 = __importDefault(__webpack_require__(/*! @actions/core */ "./node_modules/@actions/core/lib/core.js"));
const github_1 = __importDefault(__webpack_require__(/*! @actions/github */ "./node_modules/@actions/github/lib/github.js"));
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const branch = core_1.default.getInput("branch");
        const connection = yield amqplib_1.default.connect("amqp://localhost"); // Alterar para IP do servidor (laptop)
        const channel = yield connection.createChannel();
        const queue = "notify-discord";
        yield channel.assertQueue(queue, { durable: true });
        channel.sendToQueue(queue, Buffer.from(branch));
        console.log(`[x] Sent ${branch} to ${queue}`);
        yield channel.close();
        yield connection.close();
        const payload = JSON.stringify(github_1.default.context.payload, undefined, 2);
        console.log(`The event payload: ${payload}`);
    });
}
main().catch(error => {
    console.log(error.message);
});


/***/ }),

/***/ "./node_modules/tunnel/index.js":
/*!**************************************!*\
  !*** ./node_modules/tunnel/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/tunnel */ "./node_modules/tunnel/lib/tunnel.js");


/***/ }),

/***/ "./node_modules/tunnel/lib/tunnel.js":
/*!*******************************************!*\
  !*** ./node_modules/tunnel/lib/tunnel.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var assert = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'assert'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ "./node_modules/universal-user-agent/dist-web/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/universal-user-agent/dist-web/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUserAgent": () => (/* binding */ getUserAgent)
/* harmony export */ });
function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
    }
    if (typeof process === "object" && "version" in process) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "?d17e":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/is-plain-object/dist/is-plain-object.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/is-plain-object/dist/is-plain-object.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject)
/* harmony export */ });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}




/***/ }),

/***/ "./node_modules/amqplib/package.json":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/package.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"amqplib","homepage":"http://amqp-node.github.io/amqplib/","main":"./channel_api.js","version":"0.10.3","description":"An AMQP 0-9-1 (e.g., RabbitMQ) library and client.","repository":{"type":"git","url":"https://github.com/amqp-node/amqplib.git"},"engines":{"node":">=10"},"dependencies":{"@acuminous/bitsyntax":"^0.1.2","buffer-more-ints":"~1.0.0","readable-stream":"1.x >=1.1.9","url-parse":"~1.5.10"},"devDependencies":{"claire":"0.4.1","mocha":"^9.2.2","nyc":"^15.1.0","uglify-js":"2.8.x"},"scripts":{"test":"make test","prepare":"make"},"keywords":["AMQP","AMQP 0-9-1","RabbitMQ"],"author":"Michael Bridgen <mikeb@squaremobius.net>","license":"MIT"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xmQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsK0NBQVE7QUFDckMsa0JBQWtCLG1JQUF5QjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsa0RBQVE7QUFDN0IsT0FBTyxhQUFhLEVBQUUsbUJBQU8sQ0FBQyx3REFBVztBQUN6QyxPQUFPLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHdEQUFXO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQywwREFBWTtBQUNqQyxPQUFPLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNEQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxhQUFhO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsMkJBQTJCOzs7Ozs7Ozs7Ozs7QUM3UzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbUJBQW1CO0FBQ25CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLDJCQUEyQjs7Ozs7Ozs7Ozs7QUN0cEIzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLG9EQUFTOztBQUU3QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QjtBQUM3RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOzs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkZBQTJGO0FBQzdJO0FBQ0E7QUFDQSxrREFBa0Qsd0ZBQXdGO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRHQUE0RztBQUMzSTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEdBQTRHO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOEhBQThIO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxxQ0FBcUMsMkhBQTJIO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEhBQThIO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBIQUEwSDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0g7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtIQUErSDtBQUMvSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkZBQTJGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBIQUEwSDtBQUMxSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkZBQTJGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwSEFBMEg7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtIQUErSDtBQUMvSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkZBQTJGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwSEFBMEg7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwSEFBMEg7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixz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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4SEFBOEg7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhIQUE4SDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyR0FBMkc7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkdBQTJHO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStIO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxvREFBUyxVQUFVLG1CQUFPLENBQUMsNkVBQWtCLHFJQUFxSTs7QUFFdE0sd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7Ozs7Ozs7Ozs7O0FDL2EzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQix3SkFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9HQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQSxlQUFlLG1CQUFPLENBQUMsOEVBQWtCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1ZEEscUlBQXdEOzs7Ozs7Ozs7Ozs7QUNBM0M7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHFJQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxxSUFBd0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNU5hO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxtQkFBTyxDQUFDLHNEQUFTO0FBQ25ELCtCQUErQixtQkFBTyxDQUFDLCtEQUFlO0FBQ3RELGlDQUFpQyxtQkFBTyxDQUFDLHFFQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0EsZ0NBQWdDLFFBQVEsS0FBSyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ2xDRCwrRkFBd0M7Ozs7Ozs7Ozs7OztBQ0EzQjs7QUFFYixVQUFVLG1CQUFPLENBQUMsa0lBQUs7QUFDdkIsVUFBVSxtQkFBTyxDQUFDLGtJQUFLO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyxtSUFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsb0lBQU87QUFDM0IsYUFBYSxtQkFBTyxDQUFDLCtDQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxxSUFBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMsbUlBQU07OztBQUd6QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixzQkFBc0I7OztBQUd0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixhQUFhOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxhQUFhLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2UXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCLEdBQUcsbUJBQW1CLEVBQUUsYUFBYTtBQUMxRjtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCOzs7Ozs7Ozs7Ozs7QUNYYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNERBQWU7QUFDdEMsU0FBUyxtQkFBTyxDQUFDLDhEQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFNLDhCQUE4QixxQkFBTTtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELElBQUk7QUFDSixzQ0FBc0M7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHlCQUF5QjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFF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QUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9jb3JlL2xpYi9jb21tYW5kLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2NvcmUvbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvY29yZS9saWIvZmlsZS1jb21tYW5kLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2NvcmUvbGliL29pZGMtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvY29yZS9saWIvcGF0aC11dGlscy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9jb3JlL2xpYi9zdW1tYXJ5LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2NvcmUvbGliL3V0aWxzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2dpdGh1Yi9saWIvY29udGV4dC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9naXRodWIvbGliL2dpdGh1Yi5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN0aW9ucy9naXRodWIvbGliL2ludGVybmFsL3V0aWxzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2dpdGh1Yi9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvaHR0cC1jbGllbnQvbGliL2F1dGguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdGlvbnMvaHR0cC1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BhY3Rpb25zL2h0dHAtY2xpZW50L2xpYi9wcm94eS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9saWIvY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2ludGVycC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9saWIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhcnNlci5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9saWIvcGF0dGVybi5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9hdXRoLXRva2VuL2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L2NvcmUvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvZW5kcG9pbnQvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9kaXN0LXdlYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9wbHVnaW4tcGFnaW5hdGUtcmVzdC9kaXN0LXdlYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9wbHVnaW4tcmVzdC1lbmRwb2ludC1tZXRob2RzL2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3JlcXVlc3QtZXJyb3IvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC9kaXN0LXdlYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2NoYW5uZWxfYXBpLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2FwaV9hcmdzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2JpdHNldC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jaGFubmVsLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2NoYW5uZWxfbW9kZWwuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29kZWMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jb25uZWN0aW9uLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2RlZnMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZm9ybWF0LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2ZyYW1lLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2hlYXJ0YmVhdC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9tdXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL2FkZC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9iZWZvcmUtYWZ0ZXItaG9vay9saWIvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9idWZmZXItbW9yZS1pbnRzL2J1ZmZlci1tb3JlLWludHMuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvZGVwcmVjYXRpb24vZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy90dW5uZWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdHVubmVsL2xpYi90dW5uZWwuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvZGlzdC13ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uaWwuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3BhcnNlLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zaGExLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YxLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92My5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcyIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92ZXJzaW9uLmpzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvaWdub3JlZHwvaG9tZS9yYXN0ZWxpL3d3dy9ub3RpZnktZGlzY29yZC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYnx1dGlsIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkLy4vbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9kaXN0L2lzLXBsYWluLW9iamVjdC5tanMiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9ub3RpZnktZGlzY29yZC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vbm90aWZ5LWRpc2NvcmQvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL25vdGlmeS1kaXNjb3JkL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzc3VlID0gZXhwb3J0cy5pc3N1ZUNvbW1hbmQgPSB2b2lkIDA7XG5jb25zdCBvcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwib3NcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBDb21tYW5kc1xuICpcbiAqIENvbW1hbmQgRm9ybWF0OlxuICogICA6Om5hbWUga2V5PXZhbHVlLGtleT12YWx1ZTo6bWVzc2FnZVxuICpcbiAqIEV4YW1wbGVzOlxuICogICA6Ondhcm5pbmc6OlRoaXMgaXMgdGhlIG1lc3NhZ2VcbiAqICAgOjpzZXQtZW52IG5hbWU9TVlfVkFSOjpzb21lIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzc3VlQ29tbWFuZChjb21tYW5kLCBwcm9wZXJ0aWVzLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgY21kID0gbmV3IENvbW1hbmQoY29tbWFuZCwgcHJvcGVydGllcywgbWVzc2FnZSk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY21kLnRvU3RyaW5nKCkgKyBvcy5FT0wpO1xufVxuZXhwb3J0cy5pc3N1ZUNvbW1hbmQgPSBpc3N1ZUNvbW1hbmQ7XG5mdW5jdGlvbiBpc3N1ZShuYW1lLCBtZXNzYWdlID0gJycpIHtcbiAgICBpc3N1ZUNvbW1hbmQobmFtZSwge30sIG1lc3NhZ2UpO1xufVxuZXhwb3J0cy5pc3N1ZSA9IGlzc3VlO1xuY29uc3QgQ01EX1NUUklORyA9ICc6Oic7XG5jbGFzcyBDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCBwcm9wZXJ0aWVzLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29tbWFuZCkge1xuICAgICAgICAgICAgY29tbWFuZCA9ICdtaXNzaW5nLmNvbW1hbmQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgY21kU3RyID0gQ01EX1NUUklORyArIHRoaXMuY29tbWFuZDtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcyAmJiBPYmplY3Qua2V5cyh0aGlzLnByb3BlcnRpZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNtZFN0ciArPSAnICc7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMucHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kU3RyICs9ICcsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZFN0ciArPSBgJHtrZXl9PSR7ZXNjYXBlUHJvcGVydHkodmFsKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNtZFN0ciArPSBgJHtDTURfU1RSSU5HfSR7ZXNjYXBlRGF0YSh0aGlzLm1lc3NhZ2UpfWA7XG4gICAgICAgIHJldHVybiBjbWRTdHI7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlRGF0YShzKSB7XG4gICAgcmV0dXJuIHV0aWxzXzEudG9Db21tYW5kVmFsdWUocylcbiAgICAgICAgLnJlcGxhY2UoLyUvZywgJyUyNScpXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJyUwRCcpXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJyUwQScpO1xufVxuZnVuY3Rpb24gZXNjYXBlUHJvcGVydHkocykge1xuICAgIHJldHVybiB1dGlsc18xLnRvQ29tbWFuZFZhbHVlKHMpXG4gICAgICAgIC5yZXBsYWNlKC8lL2csICclMjUnKVxuICAgICAgICAucmVwbGFjZSgvXFxyL2csICclMEQnKVxuICAgICAgICAucmVwbGFjZSgvXFxuL2csICclMEEnKVxuICAgICAgICAucmVwbGFjZSgvOi9nLCAnJTNBJylcbiAgICAgICAgLnJlcGxhY2UoLywvZywgJyUyQycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SURUb2tlbiA9IGV4cG9ydHMuZ2V0U3RhdGUgPSBleHBvcnRzLnNhdmVTdGF0ZSA9IGV4cG9ydHMuZ3JvdXAgPSBleHBvcnRzLmVuZEdyb3VwID0gZXhwb3J0cy5zdGFydEdyb3VwID0gZXhwb3J0cy5pbmZvID0gZXhwb3J0cy5ub3RpY2UgPSBleHBvcnRzLndhcm5pbmcgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5kZWJ1ZyA9IGV4cG9ydHMuaXNEZWJ1ZyA9IGV4cG9ydHMuc2V0RmFpbGVkID0gZXhwb3J0cy5zZXRDb21tYW5kRWNobyA9IGV4cG9ydHMuc2V0T3V0cHV0ID0gZXhwb3J0cy5nZXRCb29sZWFuSW5wdXQgPSBleHBvcnRzLmdldE11bHRpbGluZUlucHV0ID0gZXhwb3J0cy5nZXRJbnB1dCA9IGV4cG9ydHMuYWRkUGF0aCA9IGV4cG9ydHMuc2V0U2VjcmV0ID0gZXhwb3J0cy5leHBvcnRWYXJpYWJsZSA9IGV4cG9ydHMuRXhpdENvZGUgPSB2b2lkIDA7XG5jb25zdCBjb21tYW5kXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kXCIpO1xuY29uc3QgZmlsZV9jb21tYW5kXzEgPSByZXF1aXJlKFwiLi9maWxlLWNvbW1hbmRcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBvcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwib3NcIikpO1xuY29uc3QgcGF0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBvaWRjX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9vaWRjLXV0aWxzXCIpO1xuLyoqXG4gKiBUaGUgY29kZSB0byBleGl0IGFuIGFjdGlvblxuICovXG52YXIgRXhpdENvZGU7XG4oZnVuY3Rpb24gKEV4aXRDb2RlKSB7XG4gICAgLyoqXG4gICAgICogQSBjb2RlIGluZGljYXRpbmcgdGhhdCB0aGUgYWN0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICovXG4gICAgRXhpdENvZGVbRXhpdENvZGVbXCJTdWNjZXNzXCJdID0gMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgICAvKipcbiAgICAgKiBBIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSBhY3Rpb24gd2FzIGEgZmFpbHVyZVxuICAgICAqL1xuICAgIEV4aXRDb2RlW0V4aXRDb2RlW1wiRmFpbHVyZVwiXSA9IDFdID0gXCJGYWlsdXJlXCI7XG59KShFeGl0Q29kZSA9IGV4cG9ydHMuRXhpdENvZGUgfHwgKGV4cG9ydHMuRXhpdENvZGUgPSB7fSkpO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVmFyaWFibGVzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNldHMgZW52IHZhcmlhYmxlIGZvciB0aGlzIGFjdGlvbiBhbmQgZnV0dXJlIGFjdGlvbnMgaW4gdGhlIGpvYlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIHNldFxuICogQHBhcmFtIHZhbCB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlLiBOb24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZyB2aWEgSlNPTi5zdHJpbmdpZnlcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGV4cG9ydFZhcmlhYmxlKG5hbWUsIHZhbCkge1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbCA9IHV0aWxzXzEudG9Db21tYW5kVmFsdWUodmFsKTtcbiAgICBwcm9jZXNzLmVudltuYW1lXSA9IGNvbnZlcnRlZFZhbDtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHByb2Nlc3MuZW52WydHSVRIVUJfRU5WJ10gfHwgJyc7XG4gICAgaWYgKGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBmaWxlX2NvbW1hbmRfMS5pc3N1ZUZpbGVDb21tYW5kKCdFTlYnLCBmaWxlX2NvbW1hbmRfMS5wcmVwYXJlS2V5VmFsdWVNZXNzYWdlKG5hbWUsIHZhbCkpO1xuICAgIH1cbiAgICBjb21tYW5kXzEuaXNzdWVDb21tYW5kKCdzZXQtZW52JywgeyBuYW1lIH0sIGNvbnZlcnRlZFZhbCk7XG59XG5leHBvcnRzLmV4cG9ydFZhcmlhYmxlID0gZXhwb3J0VmFyaWFibGU7XG4vKipcbiAqIFJlZ2lzdGVycyBhIHNlY3JldCB3aGljaCB3aWxsIGdldCBtYXNrZWQgZnJvbSBsb2dzXG4gKiBAcGFyYW0gc2VjcmV0IHZhbHVlIG9mIHRoZSBzZWNyZXRcbiAqL1xuZnVuY3Rpb24gc2V0U2VjcmV0KHNlY3JldCkge1xuICAgIGNvbW1hbmRfMS5pc3N1ZUNvbW1hbmQoJ2FkZC1tYXNrJywge30sIHNlY3JldCk7XG59XG5leHBvcnRzLnNldFNlY3JldCA9IHNldFNlY3JldDtcbi8qKlxuICogUHJlcGVuZHMgaW5wdXRQYXRoIHRvIHRoZSBQQVRIIChmb3IgdGhpcyBhY3Rpb24gYW5kIGZ1dHVyZSBhY3Rpb25zKVxuICogQHBhcmFtIGlucHV0UGF0aFxuICovXG5mdW5jdGlvbiBhZGRQYXRoKGlucHV0UGF0aCkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcHJvY2Vzcy5lbnZbJ0dJVEhVQl9QQVRIJ10gfHwgJyc7XG4gICAgaWYgKGZpbGVQYXRoKSB7XG4gICAgICAgIGZpbGVfY29tbWFuZF8xLmlzc3VlRmlsZUNvbW1hbmQoJ1BBVEgnLCBpbnB1dFBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnYWRkLXBhdGgnLCB7fSwgaW5wdXRQYXRoKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnZbJ1BBVEgnXSA9IGAke2lucHV0UGF0aH0ke3BhdGguZGVsaW1pdGVyfSR7cHJvY2Vzcy5lbnZbJ1BBVEgnXX1gO1xufVxuZXhwb3J0cy5hZGRQYXRoID0gYWRkUGF0aDtcbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYW4gaW5wdXQuXG4gKiBVbmxlc3MgdHJpbVdoaXRlc3BhY2UgaXMgc2V0IHRvIGZhbHNlIGluIElucHV0T3B0aW9ucywgdGhlIHZhbHVlIGlzIGFsc28gdHJpbW1lZC5cbiAqIFJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gICAgIG5hbWUgICAgIG5hbWUgb2YgdGhlIGlucHV0IHRvIGdldFxuICogQHBhcmFtICAgICBvcHRpb25zICBvcHRpb25hbC4gU2VlIElucHV0T3B0aW9ucy5cbiAqIEByZXR1cm5zICAgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldElucHV0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB2YWwgPSBwcm9jZXNzLmVudltgSU5QVVRfJHtuYW1lLnJlcGxhY2UoLyAvZywgJ18nKS50b1VwcGVyQ2FzZSgpfWBdIHx8ICcnO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVxdWlyZWQgJiYgIXZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IHJlcXVpcmVkIGFuZCBub3Qgc3VwcGxpZWQ6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmltV2hpdGVzcGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbC50cmltKCk7XG59XG5leHBvcnRzLmdldElucHV0ID0gZ2V0SW5wdXQ7XG4vKipcbiAqIEdldHMgdGhlIHZhbHVlcyBvZiBhbiBtdWx0aWxpbmUgaW5wdXQuICBFYWNoIHZhbHVlIGlzIGFsc28gdHJpbW1lZC5cbiAqXG4gKiBAcGFyYW0gICAgIG5hbWUgICAgIG5hbWUgb2YgdGhlIGlucHV0IHRvIGdldFxuICogQHBhcmFtICAgICBvcHRpb25zICBvcHRpb25hbC4gU2VlIElucHV0T3B0aW9ucy5cbiAqIEByZXR1cm5zICAgc3RyaW5nW11cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldE11bHRpbGluZUlucHV0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBnZXRJbnB1dChuYW1lLCBvcHRpb25zKVxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4ICE9PSAnJyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmltV2hpdGVzcGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0cy5tYXAoaW5wdXQgPT4gaW5wdXQudHJpbSgpKTtcbn1cbmV4cG9ydHMuZ2V0TXVsdGlsaW5lSW5wdXQgPSBnZXRNdWx0aWxpbmVJbnB1dDtcbi8qKlxuICogR2V0cyB0aGUgaW5wdXQgdmFsdWUgb2YgdGhlIGJvb2xlYW4gdHlwZSBpbiB0aGUgWUFNTCAxLjIgXCJjb3JlIHNjaGVtYVwiIHNwZWNpZmljYXRpb24uXG4gKiBTdXBwb3J0IGJvb2xlYW4gaW5wdXQgbGlzdDogYHRydWUgfCBUcnVlIHwgVFJVRSB8IGZhbHNlIHwgRmFsc2UgfCBGQUxTRWAgLlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbHNvIGluIGJvb2xlYW4gdHlwZS5cbiAqIHJlZjogaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODA0OTIzXG4gKlxuICogQHBhcmFtICAgICBuYW1lICAgICBuYW1lIG9mIHRoZSBpbnB1dCB0byBnZXRcbiAqIEBwYXJhbSAgICAgb3B0aW9ucyAgb3B0aW9uYWwuIFNlZSBJbnB1dE9wdGlvbnMuXG4gKiBAcmV0dXJucyAgIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm9vbGVhbklucHV0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cnVlVmFsdWUgPSBbJ3RydWUnLCAnVHJ1ZScsICdUUlVFJ107XG4gICAgY29uc3QgZmFsc2VWYWx1ZSA9IFsnZmFsc2UnLCAnRmFsc2UnLCAnRkFMU0UnXTtcbiAgICBjb25zdCB2YWwgPSBnZXRJbnB1dChuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAodHJ1ZVZhbHVlLmluY2x1ZGVzKHZhbCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChmYWxzZVZhbHVlLmluY2x1ZGVzKHZhbCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnB1dCBkb2VzIG5vdCBtZWV0IFlBTUwgMS4yIFwiQ29yZSBTY2hlbWFcIiBzcGVjaWZpY2F0aW9uOiAke25hbWV9XFxuYCArXG4gICAgICAgIGBTdXBwb3J0IGJvb2xlYW4gaW5wdXQgbGlzdDogXFxgdHJ1ZSB8IFRydWUgfCBUUlVFIHwgZmFsc2UgfCBGYWxzZSB8IEZBTFNFXFxgYCk7XG59XG5leHBvcnRzLmdldEJvb2xlYW5JbnB1dCA9IGdldEJvb2xlYW5JbnB1dDtcbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYW4gb3V0cHV0LlxuICpcbiAqIEBwYXJhbSAgICAgbmFtZSAgICAgbmFtZSBvZiB0aGUgb3V0cHV0IHRvIHNldFxuICogQHBhcmFtICAgICB2YWx1ZSAgICB2YWx1ZSB0byBzdG9yZS4gTm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmlhIEpTT04uc3RyaW5naWZ5XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzZXRPdXRwdXQobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHByb2Nlc3MuZW52WydHSVRIVUJfT1VUUFVUJ10gfHwgJyc7XG4gICAgaWYgKGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBmaWxlX2NvbW1hbmRfMS5pc3N1ZUZpbGVDb21tYW5kKCdPVVRQVVQnLCBmaWxlX2NvbW1hbmRfMS5wcmVwYXJlS2V5VmFsdWVNZXNzYWdlKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKG9zLkVPTCk7XG4gICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnc2V0LW91dHB1dCcsIHsgbmFtZSB9LCB1dGlsc18xLnRvQ29tbWFuZFZhbHVlKHZhbHVlKSk7XG59XG5leHBvcnRzLnNldE91dHB1dCA9IHNldE91dHB1dDtcbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZWNob2luZyBvZiBjb21tYW5kcyBpbnRvIHN0ZG91dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIHN0ZXAuXG4gKiBFY2hvaW5nIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQgaWYgQUNUSU9OU19TVEVQX0RFQlVHIGlzIG5vdCBzZXQuXG4gKlxuICovXG5mdW5jdGlvbiBzZXRDb21tYW5kRWNobyhlbmFibGVkKSB7XG4gICAgY29tbWFuZF8xLmlzc3VlKCdlY2hvJywgZW5hYmxlZCA/ICdvbicgOiAnb2ZmJyk7XG59XG5leHBvcnRzLnNldENvbW1hbmRFY2hvID0gc2V0Q29tbWFuZEVjaG87XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXN1bHRzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNldHMgdGhlIGFjdGlvbiBzdGF0dXMgdG8gZmFpbGVkLlxuICogV2hlbiB0aGUgYWN0aW9uIGV4aXRzIGl0IHdpbGwgYmUgd2l0aCBhbiBleGl0IGNvZGUgb2YgMVxuICogQHBhcmFtIG1lc3NhZ2UgYWRkIGVycm9yIGlzc3VlIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gc2V0RmFpbGVkKG1lc3NhZ2UpIHtcbiAgICBwcm9jZXNzLmV4aXRDb2RlID0gRXhpdENvZGUuRmFpbHVyZTtcbiAgICBlcnJvcihtZXNzYWdlKTtcbn1cbmV4cG9ydHMuc2V0RmFpbGVkID0gc2V0RmFpbGVkO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTG9nZ2luZyBDb21tYW5kc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgQWN0aW9ucyBTdGVwIERlYnVnIGlzIG9uIG9yIG5vdFxuICovXG5mdW5jdGlvbiBpc0RlYnVnKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudlsnUlVOTkVSX0RFQlVHJ10gPT09ICcxJztcbn1cbmV4cG9ydHMuaXNEZWJ1ZyA9IGlzRGVidWc7XG4vKipcbiAqIFdyaXRlcyBkZWJ1ZyBtZXNzYWdlIHRvIHVzZXIgbG9nXG4gKiBAcGFyYW0gbWVzc2FnZSBkZWJ1ZyBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UpIHtcbiAgICBjb21tYW5kXzEuaXNzdWVDb21tYW5kKCdkZWJ1ZycsIHt9LCBtZXNzYWdlKTtcbn1cbmV4cG9ydHMuZGVidWcgPSBkZWJ1Zztcbi8qKlxuICogQWRkcyBhbiBlcnJvciBpc3N1ZVxuICogQHBhcmFtIG1lc3NhZ2UgZXJyb3IgaXNzdWUgbWVzc2FnZS4gRXJyb3JzIHdpbGwgYmUgY29udmVydGVkIHRvIHN0cmluZyB2aWEgdG9TdHJpbmcoKVxuICogQHBhcmFtIHByb3BlcnRpZXMgb3B0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gdGhlIGFubm90YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMgPSB7fSkge1xuICAgIGNvbW1hbmRfMS5pc3N1ZUNvbW1hbmQoJ2Vycm9yJywgdXRpbHNfMS50b0NvbW1hbmRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IgPyBtZXNzYWdlLnRvU3RyaW5nKCkgOiBtZXNzYWdlKTtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbi8qKlxuICogQWRkcyBhIHdhcm5pbmcgaXNzdWVcbiAqIEBwYXJhbSBtZXNzYWdlIHdhcm5pbmcgaXNzdWUgbWVzc2FnZS4gRXJyb3JzIHdpbGwgYmUgY29udmVydGVkIHRvIHN0cmluZyB2aWEgdG9TdHJpbmcoKVxuICogQHBhcmFtIHByb3BlcnRpZXMgb3B0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gdGhlIGFubm90YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgY29tbWFuZF8xLmlzc3VlQ29tbWFuZCgnd2FybmluZycsIHV0aWxzXzEudG9Db21tYW5kUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgbWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yID8gbWVzc2FnZS50b1N0cmluZygpIDogbWVzc2FnZSk7XG59XG5leHBvcnRzLndhcm5pbmcgPSB3YXJuaW5nO1xuLyoqXG4gKiBBZGRzIGEgbm90aWNlIGlzc3VlXG4gKiBAcGFyYW0gbWVzc2FnZSBub3RpY2UgaXNzdWUgbWVzc2FnZS4gRXJyb3JzIHdpbGwgYmUgY29udmVydGVkIHRvIHN0cmluZyB2aWEgdG9TdHJpbmcoKVxuICogQHBhcmFtIHByb3BlcnRpZXMgb3B0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gdGhlIGFubm90YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vdGljZShtZXNzYWdlLCBwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBjb21tYW5kXzEuaXNzdWVDb21tYW5kKCdub3RpY2UnLCB1dGlsc18xLnRvQ29tbWFuZFByb3BlcnRpZXMocHJvcGVydGllcyksIG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvciA/IG1lc3NhZ2UudG9TdHJpbmcoKSA6IG1lc3NhZ2UpO1xufVxuZXhwb3J0cy5ub3RpY2UgPSBub3RpY2U7XG4vKipcbiAqIFdyaXRlcyBpbmZvIHRvIGxvZyB3aXRoIGNvbnNvbGUubG9nLlxuICogQHBhcmFtIG1lc3NhZ2UgaW5mbyBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGluZm8obWVzc2FnZSkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKG1lc3NhZ2UgKyBvcy5FT0wpO1xufVxuZXhwb3J0cy5pbmZvID0gaW5mbztcbi8qKlxuICogQmVnaW4gYW4gb3V0cHV0IGdyb3VwLlxuICpcbiAqIE91dHB1dCB1bnRpbCB0aGUgbmV4dCBgZ3JvdXBFbmRgIHdpbGwgYmUgZm9sZGFibGUgaW4gdGhpcyBncm91cFxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvdXRwdXQgZ3JvdXBcbiAqL1xuZnVuY3Rpb24gc3RhcnRHcm91cChuYW1lKSB7XG4gICAgY29tbWFuZF8xLmlzc3VlKCdncm91cCcsIG5hbWUpO1xufVxuZXhwb3J0cy5zdGFydEdyb3VwID0gc3RhcnRHcm91cDtcbi8qKlxuICogRW5kIGFuIG91dHB1dCBncm91cC5cbiAqL1xuZnVuY3Rpb24gZW5kR3JvdXAoKSB7XG4gICAgY29tbWFuZF8xLmlzc3VlKCdlbmRncm91cCcpO1xufVxuZXhwb3J0cy5lbmRHcm91cCA9IGVuZEdyb3VwO1xuLyoqXG4gKiBXcmFwIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBjYWxsIGluIGEgZ3JvdXAuXG4gKlxuICogUmV0dXJucyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBmdW5jdGlvbiBpdHNlbGYuXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGdyb3VwXG4gKiBAcGFyYW0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAgaW4gdGhlIGdyb3VwXG4gKi9cbmZ1bmN0aW9uIGdyb3VwKG5hbWUsIGZuKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgc3RhcnRHcm91cChuYW1lKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBlbmRHcm91cCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmdyb3VwID0gZ3JvdXA7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXcmFwcGVyIGFjdGlvbiBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTYXZlcyBzdGF0ZSBmb3IgY3VycmVudCBhY3Rpb24sIHRoZSBzdGF0ZSBjYW4gb25seSBiZSByZXRyaWV2ZWQgYnkgdGhpcyBhY3Rpb24ncyBwb3N0IGpvYiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtICAgICBuYW1lICAgICBuYW1lIG9mIHRoZSBzdGF0ZSB0byBzdG9yZVxuICogQHBhcmFtICAgICB2YWx1ZSAgICB2YWx1ZSB0byBzdG9yZS4gTm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmlhIEpTT04uc3RyaW5naWZ5XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzYXZlU3RhdGUobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHByb2Nlc3MuZW52WydHSVRIVUJfU1RBVEUnXSB8fCAnJztcbiAgICBpZiAoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVfY29tbWFuZF8xLmlzc3VlRmlsZUNvbW1hbmQoJ1NUQVRFJywgZmlsZV9jb21tYW5kXzEucHJlcGFyZUtleVZhbHVlTWVzc2FnZShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBjb21tYW5kXzEuaXNzdWVDb21tYW5kKCdzYXZlLXN0YXRlJywgeyBuYW1lIH0sIHV0aWxzXzEudG9Db21tYW5kVmFsdWUodmFsdWUpKTtcbn1cbmV4cG9ydHMuc2F2ZVN0YXRlID0gc2F2ZVN0YXRlO1xuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhbiBzdGF0ZSBzZXQgYnkgdGhpcyBhY3Rpb24ncyBtYWluIGV4ZWN1dGlvbi5cbiAqXG4gKiBAcGFyYW0gICAgIG5hbWUgICAgIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGdldFxuICogQHJldHVybnMgICBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGUobmFtZSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudltgU1RBVEVfJHtuYW1lfWBdIHx8ICcnO1xufVxuZXhwb3J0cy5nZXRTdGF0ZSA9IGdldFN0YXRlO1xuZnVuY3Rpb24gZ2V0SURUb2tlbihhdWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgb2lkY191dGlsc18xLk9pZGNDbGllbnQuZ2V0SURUb2tlbihhdWQpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRJRFRva2VuID0gZ2V0SURUb2tlbjtcbi8qKlxuICogU3VtbWFyeSBleHBvcnRzXG4gKi9cbnZhciBzdW1tYXJ5XzEgPSByZXF1aXJlKFwiLi9zdW1tYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3VtbWFyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3VtbWFyeV8xLnN1bW1hcnk7IH0gfSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBjb3JlLnN1bW1hcnlcbiAqL1xudmFyIHN1bW1hcnlfMiA9IHJlcXVpcmUoXCIuL3N1bW1hcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXJrZG93blN1bW1hcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1bW1hcnlfMi5tYXJrZG93blN1bW1hcnk7IH0gfSk7XG4vKipcbiAqIFBhdGggZXhwb3J0c1xuICovXG52YXIgcGF0aF91dGlsc18xID0gcmVxdWlyZShcIi4vcGF0aC11dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvUG9zaXhQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXRoX3V0aWxzXzEudG9Qb3NpeFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1dpbjMyUGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGF0aF91dGlsc18xLnRvV2luMzJQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9QbGF0Zm9ybVBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhdGhfdXRpbHNfMS50b1BsYXRmb3JtUGF0aDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBGb3IgaW50ZXJuYWwgdXNlLCBzdWJqZWN0IHRvIGNoYW5nZS5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZXBhcmVLZXlWYWx1ZU1lc3NhZ2UgPSBleHBvcnRzLmlzc3VlRmlsZUNvbW1hbmQgPSB2b2lkIDA7XG4vLyBXZSB1c2UgYW55IGFzIGEgdmFsaWQgaW5wdXQgdHlwZVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgZnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImZzXCIpKTtcbmNvbnN0IG9zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJvc1wiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGlzc3VlRmlsZUNvbW1hbmQoY29tbWFuZCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcHJvY2Vzcy5lbnZbYEdJVEhVQl8ke2NvbW1hbmR9YF07XG4gICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciBmaWxlIGNvbW1hbmQgJHtjb21tYW5kfWApO1xuICAgIH1cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBmaWxlIGF0IHBhdGg6ICR7ZmlsZVBhdGh9YCk7XG4gICAgfVxuICAgIGZzLmFwcGVuZEZpbGVTeW5jKGZpbGVQYXRoLCBgJHt1dGlsc18xLnRvQ29tbWFuZFZhbHVlKG1lc3NhZ2UpfSR7b3MuRU9MfWAsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xuICAgIH0pO1xufVxuZXhwb3J0cy5pc3N1ZUZpbGVDb21tYW5kID0gaXNzdWVGaWxlQ29tbWFuZDtcbmZ1bmN0aW9uIHByZXBhcmVLZXlWYWx1ZU1lc3NhZ2Uoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGRlbGltaXRlciA9IGBnaGFkZWxpbWl0ZXJfJHt1dWlkXzEudjQoKX1gO1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gdXRpbHNfMS50b0NvbW1hbmRWYWx1ZSh2YWx1ZSk7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIHJlYWxpc3RpY2FsbHkgbmV2ZXIgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlIHNvbWVvbmUgZmluZHMgYVxuICAgIC8vIHdheSB0byBleHBsb2l0IHV1aWQgZ2VuZXJhdGlvbiBsZXQncyBub3QgYWxsb3cga2V5cyBvciB2YWx1ZXMgdGhhdCBjb250YWluXG4gICAgLy8gdGhlIGRlbGltaXRlci5cbiAgICBpZiAoa2V5LmluY2x1ZGVzKGRlbGltaXRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiBuYW1lIHNob3VsZCBub3QgY29udGFpbiB0aGUgZGVsaW1pdGVyIFwiJHtkZWxpbWl0ZXJ9XCJgKTtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZFZhbHVlLmluY2x1ZGVzKGRlbGltaXRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiB2YWx1ZSBzaG91bGQgbm90IGNvbnRhaW4gdGhlIGRlbGltaXRlciBcIiR7ZGVsaW1pdGVyfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBgJHtrZXl9PDwke2RlbGltaXRlcn0ke29zLkVPTH0ke2NvbnZlcnRlZFZhbHVlfSR7b3MuRU9MfSR7ZGVsaW1pdGVyfWA7XG59XG5leHBvcnRzLnByZXBhcmVLZXlWYWx1ZU1lc3NhZ2UgPSBwcmVwYXJlS2V5VmFsdWVNZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1jb21tYW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9pZGNDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBodHRwX2NsaWVudF8xID0gcmVxdWlyZShcIkBhY3Rpb25zL2h0dHAtY2xpZW50XCIpO1xuY29uc3QgYXV0aF8xID0gcmVxdWlyZShcIkBhY3Rpb25zL2h0dHAtY2xpZW50L2xpYi9hdXRoXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNsYXNzIE9pZGNDbGllbnQge1xuICAgIHN0YXRpYyBjcmVhdGVIdHRwQ2xpZW50KGFsbG93UmV0cnkgPSB0cnVlLCBtYXhSZXRyeSA9IDEwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxsb3dSZXRyaWVzOiBhbGxvd1JldHJ5LFxuICAgICAgICAgICAgbWF4UmV0cmllczogbWF4UmV0cnlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX2NsaWVudF8xLkh0dHBDbGllbnQoJ2FjdGlvbnMvb2lkYy1jbGllbnQnLCBbbmV3IGF1dGhfMS5CZWFyZXJDcmVkZW50aWFsSGFuZGxlcihPaWRjQ2xpZW50LmdldFJlcXVlc3RUb2tlbigpKV0sIHJlcXVlc3RPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFJlcXVlc3RUb2tlbigpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwcm9jZXNzLmVudlsnQUNUSU9OU19JRF9UT0tFTl9SRVFVRVNUX1RPS0VOJ107XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBBQ1RJT05TX0lEX1RPS0VOX1JFUVVFU1RfVE9LRU4gZW52IHZhcmlhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SURUb2tlblVybCgpIHtcbiAgICAgICAgY29uc3QgcnVudGltZVVybCA9IHByb2Nlc3MuZW52WydBQ1RJT05TX0lEX1RPS0VOX1JFUVVFU1RfVVJMJ107XG4gICAgICAgIGlmICghcnVudGltZVVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IEFDVElPTlNfSURfVE9LRU5fUkVRVUVTVF9VUkwgZW52IHZhcmlhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bnRpbWVVcmw7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDYWxsKGlkX3Rva2VuX3VybCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBodHRwY2xpZW50ID0gT2lkY0NsaWVudC5jcmVhdGVIdHRwQ2xpZW50KCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBodHRwY2xpZW50XG4gICAgICAgICAgICAgICAgLmdldEpzb24oaWRfdG9rZW5fdXJsKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IElEIFRva2VuLiBcXG4gXG4gICAgICAgIEVycm9yIENvZGUgOiAke2Vycm9yLnN0YXR1c0NvZGV9XFxuIFxuICAgICAgICBFcnJvciBNZXNzYWdlOiAke2Vycm9yLnJlc3VsdC5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpZF90b2tlbiA9IChfYSA9IHJlcy5yZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghaWRfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGpzb24gYm9keSBkbyBub3QgaGF2ZSBJRCBUb2tlbiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkX3Rva2VuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldElEVG9rZW4oYXVkaWVuY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTmV3IElEIFRva2VuIGlzIHJlcXVlc3RlZCBmcm9tIGFjdGlvbiBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgbGV0IGlkX3Rva2VuX3VybCA9IE9pZGNDbGllbnQuZ2V0SURUb2tlblVybCgpO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkQXVkaWVuY2UgPSBlbmNvZGVVUklDb21wb25lbnQoYXVkaWVuY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZF90b2tlbl91cmwgPSBgJHtpZF90b2tlbl91cmx9JmF1ZGllbmNlPSR7ZW5jb2RlZEF1ZGllbmNlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvcmVfMS5kZWJ1ZyhgSUQgdG9rZW4gdXJsIGlzICR7aWRfdG9rZW5fdXJsfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkX3Rva2VuID0geWllbGQgT2lkY0NsaWVudC5nZXRDYWxsKGlkX3Rva2VuX3VybCk7XG4gICAgICAgICAgICAgICAgY29yZV8xLnNldFNlY3JldChpZF90b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkX3Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuT2lkY0NsaWVudCA9IE9pZGNDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vaWRjLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9QbGF0Zm9ybVBhdGggPSBleHBvcnRzLnRvV2luMzJQYXRoID0gZXhwb3J0cy50b1Bvc2l4UGF0aCA9IHZvaWQgMDtcbmNvbnN0IHBhdGggPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInBhdGhcIikpO1xuLyoqXG4gKiB0b1Bvc2l4UGF0aCBjb252ZXJ0cyB0aGUgZ2l2ZW4gcGF0aCB0byB0aGUgcG9zaXggZm9ybS4gT24gV2luZG93cywgXFxcXCB3aWxsIGJlXG4gKiByZXBsYWNlZCB3aXRoIC8uXG4gKlxuICogQHBhcmFtIHB0aC4gUGF0aCB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHN0cmluZyBQb3NpeCBwYXRoLlxuICovXG5mdW5jdGlvbiB0b1Bvc2l4UGF0aChwdGgpIHtcbiAgICByZXR1cm4gcHRoLnJlcGxhY2UoL1tcXFxcXS9nLCAnLycpO1xufVxuZXhwb3J0cy50b1Bvc2l4UGF0aCA9IHRvUG9zaXhQYXRoO1xuLyoqXG4gKiB0b1dpbjMyUGF0aCBjb252ZXJ0cyB0aGUgZ2l2ZW4gcGF0aCB0byB0aGUgd2luMzIgZm9ybS4gT24gTGludXgsIC8gd2lsbCBiZVxuICogcmVwbGFjZWQgd2l0aCBcXFxcLlxuICpcbiAqIEBwYXJhbSBwdGguIFBhdGggdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiBzdHJpbmcgV2luMzIgcGF0aC5cbiAqL1xuZnVuY3Rpb24gdG9XaW4zMlBhdGgocHRoKSB7XG4gICAgcmV0dXJuIHB0aC5yZXBsYWNlKC9bL10vZywgJ1xcXFwnKTtcbn1cbmV4cG9ydHMudG9XaW4zMlBhdGggPSB0b1dpbjMyUGF0aDtcbi8qKlxuICogdG9QbGF0Zm9ybVBhdGggY29udmVydHMgdGhlIGdpdmVuIHBhdGggdG8gYSBwbGF0Zm9ybS1zcGVjaWZpYyBwYXRoLiBJdCBkb2VzXG4gKiB0aGlzIGJ5IHJlcGxhY2luZyBpbnN0YW5jZXMgb2YgLyBhbmQgXFwgd2l0aCB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aFxuICogc2VwYXJhdG9yLlxuICpcbiAqIEBwYXJhbSBwdGggVGhlIHBhdGggdG8gcGxhdGZvcm1pemUuXG4gKiBAcmV0dXJuIHN0cmluZyBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aC5cbiAqL1xuZnVuY3Rpb24gdG9QbGF0Zm9ybVBhdGgocHRoKSB7XG4gICAgcmV0dXJuIHB0aC5yZXBsYWNlKC9bL1xcXFxdL2csIHBhdGguc2VwKTtcbn1cbmV4cG9ydHMudG9QbGF0Zm9ybVBhdGggPSB0b1BsYXRmb3JtUGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3VtbWFyeSA9IGV4cG9ydHMubWFya2Rvd25TdW1tYXJ5ID0gZXhwb3J0cy5TVU1NQVJZX0RPQ1NfVVJMID0gZXhwb3J0cy5TVU1NQVJZX0VOVl9WQVIgPSB2b2lkIDA7XG5jb25zdCBvc18xID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHsgYWNjZXNzLCBhcHBlbmRGaWxlLCB3cml0ZUZpbGUgfSA9IGZzXzEucHJvbWlzZXM7XG5leHBvcnRzLlNVTU1BUllfRU5WX1ZBUiA9ICdHSVRIVUJfU1RFUF9TVU1NQVJZJztcbmV4cG9ydHMuU1VNTUFSWV9ET0NTX1VSTCA9ICdodHRwczovL2RvY3MuZ2l0aHViLmNvbS9hY3Rpb25zL3VzaW5nLXdvcmtmbG93cy93b3JrZmxvdy1jb21tYW5kcy1mb3ItZ2l0aHViLWFjdGlvbnMjYWRkaW5nLWEtam9iLXN1bW1hcnknO1xuY2xhc3MgU3VtbWFyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc3VtbWFyeSBmaWxlIHBhdGggZnJvbSB0aGUgZW52aXJvbm1lbnQsIHJlamVjdHMgaWYgZW52IHZhciBpcyBub3QgZm91bmQgb3IgZmlsZSBkb2VzIG5vdCBleGlzdFxuICAgICAqIEFsc28gY2hlY2tzIHIvdyBwZXJtaXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHN0ZXAgc3VtbWFyeSBmaWxlIHBhdGhcbiAgICAgKi9cbiAgICBmaWxlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWxlUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGhGcm9tRW52ID0gcHJvY2Vzcy5lbnZbZXhwb3J0cy5TVU1NQVJZX0VOVl9WQVJdO1xuICAgICAgICAgICAgaWYgKCFwYXRoRnJvbUVudikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yICQke2V4cG9ydHMuU1VNTUFSWV9FTlZfVkFSfS4gQ2hlY2sgaWYgeW91ciBydW50aW1lIGVudmlyb25tZW50IHN1cHBvcnRzIGpvYiBzdW1tYXJpZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGFjY2VzcyhwYXRoRnJvbUVudiwgZnNfMS5jb25zdGFudHMuUl9PSyB8IGZzXzEuY29uc3RhbnRzLldfT0spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gYWNjZXNzIHN1bW1hcnkgZmlsZTogJyR7cGF0aEZyb21FbnZ9Jy4gQ2hlY2sgaWYgdGhlIGZpbGUgaGFzIGNvcnJlY3QgcmVhZC93cml0ZSBwZXJtaXNzaW9ucy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpbGVQYXRoID0gcGF0aEZyb21FbnY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsZVBhdGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwcyBjb250ZW50IGluIGFuIEhUTUwgdGFnLCBhZGRpbmcgYW55IEhUTUwgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBIVE1MIHRhZyB0byB3cmFwXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBjb250ZW50IGNvbnRlbnQgd2l0aGluIHRoZSB0YWdcbiAgICAgKiBAcGFyYW0ge1thdHRyaWJ1dGU6IHN0cmluZ106IHN0cmluZ30gYXR0cnMga2V5LXZhbHVlIGxpc3Qgb2YgSFRNTCBhdHRyaWJ1dGVzIHRvIGFkZFxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB3cmFwcGVkIGluIEhUTUwgZWxlbWVudFxuICAgICAqL1xuICAgIHdyYXAodGFnLCBjb250ZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGh0bWxBdHRycyA9IE9iamVjdC5lbnRyaWVzKGF0dHJzKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgICR7a2V5fT1cIiR7dmFsdWV9XCJgKVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBgPCR7dGFnfSR7aHRtbEF0dHJzfT5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPCR7dGFnfSR7aHRtbEF0dHJzfT4ke2NvbnRlbnR9PC8ke3RhZ30+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRleHQgaW4gdGhlIGJ1ZmZlciB0byB0aGUgc3VtbWFyeSBidWZmZXIgZmlsZSBhbmQgZW1wdGllcyBidWZmZXIuIFdpbGwgYXBwZW5kIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N1bW1hcnlXcml0ZU9wdGlvbnN9IFtvcHRpb25zXSAob3B0aW9uYWwpIG9wdGlvbnMgZm9yIHdyaXRlIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3VtbWFyeT59IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB3cml0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvdmVyd3JpdGUgPSAhIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3ZlcndyaXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0geWllbGQgdGhpcy5maWxlUGF0aCgpO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVGdW5jID0gb3ZlcndyaXRlID8gd3JpdGVGaWxlIDogYXBwZW5kRmlsZTtcbiAgICAgICAgICAgIHlpZWxkIHdyaXRlRnVuYyhmaWxlUGF0aCwgdGhpcy5fYnVmZmVyLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzdW1tYXJ5IGJ1ZmZlciBhbmQgd2lwZXMgdGhlIHN1bW1hcnkgZmlsZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QnVmZmVyKCkud3JpdGUoeyBvdmVyd3JpdGU6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN1bW1hcnkgYnVmZmVyIGFzIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmcgb2Ygc3VtbWFyeSBidWZmZXJcbiAgICAgKi9cbiAgICBzdHJpbmdpZnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdW1tYXJ5IGJ1ZmZlciBpcyBlbXB0eVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlbn0gdHJ1ZSBpZiB0aGUgYnVmZmVyIGlzIGVtcHR5XG4gICAgICovXG4gICAgaXNFbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3VtbWFyeSBidWZmZXIgd2l0aG91dCB3cml0aW5nIHRvIHN1bW1hcnkgZmlsZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gJyc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHJhdyB0ZXh0IHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgY29udGVudCB0byBhZGRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthZGRFT0w9ZmFsc2VdIChvcHRpb25hbCkgYXBwZW5kIGFuIEVPTCB0byB0aGUgcmF3IHRleHQgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRSYXcodGV4dCwgYWRkRU9MID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyICs9IHRleHQ7XG4gICAgICAgIHJldHVybiBhZGRFT0wgPyB0aGlzLmFkZEVPTCgpIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgb3BlcmF0aW5nIHN5c3RlbS1zcGVjaWZpYyBlbmQtb2YtbGluZSBtYXJrZXIgdG8gdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRFT0woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhvc18xLkVPTCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gSFRNTCBjb2RlYmxvY2sgdG8gdGhlIHN1bW1hcnkgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBjb250ZW50IHRvIHJlbmRlciB3aXRoaW4gZmVuY2VkIGNvZGUgYmxvY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyAob3B0aW9uYWwpIGxhbmd1YWdlIHRvIHN5bnRheCBoaWdobGlnaHQgY29kZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRDb2RlQmxvY2soY29kZSwgbGFuZykge1xuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oe30sIChsYW5nICYmIHsgbGFuZyB9KSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoJ3ByZScsIHRoaXMud3JhcCgnY29kZScsIGNvZGUpLCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBIVE1MIGxpc3QgdG8gdGhlIHN1bW1hcnkgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpdGVtcyBsaXN0IG9mIGl0ZW1zIHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29yZGVyZWQ9ZmFsc2VdIChvcHRpb25hbCkgaWYgdGhlIHJlbmRlcmVkIGxpc3Qgc2hvdWxkIGJlIG9yZGVyZWQgb3Igbm90IChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5fSBzdW1tYXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkTGlzdChpdGVtcywgb3JkZXJlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gdGhpcy53cmFwKCdsaScsIGl0ZW0pKS5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcCh0YWcsIGxpc3RJdGVtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBIVE1MIHRhYmxlIHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdW1tYXJ5VGFibGVDZWxsW119IHJvd3MgdGFibGUgcm93c1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRUYWJsZShyb3dzKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQm9keSA9IHJvd3NcbiAgICAgICAgICAgIC5tYXAocm93ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gcm93XG4gICAgICAgICAgICAgICAgLm1hcChjZWxsID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNlbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3RkJywgY2VsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVyLCBkYXRhLCBjb2xzcGFuLCByb3dzcGFuIH0gPSBjZWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IGhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoY29sc3BhbiAmJiB7IGNvbHNwYW4gfSkpLCAocm93c3BhbiAmJiB7IHJvd3NwYW4gfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXAodGFnLCBkYXRhLCBhdHRycyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3RyJywgY2VsbHMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwKCd0YWJsZScsIHRhYmxlQm9keSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbGxhcHNhYmxlIEhUTUwgZGV0YWlscyBlbGVtZW50IHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIHRleHQgZm9yIHRoZSBjbG9zZWQgc3RhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBjb2xsYXBzYWJsZSBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3VtbWFyeX0gc3VtbWFyeSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFkZERldGFpbHMobGFiZWwsIGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcCgnZGV0YWlscycsIHRoaXMud3JhcCgnc3VtbWFyeScsIGxhYmVsKSArIGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gSFRNTCBpbWFnZSB0YWcgdG8gdGhlIHN1bW1hcnkgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIHBhdGggdG8gdGhlIGltYWdlIHlvdSB0byBlbWJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbHQgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N1bW1hcnlJbWFnZU9wdGlvbnN9IG9wdGlvbnMgKG9wdGlvbmFsKSBhZGRpdGlvbiBpbWFnZSBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3VtbWFyeX0gc3VtbWFyeSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFkZEltYWdlKHNyYywgYWx0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICh3aWR0aCAmJiB7IHdpZHRoIH0pKSwgKGhlaWdodCAmJiB7IGhlaWdodCB9KSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoJ2ltZycsIG51bGwsIE9iamVjdC5hc3NpZ24oeyBzcmMsIGFsdCB9LCBhdHRycykpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gSFRNTCBzZWN0aW9uIGhlYWRpbmcgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgaGVhZGluZyB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IFtsZXZlbD0xXSAob3B0aW9uYWwpIHRoZSBoZWFkaW5nIGxldmVsLCBkZWZhdWx0OiAxXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3VtbWFyeX0gc3VtbWFyeSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFkZEhlYWRpbmcodGV4dCwgbGV2ZWwpIHtcbiAgICAgICAgY29uc3QgdGFnID0gYGgke2xldmVsfWA7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRUYWcgPSBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J10uaW5jbHVkZXModGFnKVxuICAgICAgICAgICAgPyB0YWdcbiAgICAgICAgICAgIDogJ2gxJztcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcChhbGxvd2VkVGFnLCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmF3KGVsZW1lbnQpLmFkZEVPTCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEhUTUwgdGhlbWF0aWMgYnJlYWsgKDxocj4pIHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRTZXBhcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXAoJ2hyJywgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhlbGVtZW50KS5hZGRFT0woKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBIVE1MIGxpbmUgYnJlYWsgKDxicj4pIHRvIHRoZSBzdW1tYXJ5IGJ1ZmZlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRCcmVhaygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcCgnYnInLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmF3KGVsZW1lbnQpLmFkZEVPTCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEhUTUwgYmxvY2txdW90ZSB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHF1b3RlIHRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2l0ZSAob3B0aW9uYWwpIGNpdGF0aW9uIHVybFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N1bW1hcnl9IHN1bW1hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRRdW90ZSh0ZXh0LCBjaXRlKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmFzc2lnbih7fSwgKGNpdGUgJiYgeyBjaXRlIH0pKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcCgnYmxvY2txdW90ZScsIHRleHQsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmF3KGVsZW1lbnQpLmFkZEVPTCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEhUTUwgYW5jaG9yIHRhZyB0byB0aGUgc3VtbWFyeSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGxpbmsgdGV4dC9jb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgaHlwZXJsaW5rXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3VtbWFyeX0gc3VtbWFyeSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFkZExpbmsodGV4dCwgaHJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwKCdhJywgdGV4dCwgeyBocmVmIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRSYXcoZWxlbWVudCkuYWRkRU9MKCk7XG4gICAgfVxufVxuY29uc3QgX3N1bW1hcnkgPSBuZXcgU3VtbWFyeSgpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgYGNvcmUuc3VtbWFyeWBcbiAqL1xuZXhwb3J0cy5tYXJrZG93blN1bW1hcnkgPSBfc3VtbWFyeTtcbmV4cG9ydHMuc3VtbWFyeSA9IF9zdW1tYXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VtbWFyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIFdlIHVzZSBhbnkgYXMgYSB2YWxpZCBpbnB1dCB0eXBlXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvQ29tbWFuZFByb3BlcnRpZXMgPSBleHBvcnRzLnRvQ29tbWFuZFZhbHVlID0gdm9pZCAwO1xuLyoqXG4gKiBTYW5pdGl6ZXMgYW4gaW5wdXQgaW50byBhIHN0cmluZyBzbyBpdCBjYW4gYmUgcGFzc2VkIGludG8gaXNzdWVDb21tYW5kIHNhZmVseVxuICogQHBhcmFtIGlucHV0IGlucHV0IHRvIHNhbml0aXplIGludG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gdG9Db21tYW5kVmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xufVxuZXhwb3J0cy50b0NvbW1hbmRWYWx1ZSA9IHRvQ29tbWFuZFZhbHVlO1xuLyoqXG4gKlxuICogQHBhcmFtIGFubm90YXRpb25Qcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyBUaGUgY29tbWFuZCBwcm9wZXJ0aWVzIHRvIHNlbmQgd2l0aCB0aGUgYWN0dWFsIGFubm90YXRpb24gY29tbWFuZFxuICogU2VlIElzc3VlQ29tbWFuZFByb3BlcnRpZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9hY3Rpb25zL3J1bm5lci9ibG9iL21haW4vc3JjL1J1bm5lci5Xb3JrZXIvQWN0aW9uQ29tbWFuZE1hbmFnZXIuY3MjTDY0NlxuICovXG5mdW5jdGlvbiB0b0NvbW1hbmRQcm9wZXJ0aWVzKGFubm90YXRpb25Qcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhhbm5vdGF0aW9uUHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGl0bGU6IGFubm90YXRpb25Qcm9wZXJ0aWVzLnRpdGxlLFxuICAgICAgICBmaWxlOiBhbm5vdGF0aW9uUHJvcGVydGllcy5maWxlLFxuICAgICAgICBsaW5lOiBhbm5vdGF0aW9uUHJvcGVydGllcy5zdGFydExpbmUsXG4gICAgICAgIGVuZExpbmU6IGFubm90YXRpb25Qcm9wZXJ0aWVzLmVuZExpbmUsXG4gICAgICAgIGNvbDogYW5ub3RhdGlvblByb3BlcnRpZXMuc3RhcnRDb2x1bW4sXG4gICAgICAgIGVuZENvbHVtbjogYW5ub3RhdGlvblByb3BlcnRpZXMuZW5kQ29sdW1uXG4gICAgfTtcbn1cbmV4cG9ydHMudG9Db21tYW5kUHJvcGVydGllcyA9IHRvQ29tbWFuZFByb3BlcnRpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGV4dCA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvc18xID0gcmVxdWlyZShcIm9zXCIpO1xuY2xhc3MgQ29udGV4dCB7XG4gICAgLyoqXG4gICAgICogSHlkcmF0ZSB0aGUgY29udGV4dCBmcm9tIHRoZSBlbnZpcm9ubWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5wYXlsb2FkID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5HSVRIVUJfRVZFTlRfUEFUSCkge1xuICAgICAgICAgICAgaWYgKGZzXzEuZXhpc3RzU3luYyhwcm9jZXNzLmVudi5HSVRIVUJfRVZFTlRfUEFUSCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBheWxvYWQgPSBKU09OLnBhcnNlKGZzXzEucmVhZEZpbGVTeW5jKHByb2Nlc3MuZW52LkdJVEhVQl9FVkVOVF9QQVRILCB7IGVuY29kaW5nOiAndXRmOCcgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IHByb2Nlc3MuZW52LkdJVEhVQl9FVkVOVF9QQVRIO1xuICAgICAgICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBHSVRIVUJfRVZFTlRfUEFUSCAke3BhdGh9IGRvZXMgbm90IGV4aXN0JHtvc18xLkVPTH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IHByb2Nlc3MuZW52LkdJVEhVQl9FVkVOVF9OQU1FO1xuICAgICAgICB0aGlzLnNoYSA9IHByb2Nlc3MuZW52LkdJVEhVQl9TSEE7XG4gICAgICAgIHRoaXMucmVmID0gcHJvY2Vzcy5lbnYuR0lUSFVCX1JFRjtcbiAgICAgICAgdGhpcy53b3JrZmxvdyA9IHByb2Nlc3MuZW52LkdJVEhVQl9XT1JLRkxPVztcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBwcm9jZXNzLmVudi5HSVRIVUJfQUNUSU9OO1xuICAgICAgICB0aGlzLmFjdG9yID0gcHJvY2Vzcy5lbnYuR0lUSFVCX0FDVE9SO1xuICAgICAgICB0aGlzLmpvYiA9IHByb2Nlc3MuZW52LkdJVEhVQl9KT0I7XG4gICAgICAgIHRoaXMucnVuTnVtYmVyID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuR0lUSFVCX1JVTl9OVU1CRVIsIDEwKTtcbiAgICAgICAgdGhpcy5ydW5JZCA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkdJVEhVQl9SVU5fSUQsIDEwKTtcbiAgICAgICAgdGhpcy5hcGlVcmwgPSAoX2EgPSBwcm9jZXNzLmVudi5HSVRIVUJfQVBJX1VSTCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb21gO1xuICAgICAgICB0aGlzLnNlcnZlclVybCA9IChfYiA9IHByb2Nlc3MuZW52LkdJVEhVQl9TRVJWRVJfVVJMKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBgaHR0cHM6Ly9naXRodWIuY29tYDtcbiAgICAgICAgdGhpcy5ncmFwaHFsVXJsID0gKF9jID0gcHJvY2Vzcy5lbnYuR0lUSFVCX0dSQVBIUUxfVVJMKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBgaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9ncmFwaHFsYDtcbiAgICB9XG4gICAgZ2V0IGlzc3VlKCkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5wYXlsb2FkO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlcG8pLCB7IG51bWJlcjogKHBheWxvYWQuaXNzdWUgfHwgcGF5bG9hZC5wdWxsX3JlcXVlc3QgfHwgcGF5bG9hZCkubnVtYmVyIH0pO1xuICAgIH1cbiAgICBnZXQgcmVwbygpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkdJVEhVQl9SRVBPU0lUT1JZKSB7XG4gICAgICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gcHJvY2Vzcy5lbnYuR0lUSFVCX1JFUE9TSVRPUlkuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIHJldHVybiB7IG93bmVyLCByZXBvIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF5bG9hZC5yZXBvc2l0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLnBheWxvYWQucmVwb3NpdG9yeS5vd25lci5sb2dpbixcbiAgICAgICAgICAgICAgICByZXBvOiB0aGlzLnBheWxvYWQucmVwb3NpdG9yeS5uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRleHQucmVwbyByZXF1aXJlcyBhIEdJVEhVQl9SRVBPU0lUT1JZIGVudmlyb25tZW50IHZhcmlhYmxlIGxpa2UgJ293bmVyL3JlcG8nXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udGV4dCA9IENvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0T2N0b2tpdCA9IGV4cG9ydHMuY29udGV4dCA9IHZvaWQgMDtcbmNvbnN0IENvbnRleHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29udGV4dFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmNvbnRleHQgPSBuZXcgQ29udGV4dC5Db250ZXh0KCk7XG4vKipcbiAqIFJldHVybnMgYSBoeWRyYXRlZCBvY3Rva2l0IHJlYWR5IHRvIHVzZSBmb3IgR2l0SHViIEFjdGlvbnNcbiAqXG4gKiBAcGFyYW0gICAgIHRva2VuICAgIHRoZSByZXBvIFBBVCBvciBHSVRIVUJfVE9LRU5cbiAqIEBwYXJhbSAgICAgb3B0aW9ucyAgb3RoZXIgb3B0aW9ucyB0byBzZXRcbiAqL1xuZnVuY3Rpb24gZ2V0T2N0b2tpdCh0b2tlbiwgb3B0aW9ucywgLi4uYWRkaXRpb25hbFBsdWdpbnMpIHtcbiAgICBjb25zdCBHaXRIdWJXaXRoUGx1Z2lucyA9IHV0aWxzXzEuR2l0SHViLnBsdWdpbiguLi5hZGRpdGlvbmFsUGx1Z2lucyk7XG4gICAgcmV0dXJuIG5ldyBHaXRIdWJXaXRoUGx1Z2lucyh1dGlsc18xLmdldE9jdG9raXRPcHRpb25zKHRva2VuLCBvcHRpb25zKSk7XG59XG5leHBvcnRzLmdldE9jdG9raXQgPSBnZXRPY3Rva2l0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2l0aHViLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXBpQmFzZVVybCA9IGV4cG9ydHMuZ2V0UHJveHlBZ2VudCA9IGV4cG9ydHMuZ2V0QXV0aFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGh0dHBDbGllbnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBhY3Rpb25zL2h0dHAtY2xpZW50XCIpKTtcbmZ1bmN0aW9uIGdldEF1dGhTdHJpbmcodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRva2VuICYmICFvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgdG9rZW4gb3Igb3B0cy5hdXRoIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRva2VuICYmIG9wdGlvbnMuYXV0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgdG9rZW4gYW5kIG9wdHMuYXV0aCBtYXkgbm90IGJvdGggYmUgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5hdXRoID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuYXV0aCA6IGB0b2tlbiAke3Rva2VufWA7XG59XG5leHBvcnRzLmdldEF1dGhTdHJpbmcgPSBnZXRBdXRoU3RyaW5nO1xuZnVuY3Rpb24gZ2V0UHJveHlBZ2VudChkZXN0aW5hdGlvblVybCkge1xuICAgIGNvbnN0IGhjID0gbmV3IGh0dHBDbGllbnQuSHR0cENsaWVudCgpO1xuICAgIHJldHVybiBoYy5nZXRBZ2VudChkZXN0aW5hdGlvblVybCk7XG59XG5leHBvcnRzLmdldFByb3h5QWdlbnQgPSBnZXRQcm94eUFnZW50O1xuZnVuY3Rpb24gZ2V0QXBpQmFzZVVybCgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbJ0dJVEhVQl9BUElfVVJMJ10gfHwgJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xufVxuZXhwb3J0cy5nZXRBcGlCYXNlVXJsID0gZ2V0QXBpQmFzZVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0T2N0b2tpdE9wdGlvbnMgPSBleHBvcnRzLkdpdEh1YiA9IGV4cG9ydHMuZGVmYXVsdHMgPSBleHBvcnRzLmNvbnRleHQgPSB2b2lkIDA7XG5jb25zdCBDb250ZXh0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRleHRcIikpO1xuY29uc3QgVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWwvdXRpbHNcIikpO1xuLy8gb2N0b2tpdCArIHBsdWdpbnNcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb2N0b2tpdC9jb3JlXCIpO1xuY29uc3QgcGx1Z2luX3Jlc3RfZW5kcG9pbnRfbWV0aG9kc18xID0gcmVxdWlyZShcIkBvY3Rva2l0L3BsdWdpbi1yZXN0LWVuZHBvaW50LW1ldGhvZHNcIik7XG5jb25zdCBwbHVnaW5fcGFnaW5hdGVfcmVzdF8xID0gcmVxdWlyZShcIkBvY3Rva2l0L3BsdWdpbi1wYWdpbmF0ZS1yZXN0XCIpO1xuZXhwb3J0cy5jb250ZXh0ID0gbmV3IENvbnRleHQuQ29udGV4dCgpO1xuY29uc3QgYmFzZVVybCA9IFV0aWxzLmdldEFwaUJhc2VVcmwoKTtcbmV4cG9ydHMuZGVmYXVsdHMgPSB7XG4gICAgYmFzZVVybCxcbiAgICByZXF1ZXN0OiB7XG4gICAgICAgIGFnZW50OiBVdGlscy5nZXRQcm94eUFnZW50KGJhc2VVcmwpXG4gICAgfVxufTtcbmV4cG9ydHMuR2l0SHViID0gY29yZV8xLk9jdG9raXQucGx1Z2luKHBsdWdpbl9yZXN0X2VuZHBvaW50X21ldGhvZHNfMS5yZXN0RW5kcG9pbnRNZXRob2RzLCBwbHVnaW5fcGFnaW5hdGVfcmVzdF8xLnBhZ2luYXRlUmVzdCkuZGVmYXVsdHMoZXhwb3J0cy5kZWZhdWx0cyk7XG4vKipcbiAqIENvbnZpZW5jZSBmdW5jdGlvbiB0byBjb3JyZWN0bHkgZm9ybWF0IE9jdG9raXQgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSAgICAgdG9rZW4gICAgdGhlIHJlcG8gUEFUIG9yIEdJVEhVQl9UT0tFTlxuICogQHBhcmFtICAgICBvcHRpb25zICBvdGhlciBvcHRpb25zIHRvIHNldFxuICovXG5mdW5jdGlvbiBnZXRPY3Rva2l0T3B0aW9ucyh0b2tlbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zIHx8IHt9KTsgLy8gU2hhbGxvdyBjbG9uZSAtIGRvbid0IG11dGF0ZSB0aGUgb2JqZWN0IHByb3ZpZGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAvLyBBdXRoXG4gICAgY29uc3QgYXV0aCA9IFV0aWxzLmdldEF1dGhTdHJpbmcodG9rZW4sIG9wdHMpO1xuICAgIGlmIChhdXRoKSB7XG4gICAgICAgIG9wdHMuYXV0aCA9IGF1dGg7XG4gICAgfVxuICAgIHJldHVybiBvcHRzO1xufVxuZXhwb3J0cy5nZXRPY3Rva2l0T3B0aW9ucyA9IGdldE9jdG9raXRPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVyc29uYWxBY2Nlc3NUb2tlbkNyZWRlbnRpYWxIYW5kbGVyID0gZXhwb3J0cy5CZWFyZXJDcmVkZW50aWFsSGFuZGxlciA9IGV4cG9ydHMuQmFzaWNDcmVkZW50aWFsSGFuZGxlciA9IHZvaWQgMDtcbmNsYXNzIEJhc2ljQ3JlZGVudGlhbEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICB9XG4gICAgcHJlcGFyZVJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSByZXF1ZXN0IGhhcyBubyBoZWFkZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtCdWZmZXIuZnJvbShgJHt0aGlzLnVzZXJuYW1lfToke3RoaXMucGFzc3dvcmR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgfVxuICAgIC8vIFRoaXMgaGFuZGxlciBjYW5ub3QgaGFuZGxlIDQwMVxuICAgIGNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY0NyZWRlbnRpYWxIYW5kbGVyID0gQmFzaWNDcmVkZW50aWFsSGFuZGxlcjtcbmNsYXNzIEJlYXJlckNyZWRlbnRpYWxIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIC8vIGN1cnJlbnRseSBpbXBsZW1lbnRzIHByZS1hdXRob3JpemF0aW9uXG4gICAgLy8gVE9ETzogc3VwcG9ydCBwcmVBdXRoID0gZmFsc2Ugd2hlcmUgaXQgaG9va3Mgb24gNDAxXG4gICAgcHJlcGFyZVJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSByZXF1ZXN0IGhhcyBubyBoZWFkZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy50b2tlbn1gO1xuICAgIH1cbiAgICAvLyBUaGlzIGhhbmRsZXIgY2Fubm90IGhhbmRsZSA0MDFcbiAgICBjYW5IYW5kbGVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmVhcmVyQ3JlZGVudGlhbEhhbmRsZXIgPSBCZWFyZXJDcmVkZW50aWFsSGFuZGxlcjtcbmNsYXNzIFBlcnNvbmFsQWNjZXNzVG9rZW5DcmVkZW50aWFsSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICAvLyBjdXJyZW50bHkgaW1wbGVtZW50cyBwcmUtYXV0aG9yaXphdGlvblxuICAgIC8vIFRPRE86IHN1cHBvcnQgcHJlQXV0aCA9IGZhbHNlIHdoZXJlIGl0IGhvb2tzIG9uIDQwMVxuICAgIHByZXBhcmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgcmVxdWVzdCBoYXMgbm8gaGVhZGVycycpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYFBBVDoke3RoaXMudG9rZW59YCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgfVxuICAgIC8vIFRoaXMgaGFuZGxlciBjYW5ub3QgaGFuZGxlIDQwMVxuICAgIGNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXIgPSBQZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwQ2xpZW50ID0gZXhwb3J0cy5pc0h0dHBzID0gZXhwb3J0cy5IdHRwQ2xpZW50UmVzcG9uc2UgPSBleHBvcnRzLkh0dHBDbGllbnRFcnJvciA9IGV4cG9ydHMuZ2V0UHJveHlVcmwgPSBleHBvcnRzLk1lZGlhVHlwZXMgPSBleHBvcnRzLkhlYWRlcnMgPSBleHBvcnRzLkh0dHBDb2RlcyA9IHZvaWQgMDtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBzXCIpKTtcbmNvbnN0IHBtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3h5XCIpKTtcbmNvbnN0IHR1bm5lbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHVubmVsXCIpKTtcbnZhciBIdHRwQ29kZXM7XG4oZnVuY3Rpb24gKEh0dHBDb2Rlcykge1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJPS1wiXSA9IDIwMF0gPSBcIk9LXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk11bHRpcGxlQ2hvaWNlc1wiXSA9IDMwMF0gPSBcIk11bHRpcGxlQ2hvaWNlc1wiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJNb3ZlZFBlcm1hbmVudGx5XCJdID0gMzAxXSA9IFwiTW92ZWRQZXJtYW5lbnRseVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJSZXNvdXJjZU1vdmVkXCJdID0gMzAyXSA9IFwiUmVzb3VyY2VNb3ZlZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJTZWVPdGhlclwiXSA9IDMwM10gPSBcIlNlZU90aGVyXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk5vdE1vZGlmaWVkXCJdID0gMzA0XSA9IFwiTm90TW9kaWZpZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiVXNlUHJveHlcIl0gPSAzMDVdID0gXCJVc2VQcm94eVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJTd2l0Y2hQcm94eVwiXSA9IDMwNl0gPSBcIlN3aXRjaFByb3h5XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlRlbXBvcmFyeVJlZGlyZWN0XCJdID0gMzA3XSA9IFwiVGVtcG9yYXJ5UmVkaXJlY3RcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiUGVybWFuZW50UmVkaXJlY3RcIl0gPSAzMDhdID0gXCJQZXJtYW5lbnRSZWRpcmVjdFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiUGF5bWVudFJlcXVpcmVkXCJdID0gNDAyXSA9IFwiUGF5bWVudFJlcXVpcmVkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkZvcmJpZGRlblwiXSA9IDQwM10gPSBcIkZvcmJpZGRlblwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJOb3RGb3VuZFwiXSA9IDQwNF0gPSBcIk5vdEZvdW5kXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk1ldGhvZE5vdEFsbG93ZWRcIl0gPSA0MDVdID0gXCJNZXRob2ROb3RBbGxvd2VkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk5vdEFjY2VwdGFibGVcIl0gPSA0MDZdID0gXCJOb3RBY2NlcHRhYmxlXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZFwiXSA9IDQwN10gPSBcIlByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJSZXF1ZXN0VGltZW91dFwiXSA9IDQwOF0gPSBcIlJlcXVlc3RUaW1lb3V0XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkNvbmZsaWN0XCJdID0gNDA5XSA9IFwiQ29uZmxpY3RcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiR29uZVwiXSA9IDQxMF0gPSBcIkdvbmVcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiVG9vTWFueVJlcXVlc3RzXCJdID0gNDI5XSA9IFwiVG9vTWFueVJlcXVlc3RzXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkludGVybmFsU2VydmVyRXJyb3JcIl0gPSA1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk5vdEltcGxlbWVudGVkXCJdID0gNTAxXSA9IFwiTm90SW1wbGVtZW50ZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiQmFkR2F0ZXdheVwiXSA9IDUwMl0gPSBcIkJhZEdhdGV3YXlcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiU2VydmljZVVuYXZhaWxhYmxlXCJdID0gNTAzXSA9IFwiU2VydmljZVVuYXZhaWxhYmxlXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkdhdGV3YXlUaW1lb3V0XCJdID0gNTA0XSA9IFwiR2F0ZXdheVRpbWVvdXRcIjtcbn0pKEh0dHBDb2RlcyA9IGV4cG9ydHMuSHR0cENvZGVzIHx8IChleHBvcnRzLkh0dHBDb2RlcyA9IHt9KSk7XG52YXIgSGVhZGVycztcbihmdW5jdGlvbiAoSGVhZGVycykge1xuICAgIEhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFjY2VwdFwiO1xuICAgIEhlYWRlcnNbXCJDb250ZW50VHlwZVwiXSA9IFwiY29udGVudC10eXBlXCI7XG59KShIZWFkZXJzID0gZXhwb3J0cy5IZWFkZXJzIHx8IChleHBvcnRzLkhlYWRlcnMgPSB7fSkpO1xudmFyIE1lZGlhVHlwZXM7XG4oZnVuY3Rpb24gKE1lZGlhVHlwZXMpIHtcbiAgICBNZWRpYVR5cGVzW1wiQXBwbGljYXRpb25Kc29uXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG59KShNZWRpYVR5cGVzID0gZXhwb3J0cy5NZWRpYVR5cGVzIHx8IChleHBvcnRzLk1lZGlhVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm94eSBVUkwsIGRlcGVuZGluZyB1cG9uIHRoZSBzdXBwbGllZCB1cmwgYW5kIHByb3h5IGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqIEBwYXJhbSBzZXJ2ZXJVcmwgIFRoZSBzZXJ2ZXIgVVJMIHdoZXJlIHRoZSByZXF1ZXN0IHdpbGwgYmUgc2VudC4gRm9yIGV4YW1wbGUsIGh0dHBzOi8vYXBpLmdpdGh1Yi5jb21cbiAqL1xuZnVuY3Rpb24gZ2V0UHJveHlVcmwoc2VydmVyVXJsKSB7XG4gICAgY29uc3QgcHJveHlVcmwgPSBwbS5nZXRQcm94eVVybChuZXcgVVJMKHNlcnZlclVybCkpO1xuICAgIHJldHVybiBwcm94eVVybCA/IHByb3h5VXJsLmhyZWYgOiAnJztcbn1cbmV4cG9ydHMuZ2V0UHJveHlVcmwgPSBnZXRQcm94eVVybDtcbmNvbnN0IEh0dHBSZWRpcmVjdENvZGVzID0gW1xuICAgIEh0dHBDb2Rlcy5Nb3ZlZFBlcm1hbmVudGx5LFxuICAgIEh0dHBDb2Rlcy5SZXNvdXJjZU1vdmVkLFxuICAgIEh0dHBDb2Rlcy5TZWVPdGhlcixcbiAgICBIdHRwQ29kZXMuVGVtcG9yYXJ5UmVkaXJlY3QsXG4gICAgSHR0cENvZGVzLlBlcm1hbmVudFJlZGlyZWN0XG5dO1xuY29uc3QgSHR0cFJlc3BvbnNlUmV0cnlDb2RlcyA9IFtcbiAgICBIdHRwQ29kZXMuQmFkR2F0ZXdheSxcbiAgICBIdHRwQ29kZXMuU2VydmljZVVuYXZhaWxhYmxlLFxuICAgIEh0dHBDb2Rlcy5HYXRld2F5VGltZW91dFxuXTtcbmNvbnN0IFJldHJ5YWJsZUh0dHBWZXJicyA9IFsnT1BUSU9OUycsICdHRVQnLCAnREVMRVRFJywgJ0hFQUQnXTtcbmNvbnN0IEV4cG9uZW50aWFsQmFja29mZkNlaWxpbmcgPSAxMDtcbmNvbnN0IEV4cG9uZW50aWFsQmFja29mZlRpbWVTbGljZSA9IDU7XG5jbGFzcyBIdHRwQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzQ29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0h0dHBDbGllbnRFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBIdHRwQ2xpZW50RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBDbGllbnRFcnJvciA9IEh0dHBDbGllbnRFcnJvcjtcbmNsYXNzIEh0dHBDbGllbnRSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICByZWFkQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IEJ1ZmZlci5jb25jYXQoW291dHB1dCwgY2h1bmtdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cENsaWVudFJlc3BvbnNlID0gSHR0cENsaWVudFJlc3BvbnNlO1xuZnVuY3Rpb24gaXNIdHRwcyhyZXF1ZXN0VXJsKSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChyZXF1ZXN0VXJsKTtcbiAgICByZXR1cm4gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jztcbn1cbmV4cG9ydHMuaXNIdHRwcyA9IGlzSHR0cHM7XG5jbGFzcyBIdHRwQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyQWdlbnQsIGhhbmRsZXJzLCByZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pZ25vcmVTc2xFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hbGxvd1JlZGlyZWN0cyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FsbG93UmVkaXJlY3REb3duZ3JhZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWF4UmVkaXJlY3RzID0gNTA7XG4gICAgICAgIHRoaXMuX2FsbG93UmV0cmllcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tYXhSZXRyaWVzID0gMTtcbiAgICAgICAgdGhpcy5fa2VlcEFsaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnMgfHwgW107XG4gICAgICAgIHRoaXMucmVxdWVzdE9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMuaWdub3JlU3NsRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lnbm9yZVNzbEVycm9yID0gcmVxdWVzdE9wdGlvbnMuaWdub3JlU3NsRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXRUaW1lb3V0ID0gcmVxdWVzdE9wdGlvbnMuc29ja2V0VGltZW91dDtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5hbGxvd1JlZGlyZWN0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dSZWRpcmVjdHMgPSByZXF1ZXN0T3B0aW9ucy5hbGxvd1JlZGlyZWN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5hbGxvd1JlZGlyZWN0RG93bmdyYWRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxvd1JlZGlyZWN0RG93bmdyYWRlID0gcmVxdWVzdE9wdGlvbnMuYWxsb3dSZWRpcmVjdERvd25ncmFkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5tYXhSZWRpcmVjdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21heFJlZGlyZWN0cyA9IE1hdGgubWF4KHJlcXVlc3RPcHRpb25zLm1heFJlZGlyZWN0cywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMua2VlcEFsaXZlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZWVwQWxpdmUgPSByZXF1ZXN0T3B0aW9ucy5rZWVwQWxpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMuYWxsb3dSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxvd1JldHJpZXMgPSByZXF1ZXN0T3B0aW9ucy5hbGxvd1JldHJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMubWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4UmV0cmllcyA9IHJlcXVlc3RPcHRpb25zLm1heFJldHJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucyhyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnT1BUSU9OUycsIHJlcXVlc3RVcmwsIG51bGwsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldChyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnR0VUJywgcmVxdWVzdFVybCwgbnVsbCwgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsKHJlcXVlc3RVcmwsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdERUxFVEUnLCByZXF1ZXN0VXJsLCBudWxsLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3N0KHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdQT1NUJywgcmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGF0Y2gocmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ1BBVENIJywgcmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHV0KHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdQVVQnLCByZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoZWFkKHJlcXVlc3RVcmwsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdIRUFEJywgcmVxdWVzdFVybCwgbnVsbCwgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFN0cmVhbSh2ZXJiLCByZXF1ZXN0VXJsLCBzdHJlYW0sIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHZlcmIsIHJlcXVlc3RVcmwsIHN0cmVhbSwgYWRkaXRpb25hbEhlYWRlcnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHR5cGVkIG9iamVjdCBmcm9tIGFuIGVuZHBvaW50XG4gICAgICogQmUgYXdhcmUgdGhhdCBub3QgZm91bmQgcmV0dXJucyBhIG51bGwuICBPdGhlciBlcnJvcnMgKDR4eCwgNXh4KSByZWplY3QgdGhlIHByb21pc2VcbiAgICAgKi9cbiAgICBnZXRKc29uKHJlcXVlc3RVcmwsIGFkZGl0aW9uYWxIZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzW0hlYWRlcnMuQWNjZXB0XSA9IHRoaXMuX2dldEV4aXN0aW5nT3JEZWZhdWx0SGVhZGVyKGFkZGl0aW9uYWxIZWFkZXJzLCBIZWFkZXJzLkFjY2VwdCwgTWVkaWFUeXBlcy5BcHBsaWNhdGlvbkpzb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5nZXQocmVxdWVzdFVybCwgYWRkaXRpb25hbEhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NSZXNwb25zZShyZXMsIHRoaXMucmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zdEpzb24ocmVxdWVzdFVybCwgb2JqLCBhZGRpdGlvbmFsSGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzW0hlYWRlcnMuQWNjZXB0XSA9IHRoaXMuX2dldEV4aXN0aW5nT3JEZWZhdWx0SGVhZGVyKGFkZGl0aW9uYWxIZWFkZXJzLCBIZWFkZXJzLkFjY2VwdCwgTWVkaWFUeXBlcy5BcHBsaWNhdGlvbkpzb24pO1xuICAgICAgICAgICAgYWRkaXRpb25hbEhlYWRlcnNbSGVhZGVycy5Db250ZW50VHlwZV0gPSB0aGlzLl9nZXRFeGlzdGluZ09yRGVmYXVsdEhlYWRlcihhZGRpdGlvbmFsSGVhZGVycywgSGVhZGVycy5Db250ZW50VHlwZSwgTWVkaWFUeXBlcy5BcHBsaWNhdGlvbkpzb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5wb3N0KHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUmVzcG9uc2UocmVzLCB0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1dEpzb24ocmVxdWVzdFVybCwgb2JqLCBhZGRpdGlvbmFsSGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzW0hlYWRlcnMuQWNjZXB0XSA9IHRoaXMuX2dldEV4aXN0aW5nT3JEZWZhdWx0SGVhZGVyKGFkZGl0aW9uYWxIZWFkZXJzLCBIZWFkZXJzLkFjY2VwdCwgTWVkaWFUeXBlcy5BcHBsaWNhdGlvbkpzb24pO1xuICAgICAgICAgICAgYWRkaXRpb25hbEhlYWRlcnNbSGVhZGVycy5Db250ZW50VHlwZV0gPSB0aGlzLl9nZXRFeGlzdGluZ09yRGVmYXVsdEhlYWRlcihhZGRpdGlvbmFsSGVhZGVycywgSGVhZGVycy5Db250ZW50VHlwZSwgTWVkaWFUeXBlcy5BcHBsaWNhdGlvbkpzb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5wdXQocmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NSZXNwb25zZShyZXMsIHRoaXMucmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGF0Y2hKc29uKHJlcXVlc3RVcmwsIG9iaiwgYWRkaXRpb25hbEhlYWRlcnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVyc1tIZWFkZXJzLkFjY2VwdF0gPSB0aGlzLl9nZXRFeGlzdGluZ09yRGVmYXVsdEhlYWRlcihhZGRpdGlvbmFsSGVhZGVycywgSGVhZGVycy5BY2NlcHQsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxIZWFkZXJzW0hlYWRlcnMuQ29udGVudFR5cGVdID0gdGhpcy5fZ2V0RXhpc3RpbmdPckRlZmF1bHRIZWFkZXIoYWRkaXRpb25hbEhlYWRlcnMsIEhlYWRlcnMuQ29udGVudFR5cGUsIE1lZGlhVHlwZXMuQXBwbGljYXRpb25Kc29uKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMucGF0Y2gocmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NSZXNwb25zZShyZXMsIHRoaXMucmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSByYXcgaHR0cCByZXF1ZXN0LlxuICAgICAqIEFsbCBvdGhlciBtZXRob2RzIHN1Y2ggYXMgZ2V0LCBwb3N0LCBwYXRjaCwgYW5kIHJlcXVlc3QgdWx0aW1hdGVseSBjYWxsIHRoaXMuXG4gICAgICogUHJlZmVyIGdldCwgZGVsLCBwb3N0IGFuZCBwYXRjaFxuICAgICAqL1xuICAgIHJlcXVlc3QodmVyYiwgcmVxdWVzdFVybCwgZGF0YSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocmVxdWVzdFVybCk7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMuX3ByZXBhcmVSZXF1ZXN0KHZlcmIsIHBhcnNlZFVybCwgaGVhZGVycyk7XG4gICAgICAgICAgICAvLyBPbmx5IHBlcmZvcm0gcmV0cmllcyBvbiByZWFkcyBzaW5jZSB3cml0ZXMgbWF5IG5vdCBiZSBpZGVtcG90ZW50LlxuICAgICAgICAgICAgY29uc3QgbWF4VHJpZXMgPSB0aGlzLl9hbGxvd1JldHJpZXMgJiYgUmV0cnlhYmxlSHR0cFZlcmJzLmluY2x1ZGVzKHZlcmIpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tYXhSZXRyaWVzICsgMVxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgIGxldCBudW1UcmllcyA9IDA7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3RSYXcoaW5mbywgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBhdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2VcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGUgPT09IEh0dHBDb2Rlcy5VbmF1dGhvcml6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF1dGhlbnRpY2F0aW9uSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dGhlbnRpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW9uSGFuZGxlci5oYW5kbGVBdXRoZW50aWNhdGlvbih0aGlzLCBpbmZvLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYW4gdW5hdXRob3JpemVkIHJlc3BvbnNlIGJ1dCBoYXZlIG5vIGhhbmRsZXJzIHRvIGhhbmRsZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgcmVzcG9uc2UgcmV0dXJuIHRvIHRoZSBjYWxsZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlZGlyZWN0c1JlbWFpbmluZyA9IHRoaXMuX21heFJlZGlyZWN0cztcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIEh0dHBSZWRpcmVjdENvZGVzLmluY2x1ZGVzKHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dSZWRpcmVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzUmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IHJlc3BvbnNlLm1lc3NhZ2UuaGVhZGVyc1snbG9jYXRpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBsb2NhdGlvbiB0byByZWRpcmVjdCB0bywgd2Ugd29uJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlZGlyZWN0VXJsID0gbmV3IFVSTChyZWRpcmVjdFVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRVcmwucHJvdG9jb2wgIT09IHBhcnNlZFJlZGlyZWN0VXJsLnByb3RvY29sICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYWxsb3dSZWRpcmVjdERvd25ncmFkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWRpcmVjdCBmcm9tIEhUVFBTIHRvIEhUVFAgcHJvdG9jb2wuIFRoaXMgZG93bmdyYWRlIGlzIG5vdCBhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLiBJZiB5b3Ugd2FudCB0byBhbGxvdyB0aGlzIGJlaGF2aW9yLCBzZXQgdGhlIGFsbG93UmVkaXJlY3REb3duZ3JhZGUgb3B0aW9uIHRvIHRydWUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBmaW5pc2ggcmVhZGluZyB0aGUgcmVzcG9uc2UgYmVmb3JlIHJlYXNzaWduaW5nIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbGVhayB0aGUgb3BlbiBzb2NrZXQuXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlLnJlYWRCb2R5KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGF1dGhvcml6YXRpb24gaGVhZGVyIGlmIHJlZGlyZWN0ZWQgdG8gYSBkaWZmZXJlbnQgaG9zdG5hbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJlZGlyZWN0VXJsLmhvc3RuYW1lICE9PSBwYXJzZWRVcmwuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXIgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnRvTG93ZXJDYXNlKCkgPT09ICdhdXRob3JpemF0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHRoZSByZXF1ZXN0IHdpdGggdGhlIG5ldyByZWRpcmVjdFVybFxuICAgICAgICAgICAgICAgICAgICBpbmZvID0gdGhpcy5fcHJlcGFyZVJlcXVlc3QodmVyYiwgcGFyc2VkUmVkaXJlY3RVcmwsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdFJhdyhpbmZvLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzUmVtYWluaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlIHx8XG4gICAgICAgICAgICAgICAgICAgICFIdHRwUmVzcG9uc2VSZXRyeUNvZGVzLmluY2x1ZGVzKHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IGEgcmV0cnkgY29kZSwgcmV0dXJuIGltbWVkaWF0ZWx5IGluc3RlYWQgb2YgcmV0cnlpbmdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1UcmllcyArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChudW1UcmllcyA8IG1heFRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlLnJlYWRCb2R5KCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX3BlcmZvcm1FeHBvbmVudGlhbEJhY2tvZmYobnVtVHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG51bVRyaWVzIDwgbWF4VHJpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVlZHMgdG8gYmUgY2FsbGVkIGlmIGtlZXBBbGl2ZSBpcyBzZXQgdG8gdHJ1ZSBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FnZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9hZ2VudC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYXcgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gaW5mb1xuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgcmVxdWVzdFJhdyhpbmZvLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrRm9yUmVzdWx0KGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGBlcnJgIGlzIG5vdCBwYXNzZWQsIHRoZW4gYHJlc2AgbXVzdCBiZSBwYXNzZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJhd1dpdGhDYWxsYmFjayhpbmZvLCBkYXRhLCBjYWxsYmFja0ZvclJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhdyByZXF1ZXN0IHdpdGggY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGluZm9cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBvblJlc3VsdFxuICAgICAqL1xuICAgIHJlcXVlc3RSYXdXaXRoQ2FsbGJhY2soaW5mbywgZGF0YSwgb25SZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFpbmZvLm9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGluZm8ub3B0aW9ucy5oZWFkZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZvLm9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEsICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbGxiYWNrQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja0NhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvblJlc3VsdChlcnIsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxID0gaW5mby5odHRwTW9kdWxlLnJlcXVlc3QoaW5mby5vcHRpb25zLCAobXNnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgSHR0cENsaWVudFJlc3BvbnNlKG1zZyk7XG4gICAgICAgICAgICBoYW5kbGVSZXN1bHQodW5kZWZpbmVkLCByZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgcmVxLm9uKCdzb2NrZXQnLCBzb2NrID0+IHtcbiAgICAgICAgICAgIHNvY2tldCA9IHNvY2s7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBldmVyIGdldCBkaXNjb25uZWN0ZWQsIHdlIHdhbnQgdGhlIHNvY2tldCB0byB0aW1lb3V0IGV2ZW50dWFsbHlcbiAgICAgICAgcmVxLnNldFRpbWVvdXQodGhpcy5fc29ja2V0VGltZW91dCB8fCAzICogNjAwMDAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVSZXN1bHQobmV3IEVycm9yKGBSZXF1ZXN0IHRpbWVvdXQ6ICR7aW5mby5vcHRpb25zLnBhdGh9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGVyciBoYXMgc3RhdHVzQ29kZSBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gcmVzIHNob3VsZCBoYXZlIGhlYWRlcnNcbiAgICAgICAgICAgIGhhbmRsZVJlc3VsdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXEud3JpdGUoZGF0YSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRhdGEub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5waXBlKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBodHRwIGFnZW50LiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIGFuIGh0dHAgYWdlbnQgdGhhdCBoYW5kbGVzXG4gICAgICogcm91dGluZyB0aHJvdWdoIGEgcHJveHkgc2VydmVyIC0gZGVwZW5kaW5nIHVwb24gdGhlIHVybCBhbmQgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSBzZXJ2ZXJVcmwgIFRoZSBzZXJ2ZXIgVVJMIHdoZXJlIHRoZSByZXF1ZXN0IHdpbGwgYmUgc2VudC4gRm9yIGV4YW1wbGUsIGh0dHBzOi8vYXBpLmdpdGh1Yi5jb21cbiAgICAgKi9cbiAgICBnZXRBZ2VudChzZXJ2ZXJVcmwpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChzZXJ2ZXJVcmwpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWdlbnQocGFyc2VkVXJsKTtcbiAgICB9XG4gICAgX3ByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcmVxdWVzdFVybCwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBpbmZvID0ge307XG4gICAgICAgIGluZm8ucGFyc2VkVXJsID0gcmVxdWVzdFVybDtcbiAgICAgICAgY29uc3QgdXNpbmdTc2wgPSBpbmZvLnBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgIGluZm8uaHR0cE1vZHVsZSA9IHVzaW5nU3NsID8gaHR0cHMgOiBodHRwO1xuICAgICAgICBjb25zdCBkZWZhdWx0UG9ydCA9IHVzaW5nU3NsID8gNDQzIDogODA7XG4gICAgICAgIGluZm8ub3B0aW9ucyA9IHt9O1xuICAgICAgICBpbmZvLm9wdGlvbnMuaG9zdCA9IGluZm8ucGFyc2VkVXJsLmhvc3RuYW1lO1xuICAgICAgICBpbmZvLm9wdGlvbnMucG9ydCA9IGluZm8ucGFyc2VkVXJsLnBvcnRcbiAgICAgICAgICAgID8gcGFyc2VJbnQoaW5mby5wYXJzZWRVcmwucG9ydClcbiAgICAgICAgICAgIDogZGVmYXVsdFBvcnQ7XG4gICAgICAgIGluZm8ub3B0aW9ucy5wYXRoID1cbiAgICAgICAgICAgIChpbmZvLnBhcnNlZFVybC5wYXRobmFtZSB8fCAnJykgKyAoaW5mby5wYXJzZWRVcmwuc2VhcmNoIHx8ICcnKTtcbiAgICAgICAgaW5mby5vcHRpb25zLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgaW5mby5vcHRpb25zLmhlYWRlcnMgPSB0aGlzLl9tZXJnZUhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLnVzZXJBZ2VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbmZvLm9wdGlvbnMuaGVhZGVyc1sndXNlci1hZ2VudCddID0gdGhpcy51c2VyQWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5vcHRpb25zLmFnZW50ID0gdGhpcy5fZ2V0QWdlbnQoaW5mby5wYXJzZWRVcmwpO1xuICAgICAgICAvLyBnaXZlcyBoYW5kbGVycyBhbiBvcHBvcnR1bml0eSB0byBwYXJ0aWNpcGF0ZVxuICAgICAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnByZXBhcmVSZXF1ZXN0KGluZm8ub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIF9tZXJnZUhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0T3B0aW9ucyAmJiB0aGlzLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBsb3dlcmNhc2VLZXlzKHRoaXMucmVxdWVzdE9wdGlvbnMuaGVhZGVycyksIGxvd2VyY2FzZUtleXMoaGVhZGVycyB8fCB7fSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb3dlcmNhc2VLZXlzKGhlYWRlcnMgfHwge30pO1xuICAgIH1cbiAgICBfZ2V0RXhpc3RpbmdPckRlZmF1bHRIZWFkZXIoYWRkaXRpb25hbEhlYWRlcnMsIGhlYWRlciwgX2RlZmF1bHQpIHtcbiAgICAgICAgbGV0IGNsaWVudEhlYWRlcjtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdE9wdGlvbnMgJiYgdGhpcy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjbGllbnRIZWFkZXIgPSBsb3dlcmNhc2VLZXlzKHRoaXMucmVxdWVzdE9wdGlvbnMuaGVhZGVycylbaGVhZGVyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbEhlYWRlcnNbaGVhZGVyXSB8fCBjbGllbnRIZWFkZXIgfHwgX2RlZmF1bHQ7XG4gICAgfVxuICAgIF9nZXRBZ2VudChwYXJzZWRVcmwpIHtcbiAgICAgICAgbGV0IGFnZW50O1xuICAgICAgICBjb25zdCBwcm94eVVybCA9IHBtLmdldFByb3h5VXJsKHBhcnNlZFVybCk7XG4gICAgICAgIGNvbnN0IHVzZVByb3h5ID0gcHJveHlVcmwgJiYgcHJveHlVcmwuaG9zdG5hbWU7XG4gICAgICAgIGlmICh0aGlzLl9rZWVwQWxpdmUgJiYgdXNlUHJveHkpIHtcbiAgICAgICAgICAgIGFnZW50ID0gdGhpcy5fcHJveHlBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fa2VlcEFsaXZlICYmICF1c2VQcm94eSkge1xuICAgICAgICAgICAgYWdlbnQgPSB0aGlzLl9hZ2VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhZ2VudCBpcyBhbHJlYWR5IGFzc2lnbmVkIHVzZSB0aGF0IGFnZW50LlxuICAgICAgICBpZiAoYWdlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZ2VudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2luZ1NzbCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgIGxldCBtYXhTb2NrZXRzID0gMTAwO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAgICAgbWF4U29ja2V0cyA9IHRoaXMucmVxdWVzdE9wdGlvbnMubWF4U29ja2V0cyB8fCBodHRwLmdsb2JhbEFnZW50Lm1heFNvY2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBgdXNlUHJveHlgIGFnYWluLCBidXQgd2UgbmVlZCB0byBjaGVjayBgcHJveHlVUmxgIGRpcmVjdGx5IGZvciBUeXBlU2NyaXB0cydzIGZsb3cgYW5hbHlzaXMuXG4gICAgICAgIGlmIChwcm94eVVybCAmJiBwcm94eVVybC5ob3N0bmFtZSkge1xuICAgICAgICAgICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1heFNvY2tldHMsXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlOiB0aGlzLl9rZWVwQWxpdmUsXG4gICAgICAgICAgICAgICAgcHJveHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKChwcm94eVVybC51c2VybmFtZSB8fCBwcm94eVVybC5wYXNzd29yZCkgJiYge1xuICAgICAgICAgICAgICAgICAgICBwcm94eUF1dGg6IGAke3Byb3h5VXJsLnVzZXJuYW1lfToke3Byb3h5VXJsLnBhc3N3b3JkfWBcbiAgICAgICAgICAgICAgICB9KSksIHsgaG9zdDogcHJveHlVcmwuaG9zdG5hbWUsIHBvcnQ6IHByb3h5VXJsLnBvcnQgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgdHVubmVsQWdlbnQ7XG4gICAgICAgICAgICBjb25zdCBvdmVySHR0cHMgPSBwcm94eVVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgICAgICBpZiAodXNpbmdTc2wpIHtcbiAgICAgICAgICAgICAgICB0dW5uZWxBZ2VudCA9IG92ZXJIdHRwcyA/IHR1bm5lbC5odHRwc092ZXJIdHRwcyA6IHR1bm5lbC5odHRwc092ZXJIdHRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHVubmVsQWdlbnQgPSBvdmVySHR0cHMgPyB0dW5uZWwuaHR0cE92ZXJIdHRwcyA6IHR1bm5lbC5odHRwT3Zlckh0dHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZ2VudCA9IHR1bm5lbEFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9wcm94eUFnZW50ID0gYWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcmV1c2luZyBhZ2VudCBhY3Jvc3MgcmVxdWVzdCBhbmQgdHVubmVsaW5nIGFnZW50IGlzbid0IGFzc2lnbmVkIGNyZWF0ZSBhIG5ldyBhZ2VudFxuICAgICAgICBpZiAodGhpcy5fa2VlcEFsaXZlICYmICFhZ2VudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsga2VlcEFsaXZlOiB0aGlzLl9rZWVwQWxpdmUsIG1heFNvY2tldHMgfTtcbiAgICAgICAgICAgIGFnZW50ID0gdXNpbmdTc2wgPyBuZXcgaHR0cHMuQWdlbnQob3B0aW9ucykgOiBuZXcgaHR0cC5BZ2VudChvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2FnZW50ID0gYWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90IHVzaW5nIHByaXZhdGUgYWdlbnQgYW5kIHR1bm5lbCBhZ2VudCBpc24ndCBzZXR1cCB0aGVuIHVzZSBnbG9iYWwgYWdlbnRcbiAgICAgICAgaWYgKCFhZ2VudCkge1xuICAgICAgICAgICAgYWdlbnQgPSB1c2luZ1NzbCA/IGh0dHBzLmdsb2JhbEFnZW50IDogaHR0cC5nbG9iYWxBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNpbmdTc2wgJiYgdGhpcy5faWdub3JlU3NsRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc2V0IE5PREVfVExTX1JFSkVDVF9VTkFVVEhPUklaRUQ9MCBzaW5jZSB0aGF0IHdpbGwgYWZmZWN0IHJlcXVlc3QgZm9yIGVudGlyZSBwcm9jZXNzXG4gICAgICAgICAgICAvLyBodHRwLlJlcXVlc3RPcHRpb25zIGRvZXNuJ3QgZXhwb3NlIGEgd2F5IHRvIG1vZGlmeSBSZXF1ZXN0T3B0aW9ucy5hZ2VudC5vcHRpb25zXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGNhc3QgaXQgdG8gYW55IGFuZCBjaGFuZ2UgaXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGFnZW50Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGFnZW50Lm9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgICByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgfVxuICAgIF9wZXJmb3JtRXhwb25lbnRpYWxCYWNrb2ZmKHJldHJ5TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXRyeU51bWJlciA9IE1hdGgubWluKEV4cG9uZW50aWFsQmFja29mZkNlaWxpbmcsIHJldHJ5TnVtYmVyKTtcbiAgICAgICAgICAgIGNvbnN0IG1zID0gRXhwb25lbnRpYWxCYWNrb2ZmVGltZVNsaWNlICogTWF0aC5wb3coMiwgcmV0cnlOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIG1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc1Jlc3BvbnNlKHJlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLm1lc3NhZ2Uuc3RhdHVzQ29kZSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBub3QgZm91bmQgbGVhZHMgdG8gbnVsbCBvYmogcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gSHR0cENvZGVzLk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHJlc3VsdCBmcm9tIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGF0ZVRpbWVEZXNlcmlhbGl6ZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oYS52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb2JqO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IHlpZWxkIHJlcy5yZWFkQm9keSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgJiYgY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZXNlcmlhbGl6ZURhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShjb250ZW50cywgZGF0ZVRpbWVEZXNlcmlhbGl6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShjb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXN1bHQgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHJlcy5tZXNzYWdlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCByZXNvdXJjZSAoY29udGVudHMgbm90IGpzb24pOyAgbGVhdmluZyByZXN1bHQgb2JqIG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IDN4eCByZWRpcmVjdHMgYXJlIGhhbmRsZWQgYnkgdGhlIGh0dHAgbGF5ZXIuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPiAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1zZztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXhjZXB0aW9uL2Vycm9yIGluIGJvZHksIGF0dGVtcHQgdG8gZ2V0IGJldHRlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50cyAmJiBjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBtYXkgYmUgdGhlIGNhc2UgdGhhdCB0aGUgZXhjZXB0aW9uIGlzIGluIHRoZSBib2R5IG1lc3NhZ2UgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBjb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IGBGYWlsZWQgcmVxdWVzdDogKCR7c3RhdHVzQ29kZX0pYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgSHR0cENsaWVudEVycm9yKG1zZywgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGVyci5yZXN1bHQgPSByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBDbGllbnQgPSBIdHRwQ2xpZW50O1xuY29uc3QgbG93ZXJjYXNlS2V5cyA9IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChjLCBrKSA9PiAoKGNbay50b0xvd2VyQ2FzZSgpXSA9IG9ialtrXSksIGMpLCB7fSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tCeXBhc3MgPSBleHBvcnRzLmdldFByb3h5VXJsID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0UHJveHlVcmwocmVxVXJsKSB7XG4gICAgY29uc3QgdXNpbmdTc2wgPSByZXFVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgIGlmIChjaGVja0J5cGFzcyhyZXFVcmwpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5VmFyID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHVzaW5nU3NsKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZbJ2h0dHBzX3Byb3h5J10gfHwgcHJvY2Vzcy5lbnZbJ0hUVFBTX1BST1hZJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZbJ2h0dHBfcHJveHknXSB8fCBwcm9jZXNzLmVudlsnSFRUUF9QUk9YWSddO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBpZiAocHJveHlWYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwocHJveHlWYXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmdldFByb3h5VXJsID0gZ2V0UHJveHlVcmw7XG5mdW5jdGlvbiBjaGVja0J5cGFzcyhyZXFVcmwpIHtcbiAgICBpZiAoIXJlcVVybC5ob3N0bmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5vUHJveHkgPSBwcm9jZXNzLmVudlsnbm9fcHJveHknXSB8fCBwcm9jZXNzLmVudlsnTk9fUFJPWFknXSB8fCAnJztcbiAgICBpZiAoIW5vUHJveHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHJlcXVlc3QgcG9ydFxuICAgIGxldCByZXFQb3J0O1xuICAgIGlmIChyZXFVcmwucG9ydCkge1xuICAgICAgICByZXFQb3J0ID0gTnVtYmVyKHJlcVVybC5wb3J0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVxVXJsLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICAgIHJlcVBvcnQgPSA4MDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVxVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICByZXFQb3J0ID0gNDQzO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgdGhlIHJlcXVlc3QgaG9zdG5hbWUgYW5kIGhvc3RuYW1lIHdpdGggcG9ydFxuICAgIGNvbnN0IHVwcGVyUmVxSG9zdHMgPSBbcmVxVXJsLmhvc3RuYW1lLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICh0eXBlb2YgcmVxUG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdXBwZXJSZXFIb3N0cy5wdXNoKGAke3VwcGVyUmVxSG9zdHNbMF19OiR7cmVxUG9ydH1gKTtcbiAgICB9XG4gICAgLy8gQ29tcGFyZSByZXF1ZXN0IGhvc3QgYWdhaW5zdCBub3Byb3h5XG4gICAgZm9yIChjb25zdCB1cHBlck5vUHJveHlJdGVtIG9mIG5vUHJveHlcbiAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgLm1hcCh4ID0+IHgudHJpbSgpLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4KSkge1xuICAgICAgICBpZiAodXBwZXJSZXFIb3N0cy5zb21lKHggPT4geCA9PT0gdXBwZXJOb1Byb3h5SXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuY2hlY2tCeXBhc3MgPSBjaGVja0J5cGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3h5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpLnBhcnNlO1xubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSByZXF1aXJlKCcuL2xpYi9pbnRlcnAnKS5tYXRjaDtcbm1vZHVsZS5leHBvcnRzLmJ1aWxkID0gcmVxdWlyZSgnLi9saWIvY29uc3RydWN0b3InKS5idWlsZDtcbm1vZHVsZS5leHBvcnRzLndyaXRlID0gcmVxdWlyZSgnLi9saWIvY29uc3RydWN0b3InKS53cml0ZTtcblxubW9kdWxlLmV4cG9ydHMubWF0Y2hlciA9IG1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPVxuICByZXF1aXJlKCcuL2xpYi9jb21waWxlJykuY29tcGlsZTtcbm1vZHVsZS5leHBvcnRzLmJ1aWxkZXIgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlJykuY29tcGlsZV9idWlsZGVyO1xuIiwiLy8gQ29tcGlsZSBwYXR0ZXJucyB0byByZWNvZ25pc2VycyBhbmQgY29uc3RydWN0b3JzXG5cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnYnVmZmVyLW1vcmUtaW50cycpO1xudmFyICQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJykucGFyc2U7XG52YXIgaW50ZXJwID0gcmVxdWlyZSgnLi9pbnRlcnAnKSxcbiAgcGFyc2VfaW50ID0gaW50ZXJwLnBhcnNlX2ludCxcbiAgcGFyc2VfZmxvYXQgPSBpbnRlcnAucGFyc2VfZmxvYXQ7XG52YXIgY29uc3RydWN0ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3RvcicpLFxuICB3cml0ZV9pbnQgPSBjb25zdHJ1Y3Qud3JpdGVfaW50LFxuICB3cml0ZV9mbG9hdCA9IGNvbnN0cnVjdC53cml0ZV9mbG9hdDtcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgbGluZXMgPSBbXTtcbmZ1bmN0aW9uICRzdGFydCgpIHtcbiAgbGluZXMgPSBbXTtcbn1cbmZ1bmN0aW9uICRsaW5lKC8qIGZvcm1hdCAsIGFyZ3MgKi8pIHtcbiAgbGluZXMucHVzaCgkLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xufVxuZnVuY3Rpb24gJHJlc3VsdCgpIHtcbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBiaXRzX2V4cHIoc2VnbWVudCkge1xuICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJCgnJXMgKiAlZCcsIHZhcl9uYW1lKHNlZ21lbnQuc2l6ZSksIHNlZ21lbnQudW5pdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0X251bWJlcihzZWdtZW50KSB7XG4gICRsaW5lKCdiaXRzID0gJXM7XFxuJywgYml0c19leHByKHNlZ21lbnQpKTtcbiAgdmFyIHBhcnNlciA9IChzZWdtZW50LnR5cGUgPT09ICdpbnRlZ2VyJykgP1xuICAgICdwYXJzZV9pbnQnIDogJ3BhcnNlX2Zsb2F0JztcbiAgdmFyIGJlID0gc2VnbWVudC5iaWdlbmRpYW4sIHNnID0gc2VnbWVudC5zaWduZWQ7XG4gICRsaW5lKFwiYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7IG9mZnNldCArPSBiaXRzXCIpO1xuICAkbGluZShcImlmIChvZmZzZXQgPiBiaW5zaXplKSB7IHJldHVybiBmYWxzZTsgfVwiKTtcbiAgJGxpbmUoXCJlbHNlIHsgcmVzdWx0ID0gJXMoYmluLCBieXRlb2Zmc2V0LCBiaXRzIC8gOCwgJXMsICVzKTsgfVwiLFxuICAgICAgICBwYXJzZXIsIGJlLCBzZyk7XG59XG5cbmZ1bmN0aW9uIGdldF9iaW5hcnkoc2VnbWVudCkge1xuICAkbGluZShcImJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4O1wiKTtcbiAgaWYgKHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICRsaW5lKFwib2Zmc2V0ID0gYmluc2l6ZTtcIik7XG4gICAgJGxpbmUoXCJyZXN1bHQgPSBiaW4uc2xpY2UoYnl0ZW9mZnNldCk7XCIpO1xuICB9XG4gIGVsc2Uge1xuICAgICRsaW5lKFwiYml0cyA9ICVzO1wiLCBiaXRzX2V4cHIoc2VnbWVudCkpO1xuICAgICRsaW5lKFwib2Zmc2V0ICs9IGJpdHM7XCIpO1xuICAgICRsaW5lKFwiaWYgKG9mZnNldCA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAgICRsaW5lKFwiZWxzZSB7IHJlc3VsdCA9IGJpbi5zbGljZShieXRlb2Zmc2V0LFwiLFxuICAgICAgICAgIFwiYnl0ZW9mZnNldCArIGJpdHMgLyA4KTsgfVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3RyaW5nKHNlZ21lbnQpIHtcbiAgJGxpbmUoXCJieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODtcIik7XG4gIHZhciBzdHJsZW4gPSBzZWdtZW50LnZhbHVlLmxlbmd0aDtcbiAgdmFyIHN0cmxlbmJpdHMgPSBzdHJsZW4gKiA4O1xuICAkbGluZShcIm9mZnNldCArPSAlZDtcIiwgc3RybGVuYml0cyk7XG4gICRsaW5lKFwiaWYgKG9mZnNldCA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAkbGluZShcImVsc2UgeyByZXN1bHQgPSBiaW4udG9TdHJpbmcoYnl0ZW9mZnNldCxcIixcbiAgICAgICAgJChcImJ5dGVvZmZzZXQgKyAlZCk7IH1cIiwgc3RybGVuKSk7XG59XG5cbmZ1bmN0aW9uIHNraXBfYml0cyhzZWdtZW50KSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgIC8vIERhbW4uIEhhdmUgdG8gbG9vayB1cCB0aGUgc2l6ZS5cbiAgICAkbGluZShcInZhciBza2lwYml0cyA9ICVzICogJWQ7XCIsXG4gICAgICAgICAgdmFyX25hbWUoc2VnbWVudC5zaXplKSwgc2VnbWVudC51bml0KTtcbiAgICAkbGluZShcImlmIChvZmZzZXQgKyBza2lwYml0cyA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAgICRsaW5lKFwiZWxzZSB7IG9mZnNldCArPSBza2lwYml0czsgfVwiKTtcbiAgfVxuICBlbHNlIGlmIChzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAkbGluZShcImlmIChvZmZzZXQgJSA4ID09PSAwKSB7IG9mZnNldCA9IGJpbnNpemU7IH1cIik7XG4gICAgJGxpbmUoXCJlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBiaXRzID0gc2VnbWVudC51bml0ICogc2VnbWVudC5zaXplO1xuICAgICRsaW5lKFwiaWYgKG9mZnNldCArICVkID4gYmluc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cIiwgYml0cyk7XG4gICAgJGxpbmUoXCJlbHNlIHsgb2Zmc2V0ICs9ICVkOyB9XCIsIGJpdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoX3NlZyhzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50Lm5hbWUgPT09ICdfJykge1xuICAgIHNraXBfYml0cyhzZWdtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgYXNzaWduX3Jlc3VsdDtcbiAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGdldF9udW1iZXIoc2VnbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgZ2V0X2JpbmFyeShzZWdtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBnZXRfc3RyaW5nKHNlZ21lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICRsaW5lKFwiaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcIik7XG4gICAgaWYgKHNlZ21lbnQubmFtZSkge1xuICAgICAgLy8gdmFyaWFibGUgaXMgZ2l2ZW4gYSB2YWx1ZSBpbiB0aGUgZW52aXJvbm1lbnRcbiAgICAgICRsaW5lKFwiZWxzZSBpZiAoJXMgIT09IHVuZGVmaW5lZCkge1wiLCB2YXJfbmFtZShzZWdtZW50Lm5hbWUpKTtcbiAgICAgIC8vIC4uIGFuZCBpdCBpcyBub3QgdGhlIHNhbWUgYXMgdGhhdCBtYXRjaGVkXG4gICAgICAkbGluZShcImlmICglcyAhPSByZXN1bHQpIHJldHVybiBmYWxzZTtcIixcbiAgICAgICAgICAgIHZhcl9uYW1lKHNlZ21lbnQubmFtZSkpO1xuICAgICAgJGxpbmUoXCJ9XCIpO1xuICAgICAgLy8gdmFyaWFibGUgaXMgZnJlZVxuICAgICAgJGxpbmUoJ2Vsc2UgJXMgPSByZXN1bHQ7JywgdmFyX25hbWUoc2VnbWVudC5uYW1lKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlcHIgPSBKU09OLnN0cmluZ2lmeShzZWdtZW50LnZhbHVlKTtcbiAgICAgICRsaW5lKFwiZWxzZSBpZiAocmVzdWx0ICE9ICVzKSByZXR1cm4gZmFsc2U7XCIsIHJlcHIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YXJfbmFtZShuYW1lKSB7XG4gIHJldHVybiAgJ3Zhcl8nICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gdmFyaWFibGVzKHNlZ21lbnRzKSB7XG4gIHZhciBuYW1lcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBzZWdtZW50c1tpXS5uYW1lO1xuICAgIGlmIChuYW1lICYmIG5hbWUgIT09ICdfJykge1xuICAgICAgbmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBuYW1lID0gc2VnbWVudHNbaV0uc2l6ZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhuYW1lcyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVfcGF0dGVybihzZWdtZW50cykge1xuICAkc3RhcnQoKTtcbiAgJGxpbmUoXCJyZXR1cm4gZnVuY3Rpb24oYmluYXJ5LCBlbnYpIHtcIik7XG4gICRsaW5lKFwiJ3VzZSBzdHJpY3QnO1wiKTtcbiAgJGxpbmUoXCJ2YXIgYmluID0gYmluYXJ5LCBlbnYgPSBlbnYgfHwge307XCIpO1xuICAkbGluZShcInZhciBvZmZzZXQgPSAwLCBiaW5zaXplID0gYmluLmxlbmd0aCAqIDg7XCIpO1xuICAkbGluZShcInZhciBiaXRzLCByZXN1bHQsIGJ5dGVvZmZzZXQ7XCIpO1xuICB2YXIgdmFybmFtZXMgPSB2YXJpYWJsZXMoc2VnbWVudHMpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IHZhcm5hbWVzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG5hbWUgPSB2YXJuYW1lc1t2XTtcbiAgICAkbGluZShcInZhciAlcyA9IGVudlsnJXMnXTtcIiwgdmFyX25hbWUobmFtZSksIG5hbWUpO1xuICB9XG5cbiAgdmFyIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgJGxpbmUoXCIvLyBcIiArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpKTtcbiAgICBtYXRjaF9zZWcoc2VnbWVudCk7XG4gIH1cblxuICAkbGluZShcImlmIChvZmZzZXQgPT0gYmluc2l6ZSkge1wiKTtcbiAgJGxpbmUoXCJyZXR1cm4ge1wiKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCB2YXJuYW1lcy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBuYW1lID0gdmFybmFtZXNbdl07XG4gICAgJGxpbmUoXCIlczogJXMsXCIsIG5hbWUsIHZhcl9uYW1lKG5hbWUpKTtcbiAgfVxuICAkbGluZSgnfTsnKTtcbiAgJGxpbmUoJ30nKTsgLy8gaWYgb2Zmc2V0ID09IGJpbnNpemVcbiAgJGxpbmUoXCJlbHNlIHJldHVybiBmYWxzZTtcIik7XG4gICRsaW5lKFwifVwiKTsgLy8gZW5kIGZ1bmN0aW9uXG5cbiAgdmFyIGZuID0gbmV3IEZ1bmN0aW9uKCdwYXJzZV9pbnQnLCAncGFyc2VfZmxvYXQnLCAkcmVzdWx0KCkpO1xuICByZXR1cm4gZm4ocGFyc2VfaW50LCBwYXJzZV9mbG9hdCk7XG59XG5cblxuZnVuY3Rpb24gd3JpdGVfc2VnKHNlZ21lbnQpIHtcbiAgc3dpdGNoIChzZWdtZW50LnR5cGUpIHtcbiAgY2FzZSAnc3RyaW5nJzpcbiAgICAkbGluZShcIm9mZnNldCArPSBidWYud3JpdGUoJXMsIG9mZnNldCwgJ3V0ZjgnKTtcIixcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZWdtZW50LnZhbHVlKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2JpbmFyeSc6XG4gICAgJGxpbmUoXCJ2YWwgPSBiaW5kaW5nc1snJXMnXTtcIiwgc2VnbWVudC5uYW1lKTtcbiAgICBpZiAoc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgICAkbGluZSgnc2l6ZSA9IHZhbC5sZW5ndGg7Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAkbGluZShcInNpemUgPSAoYmluZGluZ3NbJyVzJ10gKiAlZCkgLyA4O1wiLFxuICAgICAgICAgICAgc2VnbWVudC5zaXplLCBzZWdtZW50LnVuaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICRsaW5lKFwic2l6ZSA9ICVkO1wiLCAoc2VnbWVudC5zaXplICogc2VnbWVudC51bml0KSAvIDgpO1xuICAgIH1cbiAgICAkbGluZSgndmFsLmNvcHkoYnVmLCBvZmZzZXQsIDAsIHNpemUpOycpO1xuICAgICRsaW5lKCdvZmZzZXQgKz0gc2l6ZTsnKTtcbiAgICBicmVhaztcbiAgY2FzZSAnaW50ZWdlcic6XG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICB3cml0ZV9udW1iZXIoc2VnbWVudCk7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVfbnVtYmVyKHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQubmFtZSkge1xuICAgICRsaW5lKFwidmFsID0gYmluZGluZ3NbJyVzJ107XCIsIHNlZ21lbnQubmFtZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgJGxpbmUoXCJ2YWwgPSAlZFwiLCBzZWdtZW50LnZhbHVlKTtcbiAgfVxuICB2YXIgd3JpdGVyID0gKHNlZ21lbnQudHlwZSA9PT0gJ2ludGVnZXInKSA/XG4gICAgJ3dyaXRlX2ludCcgOiAnd3JpdGVfZmxvYXQnO1xuICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAkbGluZShcInNpemUgPSAoYmluZGluZ3NbJyVzJ10gKiAlZCkgLyA4O1wiLFxuICAgICAgICAgIHNlZ21lbnQuc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAkbGluZSgnc2l6ZSA9ICVkOycsIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gOCk7XG4gIH1cbiAgJGxpbmUoJyVzKGJ1ZiwgdmFsLCBvZmZzZXQsIHNpemUsICVzKTsnLFxuICAgICAgICB3cml0ZXIsIHNlZ21lbnQuYmlnZW5kaWFuKTtcbiAgJGxpbmUoJ29mZnNldCArPSBzaXplOycpO1xufVxuXG5mdW5jdGlvbiBzaXplX29mKHNlZ21lbnRzKSB7XG4gIHZhciB2YXJpYWJsZSA9IFtdO1xuICB2YXIgZml4ZWQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAgIHZhcmlhYmxlLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlZ21lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpeGVkICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNlZ21lbnQudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZpeGVkICs9IChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gODtcbiAgICB9XG4gIH1cblxuICAkbGluZSgndmFyIGJ1ZmZlcnNpemUgPSAlZDsnLCBmaXhlZCk7XG5cbiAgaWYgKHZhcmlhYmxlLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhcmlhYmxlLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHZhcmlhYmxlW2pdO1xuICAgICAgaWYgKHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAkbGluZShcImJ1ZmZlcnNpemUgKz0gYmluZGluZ3NbJyVzJ10ubGVuZ3RoO1wiLCBzZWdtZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICRsaW5lKFwiYnVmZmVyc2l6ZSArPSAoYmluZGluZ3NbJyVzJ10gKiAlZCkgLyA4O1wiLFxuICAgICAgICAgICAgICBzZWdtZW50LnNpemUsIHNlZ21lbnQudW5pdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRfd3JpdGUoc2VnbWVudHMpIHtcbiAgJGxpbmUoJ3ZhciB2YWwsIHNpemU7Jyk7XG5cbiAgdmFyIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgJGxpbmUoJy8vICVzJywgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkpO1xuICAgIHdyaXRlX3NlZyhzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlX2N0b3Ioc2VnbWVudHMpIHtcbiAgJHN0YXJ0KCk7XG4gICRsaW5lKCdyZXR1cm4gZnVuY3Rpb24oYmluZGluZ3MpIHsnKTtcbiAgJGxpbmUoXCIndXNlIHN0cmljdCc7XCIpO1xuICBzaXplX29mKHNlZ21lbnRzKTtcbiAgJGxpbmUoJ3ZhciBidWYgPSBCdWZmZXIuYWxsb2MoYnVmZmVyc2l6ZSk7Jyk7XG4gICRsaW5lKCd2YXIgb2Zmc2V0ID0gMDsnKTtcbiAgZW1pdF93cml0ZShzZWdtZW50cyk7XG4gICRsaW5lKCdyZXR1cm4gYnVmOycpO1xuICAkbGluZSgnfScpOyAvLyBlbmQgZnVuY3Rpb25cblxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKCd3cml0ZV9pbnQnLCAnd3JpdGVfZmxvYXQnLCAnQnVmZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAkcmVzdWx0KCkpKHdyaXRlX2ludCwgd3JpdGVfZmxvYXQsIEJ1ZmZlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbXBpbGVfcGF0dGVybiA9IGNvbXBpbGVfcGF0dGVybjtcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHZhciBwID0gcGFyc2Uoc3RyKTtcbiAgcmV0dXJuIGNvbXBpbGVfcGF0dGVybihwKTtcbn07XG5tb2R1bGUuZXhwb3J0cy5jb21waWxlX2J1aWxkZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHZhciBwID0gcGFyc2Uoc3RyKTtcbiAgcmV0dXJuIGNvbXBpbGVfY3RvcihwKTtcbn07XG4iLCIvLyAtKi0ganMtaW5kZW50LWxldmVsOiAyIC0qLVxuXG4vLyBDb25zdHJ1Y3RvcnMgZ2l2ZW4gcGF0dGVybnNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50cyA9IHJlcXVpcmUoJ2J1ZmZlci1tb3JlLWludHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcblxuLy8gSW50ZXJwcmV0IHRoZSBwYXR0ZXJuLCB3cml0aW5nIHZhbHVlcyBpbnRvIGEgYnVmZmVyXG5mdW5jdGlvbiB3cml0ZShidWYsIG9mZnNldCwgcGF0dGVybiwgYmluZGluZ3MpIHtcbiAgZm9yICh2YXIgaT0wLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBwYXR0ZXJuW2ldO1xuICAgIHN3aXRjaCAoc2VnbWVudC50eXBlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIG9mZnNldCArPSBidWYud3JpdGUoc2VnbWVudC52YWx1ZSwgb2Zmc2V0LCAndXRmOCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIG9mZnNldCArPSB3cml0ZUJpbmFyeShzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICBvZmZzZXQgKz0gd3JpdGVJbnRlZ2VyKHNlZ21lbnQsIGJ1Ziwgb2Zmc2V0LCBiaW5kaW5ncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmbG9hdCc6XG4gICAgICBvZmZzZXQgKz0gd3JpdGVGbG9hdChzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkKHBhdHRlcm4sIGJpbmRpbmdzKSB7XG4gIHZhciBidWZzaXplID0gc2l6ZV9vZihwYXR0ZXJuLCBiaW5kaW5ncyk7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoYnVmc2l6ZSk7XG4gIHdyaXRlKGJ1ZiwgMCwgcGF0dGVybiwgYmluZGluZ3MpO1xuICByZXR1cm4gYnVmO1xufVxuXG4vLyBJbiBieXRlc1xuZnVuY3Rpb24gc2l6ZV9vZl9zZWdtZW50KHNlZ21lbnQsIGJpbmRpbmdzKSB7XG4gIC8vIHNpemUgcmVmZXJzIHRvIGEgdmFyaWFibGVcbiAgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIChiaW5kaW5nc1tzZWdtZW50LnNpemVdICogc2VnbWVudC51bml0KSAvIDg7XG4gIH1cbiAgaWYgKHNlZ21lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc2VnbWVudC52YWx1ZSwgJ3V0ZjgnKTtcbiAgfVxuICBpZiAoc2VnbWVudC50eXBlID09PSAnYmluYXJ5JyAmJiBzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICB2YXIgdmFsID0gYmluZGluZ3Nbc2VnbWVudC5uYW1lXTtcbiAgICByZXR1cm4gdmFsLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gKHNlZ21lbnQuc2l6ZSAqIHNlZ21lbnQudW5pdCkgLyA4O1xufVxuXG4vLyBzaXplIG9mIHRoZSB0by1iZS1jb25zdHJ1Y3RlZCBiaW5hcnksIGluIGJ5dGVzXG5mdW5jdGlvbiBzaXplX29mKHNlZ21lbnRzLCBiaW5kaW5ncykge1xuICB2YXIgc2l6ZSA9IDA7XG4gIGZvciAodmFyIGk9MCwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzaXplICs9IHNpemVfb2Zfc2VnbWVudChzZWdtZW50c1tpXSwgYmluZGluZ3MpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJpbmFyeShzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpIHtcbiAgdmFyIGJpbiA9IGJpbmRpbmdzW3NlZ21lbnQubmFtZV07XG4gIHZhciBzaXplID0gc2l6ZV9vZl9zZWdtZW50KHNlZ21lbnQsIGJpbmRpbmdzKTtcbiAgYmluLmNvcHkoYnVmLCBvZmZzZXQsIDAsIHNpemUpO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gVE9ETyBpbiBmZiBtaWdodCB1c2UgdGhlIG5vQXNzZXJ0IGFyZ3VtZW50IHRvIEJ1ZmZlci53cml0ZSooKSBidXRcbi8vIG5lZWQgdG8gY2hlY2sgdGhhdCBpdCBkb2VzIHRoZSByaWdodCB0aGluZyB3cnQgbGl0dGxlLWVuZGlhblxuXG5mdW5jdGlvbiB3cml0ZUludGVnZXIoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKSB7XG4gIHZhciB2YWx1ZSA9IChzZWdtZW50Lm5hbWUpID8gYmluZGluZ3Nbc2VnbWVudC5uYW1lXSA6IHNlZ21lbnQudmFsdWU7XG4gIHZhciBzaXplID0gc2l6ZV9vZl9zZWdtZW50KHNlZ21lbnQsIGJpbmRpbmdzKTtcbiAgcmV0dXJuIHdyaXRlX2ludChidWYsIHZhbHVlLCBvZmZzZXQsIHNpemUsIHNlZ21lbnQuYmlnZW5kaWFuKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVfaW50KGJ1ZiwgdmFsdWUsIG9mZnNldCwgc2l6ZSwgYmlnZW5kaWFuKSB7XG4gIHN3aXRjaCAoc2l6ZSkge1xuICBjYXNlIDE6XG4gICAgYnVmLndyaXRlVUludDgodmFsdWUsIG9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgICAoYmlnZW5kaWFuKSA/XG4gICAgICBidWYud3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0KSA6XG4gICAgICBidWYud3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSA0OlxuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIDpcbiAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCkgOlxuICAgICAgaW50cy53cml0ZVVJbnQ2NExFKGJ1ZiwgdmFsdWUsIG9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZWdlciBzaXplICogdW5pdCBtdXN0IGJlIDgsIDE2LCAzMiBvciA2NFwiKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdChzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpIHtcbiAgdmFyIHZhbHVlID0gKHNlZ21lbnQubmFtZSkgPyBiaW5kaW5nc1tzZWdtZW50Lm5hbWVdIDogc2VnbWVudC52YWx1ZTtcbiAgdmFyIHNpemUgPSBzaXplX29mX3NlZ21lbnQoc2VnbWVudCwgYmluZGluZ3MpO1xuICByZXR1cm4gd3JpdGVfZmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBzaXplLCBzZWdtZW50LmJpZ2VuZGlhbik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlX2Zsb2F0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgc2l6ZSwgYmlnZW5kaWFuKSB7XG4gIGlmIChzaXplID09PSA0KSB7XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgYnVmLndyaXRlRmxvYXRCRSh2YWx1ZSwgb2Zmc2V0KSA6XG4gICAgICBidWYud3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQpO1xuICB9XG4gIGVsc2UgaWYgKHNpemUgPT09IDgpIHtcbiAgICAoYmlnZW5kaWFuKSA/XG4gICAgICBidWYud3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0KSA6XG4gICAgICBidWYud3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmbG9hdCBzaXplICogdW5pdCBtdXN0IGJlIDMyIG9yIDY0XCIpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJykucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzLndyaXRlID0gd3JpdGU7XG5tb2R1bGUuZXhwb3J0cy5idWlsZCA9IGJ1aWxkO1xubW9kdWxlLmV4cG9ydHMud3JpdGVfaW50ID0gd3JpdGVfaW50O1xubW9kdWxlLmV4cG9ydHMud3JpdGVfZmxvYXQgPSB3cml0ZV9mbG9hdDtcblxubW9kdWxlLmV4cG9ydHMuYnVpbGRlciA9IGZ1bmN0aW9uKHBzdHIpIHtcbiAgcHN0ciA9IChhcmd1bWVudHMubGVuZ3RoID4gMSkgPyBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnLCcpIDogcHN0cjtcbiAgdmFyIHBhdHRlcm4gPSBwYXJzZShwc3RyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhcnMpIHtcbiAgICByZXR1cm4gYnVpbGQocGF0dGVybiwgdmFycyk7XG4gIH07XG59O1xuIiwiLy8gLSotIGpzLWluZGVudDogMiAtKi1cbi8vIEludGVycHJldGVyIGZvciBiaXQgc3ludGF4IEFTVC5cbi8vIEdyYW1tYXI6XG4vL1xuLy8gcGF0dGVybiAgIDo9IHNlZ21lbnQgKFwiLFwiIHNlZ21lbnQpKlxuLy8gc2VnbWVudCAgIDo9ICh2YWx1ZSB8IHZhcikgKFwiOlwiIHNpemUpPyAoXCIvXCIgc3BlY2lmaWVyIChcIi1cIiBzcGVjaWZpZXIpKik/IHwgc3RyaW5nXG4vLyB2YXIgICAgICAgOj0gXCJfXCIgfCBpZGVudGlmaWVyXG4vLyBzaXplICAgICAgOj0gaW50ZWdlciB8IHZhclxuLy8gc3BlY2lmaWVyIDo9IFwibGl0dGxlXCIgfCBcImJpZ1wiIHwgXCJzaWduZWRcIiB8IFwidW5zaWduZWRcIiB8IFwidW5pdFwiIFwiOlwiIDAuLjI1NiB8IHR5cGVcbi8vIHR5cGUgICAgICA6PSBcImludGVnZXJcIiB8IFwiYmluYXJ5XCIgfCBcImZsb2F0XCJcbi8vXG4vLyB3aGVyZSBpbnRlZ2VyIGhhcyB0aGUgb2J2aW91cyBtZWFuaW5nLCBhbmQgaWRlbnRpZmllciBpcyBhbnl0aGluZ1xuLy8gb3RoZXIgdGhhbiBcIl9cIiB0aGF0IGZpdHMgdGhlIEphdmFTY3JpcHQgaWRlbnRpZmllciBzcGVjaWZpY2F0aW9uLlxuLy9cblxuLy8gV2UnbGwgdXNlIGFuIG9iamVjdCB0byByZXByZXNlbnQgZWFjaCBzZWdtZW50LCBhbmQgYW4gYXJyYXkgb2Zcbi8vIHNlZ21lbnRzIGZvciBhIHBhdHRlcm4uIFdlIHdvbid0IHRyeSB0byBvcHRpbWlzZSBmb3IgZ3JvdXBzIG9mXG4vLyBwYXR0ZXJuczsgd2UnbGwganVzdCBzdGVwIHRocm91Z2ggZWFjaCB0byBzZWUgaWYgaXQgd29ya3MuIFdlIHJlbHlcbi8vIGEgaHlwb3RoZXRpY2FsIHByaW9yIHN0ZXAgdG8gY2hlY2sgdGhhdCBpdCdzIGEgdmFsaWQgcGF0dGVybi5cblxuLy8gPyBjb21waWxlIHRvIGludGVybWVkaWF0ZSBpbnN0cnVjdGlvbnMgP1xuXG4vLyBBIHNlZ21lbnQgbG9va3MgbGlrZVxuLy8ge1xuLy8gICAgdHlwZTogc3RyaW5nLCAvLyAnc3RyaW5nJyBpcyBzcGVjaWFsIGNhc2Vcbi8vICAgIHNpemU6IGludGVnZXIgfCB0cnVlLCAvLyB0cnVlIG1lYW5zICdhbGwgcmVtYWluaW5nJ1xuLy8gICAgbmFtZTogc3RyaW5nIHwgbnVsbCwgLy8gKG1heSBiZSAnXycpXG4vLyAgICB2YWx1ZTogdmFsdWUgfCBudWxsLCAvLyBlaXRoZXIgbmFtZSBPUiB2YWx1ZVxuLy8gICAgdW5pdDogaW50ZWdlcixcbi8vICAgIHNpZ25lZDogYm9vbGVhbixcbi8vICAgIGJpZ2VuZGlhbjogYm9vbGVhblxuLy8gfVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnRzICAgID0gcmVxdWlyZSgnYnVmZmVyLW1vcmUtaW50cycpLFxuICAgIGRlYnVnICAgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXRzeW50YXgtSW50ZXJwcmV0ZXInKTtcblxuZnVuY3Rpb24gcGFyc2VfaW50KGJpbiwgb2ZmLCBzaXplSW5CeXRlcywgYmlnZW5kaWFuLCBzaWduZWQpIHtcbiAgc3dpdGNoIChzaXplSW5CeXRlcykge1xuICBjYXNlIDE6XG4gICAgcmV0dXJuIChzaWduZWQpID8gYmluLnJlYWRJbnQ4KG9mZikgOiBiaW4ucmVhZFVJbnQ4KG9mZik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgP1xuICAgICAgKHNpZ25lZCkgPyBiaW4ucmVhZEludDE2QkUob2ZmKSA6IGJpbi5yZWFkVUludDE2QkUob2ZmKSA6XG4gICAgICAoc2lnbmVkKSA/IGJpbi5yZWFkSW50MTZMRShvZmYpIDogYmluLnJlYWRVSW50MTZMRShvZmYpO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIChiaWdlbmRpYW4pID9cbiAgICAgIChzaWduZWQpID8gYmluLnJlYWRJbnQzMkJFKG9mZikgOiBiaW4ucmVhZFVJbnQzMkJFKG9mZikgOlxuICAgICAgKHNpZ25lZCkgPyBiaW4ucmVhZEludDMyTEUob2ZmKSA6IGJpbi5yZWFkVUludDMyTEUob2ZmKTtcbiAgY2FzZSA4OlxuICAgIHJldHVybiAoYmlnZW5kaWFuKSA/XG4gICAgICAoKHNpZ25lZCkgPyBpbnRzLnJlYWRJbnQ2NEJFIDogaW50cy5yZWFkVUludDY0QkUpKGJpbiwgb2ZmKSA6XG4gICAgICAoKHNpZ25lZCkgPyBpbnRzLnJlYWRJbnQ2NExFIDogaW50cy5yZWFkVUludDY0TEUpKGJpbiwgb2ZmKTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBcIkludGVnZXJzIG11c3QgYmUgOC0sIDE2LSwgMzItIG9yIDY0LWJpdFwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Zsb2F0KGJpbiwgb2ZmLCBzaXplSW5CeXRlcywgYmlnZW5kaWFuKSB7XG4gIHN3aXRjaCAoc2l6ZUluQnl0ZXMpIHtcbiAgY2FzZSA0OlxuICAgIHJldHVybiAoYmlnZW5kaWFuKSA/IGJpbi5yZWFkRmxvYXRCRShvZmYpIDogYmluLnJlYWRGbG9hdExFKG9mZik7XG4gIGNhc2UgODpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgPyBiaW4ucmVhZERvdWJsZUJFKG9mZikgOiBiaW4ucmVhZERvdWJsZUxFKG9mZik7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgXCJGbG9hdHMgbXVzdCBiZSAzMi0gb3IgNjQtYml0XCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2l6ZV9vZihzZWdtZW50LCBib3VuZCkge1xuICB2YXIgc2l6ZSA9IHNlZ21lbnQuc2l6ZTtcbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBib3VuZFtzaXplXTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXdfc2NvcGUoZW52KSB7XG4gIGZ1bmN0aW9uIHNjb3BlKCkge307XG4gIHNjb3BlLnByb3RvdHlwZSA9IGVudjtcbiAgcmV0dXJuIG5ldyBzY29wZSgpO1xufVxuXG5mdW5jdGlvbiBiaW5kaW5ncyhzY29wZSkge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBrIGluIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICBzW2tdID0gc2NvcGVba107XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBtYXRjaChwYXR0ZXJuLCBiaW5hcnksIGJvdW5kdmFycykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFycyA9IG5ld19zY29wZShib3VuZHZhcnMpO1xuICB2YXIgYmluc2l6ZSA9IGJpbmFyeS5sZW5ndGggKiA4O1xuXG4gIGZ1bmN0aW9uIHNraXBfYml0cyhzZWdtZW50KSB7XG4gICAgZGVidWcoXCJza2lwIGJpdHNcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIHZhciBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICBpZiAoc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKG9mZnNldCAlIDggPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gYmluc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiaXRzID0gc2VnbWVudC51bml0ICogc2l6ZTtcbiAgICBpZiAob2Zmc2V0ICsgYml0cyA+IGJpbnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gYml0cztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfaW50ZWdlcihzZWdtZW50KSB7XG4gICAgZGVidWcoXCJnZXRfaW50ZWdlclwiKTsgZGVidWcoc2VnbWVudCk7XG4gICAgLy8gbGV0J3MgZG8gb25seSBtdWx0aXBsZXMgb2YgZWlnaHQgYml0cyBmb3Igbm93XG4gICAgdmFyIHVuaXQgPSBzZWdtZW50LnVuaXQsIHNpemUgPSBzaXplX29mKHNlZ21lbnQsIHZhcnMpO1xuICAgIHZhciBiaXRzaXplID0gc2l6ZSAqIHVuaXQ7XG4gICAgdmFyIGJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4OyAvLyBOQiBhc3N1bWVzIGFsaWduZWRcbiAgICBvZmZzZXQgKz0gYml0c2l6ZTtcbiAgICBpZiAoYml0c2l6ZSAlIDggPiAwIHx8IChvZmZzZXQgPiBiaW5zaXplKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZV9pbnQoYmluYXJ5LCBieXRlb2Zmc2V0LCBiaXRzaXplIC8gOCxcbiAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5iaWdlbmRpYW4sIHNlZ21lbnQuc2lnbmVkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfZmxvYXQoc2VnbWVudCkge1xuICAgIGRlYnVnKFwiZ2V0X2Zsb2F0XCIpOyBkZWJ1ZyhzZWdtZW50KTtcbiAgICB2YXIgdW5pdCA9IHNlZ21lbnQudW5pdDsgdmFyIHNpemUgPSBzaXplX29mKHNlZ21lbnQsIHZhcnMpO1xuICAgIHZhciBiaXRzaXplID0gc2l6ZSAqIHVuaXQ7XG4gICAgdmFyIGJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4OyAvLyBhc3N1bWUgYWxpZ25lZFxuICAgIG9mZnNldCArPSBiaXRzaXplO1xuICAgIGlmIChvZmZzZXQgPiBiaW5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlX2Zsb2F0KGJpbmFyeSwgYnl0ZW9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzaXplIC8gOCwgc2VnbWVudC5iaWdlbmRpYW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldF9iaW5hcnkoc2VnbWVudCkge1xuICAgIGRlYnVnKFwiZ2V0X2JpbmFyeVwiKTsgZGVidWcoc2VnbWVudCk7XG4gICAgdmFyIHVuaXQgPSBzZWdtZW50LnVuaXQsIHNpemUgPSBzaXplX29mKHNlZ21lbnQsIHZhcnMpO1xuICAgIHZhciBieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgLy8gTkIgYWxpZ25tZW50XG5cbiAgICBpZiAoc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgb2Zmc2V0ID0gYmluc2l6ZTtcbiAgICAgIHJldHVybiBiaW5hcnkuc2xpY2UoYnl0ZW9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGJpdHNpemUgPSBzaXplICogdW5pdDtcbiAgICAgIGlmIChiaXRzaXplICUgOCA+IDAgfHwgKG9mZnNldCArIGJpdHNpemUpID4gYmluc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ICs9IGJpdHNpemU7XG4gICAgICAgIHJldHVybiBiaW5hcnkuc2xpY2UoYnl0ZW9mZnNldCwgYnl0ZW9mZnNldCArIGJpdHNpemUgLyA4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfc3RyaW5nKHNlZ21lbnQpIHtcbiAgICBkZWJ1ZyhcImdldF9zdHJpbmdcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIHZhciBsZW4gPSBzZWdtZW50LnZhbHVlLmxlbmd0aDtcbiAgICB2YXIgYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7XG5cbiAgICBvZmZzZXQgKz0gbGVuICogODtcbiAgICBpZiAob2Zmc2V0ID4gYmluc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGSVhNRSBieXRlcyB2cyBVVEY4IGNoYXJhY3RlcnNcbiAgICByZXR1cm4gYmluYXJ5LnNsaWNlKGJ5dGVvZmZzZXQsIGJ5dGVvZmZzZXQgKyBsZW4pLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cblxuICB2YXIgcGF0dGVybmxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgIGkgPCBwYXR0ZXJubGVuOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHBhdHRlcm5baV07XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChzZWdtZW50Lm5hbWUgPT09ICdfJykge1xuICAgICAgcmVzdWx0ID0gc2tpcF9iaXRzKHNlZ21lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN3aXRjaCAoc2VnbWVudC50eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXN1bHQgPSBnZXRfc3RyaW5nKHNlZ21lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICByZXN1bHQgPSBnZXRfaW50ZWdlcihzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHJlc3VsdCA9IGdldF9mbG9hdChzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXN1bHQgPSBnZXRfYmluYXJ5KHNlZ21lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VnbWVudC5uYW1lKSB7XG4gICAgICAgIHZhcnNbc2VnbWVudC5uYW1lXSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlZ21lbnQudmFsdWUgIT0gcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9mZnNldCA9PSBiaW5zaXplKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdzKHZhcnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xubW9kdWxlLmV4cG9ydHMucGFyc2VfaW50ID0gcGFyc2VfaW50O1xubW9kdWxlLmV4cG9ydHMucGFyc2VfZmxvYXQgPSBwYXJzZV9mbG9hdDtcbiIsIi8vIFBhcnNlIHBhdHRlcm5zIGluIHN0cmluZyBmb3JtIGludG8gdGhlIGZvcm0gd2UgdXNlIGZvciBpbnRlcnByZXRpbmdcbi8vIChhbmQgbGF0ZXIsIGZvciBjb21waWxpbmcpLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3QgPSByZXF1aXJlKCcuL3BhdHRlcm4nKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG5mdW5jdGlvbiBwYXJzZV9wYXR0ZXJuKHN0cmluZykge1xuICB2YXIgc2VnbWVudHMgPSBwYXJzZXIucGFyc2Uoc3RyaW5nKTtcbiAgZm9yICh2YXIgaT0wLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHMuc3RyaW5nICE9IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudHNbaV0gPSBhc3Quc3RyaW5nKHMuc3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocy52YWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHNlZ21lbnRzW2ldID0gYXN0LnZhbHVlKHMudmFsdWUsIHMuc2l6ZSwgcy5zcGVjaWZpZXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocy5uYW1lICE9IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudHNbaV0gPSBhc3QudmFyaWFibGUocy5uYW1lLCBzLnNpemUsIHMuc3BlY2lmaWVycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgXCJVbmtub3duIHNlZ21lbnQgXCIgKyBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VnbWVudHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHIgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnLCcpO1xuICByZXR1cm4gcGFyc2VfcGF0dGVybihzdHIpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCl7XG4gIC8qXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC43LjAuXG4gICAqXG4gICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAgICovXG4gIFxuICBmdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgLypcbiAgICAgKiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjQ6IEFsbCBjaGFyYWN0ZXJzIG1heSBhcHBlYXIgbGl0ZXJhbGx5IGluIGFcbiAgICAgKiBzdHJpbmcgbGl0ZXJhbCBleGNlcHQgZm9yIHRoZSBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlciwgYmFja3NsYXNoLFxuICAgICAqIGNhcnJpYWdlIHJldHVybiwgbGluZSBzZXBhcmF0b3IsIHBhcmFncmFwaCBzZXBhcmF0b3IsIGFuZCBsaW5lIGZlZWQuXG4gICAgICogQW55IGNoYXJhY3RlciBtYXkgYXBwZWFyIGluIHRoZSBmb3JtIG9mIGFuIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEZvciBwb3J0YWJpbGl0eSwgd2UgYWxzbyBlc2NhcGUgZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUlcbiAgICAgKiBjaGFyYWN0ZXJzLiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZFxuICAgICAqIGJlY2F1c2UgSlNIaW50IGRvZXMgbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLlxuICAgICAqL1xuICAgICByZXR1cm4gJ1wiJyArIHNcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpICAvLyBiYWNrc2xhc2hcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgICAgLy8gY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKSAvLyBiYWNrc3BhY2VcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgICAvLyBob3Jpem9udGFsIHRhYlxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAgIC8vIGxpbmUgZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKSAgIC8vIGZvcm0gZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSAgIC8vIGNhcnJpYWdlIHJldHVyblxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEUtXFx4MUZcXHg4MC1cXHVGRkZGXS9nLCBlc2NhcGUpXG4gICAgICArICdcIic7XG4gIH1cbiAgXG4gIHZhciByZXN1bHQgPSB7XG4gICAgLypcbiAgICAgKiBQYXJzZXMgdGhlIGlucHV0IHdpdGggYSBnZW5lcmF0ZWQgcGFyc2VyLiBJZiB0aGUgcGFyc2luZyBpcyBzdWNjZXNzZnVsbCxcbiAgICAgKiByZXR1cm5zIGEgdmFsdWUgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IHNwZWNpZmllZCBieSB0aGUgZ3JhbW1hciBmcm9tXG4gICAgICogd2hpY2ggdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIChzZWUgfFBFRy5idWlsZFBhcnNlcnwpLiBJZiB0aGUgcGFyc2luZyBpc1xuICAgICAqIHVuc3VjY2Vzc2Z1bCwgdGhyb3dzIHxQRUcucGFyc2VyLlN5bnRheEVycm9yfCBkZXNjcmliaW5nIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQsIHN0YXJ0UnVsZSkge1xuICAgICAgdmFyIHBhcnNlRnVuY3Rpb25zID0ge1xuICAgICAgICBcInN0YXJ0XCI6IHBhcnNlX3N0YXJ0LFxuICAgICAgICBcInNlZ21lbnRUYWlsXCI6IHBhcnNlX3NlZ21lbnRUYWlsLFxuICAgICAgICBcInNlZ21lbnRcIjogcGFyc2Vfc2VnbWVudCxcbiAgICAgICAgXCJzdHJpbmdcIjogcGFyc2Vfc3RyaW5nLFxuICAgICAgICBcImNoYXJzXCI6IHBhcnNlX2NoYXJzLFxuICAgICAgICBcImNoYXJcIjogcGFyc2VfY2hhcixcbiAgICAgICAgXCJoZXhEaWdpdFwiOiBwYXJzZV9oZXhEaWdpdCxcbiAgICAgICAgXCJpZGVudGlmaWVyXCI6IHBhcnNlX2lkZW50aWZpZXIsXG4gICAgICAgIFwibnVtYmVyXCI6IHBhcnNlX251bWJlcixcbiAgICAgICAgXCJzaXplXCI6IHBhcnNlX3NpemUsXG4gICAgICAgIFwic3BlY2lmaWVyTGlzdFwiOiBwYXJzZV9zcGVjaWZpZXJMaXN0LFxuICAgICAgICBcInNwZWNpZmllclRhaWxcIjogcGFyc2Vfc3BlY2lmaWVyVGFpbCxcbiAgICAgICAgXCJzcGVjaWZpZXJcIjogcGFyc2Vfc3BlY2lmaWVyLFxuICAgICAgICBcInVuaXRcIjogcGFyc2VfdW5pdCxcbiAgICAgICAgXCJ3c1wiOiBwYXJzZV93c1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgaWYgKHN0YXJ0UnVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJ1bGUgbmFtZTogXCIgKyBxdW90ZShzdGFydFJ1bGUpICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFJ1bGUgPSBcInN0YXJ0XCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIHJlcG9ydEZhaWx1cmVzID0gMDtcbiAgICAgIHZhciByaWdodG1vc3RGYWlsdXJlc1BvcyA9IDA7XG4gICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYWRMZWZ0KGlucHV0LCBwYWRkaW5nLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGlucHV0O1xuICAgICAgICBcbiAgICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdCA9IHBhZGRpbmcgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGVzY2FwZShjaCkge1xuICAgICAgICB2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICB2YXIgZXNjYXBlQ2hhcjtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIGlmIChjaGFyQ29kZSA8PSAweEZGKSB7XG4gICAgICAgICAgZXNjYXBlQ2hhciA9ICd4JztcbiAgICAgICAgICBsZW5ndGggPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVzY2FwZUNoYXIgPSAndSc7XG4gICAgICAgICAgbGVuZ3RoID0gNDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZUNoYXIgKyBwYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIG1hdGNoRmFpbGVkKGZhaWx1cmUpIHtcbiAgICAgICAgaWYgKHBvcyA8IHJpZ2h0bW9zdEZhaWx1cmVzUG9zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zID4gcmlnaHRtb3N0RmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICByaWdodG1vc3RGYWlsdXJlc1BvcyA9IHBvcztcbiAgICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQucHVzaChmYWlsdXJlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3RhcnQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV93cygpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zZWdtZW50KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zZWdtZW50VGFpbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHJlc3VsdDMpO1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc2VnbWVudFRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHsgdGFpbC51bnNoaWZ0KGhlYWQpOyByZXR1cm4gdGFpbDsgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zZWdtZW50VGFpbCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3dzKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIixcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIsXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV93cygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NlZ21lbnQoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgc2VnKSB7IHJldHVybiBzZWc7IH0pKHBvczAsIHJlc3VsdDBbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2VnbWVudCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3N0cmluZygpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBzdHIpIHsgcmV0dXJuIHtzdHJpbmc6IHN0cn07IH0pKHBvczAsIHJlc3VsdDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfaWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc2l6ZSgpO1xuICAgICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zcGVjaWZpZXJMaXN0KCk7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyICE9PSBudWxsID8gcmVzdWx0MiA6IFwiXCI7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHYsIHNpemUsIHNwZWNzKSB7IHJldHVybiB7bmFtZTogdiwgc2l6ZTogc2l6ZSwgc3BlY2lmaWVyczogc3BlY3N9OyB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9udW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zaXplKCk7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3NwZWNpZmllckxpc3QoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiAhPT0gbnVsbCA/IHJlc3VsdDIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHYsIHNpemUsIHNwZWNzKSB7IHJldHVybiB7dmFsdWU6IHYsIHNpemU6IHNpemUsIHNwZWNpZmllcnM6IHNwZWNzfTsgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3RyaW5nKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXCJcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiXFxcIlwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlwiOyAgICB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfY2hhcnMoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiXFxcIlwiO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFycykgeyByZXR1cm4gY2hhcnM7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NoYXJzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczA7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICByZXN1bHQxID0gcGFyc2VfY2hhcigpO1xuICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MC5wdXNoKHJlc3VsdDEpO1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NoYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7IH0pKHBvczAsIHJlc3VsdDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY2hhcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQ7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eW15cIlxcXFxcXDAtXFx4MUZ/XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlteXFxcIlxcXFxcXFxcXFxcXDAtXFxcXHgxRn9dXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxcXFwiXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcXFwiXCI7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gJ1wiJzsgIH0pKHBvczApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFxcXFwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXC9cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFwvXCI7XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXC9cXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIi9cIjsgIH0pKHBvczApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxiXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcYlwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXGZcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxmXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFxmXCI7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcblxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFxuXCI7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxyXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcclwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFx0XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFx0XCI7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcdVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXHVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcdVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NCA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChcIjB4XCIgKyBoMSArIGgyICsgaDMgKyBoNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSwgcmVzdWx0MFszXSwgcmVzdWx0MFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9oZXhEaWdpdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bMC05YS1mQS1GXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlswLTlhLWZBLUZdXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKC9eW19hLXpBLVpdLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW19hLXpBLVpdXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICBpZiAoL15bX2EtekEtWjAtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbX2EtekEtWjAtOV1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICBpZiAoL15bX2EtekEtWjAtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbX2EtekEtWjAtOV1cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7IHJldHVybiBoZWFkICsgdGFpbC5qb2luKCcnKTsgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9udW1iZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ4KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiMFwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiMFxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIDA7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICBpZiAoL15bMS05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlsxLTldXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgICAgaWYgKC9eWzAtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgICBpZiAoL15bMC05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlswLTldXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkgeyByZXR1cm4gcGFyc2VJbnQoaGVhZCArIHRhaWwuam9pbignJykpOyB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaXplKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA1OCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIjpcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjpcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9udW1iZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIG51bSkgeyByZXR1cm4gbnVtOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIjpcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI6XFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9pZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBpZCkgeyByZXR1cm4gaWQ7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NwZWNpZmllckxpc3QoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ3KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiL1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiL1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NwZWNpZmllcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gW107XG4gICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc3BlY2lmaWVyVGFpbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHJlc3VsdDMpO1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc3BlY2lmaWVyVGFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkgeyB0YWlsLnVuc2hpZnQoaGVhZCk7IHJldHVybiB0YWlsOyB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NwZWNpZmllclRhaWwoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiLVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NwZWNpZmllcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgc3BlYykgeyByZXR1cm4gc3BlYzsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDYpID09PSBcImxpdHRsZVwiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwibGl0dGxlXCI7XG4gICAgICAgICAgcG9zICs9IDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJsaXR0bGVcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAzKSA9PT0gXCJiaWdcIikge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiYmlnXCI7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiYmlnXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA2KSA9PT0gXCJzaWduZWRcIikge1xuICAgICAgICAgICAgICByZXN1bHQwID0gXCJzaWduZWRcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwic2lnbmVkXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDgpID09PSBcInVuc2lnbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJ1bnNpZ25lZFwiO1xuICAgICAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwidW5zaWduZWRcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA3KSA9PT0gXCJpbnRlZ2VyXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcImludGVnZXJcIjtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSA3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJpbnRlZ2VyXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA2KSA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJiaW5hcnlcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDY7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiYmluYXJ5XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDUpID09PSBcImZsb2F0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJmbG9hdFwiO1xuICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSA1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiZmxvYXRcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91bml0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3VuaXQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA1KSA9PT0gXCJ1bml0OlwiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwidW5pdDpcIjtcbiAgICAgICAgICBwb3MgKz0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInVuaXQ6XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfbnVtYmVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBudW0pIHsgcmV0dXJuICd1bml0OicgKyBudW07IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfd3MoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0MCA9IFtdO1xuICAgICAgICBpZiAoL15bIFxcdFxcbl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbIFxcXFx0XFxcXG5dXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICBpZiAoL15bIFxcdFxcbl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbIFxcXFx0XFxcXG5dXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgZXhwZWN0ZWQuc29ydCgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxhc3RFeHBlY3RlZCA9IG51bGw7XG4gICAgICAgIHZhciBjbGVhbkV4cGVjdGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRbaV0gIT09IGxhc3RFeHBlY3RlZCkge1xuICAgICAgICAgICAgY2xlYW5FeHBlY3RlZC5wdXNoKGV4cGVjdGVkW2ldKTtcbiAgICAgICAgICAgIGxhc3RFeHBlY3RlZCA9IGV4cGVjdGVkW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xlYW5FeHBlY3RlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY29tcHV0ZUVycm9yUG9zaXRpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBmaXJzdCBpZGVhIHdhcyB0byB1c2UgfFN0cmluZy5zcGxpdHwgdG8gYnJlYWsgdGhlIGlucHV0IHVwIHRvIHRoZVxuICAgICAgICAgKiBlcnJvciBwb3NpdGlvbiBhbG9uZyBuZXdsaW5lcyBhbmQgZGVyaXZlIHRoZSBsaW5lIGFuZCBjb2x1bW4gZnJvbVxuICAgICAgICAgKiB0aGVyZS4gSG93ZXZlciBJRSdzIHxzcGxpdHwgaW1wbGVtZW50YXRpb24gaXMgc28gYnJva2VuIHRoYXQgaXQgd2FzXG4gICAgICAgICAqIGVub3VnaCB0byBwcmV2ZW50IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIHZhciBsaW5lID0gMTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IDE7XG4gICAgICAgIHZhciBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgocG9zLCByaWdodG1vc3RGYWlsdXJlc1Bvcyk7IGkrKykge1xuICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghc2VlbkNSKSB7IGxpbmUrKzsgfVxuICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgIHNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbisrO1xuICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBsaW5lOiBsaW5lLCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdKCk7XG4gICAgICBcbiAgICAgIC8qXG4gICAgICAgKiBUaGUgcGFyc2VyIGlzIG5vdyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0aHJlZSBzdGF0ZXM6XG4gICAgICAgKlxuICAgICAgICogMS4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIHRoZSB3aG9sZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgICAtIHxyZXN1bHQgIT09IG51bGx8XG4gICAgICAgKiAgICAtIHxwb3MgPT09IGlucHV0Lmxlbmd0aHxcbiAgICAgICAqICAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nXG4gICAgICAgKlxuICAgICAgICogMi4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIG9ubHkgYSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgICAtIHxyZXN1bHQgIT09IG51bGx8XG4gICAgICAgKiAgICAtIHxwb3MgPCBpbnB1dC5sZW5ndGh8XG4gICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZ1xuICAgICAgICpcbiAgICAgICAqIDMuIFRoZSBwYXJzZXIgZGlkIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2UgYW55IHBhcnQgb2YgdGhlIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqICAgLSB8cmVzdWx0ID09PSBudWxsfFxuICAgICAgICogICAtIHxwb3MgPT09IDB8XG4gICAgICAgKiAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBmYWlsdXJlXG4gICAgICAgKlxuICAgICAgICogQWxsIGNvZGUgZm9sbG93aW5nIHRoaXMgY29tbWVudCAoaW5jbHVkaW5nIGNhbGxlZCBmdW5jdGlvbnMpIG11c3RcbiAgICAgICAqIGhhbmRsZSB0aGVzZSBzdGF0ZXMuXG4gICAgICAgKi9cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcG9zICE9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpO1xuICAgICAgICB2YXIgZm91bmQgPSBvZmZzZXQgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQob2Zmc2V0KSA6IG51bGw7XG4gICAgICAgIHZhciBlcnJvclBvc2l0aW9uID0gY29tcHV0ZUVycm9yUG9zaXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIHRocm93IG5ldyB0aGlzLlN5bnRheEVycm9yKFxuICAgICAgICAgIGNsZWFudXBFeHBlY3RlZChyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkKSxcbiAgICAgICAgICBmb3VuZCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgZXJyb3JQb3NpdGlvbi5saW5lLFxuICAgICAgICAgIGVycm9yUG9zaXRpb24uY29sdW1uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBcbiAgICAvKiBSZXR1cm5zIHRoZSBwYXJzZXIgc291cmNlIGNvZGUuICovXG4gICAgdG9Tb3VyY2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc291cmNlOyB9XG4gIH07XG4gIFxuICAvKiBUaHJvd24gd2hlbiBhIHBhcnNlciBlbmNvdW50ZXJzIGEgc3ludGF4IGVycm9yLiAqL1xuICBcbiAgcmVzdWx0LlN5bnRheEVycm9yID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgIHZhciBleHBlY3RlZEh1bWFuaXplZCwgZm91bmRIdW1hbml6ZWQ7XG4gICAgICBcbiAgICAgIHN3aXRjaCAoZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gZXhwZWN0ZWQuc2xpY2UoMCwgZXhwZWN0ZWQubGVuZ3RoIC0gMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICArIGV4cGVjdGVkW2V4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3VuZEh1bWFuaXplZCA9IGZvdW5kID8gcXVvdGUoZm91bmQpIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgIFxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZEh1bWFuaXplZCArIFwiIGJ1dCBcIiArIGZvdW5kSHVtYW5pemVkICsgXCIgZm91bmQuXCI7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCA9IGZvdW5kO1xuICAgIHRoaXMubWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gIH07XG4gIFxuICByZXN1bHQuU3ludGF4RXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG4iLCIvLyAtKi0ganMtaW5kZW50LWxldmVsOiAyIC0qLVxuLy8gQ29uc3RydWN0aW5nIHBhdHRlcm5zXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBpIGluIHZhbHVlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlcywgaSkpIGNvbnRpbnVlO1xuICAgIHNbdmFsdWVzW2ldXSA9IDE7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8vIENvbnN0cnVjdCBhIHNlZ21lbnQgYm91bmQgdG8gYSB2YXJpYWJsZSwgZS5nLiwgZnJvbSBhIHNlZ21lbnQgbGlrZVxuLy8gXCJMZW46MzIvdW5zaWduZWQtYmlnXCIuIGBzcGVjaWZpZXJzMGAgaXMgYW4gYXJyYXkuXG5mdW5jdGlvbiB2YXJpYWJsZShuYW1lLCBzaXplLCBzcGVjaWZpZXJzMCkge1xuICB2YXIgc3BlY2lmaWVycyA9IHNldChzcGVjaWZpZXJzMCk7XG4gIHZhciBzZWdtZW50ID0ge25hbWU6IG5hbWV9O1xuICBzZWdtZW50LnR5cGUgPSB0eXBlX2luKHNwZWNpZmllcnMpO1xuICBzcGVjcyhzZWdtZW50LCBzZWdtZW50LnR5cGUsIHNwZWNpZmllcnMpO1xuICBzZWdtZW50LnNpemUgPSBzaXplX29mKHNlZ21lbnQsIHNlZ21lbnQudHlwZSwgc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzLnZhcmlhYmxlID0gdmFyaWFibGU7XG5tb2R1bGUuZXhwb3J0cy5yZXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB2YXJpYWJsZSgnXycsIHRydWUsIFsnYmluYXJ5J10pO1xufVxuXG4vLyBDb25zdHJ1Y3QgYSBzZWdtZW50IHdpdGggYSBsaXRlcmFsIHZhbHVlLCBlLmcuLCBmcm9tIGEgc2VnbWVudCBsaWtlXG4vLyBcIjIwNlwiLiBgc3BlY2lmaWVyczBgIGlzIGFuIGFycmF5LlxuXG5mdW5jdGlvbiB2YWx1ZSh2YWwsIHNpemUsIHNwZWNpZmllcnMwKSB7XG4gIHZhciBzcGVjaWZpZXJzID0gc2V0KHNwZWNpZmllcnMwKTtcbiAgdmFyIHNlZ21lbnQgPSB7dmFsdWU6IHZhbH07XG4gIHNlZ21lbnQudHlwZSA9IHR5cGVfaW4oc3BlY2lmaWVycyk7XG4gIC8vIFRPRE8gY2hlY2sgdHlwZSB2LiB2YWx1ZSAuLlxuICBzcGVjcyhzZWdtZW50LCBzZWdtZW50LnR5cGUsIHNwZWNpZmllcnMpO1xuICBzZWdtZW50LnNpemUgPSBzaXplX29mKHNlZ21lbnQsIHNlZ21lbnQudHlwZSwgc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzLnZhbHVlID0gdmFsdWU7XG5cbi8vIEEgc3RyaW5nIGNhbiBhcHBlYXIgYXMgYSBsaXRlcmFsLCBidXQgaXQgbXVzdCBhcHBlYXIgd2l0aG91dFxuLy8gc3BlY2lmaWVycy5cbmZ1bmN0aW9uIHN0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsLCB0eXBlOiAnc3RyaW5nJ307XG59XG5tb2R1bGUuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5cbnZhciBUWVBFUyA9IHsnaW50ZWdlcic6IDEsICdiaW5hcnknOiAxLCAnZmxvYXQnOiAxfTtcbmZ1bmN0aW9uIHR5cGVfaW4oc3BlY2lmaWVycykge1xuICBmb3IgKHZhciB0IGluIHNwZWNpZmllcnMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcGVjaWZpZXJzLCB0KSkgY29udGludWU7XG4gICAgaWYgKFRZUEVTW3RdKSB7IHJldHVybiB0OyB9XG4gIH1cbiAgcmV0dXJuICdpbnRlZ2VyJztcbn1cblxuZnVuY3Rpb24gc3BlY3Moc2VnbWVudCwgdHlwZSwgc3BlY2lmaWVycykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnaW50ZWdlcic6XG4gICAgc2VnbWVudC5zaWduZWQgPSBzaWduZWRfaW4oc3BlY2lmaWVycyk7XG4gICAgLy8gZmFsbCB0aHJvdWdoXG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICBzZWdtZW50LmJpZ2VuZGlhbiA9IGVuZGlhbl9pbihzcGVjaWZpZXJzKTtcbiAgICAvLyBmYWxsIHRocm91Z2hcbiAgZGVmYXVsdDpcbiAgICBzZWdtZW50LnVuaXQgPSB1bml0X2luKHNwZWNpZmllcnMsIHNlZ21lbnQudHlwZSk7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGVuZGlhbl9pbihzcGVjaWZpZXJzKSB7XG4gIC8vIGRlZmF1bHQgaXMgYmlnLCBidXQgSSBoYXZlIGNob3NlbiB0cnVlID0gYmlnZW5kaWFuXG4gIHJldHVybiAhc3BlY2lmaWVyc1snbGl0dGxlJ107XG59XG5cbmZ1bmN0aW9uIHNpZ25lZF9pbihzcGVjaWZpZXJzKSB7XG4gIC8vIHRoaXMgdGltZSBJIGdvdCBpdCByaWdodDsgZGVmYXVsdCBpcyB1bnNpZ25lZFxuICByZXR1cm4gc3BlY2lmaWVyc1snc2lnbmVkJ107XG59XG5cbmZ1bmN0aW9uIHVuaXRfaW4oc3BlY2lmaWVycywgdHlwZSkge1xuICBmb3IgKHZhciBzIGluIHNwZWNpZmllcnMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcGVjaWZpZXJzLCBzKSkgY29udGludWU7XG4gICAgaWYgKHMuc3Vic3RyKDAsIDUpID09ICd1bml0OicpIHtcbiAgICAgIHZhciB1bml0ID0gcGFyc2VJbnQocy5zdWJzdHIoNSkpO1xuICAgICAgLy8gVE9ETyBjaGVjayBzYW5lIGZvciB0eXBlXG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgLy8gT0sgZGVmYXVsdHMgdGhlblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnYmluYXJ5JzpcbiAgICByZXR1cm4gODtcbiAgY2FzZSAnaW50ZWdlcic6XG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplX29mKHNlZ21lbnQsIHR5cGUsIHNpemUsIHVuaXQpIHtcbiAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBzaXplICE9PSAnJykge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgcmV0dXJuIDY0O1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IFJFR0VYX0lTX0lOU1RBTExBVElPTl9MRUdBQ1kgPSAvXnYxXFwuLztcbmNvbnN0IFJFR0VYX0lTX0lOU1RBTExBVElPTiA9IC9eZ2hzXy87XG5jb25zdCBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUiA9IC9eZ2h1Xy87XG5hc3luYyBmdW5jdGlvbiBhdXRoKHRva2VuKSB7XG4gICAgY29uc3QgaXNBcHAgPSB0b2tlbi5zcGxpdCgvXFwuLykubGVuZ3RoID09PSAzO1xuICAgIGNvbnN0IGlzSW5zdGFsbGF0aW9uID0gUkVHRVhfSVNfSU5TVEFMTEFUSU9OX0xFR0FDWS50ZXN0KHRva2VuKSB8fFxuICAgICAgICBSRUdFWF9JU19JTlNUQUxMQVRJT04udGVzdCh0b2tlbik7XG4gICAgY29uc3QgaXNVc2VyVG9TZXJ2ZXIgPSBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUi50ZXN0KHRva2VuKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBpc0FwcFxuICAgICAgICA/IFwiYXBwXCJcbiAgICAgICAgOiBpc0luc3RhbGxhdGlvblxuICAgICAgICAgICAgPyBcImluc3RhbGxhdGlvblwiXG4gICAgICAgICAgICA6IGlzVXNlclRvU2VydmVyXG4gICAgICAgICAgICAgICAgPyBcInVzZXItdG8tc2VydmVyXCJcbiAgICAgICAgICAgICAgICA6IFwib2F1dGhcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRva2VuXCIsXG4gICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgdG9rZW5UeXBlLFxuICAgIH07XG59XG5cbi8qKlxuICogUHJlZml4IHRva2VuIGZvciB1c2FnZSBpbiB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAqXG4gKiBAcGFyYW0gdG9rZW4gT0F1dGggdG9rZW4gb3IgSlNPTiBXZWIgVG9rZW5cbiAqL1xuZnVuY3Rpb24gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pIHtcbiAgICBpZiAodG9rZW4uc3BsaXQoL1xcLi8pLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gYGJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICAgIHJldHVybiBgdG9rZW4gJHt0b2tlbn1gO1xufVxuXG5hc3luYyBmdW5jdGlvbiBob29rKHRva2VuLCByZXF1ZXN0LCByb3V0ZSwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gcmVxdWVzdC5lbmRwb2ludC5tZXJnZShyb3V0ZSwgcGFyYW1ldGVycyk7XG4gICAgZW5kcG9pbnQuaGVhZGVycy5hdXRob3JpemF0aW9uID0gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pO1xuICAgIHJldHVybiByZXF1ZXN0KGVuZHBvaW50KTtcbn1cblxuY29uc3QgY3JlYXRlVG9rZW5BdXRoID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5BdXRoKHRva2VuKSB7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQG9jdG9raXQvYXV0aC10b2tlbl0gTm8gdG9rZW4gcGFzc2VkIHRvIGNyZWF0ZVRva2VuQXV0aFwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQG9jdG9raXQvYXV0aC10b2tlbl0gVG9rZW4gcGFzc2VkIHRvIGNyZWF0ZVRva2VuQXV0aCBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHRva2VuID0gdG9rZW4ucmVwbGFjZSgvXih0b2tlbnxiZWFyZXIpICsvaSwgXCJcIik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXV0aC5iaW5kKG51bGwsIHRva2VuKSwge1xuICAgICAgICBob29rOiBob29rLmJpbmQobnVsbCwgdG9rZW4pLFxuICAgIH0pO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlVG9rZW5BdXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gJ3VuaXZlcnNhbC11c2VyLWFnZW50JztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICdiZWZvcmUtYWZ0ZXItaG9vayc7XG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnQG9jdG9raXQvcmVxdWVzdCc7XG5pbXBvcnQgeyB3aXRoQ3VzdG9tUmVxdWVzdCB9IGZyb20gJ0BvY3Rva2l0L2dyYXBocWwnO1xuaW1wb3J0IHsgY3JlYXRlVG9rZW5BdXRoIH0gZnJvbSAnQG9jdG9raXQvYXV0aC10b2tlbic7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjMuNi4wXCI7XG5cbmNsYXNzIE9jdG9raXQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBob29rID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdERlZmF1bHRzID0ge1xuICAgICAgICAgICAgYmFzZVVybDogcmVxdWVzdC5lbmRwb2ludC5ERUZBVUxUUy5iYXNlVXJsLFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICByZXF1ZXN0OiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHVzYWdlIG9ubHksIG5vIG5lZWQgdG8gdHlwZVxuICAgICAgICAgICAgICAgIGhvb2s6IGhvb2suYmluZChudWxsLCBcInJlcXVlc3RcIiksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1lZGlhVHlwZToge1xuICAgICAgICAgICAgICAgIHByZXZpZXdzOiBbXSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBwcmVwZW5kIGRlZmF1bHQgdXNlciBhZ2VudCB3aXRoIGBvcHRpb25zLnVzZXJBZ2VudGAgaWYgc2V0XG4gICAgICAgIHJlcXVlc3REZWZhdWx0cy5oZWFkZXJzW1widXNlci1hZ2VudFwiXSA9IFtcbiAgICAgICAgICAgIG9wdGlvbnMudXNlckFnZW50LFxuICAgICAgICAgICAgYG9jdG9raXQtY29yZS5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YCxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICAgICAgICByZXF1ZXN0RGVmYXVsdHMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wcmV2aWV3cykge1xuICAgICAgICAgICAgcmVxdWVzdERlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3cyA9IG9wdGlvbnMucHJldmlld3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudGltZVpvbmUpIHtcbiAgICAgICAgICAgIHJlcXVlc3REZWZhdWx0cy5oZWFkZXJzW1widGltZS16b25lXCJdID0gb3B0aW9ucy50aW1lWm9uZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0LmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuZ3JhcGhxbCA9IHdpdGhDdXN0b21SZXF1ZXN0KHRoaXMucmVxdWVzdCkuZGVmYXVsdHMocmVxdWVzdERlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5sb2cgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRlYnVnOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBpbmZvOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICB3YXJuOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICAgICAgICAgIGVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgICAgIH0sIG9wdGlvbnMubG9nKTtcbiAgICAgICAgdGhpcy5ob29rID0gaG9vaztcbiAgICAgICAgLy8gKDEpIElmIG5laXRoZXIgYG9wdGlvbnMuYXV0aFN0cmF0ZWd5YCBub3IgYG9wdGlvbnMuYXV0aGAgYXJlIHNldCwgdGhlIGBvY3Rva2l0YCBpbnN0YW5jZVxuICAgICAgICAvLyAgICAgaXMgdW5hdXRoZW50aWNhdGVkLiBUaGUgYHRoaXMuYXV0aCgpYCBtZXRob2QgaXMgYSBuby1vcCBhbmQgbm8gcmVxdWVzdCBob29rIGlzIHJlZ2lzdGVyZWQuXG4gICAgICAgIC8vICgyKSBJZiBvbmx5IGBvcHRpb25zLmF1dGhgIGlzIHNldCwgdXNlIHRoZSBkZWZhdWx0IHRva2VuIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5LlxuICAgICAgICAvLyAoMykgSWYgYG9wdGlvbnMuYXV0aFN0cmF0ZWd5YCBpcyBzZXQgdGhlbiB1c2UgaXQgYW5kIHBhc3MgaW4gYG9wdGlvbnMuYXV0aGAuIEFsd2F5cyBwYXNzIG93biByZXF1ZXN0IGFzIG1hbnkgc3RyYXRlZ2llcyBhY2NlcHQgYSBjdXN0b20gcmVxdWVzdCBpbnN0YW5jZS5cbiAgICAgICAgLy8gVE9ETzogdHlwZSBgb3B0aW9ucy5hdXRoYCBiYXNlZCBvbiBgb3B0aW9ucy5hdXRoU3RyYXRlZ3lgLlxuICAgICAgICBpZiAoIW9wdGlvbnMuYXV0aFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYXV0aCkge1xuICAgICAgICAgICAgICAgIC8vICgxKVxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aCA9IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidW5hdXRoZW50aWNhdGVkXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAoMilcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoID0gY3JlYXRlVG9rZW5BdXRoKG9wdGlvbnMuYXV0aCk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFN0cmF0ZWd5LCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBhdXRoID0gYXV0aFN0cmF0ZWd5KE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgICAgICBsb2c6IHRoaXMubG9nLFxuICAgICAgICAgICAgICAgIC8vIHdlIHBhc3MgdGhlIGN1cnJlbnQgb2N0b2tpdCBpbnN0YW5jZSBhcyB3ZWxsIGFzIGl0cyBjb25zdHJ1Y3RvciBvcHRpb25zXG4gICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWdpZXMgdGhhdCByZXR1cm4gYSBuZXcgb2N0b2tpdCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgc2hhcmVzIHRoZSBzYW1lIGludGVybmFsIHN0YXRlIGFzIHRoZSBjdXJyZW50IG9uZS4gVGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnQgZm9yIHRoaXMgd2FzIHRoZSBcImV2ZW50LW9jdG9raXRcIiBhdXRoZW50aWNhdGlvbiBzdHJhdGVneVxuICAgICAgICAgICAgICAgIC8vIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9ib3Qvb2N0b2tpdC1hdXRoLXByb2JvdC5cbiAgICAgICAgICAgICAgICBvY3Rva2l0OiB0aGlzLFxuICAgICAgICAgICAgICAgIG9jdG9raXRPcHRpb25zOiBvdGhlck9wdGlvbnMsXG4gICAgICAgICAgICB9LCBvcHRpb25zLmF1dGgpKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgIMKvXFxfKOODhClfL8KvXG4gICAgICAgICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IHBsdWdpbnNcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MzQ1MTcyXG4gICAgICAgIGNvbnN0IGNsYXNzQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjbGFzc0NvbnN0cnVjdG9yLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBsdWdpbih0aGlzLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICAgICAgY29uc3QgT2N0b2tpdFdpdGhEZWZhdWx0cyA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbMF0gfHwge307XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKGRlZmF1bHRzKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucywgb3B0aW9ucy51c2VyQWdlbnQgJiYgZGVmYXVsdHMudXNlckFnZW50XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckFnZW50OiBgJHtvcHRpb25zLnVzZXJBZ2VudH0gJHtkZWZhdWx0cy51c2VyQWdlbnR9YCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9jdG9raXRXaXRoRGVmYXVsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIHBsdWdpbiAob3IgbWFueSkgdG8geW91ciBPY3Rva2l0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBBUEkgPSBPY3Rva2l0LnBsdWdpbihwbHVnaW4xLCBwbHVnaW4yLCBwbHVnaW4zLCAuLi4pXG4gICAgICovXG4gICAgc3RhdGljIHBsdWdpbiguLi5uZXdQbHVnaW5zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3VycmVudFBsdWdpbnMgPSB0aGlzLnBsdWdpbnM7XG4gICAgICAgIGNvbnN0IE5ld09jdG9raXQgPSAoX2EgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hLnBsdWdpbnMgPSBjdXJyZW50UGx1Z2lucy5jb25jYXQobmV3UGx1Z2lucy5maWx0ZXIoKHBsdWdpbikgPT4gIWN1cnJlbnRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpKSxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgcmV0dXJuIE5ld09jdG9raXQ7XG4gICAgfVxufVxuT2N0b2tpdC5WRVJTSU9OID0gVkVSU0lPTjtcbk9jdG9raXQucGx1Z2lucyA9IFtdO1xuXG5leHBvcnQgeyBPY3Rva2l0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSAndW5pdmVyc2FsLXVzZXItYWdlbnQnO1xuXG5mdW5jdGlvbiBsb3dlcmNhc2VLZXlzKG9iamVjdCkge1xuICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkucmVkdWNlKChuZXdPYmosIGtleSkgPT4ge1xuICAgICAgICBuZXdPYmpba2V5LnRvTG93ZXJDYXNlKCldID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBkZWZhdWx0cykpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlRGVlcChkZWZhdWx0c1trZXldLCBvcHRpb25zW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbWVyZ2UoZGVmYXVsdHMsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiByb3V0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZXQgW21ldGhvZCwgdXJsXSA9IHJvdXRlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odXJsID8geyBtZXRob2QsIHVybCB9IDogeyB1cmw6IG1ldGhvZCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZSk7XG4gICAgfVxuICAgIC8vIGxvd2VyY2FzZSBoZWFkZXIgbmFtZXMgYmVmb3JlIG1lcmdpbmcgd2l0aCBkZWZhdWx0cyB0byBhdm9pZCBkdXBsaWNhdGVzXG4gICAgb3B0aW9ucy5oZWFkZXJzID0gbG93ZXJjYXNlS2V5cyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIC8vIHJlbW92ZSBwcm9wZXJ0aWVzIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBiZWZvcmUgbWVyZ2luZ1xuICAgIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBtZXJnZURlZXAoZGVmYXVsdHMgfHwge30sIG9wdGlvbnMpO1xuICAgIC8vIG1lZGlhVHlwZS5wcmV2aWV3cyBhcnJheXMgYXJlIG1lcmdlZCwgaW5zdGVhZCBvZiBvdmVyd3JpdHRlblxuICAgIGlmIChkZWZhdWx0cyAmJiBkZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MubGVuZ3RoKSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzID0gZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzXG4gICAgICAgICAgICAuZmlsdGVyKChwcmV2aWV3KSA9PiAhbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MuaW5jbHVkZXMocHJldmlldykpXG4gICAgICAgICAgICAuY29uY2F0KG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzKTtcbiAgICB9XG4gICAgbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MgPSBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cy5tYXAoKHByZXZpZXcpID0+IHByZXZpZXcucmVwbGFjZSgvLXByZXZpZXcvLCBcIlwiKSk7XG4gICAgcmV0dXJuIG1lcmdlZE9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGFkZFF1ZXJ5UGFyYW1ldGVycyh1cmwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzZXBhcmF0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMocGFyYW1ldGVycyk7XG4gICAgaWYgKG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gKHVybCArXG4gICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgIG5hbWVzXG4gICAgICAgICAgICAubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJxXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFwicT1cIiArIHBhcmFtZXRlcnMucS5zcGxpdChcIitcIikubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbihcIitcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlcnNbbmFtZV0pfWA7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIiZcIikpO1xufVxuXG5jb25zdCB1cmxWYXJpYWJsZVJlZ2V4ID0gL1xce1tefV0rXFx9L2c7XG5mdW5jdGlvbiByZW1vdmVOb25DaGFycyh2YXJpYWJsZU5hbWUpIHtcbiAgICByZXR1cm4gdmFyaWFibGVOYW1lLnJlcGxhY2UoL15cXFcrfFxcVyskL2csIFwiXCIpLnNwbGl0KC8sLyk7XG59XG5mdW5jdGlvbiBleHRyYWN0VXJsVmFyaWFibGVOYW1lcyh1cmwpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdXJsLm1hdGNoKHVybFZhcmlhYmxlUmVnZXgpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzLm1hcChyZW1vdmVOb25DaGFycykucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xufVxuXG5mdW5jdGlvbiBvbWl0KG9iamVjdCwga2V5c1RvT21pdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpXG4gICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4gIWtleXNUb09taXQuaW5jbHVkZXMob3B0aW9uKSlcbiAgICAgICAgLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgICAgb2JqW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG59XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vdXJsLXRlbXBsYXRlLCBsaWNlbnNlZCB1bmRlciBCU0Rcbi8vIFRPRE86IGNyZWF0ZSBzZXBhcmF0ZSBwYWNrYWdlLlxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBCcmFtIFN0ZWluXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbi8vIGFyZSBtZXQ6XG4vLyAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4vLyAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICAzLiBUaGUgbmFtZSBvZiB0aGUgYXV0aG9yIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbi8vICAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIEFVVEhPUiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbi8vIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOT1xuLy8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuLy8gSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsXG4vLyBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuLy8gT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbi8vIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbi8vIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAuc3BsaXQoLyglWzAtOUEtRmEtZl17Mn0pL2cpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgaWYgKCEvJVswLTlBLUZhLWZdLy50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICBwYXJ0ID0gZW5jb2RlVVJJKHBhcnQpLnJlcGxhY2UoLyU1Qi9nLCBcIltcIikucmVwbGFjZSgvJTVEL2csIFwiXVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydDtcbiAgICB9KVxuICAgICAgICAuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcbiAgICB2YWx1ZSA9XG4gICAgICAgIG9wZXJhdG9yID09PSBcIitcIiB8fCBvcGVyYXRvciA9PT0gXCIjXCJcbiAgICAgICAgICAgID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpXG4gICAgICAgICAgICA6IGVuY29kZVVucmVzZXJ2ZWQodmFsdWUpO1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiICsgdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIjtcIiB8fCBvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dFtrZXldLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciAmJiBtb2RpZmllciAhPT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwgaXNLZXlPcGVyYXRvcihvcGVyYXRvcikgPyBrZXkgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNLZXlPcGVyYXRvcihvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIgKyB0bXAuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwiXCIgJiYgKG9wZXJhdG9yID09PSBcIiZcIiB8fCBvcGVyYXRvciA9PT0gXCI/XCIpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVVybCh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cGFuZDogZXhwYW5kLmJpbmQobnVsbCwgdGVtcGxhdGUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBleHBhbmQodGVtcGxhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0gW1wiK1wiLCBcIiNcIiwgXCIuXCIsIFwiL1wiLCBcIjtcIiwgXCI/XCIsIFwiJlwiXTtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFx7KFteXFx7XFx9XSspXFx9fChbXlxce1xcfV0rKS9nLCBmdW5jdGlvbiAoXywgZXhwcmVzc2lvbiwgbGl0ZXJhbCkge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgbGV0IG9wZXJhdG9yID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGV4cHJlc3Npb24uY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJlc3Npb24uc3BsaXQoLywvZykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gLyhbXjpcXCpdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvciAmJiBvcGVyYXRvciAhPT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gXCIsXCI7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBcIiZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IgIT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5sZW5ndGggIT09IDAgPyBvcGVyYXRvciA6IFwiXCIpICsgdmFsdWVzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlUmVzZXJ2ZWQobGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2Uob3B0aW9ucykge1xuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNtZXRob2RzXG4gICAgbGV0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gcmVwbGFjZSA6dmFybmFtZSB3aXRoIHt2YXJuYW1lfSB0byBtYWtlIGl0IFJGQyA2NTcwIGNvbXBhdGlibGVcbiAgICBsZXQgdXJsID0gKG9wdGlvbnMudXJsIHx8IFwiL1wiKS5yZXBsYWNlKC86KFthLXpdXFx3KykvZywgXCJ7JDF9XCIpO1xuICAgIGxldCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBsZXQgYm9keTtcbiAgICBsZXQgcGFyYW1ldGVycyA9IG9taXQob3B0aW9ucywgW1xuICAgICAgICBcIm1ldGhvZFwiLFxuICAgICAgICBcImJhc2VVcmxcIixcbiAgICAgICAgXCJ1cmxcIixcbiAgICAgICAgXCJoZWFkZXJzXCIsXG4gICAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgICBcIm1lZGlhVHlwZVwiLFxuICAgIF0pO1xuICAgIC8vIGV4dHJhY3QgdmFyaWFibGUgbmFtZXMgZnJvbSBVUkwgdG8gY2FsY3VsYXRlIHJlbWFpbmluZyB2YXJpYWJsZXMgbGF0ZXJcbiAgICBjb25zdCB1cmxWYXJpYWJsZU5hbWVzID0gZXh0cmFjdFVybFZhcmlhYmxlTmFtZXModXJsKTtcbiAgICB1cmwgPSBwYXJzZVVybCh1cmwpLmV4cGFuZChwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIS9eaHR0cC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IG9wdGlvbnMuYmFzZVVybCArIHVybDtcbiAgICB9XG4gICAgY29uc3Qgb21pdHRlZFBhcmFtZXRlcnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IHVybFZhcmlhYmxlTmFtZXMuaW5jbHVkZXMob3B0aW9uKSlcbiAgICAgICAgLmNvbmNhdChcImJhc2VVcmxcIik7XG4gICAgY29uc3QgcmVtYWluaW5nUGFyYW1ldGVycyA9IG9taXQocGFyYW1ldGVycywgb21pdHRlZFBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGlzQmluYXJ5UmVxdWVzdCA9IC9hcHBsaWNhdGlvblxcL29jdGV0LXN0cmVhbS9pLnRlc3QoaGVhZGVycy5hY2NlcHQpO1xuICAgIGlmICghaXNCaW5hcnlSZXF1ZXN0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXQpIHtcbiAgICAgICAgICAgIC8vIGUuZy4gYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uID0+IGFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMucmF3XG4gICAgICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IGhlYWRlcnMuYWNjZXB0XG4gICAgICAgICAgICAgICAgLnNwbGl0KC8sLylcbiAgICAgICAgICAgICAgICAubWFwKChwcmV2aWV3KSA9PiBwcmV2aWV3LnJlcGxhY2UoL2FwcGxpY2F0aW9uXFwvdm5kKFxcLlxcdyspKFxcLnYzKT8oXFwuXFx3Kyk/KFxcK2pzb24pPyQvLCBgYXBwbGljYXRpb24vdm5kJDEkMi4ke29wdGlvbnMubWVkaWFUeXBlLmZvcm1hdH1gKSlcbiAgICAgICAgICAgICAgICAuam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlld3NGcm9tQWNjZXB0SGVhZGVyID0gaGVhZGVycy5hY2NlcHQubWF0Y2goL1tcXHctXSsoPz0tcHJldmlldykvZykgfHwgW107XG4gICAgICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlclxuICAgICAgICAgICAgICAgIC5jb25jYXQob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpXG4gICAgICAgICAgICAgICAgLm1hcCgocHJldmlldykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdFxuICAgICAgICAgICAgICAgICAgICA/IGAuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YFxuICAgICAgICAgICAgICAgICAgICA6IFwiK2pzb25cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGFwcGxpY2F0aW9uL3ZuZC5naXRodWIuJHtwcmV2aWV3fS1wcmV2aWV3JHtmb3JtYXR9YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBHRVQvSEVBRCByZXF1ZXN0cywgc2V0IFVSTCBxdWVyeSBwYXJhbWV0ZXJzIGZyb20gcmVtYWluaW5nIHBhcmFtZXRlcnNcbiAgICAvLyBmb3IgUEFUQ0gvUE9TVC9QVVQvREVMRVRFIHJlcXVlc3RzLCBzZXQgcmVxdWVzdCBib2R5IGZyb20gcmVtYWluaW5nIHBhcmFtZXRlcnNcbiAgICBpZiAoW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgIHVybCA9IGFkZFF1ZXJ5UGFyYW1ldGVycyh1cmwsIHJlbWFpbmluZ1BhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKFwiZGF0YVwiIGluIHJlbWFpbmluZ1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGJvZHkgPSByZW1haW5pbmdQYXJhbWV0ZXJzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVtYWluaW5nUGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHJlbWFpbmluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZmF1bHQgY29udGVudC10eXBlIGZvciBKU09OIGlmIGJvZHkgaXMgc2V0XG4gICAgaWYgKCFoZWFkZXJzW1wiY29udGVudC10eXBlXCJdICYmIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIjtcbiAgICB9XG4gICAgLy8gR2l0SHViIGV4cGVjdHMgJ2NvbnRlbnQtbGVuZ3RoOiAwJyBoZWFkZXIgZm9yIFBVVC9QQVRDSCByZXF1ZXN0cyB3aXRob3V0IGJvZHkuXG4gICAgLy8gZmV0Y2ggZG9lcyBub3QgYWxsb3cgdG8gc2V0IGBjb250ZW50LWxlbmd0aGAgaGVhZGVyLCBidXQgd2UgY2FuIHNldCBib2R5IHRvIGFuIGVtcHR5IHN0cmluZ1xuICAgIGlmIChbXCJQQVRDSFwiLCBcIlBVVFwiXS5pbmNsdWRlcyhtZXRob2QpICYmIHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGJvZHkgPSBcIlwiO1xuICAgIH1cbiAgICAvLyBPbmx5IHJldHVybiBib2R5L3JlcXVlc3Qga2V5cyBpZiBwcmVzZW50XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBtZXRob2QsIHVybCwgaGVhZGVycyB9LCB0eXBlb2YgYm9keSAhPT0gXCJ1bmRlZmluZWRcIiA/IHsgYm9keSB9IDogbnVsbCwgb3B0aW9ucy5yZXF1ZXN0ID8geyByZXF1ZXN0OiBvcHRpb25zLnJlcXVlc3QgfSA6IG51bGwpO1xufVxuXG5mdW5jdGlvbiBlbmRwb2ludFdpdGhEZWZhdWx0cyhkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGFyc2UobWVyZ2UoZGVmYXVsdHMsIHJvdXRlLCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpIHtcbiAgICBjb25zdCBERUZBVUxUUyA9IG1lcmdlKG9sZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBlbmRwb2ludFdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihlbmRwb2ludCwge1xuICAgICAgICBERUZBVUxUUyxcbiAgICAgICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTKSxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLmJpbmQobnVsbCwgREVGQVVMVFMpLFxuICAgICAgICBwYXJzZSxcbiAgICB9KTtcbn1cblxuY29uc3QgVkVSU0lPTiA9IFwiNi4wLjEyXCI7XG5cbmNvbnN0IHVzZXJBZ2VudCA9IGBvY3Rva2l0LWVuZHBvaW50LmpzLyR7VkVSU0lPTn0gJHtnZXRVc2VyQWdlbnQoKX1gO1xuLy8gREVGQVVMVFMgaGFzIGFsbCBwcm9wZXJ0aWVzIHNldCB0aGF0IEVuZHBvaW50T3B0aW9ucyBoYXMsIGV4Y2VwdCB1cmwuXG4vLyBTbyB3ZSB1c2UgUmVxdWVzdFBhcmFtZXRlcnMgYW5kIGFkZCBtZXRob2QgYXMgYWRkaXRpb25hbCByZXF1aXJlZCBwcm9wZXJ0eS5cbmNvbnN0IERFRkFVTFRTID0ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBiYXNlVXJsOiBcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb21cIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzK2pzb25cIixcbiAgICAgICAgXCJ1c2VyLWFnZW50XCI6IHVzZXJBZ2VudCxcbiAgICB9LFxuICAgIG1lZGlhVHlwZToge1xuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIHByZXZpZXdzOiBbXSxcbiAgICB9LFxufTtcblxuY29uc3QgZW5kcG9pbnQgPSB3aXRoRGVmYXVsdHMobnVsbCwgREVGQVVMVFMpO1xuXG5leHBvcnQgeyBlbmRwb2ludCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnQG9jdG9raXQvcmVxdWVzdCc7XG5pbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tICd1bml2ZXJzYWwtdXNlci1hZ2VudCc7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjQuOC4wXCI7XG5cbmZ1bmN0aW9uIF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhkYXRhKSB7XG4gICAgcmV0dXJuIChgUmVxdWVzdCBmYWlsZWQgZHVlIHRvIGZvbGxvd2luZyByZXNwb25zZSBlcnJvcnM6XFxuYCArXG4gICAgICAgIGRhdGEuZXJyb3JzLm1hcCgoZSkgPT4gYCAtICR7ZS5tZXNzYWdlfWApLmpvaW4oXCJcXG5cIikpO1xufVxuY2xhc3MgR3JhcGhxbFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCwgaGVhZGVycywgcmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIoX2J1aWxkTWVzc2FnZUZvclJlc3BvbnNlRXJyb3JzKHJlc3BvbnNlKSk7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJHcmFwaHFsUmVzcG9uc2VFcnJvclwiO1xuICAgICAgICAvLyBFeHBvc2UgdGhlIGVycm9ycyBhbmQgcmVzcG9uc2UgZGF0YSBpbiB0aGVpciBzaG9ydGhhbmQgcHJvcGVydGllcy5cbiAgICAgICAgdGhpcy5lcnJvcnMgPSByZXNwb25zZS5lcnJvcnM7XG4gICAgICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBOT05fVkFSSUFCTEVfT1BUSU9OUyA9IFtcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwiYmFzZVVybFwiLFxuICAgIFwidXJsXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJyZXF1ZXN0XCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwibWVkaWFUeXBlXCIsXG5dO1xuY29uc3QgRk9SQklEREVOX1ZBUklBQkxFX09QVElPTlMgPSBbXCJxdWVyeVwiLCBcIm1ldGhvZFwiLCBcInVybFwiXTtcbmNvbnN0IEdIRVNfVjNfU1VGRklYX1JFR0VYID0gL1xcL2FwaVxcL3YzXFwvPyQvO1xuZnVuY3Rpb24gZ3JhcGhxbChyZXF1ZXN0LCBxdWVyeSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgJiYgXCJxdWVyeVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFtAb2N0b2tpdC9ncmFwaHFsXSBcInF1ZXJ5XCIgY2Fubm90IGJlIHVzZWQgYXMgdmFyaWFibGUgbmFtZWApKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIUZPUkJJRERFTl9WQVJJQUJMRV9PUFRJT05TLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBbQG9jdG9raXQvZ3JhcGhxbF0gXCIke2tleX1cIiBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lYCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnMgPSB0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgPyBPYmplY3QuYXNzaWduKHsgcXVlcnkgfSwgb3B0aW9ucykgOiBxdWVyeTtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5rZXlzKHBhcnNlZE9wdGlvbnMpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgaWYgKE5PTl9WQVJJQUJMRV9PUFRJT05TLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudmFyaWFibGVzW2tleV0gPSBwYXJzZWRPcHRpb25zW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICAgIC8vIHdvcmthcm91bmQgZm9yIEdpdEh1YiBFbnRlcnByaXNlIGJhc2VVcmwgc2V0IHdpdGggL2FwaS92MyBzdWZmaXhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC9hdXRoLWFwcC5qcy9pc3N1ZXMvMTExI2lzc3VlY29tbWVudC02NTc2MTA0NTFcbiAgICBjb25zdCBiYXNlVXJsID0gcGFyc2VkT3B0aW9ucy5iYXNlVXJsIHx8IHJlcXVlc3QuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybDtcbiAgICBpZiAoR0hFU19WM19TVUZGSVhfUkVHRVgudGVzdChiYXNlVXJsKSkge1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy51cmwgPSBiYXNlVXJsLnJlcGxhY2UoR0hFU19WM19TVUZGSVhfUkVHRVgsIFwiL2FwaS9ncmFwaHFsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdChyZXF1ZXN0T3B0aW9ucykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXNwb25zZS5oZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHJlc3BvbnNlLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaHFsUmVzcG9uc2VFcnJvcihyZXF1ZXN0T3B0aW9ucywgaGVhZGVycywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHJlcXVlc3QkMSwgbmV3RGVmYXVsdHMpIHtcbiAgICBjb25zdCBuZXdSZXF1ZXN0ID0gcmVxdWVzdCQxLmRlZmF1bHRzKG5ld0RlZmF1bHRzKTtcbiAgICBjb25zdCBuZXdBcGkgPSAocXVlcnksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIGdyYXBocWwobmV3UmVxdWVzdCwgcXVlcnksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBuZXdSZXF1ZXN0KSxcbiAgICAgICAgZW5kcG9pbnQ6IHJlcXVlc3QuZW5kcG9pbnQsXG4gICAgfSk7XG59XG5cbmNvbnN0IGdyYXBocWwkMSA9IHdpdGhEZWZhdWx0cyhyZXF1ZXN0LCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtZ3JhcGhxbC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YCxcbiAgICB9LFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ncmFwaHFsXCIsXG59KTtcbmZ1bmN0aW9uIHdpdGhDdXN0b21SZXF1ZXN0KGN1c3RvbVJlcXVlc3QpIHtcbiAgICByZXR1cm4gd2l0aERlZmF1bHRzKGN1c3RvbVJlcXVlc3QsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgdXJsOiBcIi9ncmFwaHFsXCIsXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IEdyYXBocWxSZXNwb25zZUVycm9yLCBncmFwaHFsJDEgYXMgZ3JhcGhxbCwgd2l0aEN1c3RvbVJlcXVlc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiY29uc3QgVkVSU0lPTiA9IFwiMi4yMS4zXCI7XG5cbi8qKlxuICogU29tZSDigJxsaXN04oCdIHJlc3BvbnNlIHRoYXQgY2FuIGJlIHBhZ2luYXRlZCBoYXZlIGEgZGlmZmVyZW50IHJlc3BvbnNlIHN0cnVjdHVyZVxuICpcbiAqIFRoZXkgaGF2ZSBhIGB0b3RhbF9jb3VudGAga2V5IGluIHRoZSByZXNwb25zZSAoc2VhcmNoIGFsc28gaGFzIGBpbmNvbXBsZXRlX3Jlc3VsdHNgLFxuICogL2luc3RhbGxhdGlvbi9yZXBvc2l0b3JpZXMgYWxzbyBoYXMgYHJlcG9zaXRvcnlfc2VsZWN0aW9uYCksIGFzIHdlbGwgYXMgYSBrZXkgd2l0aFxuICogdGhlIGxpc3Qgb2YgdGhlIGl0ZW1zIHdoaWNoIG5hbWUgdmFyaWVzIGZyb20gZW5kcG9pbnQgdG8gZW5kcG9pbnQuXG4gKlxuICogT2N0b2tpdCBub3JtYWxpemVzIHRoZXNlIHJlc3BvbnNlcyBzbyB0aGF0IHBhZ2luYXRlZCByZXN1bHRzIGFyZSBhbHdheXMgcmV0dXJuZWQgZm9sbG93aW5nXG4gKiB0aGUgc2FtZSBzdHJ1Y3R1cmUuIE9uZSBjaGFsbGVuZ2UgaXMgdGhhdCBpZiB0aGUgbGlzdCByZXNwb25zZSBoYXMgb25seSBvbmUgcGFnZSwgbm8gTGlua1xuICogaGVhZGVyIGlzIHByb3ZpZGVkLCBzbyB0aGlzIGhlYWRlciBhbG9uZSBpcyBub3Qgc3VmZmljaWVudCB0byBjaGVjayB3ZXRoZXIgYSByZXNwb25zZSBpc1xuICogcGFnaW5hdGVkIG9yIG5vdC5cbiAqXG4gKiBXZSBjaGVjayBpZiBhIFwidG90YWxfY291bnRcIiBrZXkgaXMgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2UgZGF0YSwgYnV0IGFsc28gbWFrZSBzdXJlIHRoYXRcbiAqIGEgXCJ1cmxcIiBwcm9wZXJ0eSBpcyBub3QsIGFzIHRoZSBcIkdldCB0aGUgY29tYmluZWQgc3RhdHVzIGZvciBhIHNwZWNpZmljIHJlZlwiIGVuZHBvaW50IHdvdWxkXG4gKiBvdGhlcndpc2UgbWF0Y2g6IGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvcmVwb3Mvc3RhdHVzZXMvI2dldC10aGUtY29tYmluZWQtc3RhdHVzLWZvci1hLXNwZWNpZmljLXJlZlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQYWdpbmF0ZWRMaXN0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAvLyBlbmRwb2ludHMgY2FuIHJlc3BvbmQgd2l0aCAyMDQgaWYgcmVwb3NpdG9yeSBpcyBlbXB0eVxuICAgIGlmICghcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VOZWVkc05vcm1hbGl6YXRpb24gPSBcInRvdGFsX2NvdW50XCIgaW4gcmVzcG9uc2UuZGF0YSAmJiAhKFwidXJsXCIgaW4gcmVzcG9uc2UuZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZU5lZWRzTm9ybWFsaXphdGlvbilcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIC8vIGtlZXAgdGhlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbnRhY3QgYXMgdGhlcmUgaXMgY3VycmVudGx5IG5vIG90aGVyIHdheVxuICAgIC8vIHRvIHJldHJpZXZlIHRoZSBzYW1lIGluZm9ybWF0aW9uLlxuICAgIGNvbnN0IGluY29tcGxldGVSZXN1bHRzID0gcmVzcG9uc2UuZGF0YS5pbmNvbXBsZXRlX3Jlc3VsdHM7XG4gICAgY29uc3QgcmVwb3NpdG9yeVNlbGVjdGlvbiA9IHJlc3BvbnNlLmRhdGEucmVwb3NpdG9yeV9zZWxlY3Rpb247XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHJlc3BvbnNlLmRhdGEudG90YWxfY291bnQ7XG4gICAgZGVsZXRlIHJlc3BvbnNlLmRhdGEuaW5jb21wbGV0ZV9yZXN1bHRzO1xuICAgIGRlbGV0ZSByZXNwb25zZS5kYXRhLnJlcG9zaXRvcnlfc2VsZWN0aW9uO1xuICAgIGRlbGV0ZSByZXNwb25zZS5kYXRhLnRvdGFsX2NvdW50O1xuICAgIGNvbnN0IG5hbWVzcGFjZUtleSA9IE9iamVjdC5rZXlzKHJlc3BvbnNlLmRhdGEpWzBdO1xuICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhW25hbWVzcGFjZUtleV07XG4gICAgcmVzcG9uc2UuZGF0YSA9IGRhdGE7XG4gICAgaWYgKHR5cGVvZiBpbmNvbXBsZXRlUmVzdWx0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXNwb25zZS5kYXRhLmluY29tcGxldGVfcmVzdWx0cyA9IGluY29tcGxldGVSZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcG9zaXRvcnlTZWxlY3Rpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5X3NlbGVjdGlvbiA9IHJlcG9zaXRvcnlTZWxlY3Rpb247XG4gICAgfVxuICAgIHJlc3BvbnNlLmRhdGEudG90YWxfY291bnQgPSB0b3RhbENvdW50O1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cblxuZnVuY3Rpb24gaXRlcmF0b3Iob2N0b2tpdCwgcm91dGUsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHJvdXRlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyByb3V0ZS5lbmRwb2ludChwYXJhbWV0ZXJzKVxuICAgICAgICA6IG9jdG9raXQucmVxdWVzdC5lbmRwb2ludChyb3V0ZSwgcGFyYW1ldGVycyk7XG4gICAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IHR5cGVvZiByb3V0ZSA9PT0gXCJmdW5jdGlvblwiID8gcm91dGUgOiBvY3Rva2l0LnJlcXVlc3Q7XG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9ucy5tZXRob2Q7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICBsZXQgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gKHtcbiAgICAgICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cmwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RNZXRob2QoeyBtZXRob2QsIHVybCwgaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlc3BvbnNlID0gbm9ybWFsaXplUGFnaW5hdGVkTGlzdFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHJlc3BvbnNlLmhlYWRlcnMubGlua2AgZm9ybWF0OlxuICAgICAgICAgICAgICAgICAgICAvLyAnPGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnMvYXNlZW1rL2ZvbGxvd2Vycz9wYWdlPTI+OyByZWw9XCJuZXh0XCIsIDxodHRwczovL2FwaS5naXRodWIuY29tL3VzZXJzL2FzZWVtay9mb2xsb3dlcnM/cGFnZT0yPjsgcmVsPVwibGFzdFwiJ1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIGB1cmxgIHRvIHVuZGVmaW5lZCBpZiBcIm5leHRcIiBVUkwgaXMgbm90IHByZXNlbnQgb3IgYGxpbmtgIGhlYWRlciBpcyBub3Qgc2V0XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgobm9ybWFsaXplZFJlc3BvbnNlLmhlYWRlcnMubGluayB8fCBcIlwiKS5tYXRjaCgvPChbXj5dKyk+O1xccypyZWw9XCJuZXh0XCIvKSB8fCBbXSlbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBub3JtYWxpemVkUmVzcG9uc2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgIT09IDQwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFnaW5hdGUob2N0b2tpdCwgcm91dGUsIHBhcmFtZXRlcnMsIG1hcEZuKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWFwRm4gPSBwYXJhbWV0ZXJzO1xuICAgICAgICBwYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZ2F0aGVyKG9jdG9raXQsIFtdLCBpdGVyYXRvcihvY3Rva2l0LCByb3V0ZSwgcGFyYW1ldGVycylbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIG1hcEZuKTtcbn1cbmZ1bmN0aW9uIGdhdGhlcihvY3Rva2l0LCByZXN1bHRzLCBpdGVyYXRvciwgbWFwRm4pIHtcbiAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlYXJseUV4aXQgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgIGVhcmx5RXhpdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KG1hcEZuID8gbWFwRm4ocmVzdWx0LnZhbHVlLCBkb25lKSA6IHJlc3VsdC52YWx1ZS5kYXRhKTtcbiAgICAgICAgaWYgKGVhcmx5RXhpdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhdGhlcihvY3Rva2l0LCByZXN1bHRzLCBpdGVyYXRvciwgbWFwRm4pO1xuICAgIH0pO1xufVxuXG5jb25zdCBjb21wb3NlUGFnaW5hdGVSZXN0ID0gT2JqZWN0LmFzc2lnbihwYWdpbmF0ZSwge1xuICAgIGl0ZXJhdG9yLFxufSk7XG5cbmNvbnN0IHBhZ2luYXRpbmdFbmRwb2ludHMgPSBbXG4gICAgXCJHRVQgL2FwcC9ob29rL2RlbGl2ZXJpZXNcIixcbiAgICBcIkdFVCAvYXBwL2luc3RhbGxhdGlvbnNcIixcbiAgICBcIkdFVCAvYXBwbGljYXRpb25zL2dyYW50c1wiLFxuICAgIFwiR0VUIC9hdXRob3JpemF0aW9uc1wiLFxuICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9wZXJtaXNzaW9ucy9vcmdhbml6YXRpb25zXCIsXG4gICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3J1bm5lci1ncm91cHNcIixcbiAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcnVubmVyLWdyb3Vwcy97cnVubmVyX2dyb3VwX2lkfS9vcmdhbml6YXRpb25zXCIsXG4gICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3J1bm5lci1ncm91cHMve3J1bm5lcl9ncm91cF9pZH0vcnVubmVyc1wiLFxuICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9ydW5uZXJzXCIsXG4gICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hdWRpdC1sb2dcIixcbiAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIixcbiAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L3NldHRpbmdzL2JpbGxpbmcvYWR2YW5jZWQtc2VjdXJpdHlcIixcbiAgICBcIkdFVCAvZXZlbnRzXCIsXG4gICAgXCJHRVQgL2dpc3RzXCIsXG4gICAgXCJHRVQgL2dpc3RzL3B1YmxpY1wiLFxuICAgIFwiR0VUIC9naXN0cy9zdGFycmVkXCIsXG4gICAgXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9jb21tZW50c1wiLFxuICAgIFwiR0VUIC9naXN0cy97Z2lzdF9pZH0vY29tbWl0c1wiLFxuICAgIFwiR0VUIC9naXN0cy97Z2lzdF9pZH0vZm9ya3NcIixcbiAgICBcIkdFVCAvaW5zdGFsbGF0aW9uL3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC9pc3N1ZXNcIixcbiAgICBcIkdFVCAvbGljZW5zZXNcIixcbiAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9wbGFuc1wiLFxuICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3BsYW5zL3twbGFuX2lkfS9hY2NvdW50c1wiLFxuICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3N0dWJiZWQvcGxhbnNcIixcbiAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9zdHViYmVkL3BsYW5zL3twbGFuX2lkfS9hY2NvdW50c1wiLFxuICAgIFwiR0VUIC9uZXR3b3Jrcy97b3duZXJ9L3tyZXBvfS9ldmVudHNcIixcbiAgICBcIkdFVCAvbm90aWZpY2F0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdhbml6YXRpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9jYWNoZS91c2FnZS1ieS1yZXBvc2l0b3J5XCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy9yZXBvc2l0b3JpZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lci1ncm91cHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lci1ncm91cHMve3J1bm5lcl9ncm91cF9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L3J1bm5lcnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9hdWRpdC1sb2dcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9ibG9ja3NcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9jb2RlLXNjYW5uaW5nL2FsZXJ0c1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2NvZGVzcGFjZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9jcmVkZW50aWFsLWF1dGhvcml6YXRpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vZXZlbnRzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vZXh0ZXJuYWwtZ3JvdXBzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vZmFpbGVkX2ludml0YXRpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vaG9va3NcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2luc3RhbGxhdGlvbnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9pbnZpdGF0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfS90ZWFtc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L2lzc3Vlc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L21lbWJlcnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9taWdyYXRpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9vdXRzaWRlX2NvbGxhYm9yYXRvcnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vcHJvamVjdHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS9wdWJsaWNfbWVtYmVyc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3JlcG9zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0c1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3NldHRpbmdzL2JpbGxpbmcvYWR2YW5jZWQtc2VjdXJpdHlcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtLXN5bmMvZ3JvdXBzXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzL3tjb21tZW50X251bWJlcn0vcmVhY3Rpb25zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9pbnZpdGF0aW9uc1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L21lbWJlcnNcIixcbiAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9wcm9qZWN0c1wiLFxuICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3JlcG9zXCIsXG4gICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vdGVhbXNcIixcbiAgICBcIkdFVCAvcHJvamVjdHMvY29sdW1ucy97Y29sdW1uX2lkfS9jYXJkc1wiLFxuICAgIFwiR0VUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sbGFib3JhdG9yc1wiLFxuICAgIFwiR0VUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sdW1uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2FydGlmYWN0c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hcnRpZmFjdHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2F0dGVtcHRzL3thdHRlbXB0X251bWJlcn0vam9ic1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vam9ic1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3NlY3JldHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3NcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9ydW5zXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Fzc2lnbmVlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1ydW5zL3tjaGVja19ydW5faWR9L2Fubm90YXRpb25zXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlcy97Y2hlY2tfc3VpdGVfaWR9L2NoZWNrLXJ1bnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHMve2FsZXJ0X251bWJlcn0vaW5zdGFuY2VzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYW5hbHlzZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL2RldmNvbnRhaW5lcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbGxhYm9yYXRvcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve2NvbW1pdF9zaGF9L2NvbW1lbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve2NvbW1pdF9zaGF9L3B1bGxzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vY2hlY2stcnVuc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L2NoZWNrLXN1aXRlc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L3N0YXR1c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L3N0YXR1c2VzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbnRyaWJ1dG9yc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9L3N0YXR1c2VzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ldmVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZm9ya3NcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L21hdGNoaW5nLXJlZnMve3JlZn1cIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3NcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW52aXRhdGlvbnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvZXZlbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9jb21tZW50c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vZXZlbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sYWJlbHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vdGltZWxpbmVcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30va2V5c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzL3ttaWxlc3RvbmVfbnVtYmVyfS9sYWJlbHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbm90aWZpY2F0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9idWlsZHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHJvamVjdHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWl0c1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2ZpbGVzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmVxdWVzdGVkX3Jldmlld2Vyc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3NcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9L2NvbW1lbnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9hc3NldHNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3JldC1zY2FubmluZy9hbGVydHMve2FsZXJ0X251bWJlcn0vbG9jYXRpb25zXCIsXG4gICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXJnYXplcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3Vic2NyaWJlcnNcIixcbiAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdGFnc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90ZWFtc1wiLFxuICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90b3BpY3NcIixcbiAgICBcIkdFVCAvcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH0vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzXCIsXG4gICAgXCJHRVQgL3NlYXJjaC9jb2RlXCIsXG4gICAgXCJHRVQgL3NlYXJjaC9jb21taXRzXCIsXG4gICAgXCJHRVQgL3NlYXJjaC9pc3N1ZXNcIixcbiAgICBcIkdFVCAvc2VhcmNoL2xhYmVsc1wiLFxuICAgIFwiR0VUIC9zZWFyY2gvcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL3NlYXJjaC90b3BpY3NcIixcbiAgICBcIkdFVCAvc2VhcmNoL3VzZXJzXCIsXG4gICAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9kaXNjdXNzaW9uc1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50c1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L2ludml0YXRpb25zXCIsXG4gICAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9tZW1iZXJzXCIsXG4gICAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9wcm9qZWN0c1wiLFxuICAgIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vcmVwb3NcIixcbiAgICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L3RlYW1zXCIsXG4gICAgXCJHRVQgL3VzZXIvYmxvY2tzXCIsXG4gICAgXCJHRVQgL3VzZXIvY29kZXNwYWNlc1wiLFxuICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0c1wiLFxuICAgIFwiR0VUIC91c2VyL2VtYWlsc1wiLFxuICAgIFwiR0VUIC91c2VyL2ZvbGxvd2Vyc1wiLFxuICAgIFwiR0VUIC91c2VyL2ZvbGxvd2luZ1wiLFxuICAgIFwiR0VUIC91c2VyL2dwZ19rZXlzXCIsXG4gICAgXCJHRVQgL3VzZXIvaW5zdGFsbGF0aW9uc1wiLFxuICAgIFwiR0VUIC91c2VyL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gICAgXCJHRVQgL3VzZXIvaXNzdWVzXCIsXG4gICAgXCJHRVQgL3VzZXIva2V5c1wiLFxuICAgIFwiR0VUIC91c2VyL21hcmtldHBsYWNlX3B1cmNoYXNlc1wiLFxuICAgIFwiR0VUIC91c2VyL21hcmtldHBsYWNlX3B1cmNoYXNlcy9zdHViYmVkXCIsXG4gICAgXCJHRVQgL3VzZXIvbWVtYmVyc2hpcHMvb3Jnc1wiLFxuICAgIFwiR0VUIC91c2VyL21pZ3JhdGlvbnNcIixcbiAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICAgIFwiR0VUIC91c2VyL29yZ3NcIixcbiAgICBcIkdFVCAvdXNlci9wYWNrYWdlc1wiLFxuICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCIsXG4gICAgXCJHRVQgL3VzZXIvcHVibGljX2VtYWlsc1wiLFxuICAgIFwiR0VUIC91c2VyL3JlcG9zXCIsXG4gICAgXCJHRVQgL3VzZXIvcmVwb3NpdG9yeV9pbnZpdGF0aW9uc1wiLFxuICAgIFwiR0VUIC91c2VyL3N0YXJyZWRcIixcbiAgICBcIkdFVCAvdXNlci9zdWJzY3JpcHRpb25zXCIsXG4gICAgXCJHRVQgL3VzZXIvdGVhbXNcIixcbiAgICBcIkdFVCAvdXNlcnNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHMvb3Jncy97b3JnfVwiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2V2ZW50cy9wdWJsaWNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9mb2xsb3dlcnNcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9mb2xsb3dpbmdcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9naXN0c1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2dwZ19rZXlzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0va2V5c1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L29yZ3NcIixcbiAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlc1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3Byb2plY3RzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcmVjZWl2ZWRfZXZlbnRzXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcmVjZWl2ZWRfZXZlbnRzL3B1YmxpY1wiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3JlcG9zXCIsXG4gICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc3RhcnJlZFwiLFxuICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3N1YnNjcmlwdGlvbnNcIixcbl07XG5cbmZ1bmN0aW9uIGlzUGFnaW5hdGluZ0VuZHBvaW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYWdpbmF0aW5nRW5kcG9pbnRzLmluY2x1ZGVzKGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBvY3Rva2l0IE9jdG9raXQgaW5zdGFuY2VcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgcGFzc2VkIHRvIE9jdG9raXQgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcGFnaW5hdGVSZXN0KG9jdG9raXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYWdpbmF0ZTogT2JqZWN0LmFzc2lnbihwYWdpbmF0ZS5iaW5kKG51bGwsIG9jdG9raXQpLCB7XG4gICAgICAgICAgICBpdGVyYXRvcjogaXRlcmF0b3IuYmluZChudWxsLCBvY3Rva2l0KSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbnBhZ2luYXRlUmVzdC5WRVJTSU9OID0gVkVSU0lPTjtcblxuZXhwb3J0IHsgY29tcG9zZVBhZ2luYXRlUmVzdCwgaXNQYWdpbmF0aW5nRW5kcG9pbnQsIHBhZ2luYXRlUmVzdCwgcGFnaW5hdGluZ0VuZHBvaW50cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJjb25zdCBFbmRwb2ludHMgPSB7XG4gICAgYWN0aW9uczoge1xuICAgICAgICBhZGRDdXN0b21MYWJlbHNUb1NlbGZIb3N0ZWRSdW5uZXJGb3JPcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGFkZEN1c3RvbUxhYmVsc1RvU2VsZkhvc3RlZFJ1bm5lckZvclJlcG86IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBhZGRTZWxlY3RlZFJlcG9Ub09yZ1NlY3JldDogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBhcHByb3ZlV29ya2Zsb3dSdW46IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2FwcHJvdmVcIixcbiAgICAgICAgXSxcbiAgICAgICAgY2FuY2VsV29ya2Zsb3dSdW46IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2NhbmNlbFwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZUVudmlyb25tZW50U2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZU9yZ1NlY3JldDogW1wiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVSZWdpc3RyYXRpb25Ub2tlbkZvck9yZzogW1xuICAgICAgICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy9yZWdpc3RyYXRpb24tdG9rZW5cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlUmVnaXN0cmF0aW9uVG9rZW5Gb3JSZXBvOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy9yZWdpc3RyYXRpb24tdG9rZW5cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlUmVtb3ZlVG9rZW5Gb3JPcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3JlbW92ZS10b2tlblwiXSxcbiAgICAgICAgY3JlYXRlUmVtb3ZlVG9rZW5Gb3JSZXBvOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy9yZW1vdmUtdG9rZW5cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlV29ya2Zsb3dEaXNwYXRjaDogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9L2Rpc3BhdGNoZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQWN0aW9uc0NhY2hlQnlJZDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvY2FjaGVzL3tjYWNoZV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQWN0aW9uc0NhY2hlQnlLZXk6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlc3s/a2V5LHJlZn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQXJ0aWZhY3Q6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2FydGlmYWN0cy97YXJ0aWZhY3RfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUVudmlyb25tZW50U2VjcmV0OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVPcmdTZWNyZXQ6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICAgICAgZGVsZXRlUmVwb1NlY3JldDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVNlbGZIb3N0ZWRSdW5uZXJGcm9tT3JnOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlU2VsZkhvc3RlZFJ1bm5lckZyb21SZXBvOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVdvcmtmbG93UnVuOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfVwiXSxcbiAgICAgICAgZGVsZXRlV29ya2Zsb3dSdW5Mb2dzOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2xvZ3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGlzYWJsZVNlbGVjdGVkUmVwb3NpdG9yeUdpdGh1YkFjdGlvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkaXNhYmxlV29ya2Zsb3c6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9L2Rpc2FibGVcIixcbiAgICAgICAgXSxcbiAgICAgICAgZG93bmxvYWRBcnRpZmFjdDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvYXJ0aWZhY3RzL3thcnRpZmFjdF9pZH0ve2FyY2hpdmVfZm9ybWF0fVwiLFxuICAgICAgICBdLFxuICAgICAgICBkb3dubG9hZEpvYkxvZ3NGb3JXb3JrZmxvd1J1bjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvam9icy97am9iX2lkfS9sb2dzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRvd25sb2FkV29ya2Zsb3dSdW5BdHRlbXB0TG9nczogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hdHRlbXB0cy97YXR0ZW1wdF9udW1iZXJ9L2xvZ3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgZG93bmxvYWRXb3JrZmxvd1J1bkxvZ3M6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vbG9nc1wiLFxuICAgICAgICBdLFxuICAgICAgICBlbmFibGVTZWxlY3RlZFJlcG9zaXRvcnlHaXRodWJBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZW5hYmxlV29ya2Zsb3c6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9L2VuYWJsZVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBY3Rpb25zQ2FjaGVMaXN0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvY2FjaGVzXCJdLFxuICAgICAgICBnZXRBY3Rpb25zQ2FjaGVVc2FnZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlL3VzYWdlXCJdLFxuICAgICAgICBnZXRBY3Rpb25zQ2FjaGVVc2FnZUJ5UmVwb0Zvck9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9jYWNoZS91c2FnZS1ieS1yZXBvc2l0b3J5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFjdGlvbnNDYWNoZVVzYWdlRm9yRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL2NhY2hlL3VzYWdlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFjdGlvbnNDYWNoZVVzYWdlRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9jYWNoZS91c2FnZVwiXSxcbiAgICAgICAgZ2V0QWxsb3dlZEFjdGlvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvc2VsZWN0ZWQtYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGxvd2VkQWN0aW9uc1JlcG9zaXRvcnk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zL3NlbGVjdGVkLWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QXJ0aWZhY3Q6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9hcnRpZmFjdHMve2FydGlmYWN0X2lkfVwiXSxcbiAgICAgICAgZ2V0RW52aXJvbm1lbnRQdWJsaWNLZXk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vc2VjcmV0cy9wdWJsaWMta2V5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEVudmlyb25tZW50U2VjcmV0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBY3Rpb25zRGVmYXVsdFdvcmtmbG93UGVybWlzc2lvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnMvd29ya2Zsb3dcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0R2l0aHViQWN0aW9uc0RlZmF1bHRXb3JrZmxvd1Blcm1pc3Npb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3dvcmtmbG93XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEdpdGh1YkFjdGlvbnNEZWZhdWx0V29ya2Zsb3dQZXJtaXNzaW9uc1JlcG9zaXRvcnk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zL3dvcmtmbG93XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEdpdGh1YkFjdGlvbnNQZXJtaXNzaW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNSZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRKb2JGb3JXb3JrZmxvd1J1bjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2pvYnMve2pvYl9pZH1cIl0sXG4gICAgICAgIGdldE9yZ1B1YmxpY0tleTogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvc2VjcmV0cy9wdWJsaWMta2V5XCJdLFxuICAgICAgICBnZXRPcmdTZWNyZXQ6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICAgICAgZ2V0UGVuZGluZ0RlcGxveW1lbnRzRm9yUnVuOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L3BlbmRpbmdfZGVwbG95bWVudHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UmVwb1Blcm1pc3Npb25zOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9uc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcImFjdGlvbnNcIiwgXCJnZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNSZXBvc2l0b3J5XCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGdldFJlcG9QdWJsaWNLZXk6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9zZWNyZXRzL3B1YmxpYy1rZXlcIl0sXG4gICAgICAgIGdldFJlcG9TZWNyZXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgICAgIGdldFJldmlld3NGb3JSdW46IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXBwcm92YWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFNlbGZIb3N0ZWRSdW5uZXJGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH1cIl0sXG4gICAgICAgIGdldFNlbGZIb3N0ZWRSdW5uZXJGb3JSZXBvOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFdvcmtmbG93OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzL3t3b3JrZmxvd19pZH1cIl0sXG4gICAgICAgIGdldFdvcmtmbG93QWNjZXNzVG9SZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy9hY2Nlc3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0V29ya2Zsb3dSdW46IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9XCJdLFxuICAgICAgICBnZXRXb3JrZmxvd1J1bkF0dGVtcHQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXR0ZW1wdHMve2F0dGVtcHRfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRXb3JrZmxvd1J1blVzYWdlOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L3RpbWluZ1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRXb3JrZmxvd1VzYWdlOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS90aW1pbmdcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEFydGlmYWN0c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9hcnRpZmFjdHNcIl0sXG4gICAgICAgIGxpc3RFbnZpcm9ubWVudFNlY3JldHM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vc2VjcmV0c1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Sm9ic0ZvcldvcmtmbG93UnVuOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2pvYnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEpvYnNGb3JXb3JrZmxvd1J1bkF0dGVtcHQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXR0ZW1wdHMve2F0dGVtcHRfbnVtYmVyfS9qb2JzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RMYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RMYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdE9yZ1NlY3JldHM6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHNcIl0sXG4gICAgICAgIGxpc3RSZXBvU2VjcmV0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3NlY3JldHNcIl0sXG4gICAgICAgIGxpc3RSZXBvV29ya2Zsb3dzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzXCJdLFxuICAgICAgICBsaXN0UnVubmVyQXBwbGljYXRpb25zRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL2Rvd25sb2Fkc1wiXSxcbiAgICAgICAgbGlzdFJ1bm5lckFwcGxpY2F0aW9uc0ZvclJlcG86IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMvZG93bmxvYWRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFNlbGVjdGVkUmVwb3NpdG9yaWVzRW5hYmxlZEdpdGh1YkFjdGlvbnNPcmdhbml6YXRpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RTZWxmSG9zdGVkUnVubmVyc0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVyc1wiXSxcbiAgICAgICAgbGlzdFNlbGZIb3N0ZWRSdW5uZXJzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnNcIl0sXG4gICAgICAgIGxpc3RXb3JrZmxvd1J1bkFydGlmYWN0czogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hcnRpZmFjdHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFdvcmtmbG93UnVuczogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzL3t3b3JrZmxvd19pZH0vcnVuc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0V29ya2Zsb3dSdW5zRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnNcIl0sXG4gICAgICAgIHJlUnVuSm9iRm9yV29ya2Zsb3dSdW46IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9qb2JzL3tqb2JfaWR9L3JlcnVuXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlUnVuV29ya2Zsb3c6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9yZXJ1blwiXSxcbiAgICAgICAgcmVSdW5Xb3JrZmxvd0ZhaWxlZEpvYnM6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L3JlcnVuLWZhaWxlZC1qb2JzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUFsbEN1c3RvbUxhYmVsc0Zyb21TZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUFsbEN1c3RvbUxhYmVsc0Zyb21TZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlQ3VzdG9tTGFiZWxGcm9tU2VsZkhvc3RlZFJ1bm5lckZvck9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVscy97bmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlQ3VzdG9tTGFiZWxGcm9tU2VsZkhvc3RlZFJ1bm5lckZvclJlcG86IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzL3tuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVTZWxlY3RlZFJlcG9Gcm9tT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJldmlld1BlbmRpbmdEZXBsb3ltZW50c0ZvclJ1bjogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vcGVuZGluZ19kZXBsb3ltZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRBbGxvd2VkQWN0aW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy9zZWxlY3RlZC1hY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEFsbG93ZWRBY3Rpb25zUmVwb3NpdG9yeTogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnMvc2VsZWN0ZWQtYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRDdXN0b21MYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEN1c3RvbUxhYmVsc0ZvclNlbGZIb3N0ZWRSdW5uZXJGb3JSZXBvOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRHaXRodWJBY3Rpb25zRGVmYXVsdFdvcmtmbG93UGVybWlzc2lvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIlBVVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnMvd29ya2Zsb3dcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0R2l0aHViQWN0aW9uc0RlZmF1bHRXb3JrZmxvd1Blcm1pc3Npb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3dvcmtmbG93XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEdpdGh1YkFjdGlvbnNEZWZhdWx0V29ya2Zsb3dQZXJtaXNzaW9uc1JlcG9zaXRvcnk6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zL3dvcmtmbG93XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEdpdGh1YkFjdGlvbnNQZXJtaXNzaW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNSZXBvc2l0b3J5OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0U2VsZWN0ZWRSZXBvc2l0b3JpZXNFbmFibGVkR2l0aHViQWN0aW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0V29ya2Zsb3dBY2Nlc3NUb1JlcG9zaXRvcnk6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zL2FjY2Vzc1wiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgYWN0aXZpdHk6IHtcbiAgICAgICAgY2hlY2tSZXBvSXNTdGFycmVkQnlBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3N0YXJyZWQve293bmVyfS97cmVwb31cIl0sXG4gICAgICAgIGRlbGV0ZVJlcG9TdWJzY3JpcHRpb246IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vc3Vic2NyaXB0aW9uXCJdLFxuICAgICAgICBkZWxldGVUaHJlYWRTdWJzY3JpcHRpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9ub3RpZmljYXRpb25zL3RocmVhZHMve3RocmVhZF9pZH0vc3Vic2NyaXB0aW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEZlZWRzOiBbXCJHRVQgL2ZlZWRzXCJdLFxuICAgICAgICBnZXRSZXBvU3Vic2NyaXB0aW9uOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N1YnNjcmlwdGlvblwiXSxcbiAgICAgICAgZ2V0VGhyZWFkOiBbXCJHRVQgL25vdGlmaWNhdGlvbnMvdGhyZWFkcy97dGhyZWFkX2lkfVwiXSxcbiAgICAgICAgZ2V0VGhyZWFkU3Vic2NyaXB0aW9uRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC9ub3RpZmljYXRpb25zL3RocmVhZHMve3RocmVhZF9pZH0vc3Vic2NyaXB0aW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RFdmVudHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2V2ZW50c1wiXSxcbiAgICAgICAgbGlzdE5vdGlmaWNhdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC9ub3RpZmljYXRpb25zXCJdLFxuICAgICAgICBsaXN0T3JnRXZlbnRzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2V2ZW50cy9vcmdzL3tvcmd9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RQdWJsaWNFdmVudHM6IFtcIkdFVCAvZXZlbnRzXCJdLFxuICAgICAgICBsaXN0UHVibGljRXZlbnRzRm9yUmVwb05ldHdvcms6IFtcIkdFVCAvbmV0d29ya3Mve293bmVyfS97cmVwb30vZXZlbnRzXCJdLFxuICAgICAgICBsaXN0UHVibGljRXZlbnRzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2V2ZW50cy9wdWJsaWNcIl0sXG4gICAgICAgIGxpc3RQdWJsaWNPcmdFdmVudHM6IFtcIkdFVCAvb3Jncy97b3JnfS9ldmVudHNcIl0sXG4gICAgICAgIGxpc3RSZWNlaXZlZEV2ZW50c0ZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZWNlaXZlZF9ldmVudHNcIl0sXG4gICAgICAgIGxpc3RSZWNlaXZlZFB1YmxpY0V2ZW50c0ZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3JlY2VpdmVkX2V2ZW50cy9wdWJsaWNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJlcG9FdmVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZXZlbnRzXCJdLFxuICAgICAgICBsaXN0UmVwb05vdGlmaWNhdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L25vdGlmaWNhdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJlcG9zU3RhcnJlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9zdGFycmVkXCJdLFxuICAgICAgICBsaXN0UmVwb3NTdGFycmVkQnlVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc3RhcnJlZFwiXSxcbiAgICAgICAgbGlzdFJlcG9zV2F0Y2hlZEJ5VXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L3N1YnNjcmlwdGlvbnNcIl0sXG4gICAgICAgIGxpc3RTdGFyZ2F6ZXJzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGFyZ2F6ZXJzXCJdLFxuICAgICAgICBsaXN0V2F0Y2hlZFJlcG9zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9zdWJzY3JpcHRpb25zXCJdLFxuICAgICAgICBsaXN0V2F0Y2hlcnNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N1YnNjcmliZXJzXCJdLFxuICAgICAgICBtYXJrTm90aWZpY2F0aW9uc0FzUmVhZDogW1wiUFVUIC9ub3RpZmljYXRpb25zXCJdLFxuICAgICAgICBtYXJrUmVwb05vdGlmaWNhdGlvbnNBc1JlYWQ6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vbm90aWZpY2F0aW9uc1wiXSxcbiAgICAgICAgbWFya1RocmVhZEFzUmVhZDogW1wiUEFUQ0ggL25vdGlmaWNhdGlvbnMvdGhyZWFkcy97dGhyZWFkX2lkfVwiXSxcbiAgICAgICAgc2V0UmVwb1N1YnNjcmlwdGlvbjogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdWJzY3JpcHRpb25cIl0sXG4gICAgICAgIHNldFRocmVhZFN1YnNjcmlwdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL25vdGlmaWNhdGlvbnMvdGhyZWFkcy97dGhyZWFkX2lkfS9zdWJzY3JpcHRpb25cIixcbiAgICAgICAgXSxcbiAgICAgICAgc3RhclJlcG9Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUFVUIC91c2VyL3N0YXJyZWQve293bmVyfS97cmVwb31cIl0sXG4gICAgICAgIHVuc3RhclJlcG9Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiREVMRVRFIC91c2VyL3N0YXJyZWQve293bmVyfS97cmVwb31cIl0sXG4gICAgfSxcbiAgICBhcHBzOiB7XG4gICAgICAgIGFkZFJlcG9Ub0luc3RhbGxhdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wiYXBwc1wiLCBcImFkZFJlcG9Ub0luc3RhbGxhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFkZFJlcG9Ub0luc3RhbGxhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBVVCAvdXNlci9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY2hlY2tUb2tlbjogW1wiUE9TVCAvYXBwbGljYXRpb25zL3tjbGllbnRfaWR9L3Rva2VuXCJdLFxuICAgICAgICBjcmVhdGVGcm9tTWFuaWZlc3Q6IFtcIlBPU1QgL2FwcC1tYW5pZmVzdHMve2NvZGV9L2NvbnZlcnNpb25zXCJdLFxuICAgICAgICBjcmVhdGVJbnN0YWxsYXRpb25BY2Nlc3NUb2tlbjogW1xuICAgICAgICAgICAgXCJQT1NUIC9hcHAvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9hY2Nlc3NfdG9rZW5zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUF1dGhvcml6YXRpb246IFtcIkRFTEVURSAvYXBwbGljYXRpb25zL3tjbGllbnRfaWR9L2dyYW50XCJdLFxuICAgICAgICBkZWxldGVJbnN0YWxsYXRpb246IFtcIkRFTEVURSAvYXBwL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZVRva2VuOiBbXCJERUxFVEUgL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS90b2tlblwiXSxcbiAgICAgICAgZ2V0QXV0aGVudGljYXRlZDogW1wiR0VUIC9hcHBcIl0sXG4gICAgICAgIGdldEJ5U2x1ZzogW1wiR0VUIC9hcHBzL3thcHBfc2x1Z31cIl0sXG4gICAgICAgIGdldEluc3RhbGxhdGlvbjogW1wiR0VUIC9hcHAvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfVwiXSxcbiAgICAgICAgZ2V0T3JnSW5zdGFsbGF0aW9uOiBbXCJHRVQgL29yZ3Mve29yZ30vaW5zdGFsbGF0aW9uXCJdLFxuICAgICAgICBnZXRSZXBvSW5zdGFsbGF0aW9uOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2luc3RhbGxhdGlvblwiXSxcbiAgICAgICAgZ2V0U3Vic2NyaXB0aW9uUGxhbkZvckFjY291bnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL2FjY291bnRzL3thY2NvdW50X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRTdWJzY3JpcHRpb25QbGFuRm9yQWNjb3VudFN0dWJiZWQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3N0dWJiZWQvYWNjb3VudHMve2FjY291bnRfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFVzZXJJbnN0YWxsYXRpb246IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9pbnN0YWxsYXRpb25cIl0sXG4gICAgICAgIGdldFdlYmhvb2tDb25maWdGb3JBcHA6IFtcIkdFVCAvYXBwL2hvb2svY29uZmlnXCJdLFxuICAgICAgICBnZXRXZWJob29rRGVsaXZlcnk6IFtcIkdFVCAvYXBwL2hvb2svZGVsaXZlcmllcy97ZGVsaXZlcnlfaWR9XCJdLFxuICAgICAgICBsaXN0QWNjb3VudHNGb3JQbGFuOiBbXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnMve3BsYW5faWR9L2FjY291bnRzXCJdLFxuICAgICAgICBsaXN0QWNjb3VudHNGb3JQbGFuU3R1YmJlZDogW1xuICAgICAgICAgICAgXCJHRVQgL21hcmtldHBsYWNlX2xpc3Rpbmcvc3R1YmJlZC9wbGFucy97cGxhbl9pZH0vYWNjb3VudHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEluc3RhbGxhdGlvblJlcG9zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RJbnN0YWxsYXRpb25zOiBbXCJHRVQgL2FwcC9pbnN0YWxsYXRpb25zXCJdLFxuICAgICAgICBsaXN0SW5zdGFsbGF0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvaW5zdGFsbGF0aW9uc1wiXSxcbiAgICAgICAgbGlzdFBsYW5zOiBbXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnNcIl0sXG4gICAgICAgIGxpc3RQbGFuc1N0dWJiZWQ6IFtcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9zdHViYmVkL3BsYW5zXCJdLFxuICAgICAgICBsaXN0UmVwb3NBY2Nlc3NpYmxlVG9JbnN0YWxsYXRpb246IFtcIkdFVCAvaW5zdGFsbGF0aW9uL3JlcG9zaXRvcmllc1wiXSxcbiAgICAgICAgbGlzdFN1YnNjcmlwdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21hcmtldHBsYWNlX3B1cmNoYXNlc1wiXSxcbiAgICAgICAgbGlzdFN1YnNjcmlwdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlclN0dWJiZWQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL21hcmtldHBsYWNlX3B1cmNoYXNlcy9zdHViYmVkXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RXZWJob29rRGVsaXZlcmllczogW1wiR0VUIC9hcHAvaG9vay9kZWxpdmVyaWVzXCJdLFxuICAgICAgICByZWRlbGl2ZXJXZWJob29rRGVsaXZlcnk6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvYXBwL2hvb2svZGVsaXZlcmllcy97ZGVsaXZlcnlfaWR9L2F0dGVtcHRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVJlcG9Gcm9tSW5zdGFsbGF0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJhcHBzXCIsIFwicmVtb3ZlUmVwb0Zyb21JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVSZXBvRnJvbUluc3RhbGxhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVzZXRUb2tlbjogW1wiUEFUQ0ggL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS90b2tlblwiXSxcbiAgICAgICAgcmV2b2tlSW5zdGFsbGF0aW9uQWNjZXNzVG9rZW46IFtcIkRFTEVURSAvaW5zdGFsbGF0aW9uL3Rva2VuXCJdLFxuICAgICAgICBzY29wZVRva2VuOiBbXCJQT1NUIC9hcHBsaWNhdGlvbnMve2NsaWVudF9pZH0vdG9rZW4vc2NvcGVkXCJdLFxuICAgICAgICBzdXNwZW5kSW5zdGFsbGF0aW9uOiBbXCJQVVQgL2FwcC9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L3N1c3BlbmRlZFwiXSxcbiAgICAgICAgdW5zdXNwZW5kSW5zdGFsbGF0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvYXBwL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vc3VzcGVuZGVkXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZVdlYmhvb2tDb25maWdGb3JBcHA6IFtcIlBBVENIIC9hcHAvaG9vay9jb25maWdcIl0sXG4gICAgfSxcbiAgICBiaWxsaW5nOiB7XG4gICAgICAgIGdldEdpdGh1YkFjdGlvbnNCaWxsaW5nT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vc2V0dGluZ3MvYmlsbGluZy9hY3Rpb25zXCJdLFxuICAgICAgICBnZXRHaXRodWJBY3Rpb25zQmlsbGluZ1VzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3NldHRpbmdzL2JpbGxpbmcvYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBZHZhbmNlZFNlY3VyaXR5QmlsbGluZ0doZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9zZXR0aW5ncy9iaWxsaW5nL2FkdmFuY2VkLXNlY3VyaXR5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEdpdGh1YkFkdmFuY2VkU2VjdXJpdHlCaWxsaW5nT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9iaWxsaW5nL2FkdmFuY2VkLXNlY3VyaXR5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEdpdGh1YlBhY2thZ2VzQmlsbGluZ09yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3NldHRpbmdzL2JpbGxpbmcvcGFja2FnZXNcIl0sXG4gICAgICAgIGdldEdpdGh1YlBhY2thZ2VzQmlsbGluZ1VzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3NldHRpbmdzL2JpbGxpbmcvcGFja2FnZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0U2hhcmVkU3RvcmFnZUJpbGxpbmdPcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3NldHRpbmdzL2JpbGxpbmcvc2hhcmVkLXN0b3JhZ2VcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0U2hhcmVkU3RvcmFnZUJpbGxpbmdVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zZXR0aW5ncy9iaWxsaW5nL3NoYXJlZC1zdG9yYWdlXCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBjaGVja3M6IHtcbiAgICAgICAgY3JlYXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1ydW5zXCJdLFxuICAgICAgICBjcmVhdGVTdWl0ZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stc3VpdGVzXCJdLFxuICAgICAgICBnZXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stcnVucy97Y2hlY2tfcnVuX2lkfVwiXSxcbiAgICAgICAgZ2V0U3VpdGU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stc3VpdGVzL3tjaGVja19zdWl0ZV9pZH1cIl0sXG4gICAgICAgIGxpc3RBbm5vdGF0aW9uczogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH0vYW5ub3RhdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvclJlZjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L2NoZWNrLXJ1bnNcIl0sXG4gICAgICAgIGxpc3RGb3JTdWl0ZTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlcy97Y2hlY2tfc3VpdGVfaWR9L2NoZWNrLXJ1bnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFN1aXRlc0ZvclJlZjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L2NoZWNrLXN1aXRlc1wiXSxcbiAgICAgICAgcmVyZXF1ZXN0UnVuOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH0vcmVyZXF1ZXN0XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlcmVxdWVzdFN1aXRlOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlcy97Y2hlY2tfc3VpdGVfaWR9L3JlcmVxdWVzdFwiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRTdWl0ZXNQcmVmZXJlbmNlczogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stc3VpdGVzL3ByZWZlcmVuY2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZTogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH1cIl0sXG4gICAgfSxcbiAgICBjb2RlU2Nhbm5pbmc6IHtcbiAgICAgICAgZGVsZXRlQW5hbHlzaXM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FuYWx5c2VzL3thbmFseXNpc19pZH17P2NvbmZpcm1fZGVsZXRlfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGVydDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZFBhcmFtZXRlcnM6IHsgYWxlcnRfaWQ6IFwiYWxlcnRfbnVtYmVyXCIgfSB9LFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbmFseXNpczogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYW5hbHlzZXMve2FuYWx5c2lzX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRTYXJpZjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL3Nhcmlmcy97c2FyaWZfaWR9XCJdLFxuICAgICAgICBsaXN0QWxlcnRJbnN0YW5jZXM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfS9pbnN0YW5jZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEFsZXJ0c0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2NvZGUtc2Nhbm5pbmcvYWxlcnRzXCJdLFxuICAgICAgICBsaXN0QWxlcnRzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0c1wiXSxcbiAgICAgICAgbGlzdEFsZXJ0c0luc3RhbmNlczogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2luc3RhbmNlc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcImNvZGVTY2FubmluZ1wiLCBcImxpc3RBbGVydEluc3RhbmNlc1wiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UmVjZW50QW5hbHlzZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbmFseXNlc1wiXSxcbiAgICAgICAgdXBkYXRlQWxlcnQ6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwbG9hZFNhcmlmOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL3Nhcmlmc1wiXSxcbiAgICB9LFxuICAgIGNvZGVzT2ZDb25kdWN0OiB7XG4gICAgICAgIGdldEFsbENvZGVzT2ZDb25kdWN0OiBbXCJHRVQgL2NvZGVzX29mX2NvbmR1Y3RcIl0sXG4gICAgICAgIGdldENvbmR1Y3RDb2RlOiBbXCJHRVQgL2NvZGVzX29mX2NvbmR1Y3Qve2tleX1cIl0sXG4gICAgfSxcbiAgICBjb2Rlc3BhY2VzOiB7XG4gICAgICAgIGFkZFJlcG9zaXRvcnlGb3JTZWNyZXRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQVVQgL3VzZXIvY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjb2Rlc3BhY2VNYWNoaW5lc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vbWFjaGluZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvY29kZXNwYWNlc1wiXSxcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVSZXBvU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVTZWNyZXRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQVVQgL3VzZXIvY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlV2l0aFByRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb2Rlc3BhY2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZVdpdGhSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiREVMRVRFIC91c2VyL2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfVwiXSxcbiAgICAgICAgZGVsZXRlRnJvbU9yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vbWVtYmVycy97dXNlcm5hbWV9L2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVSZXBvU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9L2V4cG9ydHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0RXhwb3J0RGV0YWlsc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vZXhwb3J0cy97ZXhwb3J0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfVwiXSxcbiAgICAgICAgZ2V0UHVibGljS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy9wdWJsaWMta2V5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFJlcG9QdWJsaWNLZXk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL3NlY3JldHMvcHVibGljLWtleVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRSZXBvU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0U2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3REZXZjb250YWluZXJzSW5SZXBvc2l0b3J5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL2RldmNvbnRhaW5lcnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvY29kZXNwYWNlc1wiXSxcbiAgICAgICAgbGlzdEluT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9jb2Rlc3BhY2VzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZFBhcmFtZXRlcnM6IHsgb3JnX2lkOiBcIm9yZ1wiIH0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEluUmVwb3NpdG9yeUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UmVwb1NlY3JldHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzXCJdLFxuICAgICAgICBsaXN0UmVwb3NpdG9yaWVzRm9yU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0U2VjcmV0c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvY29kZXNwYWNlcy9zZWNyZXRzXCJdLFxuICAgICAgICByZW1vdmVSZXBvc2l0b3J5Rm9yU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVwb01hY2hpbmVzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL21hY2hpbmVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldFJlcG9zaXRvcmllc0ZvclNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBVVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgc3RhcnRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vc3RhcnRcIl0sXG4gICAgICAgIHN0b3BGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vc3RvcFwiXSxcbiAgICAgICAgc3RvcEluT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vbWVtYmVycy97dXNlcm5hbWV9L2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfS9zdG9wXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQQVRDSCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX1cIl0sXG4gICAgfSxcbiAgICBkZXBlbmRhYm90OiB7XG4gICAgICAgIGFkZFNlbGVjdGVkUmVwb1RvT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVPclVwZGF0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVPcmdTZWNyZXQ6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICAgICAgZGVsZXRlUmVwb1NlY3JldDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldE9yZ1B1YmxpY0tleTogW1wiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy9wdWJsaWMta2V5XCJdLFxuICAgICAgICBnZXRPcmdTZWNyZXQ6IFtcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICAgICAgZ2V0UmVwb1B1YmxpY0tleTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3Qvc2VjcmV0cy9wdWJsaWMta2V5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFJlcG9TZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0T3JnU2VjcmV0czogW1wiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0c1wiXSxcbiAgICAgICAgbGlzdFJlcG9TZWNyZXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3Qvc2VjcmV0c1wiXSxcbiAgICAgICAgbGlzdFNlbGVjdGVkUmVwb3NGb3JPcmdTZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVTZWxlY3RlZFJlcG9Gcm9tT3JnU2VjcmV0OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldFNlbGVjdGVkUmVwb3NGb3JPcmdTZWNyZXQ6IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgZGVwZW5kZW5jeUdyYXBoOiB7XG4gICAgICAgIGNyZWF0ZVJlcG9zaXRvcnlTbmFwc2hvdDogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRlbmN5LWdyYXBoL3NuYXBzaG90c1wiLFxuICAgICAgICBdLFxuICAgICAgICBkaWZmUmFuZ2U6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRlbmN5LWdyYXBoL2NvbXBhcmUve2Jhc2VoZWFkfVwiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgZW1vamlzOiB7IGdldDogW1wiR0VUIC9lbW9qaXNcIl0gfSxcbiAgICBlbnRlcnByaXNlQWRtaW46IHtcbiAgICAgICAgYWRkQ3VzdG9tTGFiZWxzVG9TZWxmSG9zdGVkUnVubmVyRm9yRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJQT1NUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkaXNhYmxlU2VsZWN0ZWRPcmdhbml6YXRpb25HaXRodWJBY3Rpb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJERUxFVEUgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL29yZ2FuaXphdGlvbnMve29yZ19pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZW5hYmxlU2VsZWN0ZWRPcmdhbml6YXRpb25HaXRodWJBY3Rpb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJQVVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL29yZ2FuaXphdGlvbnMve29yZ19pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWxsb3dlZEFjdGlvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnMvc2VsZWN0ZWQtYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0U2VydmVyU3RhdGlzdGljczogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2UtaW5zdGFsbGF0aW9uL3tlbnRlcnByaXNlX29yX29yZ30vc2VydmVyLXN0YXRpc3RpY3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdExhYmVsc0ZvclNlbGZIb3N0ZWRSdW5uZXJGb3JFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFNlbGVjdGVkT3JnYW5pemF0aW9uc0VuYWJsZWRHaXRodWJBY3Rpb25zRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJHRVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3Blcm1pc3Npb25zL29yZ2FuaXphdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlQWxsQ3VzdG9tTGFiZWxzRnJvbVNlbGZIb3N0ZWRSdW5uZXJGb3JFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlQ3VzdG9tTGFiZWxGcm9tU2VsZkhvc3RlZFJ1bm5lckZvckVudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVscy97bmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgc2V0QWxsb3dlZEFjdGlvbnNFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIlBVVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2FjdGlvbnMvcGVybWlzc2lvbnMvc2VsZWN0ZWQtYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRDdXN0b21MYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yRW50ZXJwcmlzZTogW1xuICAgICAgICAgICAgXCJQVVQgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEdpdGh1YkFjdGlvbnNQZXJtaXNzaW9uc0VudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiUFVUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRTZWxlY3RlZE9yZ2FuaXphdGlvbnNFbmFibGVkR2l0aHViQWN0aW9uc0VudGVycHJpc2U6IFtcbiAgICAgICAgICAgIFwiUFVUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vYWN0aW9ucy9wZXJtaXNzaW9ucy9vcmdhbml6YXRpb25zXCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBnaXN0czoge1xuICAgICAgICBjaGVja0lzU3RhcnJlZDogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH0vc3RhclwiXSxcbiAgICAgICAgY3JlYXRlOiBbXCJQT1NUIC9naXN0c1wiXSxcbiAgICAgICAgY3JlYXRlQ29tbWVudDogW1wiUE9TVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzXCJdLFxuICAgICAgICBkZWxldGU6IFtcIkRFTEVURSAvZ2lzdHMve2dpc3RfaWR9XCJdLFxuICAgICAgICBkZWxldGVDb21tZW50OiBbXCJERUxFVEUgL2dpc3RzL3tnaXN0X2lkfS9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgICAgIGZvcms6IFtcIlBPU1QgL2dpc3RzL3tnaXN0X2lkfS9mb3Jrc1wiXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL2dpc3RzL3tnaXN0X2lkfVwiXSxcbiAgICAgICAgZ2V0Q29tbWVudDogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgICAgICBnZXRSZXZpc2lvbjogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH0ve3NoYX1cIl0sXG4gICAgICAgIGxpc3Q6IFtcIkdFVCAvZ2lzdHNcIl0sXG4gICAgICAgIGxpc3RDb21tZW50czogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHNcIl0sXG4gICAgICAgIGxpc3RDb21taXRzOiBbXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9jb21taXRzXCJdLFxuICAgICAgICBsaXN0Rm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2dpc3RzXCJdLFxuICAgICAgICBsaXN0Rm9ya3M6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2ZvcmtzXCJdLFxuICAgICAgICBsaXN0UHVibGljOiBbXCJHRVQgL2dpc3RzL3B1YmxpY1wiXSxcbiAgICAgICAgbGlzdFN0YXJyZWQ6IFtcIkdFVCAvZ2lzdHMvc3RhcnJlZFwiXSxcbiAgICAgICAgc3RhcjogW1wiUFVUIC9naXN0cy97Z2lzdF9pZH0vc3RhclwiXSxcbiAgICAgICAgdW5zdGFyOiBbXCJERUxFVEUgL2dpc3RzL3tnaXN0X2lkfS9zdGFyXCJdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9naXN0cy97Z2lzdF9pZH1cIl0sXG4gICAgICAgIHVwZGF0ZUNvbW1lbnQ6IFtcIlBBVENIIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgIH0sXG4gICAgZ2l0OiB7XG4gICAgICAgIGNyZWF0ZUJsb2I6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9ic1wiXSxcbiAgICAgICAgY3JlYXRlQ29tbWl0OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvY29tbWl0c1wiXSxcbiAgICAgICAgY3JlYXRlUmVmOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvcmVmc1wiXSxcbiAgICAgICAgY3JlYXRlVGFnOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvdGFnc1wiXSxcbiAgICAgICAgY3JlYXRlVHJlZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RyZWVzXCJdLFxuICAgICAgICBkZWxldGVSZWY6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZnMve3JlZn1cIl0sXG4gICAgICAgIGdldEJsb2I6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2Jsb2JzL3tmaWxlX3NoYX1cIl0sXG4gICAgICAgIGdldENvbW1pdDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvY29tbWl0cy97Y29tbWl0X3NoYX1cIl0sXG4gICAgICAgIGdldFJlZjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvcmVmL3tyZWZ9XCJdLFxuICAgICAgICBnZXRUYWc6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RhZ3Mve3RhZ19zaGF9XCJdLFxuICAgICAgICBnZXRUcmVlOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90cmVlcy97dHJlZV9zaGF9XCJdLFxuICAgICAgICBsaXN0TWF0Y2hpbmdSZWZzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9tYXRjaGluZy1yZWZzL3tyZWZ9XCJdLFxuICAgICAgICB1cGRhdGVSZWY6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvcmVmcy97cmVmfVwiXSxcbiAgICB9LFxuICAgIGdpdGlnbm9yZToge1xuICAgICAgICBnZXRBbGxUZW1wbGF0ZXM6IFtcIkdFVCAvZ2l0aWdub3JlL3RlbXBsYXRlc1wiXSxcbiAgICAgICAgZ2V0VGVtcGxhdGU6IFtcIkdFVCAvZ2l0aWdub3JlL3RlbXBsYXRlcy97bmFtZX1cIl0sXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbnM6IHtcbiAgICAgICAgZ2V0UmVzdHJpY3Rpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgICAgIGdldFJlc3RyaWN0aW9uc0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2ludGVyYWN0aW9uLWxpbWl0c1wiXSxcbiAgICAgICAgZ2V0UmVzdHJpY3Rpb25zRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgICAgIGdldFJlc3RyaWN0aW9uc0ZvcllvdXJQdWJsaWNSZXBvczogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvaW50ZXJhY3Rpb24tbGltaXRzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wiaW50ZXJhY3Rpb25zXCIsIFwiZ2V0UmVzdHJpY3Rpb25zRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlUmVzdHJpY3Rpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgICAgIHJlbW92ZVJlc3RyaWN0aW9uc0Zvck9yZzogW1wiREVMRVRFIC9vcmdzL3tvcmd9L2ludGVyYWN0aW9uLWxpbWl0c1wiXSxcbiAgICAgICAgcmVtb3ZlUmVzdHJpY3Rpb25zRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ludGVyYWN0aW9uLWxpbWl0c1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVSZXN0cmljdGlvbnNGb3JZb3VyUHVibGljUmVwb3M6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL2ludGVyYWN0aW9uLWxpbWl0c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcImludGVyYWN0aW9uc1wiLCBcInJlbW92ZVJlc3RyaWN0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHNldFJlc3RyaWN0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQVVQgL3VzZXIvaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgICAgICBzZXRSZXN0cmljdGlvbnNGb3JPcmc6IFtcIlBVVCAvb3Jncy97b3JnfS9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgICAgIHNldFJlc3RyaWN0aW9uc0ZvclJlcG86IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgICAgICBzZXRSZXN0cmljdGlvbnNGb3JZb3VyUHVibGljUmVwb3M6IFtcbiAgICAgICAgICAgIFwiUFVUIC91c2VyL2ludGVyYWN0aW9uLWxpbWl0c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcImludGVyYWN0aW9uc1wiLCBcInNldFJlc3RyaWN0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBpc3N1ZXM6IHtcbiAgICAgICAgYWRkQXNzaWduZWVzOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9hc3NpZ25lZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgYWRkTGFiZWxzOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbGFiZWxzXCJdLFxuICAgICAgICBjaGVja1VzZXJDYW5CZUFzc2lnbmVkOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Fzc2lnbmVlcy97YXNzaWduZWV9XCJdLFxuICAgICAgICBjcmVhdGU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlc1wiXSxcbiAgICAgICAgY3JlYXRlQ29tbWVudDogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vY29tbWVudHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlTGFiZWw6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2xhYmVsc1wiXSxcbiAgICAgICAgY3JlYXRlTWlsZXN0b25lOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzXCJdLFxuICAgICAgICBkZWxldGVDb21tZW50OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVMYWJlbDogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHMve25hbWV9XCJdLFxuICAgICAgICBkZWxldGVNaWxlc3RvbmU6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzL3ttaWxlc3RvbmVfbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9XCJdLFxuICAgICAgICBnZXRDb21tZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgICAgIGdldEV2ZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9ldmVudHMve2V2ZW50X2lkfVwiXSxcbiAgICAgICAgZ2V0TGFiZWw6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbGFiZWxzL3tuYW1lfVwiXSxcbiAgICAgICAgZ2V0TWlsZXN0b25lOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXMve21pbGVzdG9uZV9udW1iZXJ9XCJdLFxuICAgICAgICBsaXN0OiBbXCJHRVQgL2lzc3Vlc1wiXSxcbiAgICAgICAgbGlzdEFzc2lnbmVlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hc3NpZ25lZXNcIl0sXG4gICAgICAgIGxpc3RDb21tZW50czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vY29tbWVudHNcIl0sXG4gICAgICAgIGxpc3RDb21tZW50c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzXCJdLFxuICAgICAgICBsaXN0RXZlbnRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9ldmVudHNcIl0sXG4gICAgICAgIGxpc3RFdmVudHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9ldmVudHNcIl0sXG4gICAgICAgIGxpc3RFdmVudHNGb3JUaW1lbGluZTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS90aW1lbGluZVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9pc3N1ZXNcIl0sXG4gICAgICAgIGxpc3RGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9pc3N1ZXNcIl0sXG4gICAgICAgIGxpc3RGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlc1wiXSxcbiAgICAgICAgbGlzdExhYmVsc0Zvck1pbGVzdG9uZTogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXMve21pbGVzdG9uZV9udW1iZXJ9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0TGFiZWxzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHNcIl0sXG4gICAgICAgIGxpc3RMYWJlbHNPbklzc3VlOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVsc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0TWlsZXN0b25lczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzXCJdLFxuICAgICAgICBsb2NrOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sb2NrXCJdLFxuICAgICAgICByZW1vdmVBbGxMYWJlbHM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbGFiZWxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZUFzc2lnbmVlczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9hc3NpZ25lZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlTGFiZWw6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbGFiZWxzL3tuYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBzZXRMYWJlbHM6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVsc1wiXSxcbiAgICAgICAgdW5sb2NrOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sb2NrXCJdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn1cIl0sXG4gICAgICAgIHVwZGF0ZUNvbW1lbnQ6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgICAgICB1cGRhdGVMYWJlbDogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2xhYmVscy97bmFtZX1cIl0sXG4gICAgICAgIHVwZGF0ZU1pbGVzdG9uZTogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lcy97bWlsZXN0b25lX251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxpY2Vuc2VzOiB7XG4gICAgICAgIGdldDogW1wiR0VUIC9saWNlbnNlcy97bGljZW5zZX1cIl0sXG4gICAgICAgIGdldEFsbENvbW1vbmx5VXNlZDogW1wiR0VUIC9saWNlbnNlc1wiXSxcbiAgICAgICAgZ2V0Rm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9saWNlbnNlXCJdLFxuICAgIH0sXG4gICAgbWFya2Rvd246IHtcbiAgICAgICAgcmVuZGVyOiBbXCJQT1NUIC9tYXJrZG93blwiXSxcbiAgICAgICAgcmVuZGVyUmF3OiBbXG4gICAgICAgICAgICBcIlBPU1QgL21hcmtkb3duL3Jhd1wiLFxuICAgICAgICAgICAgeyBoZWFkZXJzOiB7IFwiY29udGVudC10eXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiIH0gfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIG1ldGE6IHtcbiAgICAgICAgZ2V0OiBbXCJHRVQgL21ldGFcIl0sXG4gICAgICAgIGdldE9jdG9jYXQ6IFtcIkdFVCAvb2N0b2NhdFwiXSxcbiAgICAgICAgZ2V0WmVuOiBbXCJHRVQgL3plblwiXSxcbiAgICAgICAgcm9vdDogW1wiR0VUIC9cIl0sXG4gICAgfSxcbiAgICBtaWdyYXRpb25zOiB7XG4gICAgICAgIGNhbmNlbEltcG9ydDogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbXBvcnRcIl0sXG4gICAgICAgIGRlbGV0ZUFyY2hpdmVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIvbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9hcmNoaXZlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUFyY2hpdmVGb3JPcmc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiLFxuICAgICAgICBdLFxuICAgICAgICBkb3dubG9hZEFyY2hpdmVGb3JPcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBcmNoaXZlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRDb21taXRBdXRob3JzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ltcG9ydC9hdXRob3JzXCJdLFxuICAgICAgICBnZXRJbXBvcnRTdGF0dXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW1wb3J0XCJdLFxuICAgICAgICBnZXRMYXJnZUZpbGVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ltcG9ydC9sYXJnZV9maWxlc1wiXSxcbiAgICAgICAgZ2V0U3RhdHVzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9XCJdLFxuICAgICAgICBnZXRTdGF0dXNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9XCJdLFxuICAgICAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9taWdyYXRpb25zXCJdLFxuICAgICAgICBsaXN0Rm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vbWlncmF0aW9uc1wiXSxcbiAgICAgICAgbGlzdFJlcG9zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RSZXBvc0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCJdLFxuICAgICAgICBsaXN0UmVwb3NGb3JVc2VyOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcIm1pZ3JhdGlvbnNcIiwgXCJsaXN0UmVwb3NGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBtYXBDb21taXRBdXRob3I6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbXBvcnQvYXV0aG9ycy97YXV0aG9yX2lkfVwiXSxcbiAgICAgICAgc2V0TGZzUHJlZmVyZW5jZTogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2ltcG9ydC9sZnNcIl0sXG4gICAgICAgIHN0YXJ0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvbWlncmF0aW9uc1wiXSxcbiAgICAgICAgc3RhcnRGb3JPcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vbWlncmF0aW9uc1wiXSxcbiAgICAgICAgc3RhcnRJbXBvcnQ6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW1wb3J0XCJdLFxuICAgICAgICB1bmxvY2tSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vcmVwb3Mve3JlcG9fbmFtZX0vbG9ja1wiLFxuICAgICAgICBdLFxuICAgICAgICB1bmxvY2tSZXBvRm9yT3JnOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zL3tyZXBvX25hbWV9L2xvY2tcIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlSW1wb3J0OiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaW1wb3J0XCJdLFxuICAgIH0sXG4gICAgb3Jnczoge1xuICAgICAgICBibG9ja1VzZXI6IFtcIlBVVCAvb3Jncy97b3JnfS9ibG9ja3Mve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY2FuY2VsSW52aXRhdGlvbjogW1wiREVMRVRFIC9vcmdzL3tvcmd9L2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfVwiXSxcbiAgICAgICAgY2hlY2tCbG9ja2VkVXNlcjogW1wiR0VUIC9vcmdzL3tvcmd9L2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBjaGVja01lbWJlcnNoaXBGb3JVc2VyOiBbXCJHRVQgL29yZ3Mve29yZ30vbWVtYmVycy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBjaGVja1B1YmxpY01lbWJlcnNoaXBGb3JVc2VyOiBbXCJHRVQgL29yZ3Mve29yZ30vcHVibGljX21lbWJlcnMve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY29udmVydE1lbWJlclRvT3V0c2lkZUNvbGxhYm9yYXRvcjogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vb3V0c2lkZV9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlSW52aXRhdGlvbjogW1wiUE9TVCAvb3Jncy97b3JnfS9pbnZpdGF0aW9uc1wiXSxcbiAgICAgICAgY3JlYXRlV2ViaG9vazogW1wiUE9TVCAvb3Jncy97b3JnfS9ob29rc1wiXSxcbiAgICAgICAgZGVsZXRlV2ViaG9vazogW1wiREVMRVRFIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfVwiXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL29yZ3Mve29yZ31cIl0sXG4gICAgICAgIGdldE1lbWJlcnNoaXBGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21lbWJlcnNoaXBzL29yZ3Mve29yZ31cIl0sXG4gICAgICAgIGdldE1lbWJlcnNoaXBGb3JVc2VyOiBbXCJHRVQgL29yZ3Mve29yZ30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgZ2V0V2ViaG9vazogW1wiR0VUIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfVwiXSxcbiAgICAgICAgZ2V0V2ViaG9va0NvbmZpZ0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfS9jb25maWdcIl0sXG4gICAgICAgIGdldFdlYmhvb2tEZWxpdmVyeTogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0OiBbXCJHRVQgL29yZ2FuaXphdGlvbnNcIl0sXG4gICAgICAgIGxpc3RBcHBJbnN0YWxsYXRpb25zOiBbXCJHRVQgL29yZ3Mve29yZ30vaW5zdGFsbGF0aW9uc1wiXSxcbiAgICAgICAgbGlzdEJsb2NrZWRVc2VyczogW1wiR0VUIC9vcmdzL3tvcmd9L2Jsb2Nrc1wiXSxcbiAgICAgICAgbGlzdEN1c3RvbVJvbGVzOiBbXCJHRVQgL29yZ2FuaXphdGlvbnMve29yZ2FuaXphdGlvbl9pZH0vY3VzdG9tX3JvbGVzXCJdLFxuICAgICAgICBsaXN0RmFpbGVkSW52aXRhdGlvbnM6IFtcIkdFVCAvb3Jncy97b3JnfS9mYWlsZWRfaW52aXRhdGlvbnNcIl0sXG4gICAgICAgIGxpc3RGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL29yZ3NcIl0sXG4gICAgICAgIGxpc3RGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vb3Jnc1wiXSxcbiAgICAgICAgbGlzdEludml0YXRpb25UZWFtczogW1wiR0VUIC9vcmdzL3tvcmd9L2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfS90ZWFtc1wiXSxcbiAgICAgICAgbGlzdE1lbWJlcnM6IFtcIkdFVCAvb3Jncy97b3JnfS9tZW1iZXJzXCJdLFxuICAgICAgICBsaXN0TWVtYmVyc2hpcHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21lbWJlcnNoaXBzL29yZ3NcIl0sXG4gICAgICAgIGxpc3RPdXRzaWRlQ29sbGFib3JhdG9yczogW1wiR0VUIC9vcmdzL3tvcmd9L291dHNpZGVfY29sbGFib3JhdG9yc1wiXSxcbiAgICAgICAgbGlzdFBlbmRpbmdJbnZpdGF0aW9uczogW1wiR0VUIC9vcmdzL3tvcmd9L2ludml0YXRpb25zXCJdLFxuICAgICAgICBsaXN0UHVibGljTWVtYmVyczogW1wiR0VUIC9vcmdzL3tvcmd9L3B1YmxpY19tZW1iZXJzXCJdLFxuICAgICAgICBsaXN0V2ViaG9va0RlbGl2ZXJpZXM6IFtcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllc1wiXSxcbiAgICAgICAgbGlzdFdlYmhvb2tzOiBbXCJHRVQgL29yZ3Mve29yZ30vaG9va3NcIl0sXG4gICAgICAgIHBpbmdXZWJob29rOiBbXCJQT1NUIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfS9waW5nc1wiXSxcbiAgICAgICAgcmVkZWxpdmVyV2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICAgICAgICBcIlBPU1QgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfS9hdHRlbXB0c1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVNZW1iZXI6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9tZW1iZXJzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIHJlbW92ZU1lbWJlcnNoaXBGb3JVc2VyOiBbXCJERUxFVEUgL29yZ3Mve29yZ30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgcmVtb3ZlT3V0c2lkZUNvbGxhYm9yYXRvcjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vb3V0c2lkZV9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlUHVibGljTWVtYmVyc2hpcEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9wdWJsaWNfbWVtYmVycy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldE1lbWJlcnNoaXBGb3JVc2VyOiBbXCJQVVQgL29yZ3Mve29yZ30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgc2V0UHVibGljTWVtYmVyc2hpcEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBVVCAvb3Jncy97b3JnfS9wdWJsaWNfbWVtYmVycy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVuYmxvY2tVc2VyOiBbXCJERUxFVEUgL29yZ3Mve29yZ30vYmxvY2tzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIHVwZGF0ZTogW1wiUEFUQ0ggL29yZ3Mve29yZ31cIl0sXG4gICAgICAgIHVwZGF0ZU1lbWJlcnNoaXBGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJQQVRDSCAvdXNlci9tZW1iZXJzaGlwcy9vcmdzL3tvcmd9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZVdlYmhvb2s6IFtcIlBBVENIIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfVwiXSxcbiAgICAgICAgdXBkYXRlV2ViaG9va0NvbmZpZ0Zvck9yZzogW1wiUEFUQ0ggL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2NvbmZpZ1wiXSxcbiAgICB9LFxuICAgIHBhY2thZ2VzOiB7XG4gICAgICAgIGRlbGV0ZVBhY2thZ2VGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUGFja2FnZUZvck9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUGFja2FnZUZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVBhY2thZ2VWZXJzaW9uRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVBhY2thZ2VWZXJzaW9uRm9yT3JnOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVQYWNrYWdlVmVyc2lvbkZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvckFQYWNrYWdlT3duZWRCeUFuT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInBhY2thZ2VzXCIsIFwiZ2V0QWxsUGFja2FnZVZlcnNpb25zRm9yUGFja2FnZU93bmVkQnlPcmdcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWxsUGFja2FnZVZlcnNpb25zRm9yQVBhY2thZ2VPd25lZEJ5VGhlQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZW5hbWVkOiBbXG4gICAgICAgICAgICAgICAgICAgIFwicGFja2FnZXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JQYWNrYWdlT3duZWRCeUF1dGhlbnRpY2F0ZWRVc2VyXCIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvclBhY2thZ2VPd25lZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvclBhY2thZ2VPd25lZEJ5T3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JQYWNrYWdlT3duZWRCeVVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFBhY2thZ2VGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UGFja2FnZUZvck9yZ2FuaXphdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UGFja2FnZUZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFBhY2thZ2VWZXJzaW9uRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFBhY2thZ2VWZXJzaW9uRm9yT3JnYW5pemF0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRQYWNrYWdlVmVyc2lvbkZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RQYWNrYWdlc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcGFja2FnZXNcIl0sXG4gICAgICAgIGxpc3RQYWNrYWdlc0Zvck9yZ2FuaXphdGlvbjogW1wiR0VUIC9vcmdzL3tvcmd9L3BhY2thZ2VzXCJdLFxuICAgICAgICBsaXN0UGFja2FnZXNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXNcIl0sXG4gICAgICAgIHJlc3RvcmVQYWNrYWdlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS9yZXN0b3Jlez90b2tlbn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVzdG9yZVBhY2thZ2VGb3JPcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS9yZXN0b3Jlez90b2tlbn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVzdG9yZVBhY2thZ2VGb3JVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vcmVzdG9yZXs/dG9rZW59XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlc3RvcmVQYWNrYWdlVmVyc2lvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH0vcmVzdG9yZVwiLFxuICAgICAgICBdLFxuICAgICAgICByZXN0b3JlUGFja2FnZVZlcnNpb25Gb3JPcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfS9yZXN0b3JlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlc3RvcmVQYWNrYWdlVmVyc2lvbkZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfS9yZXN0b3JlXCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBwcm9qZWN0czoge1xuICAgICAgICBhZGRDb2xsYWJvcmF0b3I6IFtcIlBVVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbGxhYm9yYXRvcnMve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY3JlYXRlQ2FyZDogW1wiUE9TVCAvcHJvamVjdHMvY29sdW1ucy97Y29sdW1uX2lkfS9jYXJkc1wiXSxcbiAgICAgICAgY3JlYXRlQ29sdW1uOiBbXCJQT1NUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sdW1uc1wiXSxcbiAgICAgICAgY3JlYXRlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvcHJvamVjdHNcIl0sXG4gICAgICAgIGNyZWF0ZUZvck9yZzogW1wiUE9TVCAvb3Jncy97b3JnfS9wcm9qZWN0c1wiXSxcbiAgICAgICAgY3JlYXRlRm9yUmVwbzogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHJvamVjdHNcIl0sXG4gICAgICAgIGRlbGV0ZTogW1wiREVMRVRFIC9wcm9qZWN0cy97cHJvamVjdF9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZUNhcmQ6IFtcIkRFTEVURSAvcHJvamVjdHMvY29sdW1ucy9jYXJkcy97Y2FyZF9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZUNvbHVtbjogW1wiREVMRVRFIC9wcm9qZWN0cy9jb2x1bW5zL3tjb2x1bW5faWR9XCJdLFxuICAgICAgICBnZXQ6IFtcIkdFVCAvcHJvamVjdHMve3Byb2plY3RfaWR9XCJdLFxuICAgICAgICBnZXRDYXJkOiBbXCJHRVQgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMve2NhcmRfaWR9XCJdLFxuICAgICAgICBnZXRDb2x1bW46IFtcIkdFVCAvcHJvamVjdHMvY29sdW1ucy97Y29sdW1uX2lkfVwiXSxcbiAgICAgICAgZ2V0UGVybWlzc2lvbkZvclVzZXI6IFtcbiAgICAgICAgICAgIFwiR0VUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9L3Blcm1pc3Npb25cIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdENhcmRzOiBbXCJHRVQgL3Byb2plY3RzL2NvbHVtbnMve2NvbHVtbl9pZH0vY2FyZHNcIl0sXG4gICAgICAgIGxpc3RDb2xsYWJvcmF0b3JzOiBbXCJHRVQgL3Byb2plY3RzL3twcm9qZWN0X2lkfS9jb2xsYWJvcmF0b3JzXCJdLFxuICAgICAgICBsaXN0Q29sdW1uczogW1wiR0VUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sdW1uc1wiXSxcbiAgICAgICAgbGlzdEZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3Byb2plY3RzXCJdLFxuICAgICAgICBsaXN0Rm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wcm9qZWN0c1wiXSxcbiAgICAgICAgbGlzdEZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wcm9qZWN0c1wiXSxcbiAgICAgICAgbW92ZUNhcmQ6IFtcIlBPU1QgL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMve2NhcmRfaWR9L21vdmVzXCJdLFxuICAgICAgICBtb3ZlQ29sdW1uOiBbXCJQT1NUIC9wcm9qZWN0cy9jb2x1bW5zL3tjb2x1bW5faWR9L21vdmVzXCJdLFxuICAgICAgICByZW1vdmVDb2xsYWJvcmF0b3I6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZTogW1wiUEFUQ0ggL3Byb2plY3RzL3twcm9qZWN0X2lkfVwiXSxcbiAgICAgICAgdXBkYXRlQ2FyZDogW1wiUEFUQ0ggL3Byb2plY3RzL2NvbHVtbnMvY2FyZHMve2NhcmRfaWR9XCJdLFxuICAgICAgICB1cGRhdGVDb2x1bW46IFtcIlBBVENIIC9wcm9qZWN0cy9jb2x1bW5zL3tjb2x1bW5faWR9XCJdLFxuICAgIH0sXG4gICAgcHVsbHM6IHtcbiAgICAgICAgY2hlY2tJZk1lcmdlZDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L21lcmdlXCJdLFxuICAgICAgICBjcmVhdGU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzXCJdLFxuICAgICAgICBjcmVhdGVSZXBseUZvclJldmlld0NvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9pZH0vcmVwbGllc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVSZXZpZXc6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3c1wiXSxcbiAgICAgICAgY3JlYXRlUmV2aWV3Q29tbWVudDogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVBlbmRpbmdSZXZpZXc6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUmV2aWV3Q29tbWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkaXNtaXNzUmV2aWV3OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9L2Rpc21pc3NhbHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn1cIl0sXG4gICAgICAgIGdldFJldmlldzogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRSZXZpZXdDb21tZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICAgICAgbGlzdDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxsc1wiXSxcbiAgICAgICAgbGlzdENvbW1lbnRzRm9yUmV2aWV3OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RDb21taXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWl0c1wiXSxcbiAgICAgICAgbGlzdEZpbGVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vZmlsZXNcIl0sXG4gICAgICAgIGxpc3RSZXF1ZXN0ZWRSZXZpZXdlcnM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3JlcXVlc3RlZF9yZXZpZXdlcnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFJldmlld0NvbW1lbnRzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21tZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UmV2aWV3Q29tbWVudHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzXCJdLFxuICAgICAgICBsaXN0UmV2aWV3czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3NcIl0sXG4gICAgICAgIG1lcmdlOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vbWVyZ2VcIl0sXG4gICAgICAgIHJlbW92ZVJlcXVlc3RlZFJldmlld2VyczogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmVxdWVzdGVkX3Jldmlld2Vyc1wiLFxuICAgICAgICBdLFxuICAgICAgICByZXF1ZXN0UmV2aWV3ZXJzOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmVxdWVzdGVkX3Jldmlld2Vyc1wiLFxuICAgICAgICBdLFxuICAgICAgICBzdWJtaXRSZXZpZXc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9L2V2ZW50c1wiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9XCJdLFxuICAgICAgICB1cGRhdGVCcmFuY2g6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3VwZGF0ZS1icmFuY2hcIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlUmV2aWV3OiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZVJldmlld0NvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfVwiLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgcmF0ZUxpbWl0OiB7IGdldDogW1wiR0VUIC9yYXRlX2xpbWl0XCJdIH0sXG4gICAgcmVhY3Rpb25zOiB7XG4gICAgICAgIGNyZWF0ZUZvckNvbW1pdENvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVGb3JJc3N1ZTogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUZvcklzc3VlQ29tbWVudDogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVGb3JQdWxsUmVxdWVzdFJldmlld0NvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVGb3JSZWxlYXNlOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlRm9yVGVhbURpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzL3tjb21tZW50X251bWJlcn0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUZvclRlYW1EaXNjdXNzaW9uSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVGb3JDb21taXRDb21tZW50OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZvcklzc3VlOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZvcklzc3VlQ29tbWVudDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50cy97Y29tbWVudF9pZH0vcmVhY3Rpb25zL3tyZWFjdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRm9yUHVsbFJlcXVlc3RDb21tZW50OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZUZvclJlbGVhc2U6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vcmVhY3Rpb25zL3tyZWFjdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRm9yVGVhbURpc2N1c3Npb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vcmVhY3Rpb25zL3tyZWFjdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRm9yVGVhbURpc2N1c3Npb25Db21tZW50OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzL3tjb21tZW50X251bWJlcn0vcmVhY3Rpb25zL3tyZWFjdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvckNvbW1pdENvbW1lbnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21tZW50cy97Y29tbWVudF9pZH0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JJc3N1ZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vcmVhY3Rpb25zXCJdLFxuICAgICAgICBsaXN0Rm9ySXNzdWVDb21tZW50OiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvclB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEZvclJlbGVhc2U6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vcmVhY3Rpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb3JUZWFtRGlzY3Vzc2lvbkNvbW1lbnRJbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0Rm9yVGVhbURpc2N1c3Npb25Jbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHJlcG9zOiB7XG4gICAgICAgIGFjY2VwdEludml0YXRpb246IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3VzZXIvcmVwb3NpdG9yeV9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH1cIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJyZXBvc1wiLCBcImFjY2VwdEludml0YXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBhY2NlcHRJbnZpdGF0aW9uRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3VzZXIvcmVwb3NpdG9yeV9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgYWRkQXBwQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL2FwcHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwiYXBwc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFkZENvbGxhYm9yYXRvcjogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGFkZFN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzL2NvbnRleHRzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcImNvbnRleHRzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgYWRkVGVhbUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy90ZWFtc1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IG1hcFRvRGF0YTogXCJ0ZWFtc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFkZFVzZXJBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdXNlcnNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwidXNlcnNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBjaGVja0NvbGxhYm9yYXRvcjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGNoZWNrVnVsbmVyYWJpbGl0eUFsZXJ0czogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Z1bG5lcmFiaWxpdHktYWxlcnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNvZGVvd25lcnNFcnJvcnM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZW93bmVycy9lcnJvcnNcIl0sXG4gICAgICAgIGNvbXBhcmVDb21taXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbXBhcmUve2Jhc2V9Li4ue2hlYWR9XCJdLFxuICAgICAgICBjb21wYXJlQ29tbWl0c1dpdGhCYXNlaGVhZDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbXBhcmUve2Jhc2VoZWFkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVBdXRvbGluazogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b2xpbmtzXCJdLFxuICAgICAgICBjcmVhdGVDb21taXRDb21tZW50OiBbXG4gICAgICAgICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve2NvbW1pdF9zaGF9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUNvbW1pdFNpZ25hdHVyZVByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zaWduYXR1cmVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUNvbW1pdFN0YXR1czogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3RhdHVzZXMve3NoYX1cIl0sXG4gICAgICAgIGNyZWF0ZURlcGxveUtleTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30va2V5c1wiXSxcbiAgICAgICAgY3JlYXRlRGVwbG95bWVudDogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHNcIl0sXG4gICAgICAgIGNyZWF0ZURlcGxveW1lbnRTdGF0dXM6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9L3N0YXR1c2VzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZURpc3BhdGNoRXZlbnQ6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Rpc3BhdGNoZXNcIl0sXG4gICAgICAgIGNyZWF0ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL3JlcG9zXCJdLFxuICAgICAgICBjcmVhdGVGb3JrOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9mb3Jrc1wiXSxcbiAgICAgICAgY3JlYXRlSW5Pcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vcmVwb3NcIl0sXG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlRW52aXJvbm1lbnQ6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlRmlsZUNvbnRlbnRzOiBbXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbnRlbnRzL3twYXRofVwiXSxcbiAgICAgICAgY3JlYXRlUGFnZXNTaXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlc1wiXSxcbiAgICAgICAgY3JlYXRlUmVsZWFzZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXNcIl0sXG4gICAgICAgIGNyZWF0ZVRhZ1Byb3RlY3Rpb246IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhZ3MvcHJvdGVjdGlvblwiXSxcbiAgICAgICAgY3JlYXRlVXNpbmdUZW1wbGF0ZTogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97dGVtcGxhdGVfb3duZXJ9L3t0ZW1wbGF0ZV9yZXBvfS9nZW5lcmF0ZVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVXZWJob29rOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rc1wiXSxcbiAgICAgICAgZGVjbGluZUludml0YXRpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wicmVwb3NcIiwgXCJkZWNsaW5lSW52aXRhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xpbmVJbnZpdGF0aW9uRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZTogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXSxcbiAgICAgICAgZGVsZXRlQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQWRtaW5CcmFuY2hQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9lbmZvcmNlX2FkbWluc1wiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVBbkVudmlyb25tZW50OiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVBdXRvbGluazogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hdXRvbGlua3Mve2F1dG9saW5rX2lkfVwiXSxcbiAgICAgICAgZGVsZXRlQnJhbmNoUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb25cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlQ29tbWl0Q29tbWVudDogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZUNvbW1pdFNpZ25hdHVyZVByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3NpZ25hdHVyZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRGVwbG95S2V5OiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXMve2tleV9pZH1cIl0sXG4gICAgICAgIGRlbGV0ZURlcGxveW1lbnQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudF9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRmlsZTogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb250ZW50cy97cGF0aH1cIl0sXG4gICAgICAgIGRlbGV0ZUludml0YXRpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUGFnZXNTaXRlOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzXCJdLFxuICAgICAgICBkZWxldGVQdWxsUmVxdWVzdFJldmlld1Byb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3B1bGxfcmVxdWVzdF9yZXZpZXdzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZVJlbGVhc2U6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9XCJdLFxuICAgICAgICBkZWxldGVSZWxlYXNlQXNzZXQ6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9hc3NldHMve2Fzc2V0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVUYWdQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vdGFncy9wcm90ZWN0aW9uL3t0YWdfcHJvdGVjdGlvbl9pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlV2ViaG9vazogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgICAgIGRpc2FibGVBdXRvbWF0ZWRTZWN1cml0eUZpeGVzOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b21hdGVkLXNlY3VyaXR5LWZpeGVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRpc2FibGVMZnNGb3JSZXBvOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2xmc1wiXSxcbiAgICAgICAgZGlzYWJsZVZ1bG5lcmFiaWxpdHlBbGVydHM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS92dWxuZXJhYmlsaXR5LWFsZXJ0c1wiLFxuICAgICAgICBdLFxuICAgICAgICBkb3dubG9hZEFyY2hpdmU6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS96aXBiYWxsL3tyZWZ9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1wicmVwb3NcIiwgXCJkb3dubG9hZFppcGJhbGxBcmNoaXZlXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRvd25sb2FkVGFyYmFsbEFyY2hpdmU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdGFyYmFsbC97cmVmfVwiXSxcbiAgICAgICAgZG93bmxvYWRaaXBiYWxsQXJjaGl2ZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS96aXBiYWxsL3tyZWZ9XCJdLFxuICAgICAgICBlbmFibGVBdXRvbWF0ZWRTZWN1cml0eUZpeGVzOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b21hdGVkLXNlY3VyaXR5LWZpeGVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGVuYWJsZUxmc0ZvclJlcG86IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vbGZzXCJdLFxuICAgICAgICBlbmFibGVWdWxuZXJhYmlsaXR5QWxlcnRzOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vdnVsbmVyYWJpbGl0eS1hbGVydHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2VuZXJhdGVSZWxlYXNlTm90ZXM6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMvZ2VuZXJhdGUtbm90ZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99XCJdLFxuICAgICAgICBnZXRBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRBZG1pbkJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL2VuZm9yY2VfYWRtaW5zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldEFsbEVudmlyb25tZW50czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHNcIl0sXG4gICAgICAgIGdldEFsbFN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3MvY29udGV4dHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QWxsVG9waWNzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RvcGljc1wiXSxcbiAgICAgICAgZ2V0QXBwc1dpdGhBY2Nlc3NUb1Byb3RlY3RlZEJyYW5jaDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL2FwcHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0QXV0b2xpbms6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b2xpbmtzL3thdXRvbGlua19pZH1cIl0sXG4gICAgICAgIGdldEJyYW5jaDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofVwiXSxcbiAgICAgICAgZ2V0QnJhbmNoUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb25cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0Q2xvbmVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYWZmaWMvY2xvbmVzXCJdLFxuICAgICAgICBnZXRDb2RlRnJlcXVlbmN5U3RhdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3RhdHMvY29kZV9mcmVxdWVuY3lcIl0sXG4gICAgICAgIGdldENvbGxhYm9yYXRvclBlcm1pc3Npb25MZXZlbDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbGxhYm9yYXRvcnMve3VzZXJuYW1lfS9wZXJtaXNzaW9uXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldENvbWJpbmVkU3RhdHVzRm9yUmVmOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vc3RhdHVzXCJdLFxuICAgICAgICBnZXRDb21taXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfVwiXSxcbiAgICAgICAgZ2V0Q29tbWl0QWN0aXZpdHlTdGF0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGF0cy9jb21taXRfYWN0aXZpdHlcIl0sXG4gICAgICAgIGdldENvbW1pdENvbW1lbnQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgICAgICBnZXRDb21taXRTaWduYXR1cmVQcm90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zaWduYXR1cmVzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldENvbW11bml0eVByb2ZpbGVNZXRyaWNzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW11bml0eS9wcm9maWxlXCJdLFxuICAgICAgICBnZXRDb250ZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbnRlbnRzL3twYXRofVwiXSxcbiAgICAgICAgZ2V0Q29udHJpYnV0b3JzU3RhdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3RhdHMvY29udHJpYnV0b3JzXCJdLFxuICAgICAgICBnZXREZXBsb3lLZXk6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30va2V5cy97a2V5X2lkfVwiXSxcbiAgICAgICAgZ2V0RGVwbG95bWVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudF9pZH1cIl0sXG4gICAgICAgIGdldERlcGxveW1lbnRTdGF0dXM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudF9pZH0vc3RhdHVzZXMve3N0YXR1c19pZH1cIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0RW52aXJvbm1lbnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldExhdGVzdFBhZ2VzQnVpbGQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXMvYnVpbGRzL2xhdGVzdFwiXSxcbiAgICAgICAgZ2V0TGF0ZXN0UmVsZWFzZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9sYXRlc3RcIl0sXG4gICAgICAgIGdldFBhZ2VzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzXCJdLFxuICAgICAgICBnZXRQYWdlc0J1aWxkOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2J1aWxkcy97YnVpbGRfaWR9XCJdLFxuICAgICAgICBnZXRQYWdlc0hlYWx0aENoZWNrOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2hlYWx0aFwiXSxcbiAgICAgICAgZ2V0UGFydGljaXBhdGlvblN0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL3BhcnRpY2lwYXRpb25cIl0sXG4gICAgICAgIGdldFB1bGxSZXF1ZXN0UmV2aWV3UHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfcHVsbF9yZXF1ZXN0X3Jldmlld3NcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0UHVuY2hDYXJkU3RhdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc3RhdHMvcHVuY2hfY2FyZFwiXSxcbiAgICAgICAgZ2V0UmVhZG1lOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlYWRtZVwiXSxcbiAgICAgICAgZ2V0UmVhZG1lSW5EaXJlY3Rvcnk6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVhZG1lL3tkaXJ9XCJdLFxuICAgICAgICBnZXRSZWxlYXNlOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfVwiXSxcbiAgICAgICAgZ2V0UmVsZWFzZUFzc2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL2Fzc2V0cy97YXNzZXRfaWR9XCJdLFxuICAgICAgICBnZXRSZWxlYXNlQnlUYWc6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMvdGFncy97dGFnfVwiXSxcbiAgICAgICAgZ2V0U3RhdHVzQ2hlY2tzUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc3RhdHVzX2NoZWNrc1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRUZWFtc1dpdGhBY2Nlc3NUb1Byb3RlY3RlZEJyYW5jaDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3RlYW1zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldFRvcFBhdGhzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYWZmaWMvcG9wdWxhci9wYXRoc1wiXSxcbiAgICAgICAgZ2V0VG9wUmVmZXJyZXJzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYWZmaWMvcG9wdWxhci9yZWZlcnJlcnNcIl0sXG4gICAgICAgIGdldFVzZXJzV2l0aEFjY2Vzc1RvUHJvdGVjdGVkQnJhbmNoOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdXNlcnNcIixcbiAgICAgICAgXSxcbiAgICAgICAgZ2V0Vmlld3M6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdHJhZmZpYy92aWV3c1wiXSxcbiAgICAgICAgZ2V0V2ViaG9vazogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgICAgIGdldFdlYmhvb2tDb25maWdGb3JSZXBvOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2NvbmZpZ1wiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRXZWJob29rRGVsaXZlcnk6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllcy97ZGVsaXZlcnlfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RBdXRvbGlua3M6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b2xpbmtzXCJdLFxuICAgICAgICBsaXN0QnJhbmNoZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXNcIl0sXG4gICAgICAgIGxpc3RCcmFuY2hlc0ZvckhlYWRDb21taXQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9icmFuY2hlcy13aGVyZS1oZWFkXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RDb2xsYWJvcmF0b3JzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbGxhYm9yYXRvcnNcIl0sXG4gICAgICAgIGxpc3RDb21tZW50c0ZvckNvbW1pdDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve2NvbW1pdF9zaGF9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RDb21taXRDb21tZW50c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHNcIl0sXG4gICAgICAgIGxpc3RDb21taXRTdGF0dXNlc0ZvclJlZjogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vc3RhdHVzZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdENvbW1pdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0c1wiXSxcbiAgICAgICAgbGlzdENvbnRyaWJ1dG9yczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb250cmlidXRvcnNcIl0sXG4gICAgICAgIGxpc3REZXBsb3lLZXlzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXNcIl0sXG4gICAgICAgIGxpc3REZXBsb3ltZW50U3RhdHVzZXM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudF9pZH0vc3RhdHVzZXNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdERlcGxveW1lbnRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzXCJdLFxuICAgICAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9yZXBvc1wiXSxcbiAgICAgICAgbGlzdEZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3JlcG9zXCJdLFxuICAgICAgICBsaXN0Rm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L3JlcG9zXCJdLFxuICAgICAgICBsaXN0Rm9ya3M6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZm9ya3NcIl0sXG4gICAgICAgIGxpc3RJbnZpdGF0aW9uczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnZpdGF0aW9uc1wiXSxcbiAgICAgICAgbGlzdEludml0YXRpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9yZXBvc2l0b3J5X2ludml0YXRpb25zXCJdLFxuICAgICAgICBsaXN0TGFuZ3VhZ2VzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2xhbmd1YWdlc1wiXSxcbiAgICAgICAgbGlzdFBhZ2VzQnVpbGRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2J1aWxkc1wiXSxcbiAgICAgICAgbGlzdFB1YmxpYzogW1wiR0VUIC9yZXBvc2l0b3JpZXNcIl0sXG4gICAgICAgIGxpc3RQdWxsUmVxdWVzdHNBc3NvY2lhdGVkV2l0aENvbW1pdDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve2NvbW1pdF9zaGF9L3B1bGxzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RSZWxlYXNlQXNzZXRzOiBbXG4gICAgICAgICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9L2Fzc2V0c1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UmVsZWFzZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXNcIl0sXG4gICAgICAgIGxpc3RUYWdQcm90ZWN0aW9uOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhZ3MvcHJvdGVjdGlvblwiXSxcbiAgICAgICAgbGlzdFRhZ3M6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdGFnc1wiXSxcbiAgICAgICAgbGlzdFRlYW1zOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RlYW1zXCJdLFxuICAgICAgICBsaXN0V2ViaG9va0RlbGl2ZXJpZXM6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0V2ViaG9va3M6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3NcIl0sXG4gICAgICAgIG1lcmdlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9tZXJnZXNcIl0sXG4gICAgICAgIG1lcmdlVXBzdHJlYW06IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L21lcmdlLXVwc3RyZWFtXCJdLFxuICAgICAgICBwaW5nV2ViaG9vazogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L3BpbmdzXCJdLFxuICAgICAgICByZWRlbGl2ZXJXZWJob29rRGVsaXZlcnk6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfS9hdHRlbXB0c1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVBcHBBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy9hcHBzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgbWFwVG9EYXRhOiBcImFwcHNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVDb2xsYWJvcmF0b3I6IFtcbiAgICAgICAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgcmVtb3ZlU3RhdHVzQ2hlY2tDb250ZXh0czogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc3RhdHVzX2NoZWNrcy9jb250ZXh0c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IG1hcFRvRGF0YTogXCJjb250ZXh0c1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVN0YXR1c0NoZWNrUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc3RhdHVzX2NoZWNrc1wiLFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVUZWFtQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdGVhbXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwidGVhbXNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICByZW1vdmVVc2VyQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdXNlcnNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwidXNlcnNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICByZW5hbWVCcmFuY2g6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3JlbmFtZVwiXSxcbiAgICAgICAgcmVwbGFjZUFsbFRvcGljczogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90b3BpY3NcIl0sXG4gICAgICAgIHJlcXVlc3RQYWdlc0J1aWxkOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9idWlsZHNcIl0sXG4gICAgICAgIHNldEFkbWluQnJhbmNoUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL2VuZm9yY2VfYWRtaW5zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHNldEFwcEFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL2FwcHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwiYXBwc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHNldFN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgICAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3MvY29udGV4dHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwiY29udGV4dHNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzZXRUZWFtQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdGVhbXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwidGVhbXNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzZXRVc2VyQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICAgICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdXNlcnNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBtYXBUb0RhdGE6IFwidXNlcnNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICB0ZXN0UHVzaFdlYmhvb2s6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS90ZXN0c1wiXSxcbiAgICAgICAgdHJhbnNmZXI6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYW5zZmVyXCJdLFxuICAgICAgICB1cGRhdGU6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXSxcbiAgICAgICAgdXBkYXRlQnJhbmNoUHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb25cIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlQ29tbWl0Q29tbWVudDogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICAgICAgdXBkYXRlSW5mb3JtYXRpb25BYm91dFBhZ2VzU2l0ZTogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlc1wiXSxcbiAgICAgICAgdXBkYXRlSW52aXRhdGlvbjogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZVB1bGxSZXF1ZXN0UmV2aWV3UHJvdGVjdGlvbjogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9wdWxsX3JlcXVlc3RfcmV2aWV3c1wiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVSZWxlYXNlOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9XCJdLFxuICAgICAgICB1cGRhdGVSZWxlYXNlQXNzZXQ6IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL2Fzc2V0cy97YXNzZXRfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZVN0YXR1c0NoZWNrUG90ZWN0aW9uOiBbXG4gICAgICAgICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3NcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJyZXBvc1wiLCBcInVwZGF0ZVN0YXR1c0NoZWNrUHJvdGVjdGlvblwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVTdGF0dXNDaGVja1Byb3RlY3Rpb246IFtcbiAgICAgICAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc3RhdHVzX2NoZWNrc1wiLFxuICAgICAgICBdLFxuICAgICAgICB1cGRhdGVXZWJob29rOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9XCJdLFxuICAgICAgICB1cGRhdGVXZWJob29rQ29uZmlnRm9yUmVwbzogW1xuICAgICAgICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2NvbmZpZ1wiLFxuICAgICAgICBdLFxuICAgICAgICB1cGxvYWRSZWxlYXNlQXNzZXQ6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9L2Fzc2V0c3s/bmFtZSxsYWJlbH1cIixcbiAgICAgICAgICAgIHsgYmFzZVVybDogXCJodHRwczovL3VwbG9hZHMuZ2l0aHViLmNvbVwiIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBzZWFyY2g6IHtcbiAgICAgICAgY29kZTogW1wiR0VUIC9zZWFyY2gvY29kZVwiXSxcbiAgICAgICAgY29tbWl0czogW1wiR0VUIC9zZWFyY2gvY29tbWl0c1wiXSxcbiAgICAgICAgaXNzdWVzQW5kUHVsbFJlcXVlc3RzOiBbXCJHRVQgL3NlYXJjaC9pc3N1ZXNcIl0sXG4gICAgICAgIGxhYmVsczogW1wiR0VUIC9zZWFyY2gvbGFiZWxzXCJdLFxuICAgICAgICByZXBvczogW1wiR0VUIC9zZWFyY2gvcmVwb3NpdG9yaWVzXCJdLFxuICAgICAgICB0b3BpY3M6IFtcIkdFVCAvc2VhcmNoL3RvcGljc1wiXSxcbiAgICAgICAgdXNlcnM6IFtcIkdFVCAvc2VhcmNoL3VzZXJzXCJdLFxuICAgIH0sXG4gICAgc2VjcmV0U2Nhbm5pbmc6IHtcbiAgICAgICAgZ2V0QWxlcnQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RBbGVydHNGb3JFbnRlcnByaXNlOiBbXG4gICAgICAgICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIixcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEFsZXJ0c0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIl0sXG4gICAgICAgIGxpc3RBbGVydHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3JldC1zY2FubmluZy9hbGVydHNcIl0sXG4gICAgICAgIGxpc3RMb2NhdGlvbnNGb3JBbGVydDogW1xuICAgICAgICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3JldC1zY2FubmluZy9hbGVydHMve2FsZXJ0X251bWJlcn0vbG9jYXRpb25zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIHVwZGF0ZUFsZXJ0OiBbXG4gICAgICAgICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB0ZWFtczoge1xuICAgICAgICBhZGRPclVwZGF0ZU1lbWJlcnNoaXBGb3JVc2VySW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L21lbWJlcnNoaXBzL3t1c2VybmFtZX1cIixcbiAgICAgICAgXSxcbiAgICAgICAgYWRkT3JVcGRhdGVQcm9qZWN0UGVybWlzc2lvbnNJbk9yZzogW1xuICAgICAgICAgICAgXCJQVVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vcHJvamVjdHMve3Byb2plY3RfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGFkZE9yVXBkYXRlUmVwb1Blcm1pc3Npb25zSW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3JlcG9zL3tvd25lcn0ve3JlcG99XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNoZWNrUGVybWlzc2lvbnNGb3JQcm9qZWN0SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3Byb2plY3RzL3twcm9qZWN0X2lkfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjaGVja1Blcm1pc3Npb25zRm9yUmVwb0luT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvcy97b3duZXJ9L3tyZXBvfVwiLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGU6IFtcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXNcIl0sXG4gICAgICAgIGNyZWF0ZURpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgICAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZURpc2N1c3Npb25Jbk9yZzogW1wiUE9TVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9uc1wiXSxcbiAgICAgICAgZGVsZXRlRGlzY3Vzc2lvbkNvbW1lbnRJbk9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGRlbGV0ZURpc2N1c3Npb25Jbk9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVJbk9yZzogW1wiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9XCJdLFxuICAgICAgICBnZXRCeU5hbWU6IFtcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfVwiXSxcbiAgICAgICAgZ2V0RGlzY3Vzc2lvbkNvbW1lbnRJbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGdldERpc2N1c3Npb25Jbk9yZzogW1xuICAgICAgICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfVwiLFxuICAgICAgICBdLFxuICAgICAgICBnZXRNZW1iZXJzaGlwRm9yVXNlckluT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9tZW1iZXJzaGlwcy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3Q6IFtcIkdFVCAvb3Jncy97b3JnfS90ZWFtc1wiXSxcbiAgICAgICAgbGlzdENoaWxkSW5Pcmc6IFtcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS90ZWFtc1wiXSxcbiAgICAgICAgbGlzdERpc2N1c3Npb25Db21tZW50c0luT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3REaXNjdXNzaW9uc0luT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnNcIl0sXG4gICAgICAgIGxpc3RGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3RlYW1zXCJdLFxuICAgICAgICBsaXN0TWVtYmVyc0luT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vbWVtYmVyc1wiXSxcbiAgICAgICAgbGlzdFBlbmRpbmdJbnZpdGF0aW9uc0luT3JnOiBbXG4gICAgICAgICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9pbnZpdGF0aW9uc1wiLFxuICAgICAgICBdLFxuICAgICAgICBsaXN0UHJvamVjdHNJbk9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3Byb2plY3RzXCJdLFxuICAgICAgICBsaXN0UmVwb3NJbk9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3JlcG9zXCJdLFxuICAgICAgICByZW1vdmVNZW1iZXJzaGlwRm9yVXNlckluT3JnOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9tZW1iZXJzaGlwcy97dXNlcm5hbWV9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVByb2plY3RJbk9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vcHJvamVjdHMve3Byb2plY3RfaWR9XCIsXG4gICAgICAgIF0sXG4gICAgICAgIHJlbW92ZVJlcG9Jbk9yZzogW1xuICAgICAgICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vcmVwb3Mve293bmVyfS97cmVwb31cIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlRGlzY3Vzc2lvbkNvbW1lbnRJbk9yZzogW1xuICAgICAgICAgICAgXCJQQVRDSCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzL3tjb21tZW50X251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlRGlzY3Vzc2lvbkluT3JnOiBbXG4gICAgICAgICAgICBcIlBBVENIIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn1cIixcbiAgICAgICAgXSxcbiAgICAgICAgdXBkYXRlSW5Pcmc6IFtcIlBBVENIIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9XCJdLFxuICAgIH0sXG4gICAgdXNlcnM6IHtcbiAgICAgICAgYWRkRW1haWxGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXIvZW1haWxzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJhZGRFbWFpbEZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFkZEVtYWlsRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvZW1haWxzXCJdLFxuICAgICAgICBibG9jazogW1wiUFVUIC91c2VyL2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBjaGVja0Jsb2NrZWQ6IFtcIkdFVCAvdXNlci9ibG9ja3Mve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgY2hlY2tGb2xsb3dpbmdGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93aW5nL3t0YXJnZXRfdXNlcn1cIl0sXG4gICAgICAgIGNoZWNrUGVyc29uSXNGb2xsb3dlZEJ5QXV0aGVudGljYXRlZDogW1wiR0VUIC91c2VyL2ZvbGxvd2luZy97dXNlcm5hbWV9XCJdLFxuICAgICAgICBjcmVhdGVHcGdLZXlGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXIvZ3BnX2tleXNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImNyZWF0ZUdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZUdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL2dwZ19rZXlzXCJdLFxuICAgICAgICBjcmVhdGVQdWJsaWNTc2hLZXlGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIlBPU1QgL3VzZXIva2V5c1wiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwiY3JlYXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgY3JlYXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIva2V5c1wiXSxcbiAgICAgICAgZGVsZXRlRW1haWxGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkRFTEVURSAvdXNlci9lbWFpbHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImRlbGV0ZUVtYWlsRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlRW1haWxGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiREVMRVRFIC91c2VyL2VtYWlsc1wiXSxcbiAgICAgICAgZGVsZXRlR3BnS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIvZ3BnX2tleXMve2dwZ19rZXlfaWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJkZWxldGVHcGdLZXlGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBkZWxldGVHcGdLZXlGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiREVMRVRFIC91c2VyL2dwZ19rZXlzL3tncGdfa2V5X2lkfVwiXSxcbiAgICAgICAgZGVsZXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJERUxFVEUgL3VzZXIva2V5cy97a2V5X2lkfVwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwiZGVsZXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVsZXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9rZXlzL3trZXlfaWR9XCJdLFxuICAgICAgICBmb2xsb3c6IFtcIlBVVCAvdXNlci9mb2xsb3dpbmcve3VzZXJuYW1lfVwiXSxcbiAgICAgICAgZ2V0QXV0aGVudGljYXRlZDogW1wiR0VUIC91c2VyXCJdLFxuICAgICAgICBnZXRCeVVzZXJuYW1lOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX1cIl0sXG4gICAgICAgIGdldENvbnRleHRGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vaG92ZXJjYXJkXCJdLFxuICAgICAgICBnZXRHcGdLZXlGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9ncGdfa2V5cy97Z3BnX2tleV9pZH1cIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImdldEdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGdldEdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZ3BnX2tleXMve2dwZ19rZXlfaWR9XCJdLFxuICAgICAgICBnZXRQdWJsaWNTc2hLZXlGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9rZXlzL3trZXlfaWR9XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJnZXRQdWJsaWNTc2hLZXlGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBnZXRQdWJsaWNTc2hLZXlGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2tleXMve2tleV9pZH1cIl0sXG4gICAgICAgIGxpc3Q6IFtcIkdFVCAvdXNlcnNcIl0sXG4gICAgICAgIGxpc3RCbG9ja2VkQnlBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9ibG9ja3NcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImxpc3RCbG9ja2VkQnlBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBsaXN0QmxvY2tlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9ibG9ja3NcIl0sXG4gICAgICAgIGxpc3RFbWFpbHNGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9lbWFpbHNcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImxpc3RFbWFpbHNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9LFxuICAgICAgICBdLFxuICAgICAgICBsaXN0RW1haWxzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9lbWFpbHNcIl0sXG4gICAgICAgIGxpc3RGb2xsb3dlZEJ5QXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJHRVQgL3VzZXIvZm9sbG93aW5nXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0Rm9sbG93ZWRCeUF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RGb2xsb3dlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9mb2xsb3dpbmdcIl0sXG4gICAgICAgIGxpc3RGb2xsb3dlcnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2ZvbGxvd2Vyc1wiXSxcbiAgICAgICAgbGlzdEZvbGxvd2Vyc0ZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9mb2xsb3dlcnNcIl0sXG4gICAgICAgIGxpc3RGb2xsb3dpbmdGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93aW5nXCJdLFxuICAgICAgICBsaXN0R3BnS2V5c0ZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgICAgICAgIFwiR0VUIC91c2VyL2dwZ19rZXlzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0R3BnS2V5c0ZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RHcGdLZXlzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9ncGdfa2V5c1wiXSxcbiAgICAgICAgbGlzdEdwZ0tleXNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZ3BnX2tleXNcIl0sXG4gICAgICAgIGxpc3RQdWJsaWNFbWFpbHNGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9wdWJsaWNfZW1haWxzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0UHVibGljRW1haWxzRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFB1YmxpY0VtYWlsc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcHVibGljX2VtYWlsc1wiXSxcbiAgICAgICAgbGlzdFB1YmxpY0tleXNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0va2V5c1wiXSxcbiAgICAgICAgbGlzdFB1YmxpY1NzaEtleXNGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICAgICAgICBcIkdFVCAvdXNlci9rZXlzXCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0UHVibGljU3NoS2V5c0ZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RQdWJsaWNTc2hLZXlzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9rZXlzXCJdLFxuICAgICAgICBzZXRQcmltYXJ5RW1haWxWaXNpYmlsaXR5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgICAgICAgXCJQQVRDSCAvdXNlci9lbWFpbC92aXNpYmlsaXR5XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJzZXRQcmltYXJ5RW1haWxWaXNpYmlsaXR5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgc2V0UHJpbWFyeUVtYWlsVmlzaWJpbGl0eUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICAgICAgICBcIlBBVENIIC91c2VyL2VtYWlsL3Zpc2liaWxpdHlcIixcbiAgICAgICAgXSxcbiAgICAgICAgdW5ibG9jazogW1wiREVMRVRFIC91c2VyL2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgICAgICB1bmZvbGxvdzogW1wiREVMRVRFIC91c2VyL2ZvbGxvd2luZy97dXNlcm5hbWV9XCJdLFxuICAgICAgICB1cGRhdGVBdXRoZW50aWNhdGVkOiBbXCJQQVRDSCAvdXNlclwiXSxcbiAgICB9LFxufTtcblxuY29uc3QgVkVSU0lPTiA9IFwiNS4xNi4yXCI7XG5cbmZ1bmN0aW9uIGVuZHBvaW50c1RvTWV0aG9kcyhvY3Rva2l0LCBlbmRwb2ludHNNYXApIHtcbiAgICBjb25zdCBuZXdNZXRob2RzID0ge307XG4gICAgZm9yIChjb25zdCBbc2NvcGUsIGVuZHBvaW50c10gb2YgT2JqZWN0LmVudHJpZXMoZW5kcG9pbnRzTWFwKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFttZXRob2ROYW1lLCBlbmRwb2ludF0gb2YgT2JqZWN0LmVudHJpZXMoZW5kcG9pbnRzKSkge1xuICAgICAgICAgICAgY29uc3QgW3JvdXRlLCBkZWZhdWx0cywgZGVjb3JhdGlvbnNdID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICBjb25zdCBbbWV0aG9kLCB1cmxdID0gcm91dGUuc3BsaXQoLyAvKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50RGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKHsgbWV0aG9kLCB1cmwgfSwgZGVmYXVsdHMpO1xuICAgICAgICAgICAgaWYgKCFuZXdNZXRob2RzW3Njb3BlXSkge1xuICAgICAgICAgICAgICAgIG5ld01ldGhvZHNbc2NvcGVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZU1ldGhvZHMgPSBuZXdNZXRob2RzW3Njb3BlXTtcbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHNjb3BlTWV0aG9kc1ttZXRob2ROYW1lXSA9IGRlY29yYXRlKG9jdG9raXQsIHNjb3BlLCBtZXRob2ROYW1lLCBlbmRwb2ludERlZmF1bHRzLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZU1ldGhvZHNbbWV0aG9kTmFtZV0gPSBvY3Rva2l0LnJlcXVlc3QuZGVmYXVsdHMoZW5kcG9pbnREZWZhdWx0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld01ldGhvZHM7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZShvY3Rva2l0LCBzY29wZSwgbWV0aG9kTmFtZSwgZGVmYXVsdHMsIGRlY29yYXRpb25zKSB7XG4gICAgY29uc3QgcmVxdWVzdFdpdGhEZWZhdWx0cyA9IG9jdG9raXQucmVxdWVzdC5kZWZhdWx0cyhkZWZhdWx0cyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiB3aXRoRGVjb3JhdGlvbnMoLi4uYXJncykge1xuICAgICAgICAvLyBAdHMtaWdub3JlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjU0ODhcbiAgICAgICAgbGV0IG9wdGlvbnMgPSByZXF1ZXN0V2l0aERlZmF1bHRzLmVuZHBvaW50Lm1lcmdlKC4uLmFyZ3MpO1xuICAgICAgICAvLyBUaGVyZSBhcmUgY3VycmVudGx5IG5vIG90aGVyIGRlY29yYXRpb25zIHRoYW4gYC5tYXBUb0RhdGFgXG4gICAgICAgIGlmIChkZWNvcmF0aW9ucy5tYXBUb0RhdGEpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW9uc1tkZWNvcmF0aW9ucy5tYXBUb0RhdGFdLFxuICAgICAgICAgICAgICAgIFtkZWNvcmF0aW9ucy5tYXBUb0RhdGFdOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0V2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNvcmF0aW9ucy5yZW5hbWVkKSB7XG4gICAgICAgICAgICBjb25zdCBbbmV3U2NvcGUsIG5ld01ldGhvZE5hbWVdID0gZGVjb3JhdGlvbnMucmVuYW1lZDtcbiAgICAgICAgICAgIG9jdG9raXQubG9nLndhcm4oYG9jdG9raXQuJHtzY29wZX0uJHttZXRob2ROYW1lfSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gb2N0b2tpdC4ke25ld1Njb3BlfS4ke25ld01ldGhvZE5hbWV9KClgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb3JhdGlvbnMuZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgb2N0b2tpdC5sb2cud2FybihkZWNvcmF0aW9ucy5kZXByZWNhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb3JhdGlvbnMucmVuYW1lZFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNTQ4OFxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHJlcXVlc3RXaXRoRGVmYXVsdHMuZW5kcG9pbnQubWVyZ2UoLi4uYXJncyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhbGlhc10gb2YgT2JqZWN0LmVudHJpZXMoZGVjb3JhdGlvbnMucmVuYW1lZFBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBvY3Rva2l0LmxvZy53YXJuKGBcIiR7bmFtZX1cIiBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZCBmb3IgXCJvY3Rva2l0LiR7c2NvcGV9LiR7bWV0aG9kTmFtZX0oKVwiLiBVc2UgXCIke2FsaWFzfVwiIGluc3RlYWRgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWxpYXMgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbYWxpYXNdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFdpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjU0ODhcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RXaXRoRGVmYXVsdHMoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHdpdGhEZWNvcmF0aW9ucywgcmVxdWVzdFdpdGhEZWZhdWx0cyk7XG59XG5cbmZ1bmN0aW9uIHJlc3RFbmRwb2ludE1ldGhvZHMob2N0b2tpdCkge1xuICAgIGNvbnN0IGFwaSA9IGVuZHBvaW50c1RvTWV0aG9kcyhvY3Rva2l0LCBFbmRwb2ludHMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3Q6IGFwaSxcbiAgICB9O1xufVxucmVzdEVuZHBvaW50TWV0aG9kcy5WRVJTSU9OID0gVkVSU0lPTjtcbmZ1bmN0aW9uIGxlZ2FjeVJlc3RFbmRwb2ludE1ldGhvZHMob2N0b2tpdCkge1xuICAgIGNvbnN0IGFwaSA9IGVuZHBvaW50c1RvTWV0aG9kcyhvY3Rva2l0LCBFbmRwb2ludHMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwaSxcbiAgICAgICAgcmVzdDogYXBpLFxuICAgIH07XG59XG5sZWdhY3lSZXN0RW5kcG9pbnRNZXRob2RzLlZFUlNJT04gPSBWRVJTSU9OO1xuXG5leHBvcnQgeyBsZWdhY3lSZXN0RW5kcG9pbnRNZXRob2RzLCByZXN0RW5kcG9pbnRNZXRob2RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImltcG9ydCB7IERlcHJlY2F0aW9uIH0gZnJvbSAnZGVwcmVjYXRpb24nO1xuaW1wb3J0IG9uY2UgZnJvbSAnb25jZSc7XG5cbmNvbnN0IGxvZ09uY2VDb2RlID0gb25jZSgoZGVwcmVjYXRpb24pID0+IGNvbnNvbGUud2FybihkZXByZWNhdGlvbikpO1xuY29uc3QgbG9nT25jZUhlYWRlcnMgPSBvbmNlKChkZXByZWNhdGlvbikgPT4gY29uc29sZS53YXJuKGRlcHJlY2F0aW9uKSk7XG4vKipcbiAqIEVycm9yIHdpdGggZXh0cmEgcHJvcGVydGllcyB0byBoZWxwIHdpdGggZGVidWdnaW5nXG4gKi9cbmNsYXNzIFJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgICAgIGxldCBoZWFkZXJzO1xuICAgICAgICBpZiAoXCJoZWFkZXJzXCIgaW4gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5oZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInJlc3BvbnNlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5yZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZGFjdCByZXF1ZXN0IGNyZWRlbnRpYWxzIHdpdGhvdXQgbXV0YXRpbmcgb3JpZ2luYWwgcmVxdWVzdCBvcHRpb25zXG4gICAgICAgIGNvbnN0IHJlcXVlc3RDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgIHJlcXVlc3RDb3B5LmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb246IG9wdGlvbnMucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24ucmVwbGFjZSgvIC4qJC8sIFwiIFtSRURBQ1RFRF1cIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0Q29weS51cmwgPSByZXF1ZXN0Q29weS51cmxcbiAgICAgICAgICAgIC8vIGNsaWVudF9pZCAmIGNsaWVudF9zZWNyZXQgY2FuIGJlIHBhc3NlZCBhcyBVUkwgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNyZWFzZSByYXRlIGxpbWl0XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My8jaW5jcmVhc2luZy10aGUtdW5hdXRoZW50aWNhdGVkLXJhdGUtbGltaXQtZm9yLW9hdXRoLWFwcGxpY2F0aW9uc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcYmNsaWVudF9zZWNyZXQ9XFx3Ky9nLCBcImNsaWVudF9zZWNyZXQ9W1JFREFDVEVEXVwiKVxuICAgICAgICAgICAgLy8gT0F1dGggdG9rZW5zIGNhbiBiZSBwYXNzZWQgYXMgVVJMIHF1ZXJ5IHBhcmFtZXRlcnMsIGFsdGhvdWdoIGl0IGlzIG5vdCByZWNvbW1lbmRlZFxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmdpdGh1Yi5jb20vdjMvI29hdXRoMi10b2tlbi1zZW50LWluLWEtaGVhZGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxiYWNjZXNzX3Rva2VuPVxcdysvZywgXCJhY2Nlc3NfdG9rZW49W1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdENvcHk7XG4gICAgICAgIC8vIGRlcHJlY2F0aW9uc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBsb2dPbmNlQ29kZShuZXcgRGVwcmVjYXRpb24oXCJbQG9jdG9raXQvcmVxdWVzdC1lcnJvcl0gYGVycm9yLmNvZGVgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgZXJyb3Iuc3RhdHVzYC5cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXNDb2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlYWRlcnNcIiwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGxvZ09uY2VIZWFkZXJzKG5ldyBEZXByZWNhdGlvbihcIltAb2N0b2tpdC9yZXF1ZXN0LWVycm9yXSBgZXJyb3IuaGVhZGVyc2AgaXMgZGVwcmVjYXRlZCwgdXNlIGBlcnJvci5yZXNwb25zZS5oZWFkZXJzYC5cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBSZXF1ZXN0RXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiaW1wb3J0IHsgZW5kcG9pbnQgfSBmcm9tICdAb2N0b2tpdC9lbmRwb2ludCc7XG5pbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tICd1bml2ZXJzYWwtdXNlci1hZ2VudCc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCBub2RlRmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tICdAb2N0b2tpdC9yZXF1ZXN0LWVycm9yJztcblxuY29uc3QgVkVSU0lPTiA9IFwiNS42LjNcIjtcblxuZnVuY3Rpb24gZ2V0QnVmZmVyUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbn1cblxuZnVuY3Rpb24gZmV0Y2hXcmFwcGVyKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3QgbG9nID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdCAmJiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmxvZ1xuICAgICAgICA/IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QubG9nXG4gICAgICAgIDogY29uc29sZTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXF1ZXN0T3B0aW9ucy5ib2R5KSB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KHJlcXVlc3RPcHRpb25zLmJvZHkpKSB7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3B0aW9ucy5ib2R5KTtcbiAgICB9XG4gICAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgICBsZXQgc3RhdHVzO1xuICAgIGxldCB1cmw7XG4gICAgY29uc3QgZmV0Y2ggPSAocmVxdWVzdE9wdGlvbnMucmVxdWVzdCAmJiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmZldGNoKSB8fCBub2RlRmV0Y2g7XG4gICAgcmV0dXJuIGZldGNoKHJlcXVlc3RPcHRpb25zLnVybCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdE9wdGlvbnMubWV0aG9kLFxuICAgICAgICBib2R5OiByZXF1ZXN0T3B0aW9ucy5ib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICByZWRpcmVjdDogcmVxdWVzdE9wdGlvbnMucmVkaXJlY3QsXG4gICAgfSwgXG4gICAgLy8gYHJlcXVlc3RPcHRpb25zLnJlcXVlc3QuYWdlbnRgIHR5cGUgaXMgaW5jb21wYXRpYmxlXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3Rva2l0L3R5cGVzLnRzL3B1bGwvMjY0XG4gICAgcmVxdWVzdE9wdGlvbnMucmVxdWVzdCkpXG4gICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgICAgIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgZm9yIChjb25zdCBrZXlBbmRWYWx1ZSBvZiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleUFuZFZhbHVlWzBdXSA9IGtleUFuZFZhbHVlWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImRlcHJlY2F0aW9uXCIgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGhlYWRlcnMubGluayAmJiBoZWFkZXJzLmxpbmsubWF0Y2goLzwoW14+XSspPjsgcmVsPVwiZGVwcmVjYXRpb25cIi8pO1xuICAgICAgICAgICAgY29uc3QgZGVwcmVjYXRpb25MaW5rID0gbWF0Y2hlcyAmJiBtYXRjaGVzLnBvcCgpO1xuICAgICAgICAgICAgbG9nLndhcm4oYFtAb2N0b2tpdC9yZXF1ZXN0XSBcIiR7cmVxdWVzdE9wdGlvbnMubWV0aG9kfSAke3JlcXVlc3RPcHRpb25zLnVybH1cIiBpcyBkZXByZWNhdGVkLiBJdCBpcyBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBvbiAke2hlYWRlcnMuc3Vuc2V0fSR7ZGVwcmVjYXRpb25MaW5rID8gYC4gU2VlICR7ZGVwcmVjYXRpb25MaW5rfWAgOiBcIlwifWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzdGF0dXMgPT09IDIwNSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdEh1YiBBUEkgcmV0dXJucyAyMDAgZm9yIEhFQUQgcmVxdWVzdHNcbiAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHN0YXR1cywge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RFcnJvcihcIk5vdCBtb2RpZmllZFwiLCBzdGF0dXMsIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgUmVxdWVzdEVycm9yKHRvRXJyb3JNZXNzYWdlKGRhdGEpLCBzdGF0dXMsIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICB9KVxuICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH07XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKC9hcHBsaWNhdGlvblxcL2pzb24vLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGlmICghY29udGVudFR5cGUgfHwgL150ZXh0XFwvfGNoYXJzZXQ9dXRmLTgkLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QnVmZmVyUmVzcG9uc2UocmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gdG9FcnJvck1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2UgLSBqdXN0IGluIGNhc2VcbiAgICBpZiAoXCJtZXNzYWdlXCIgaW4gZGF0YSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmVycm9ycykpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtkYXRhLm1lc3NhZ2V9OiAke2RhdGEuZXJyb3JzLm1hcChKU09OLnN0cmluZ2lmeSkuam9pbihcIiwgXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEubWVzc2FnZTtcbiAgICB9XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgLSBqdXN0IGluIGNhc2VcbiAgICByZXR1cm4gYFVua25vd24gZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YDtcbn1cblxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZEVuZHBvaW50LCBuZXdEZWZhdWx0cykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gb2xkRW5kcG9pbnQuZGVmYXVsdHMobmV3RGVmYXVsdHMpO1xuICAgIGNvbnN0IG5ld0FwaSA9IGZ1bmN0aW9uIChyb3V0ZSwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBlbmRwb2ludE9wdGlvbnMgPSBlbmRwb2ludC5tZXJnZShyb3V0ZSwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QgfHwgIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0Lmhvb2spIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFdyYXBwZXIoZW5kcG9pbnQucGFyc2UoZW5kcG9pbnRPcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IChyb3V0ZSwgcGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoV3JhcHBlcihlbmRwb2ludC5wYXJzZShlbmRwb2ludC5tZXJnZShyb3V0ZSwgcGFyYW1ldGVycykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXF1ZXN0LCB7XG4gICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBlbmRwb2ludCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QuaG9vayhyZXF1ZXN0LCBlbmRwb2ludE9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgICAgIGVuZHBvaW50LFxuICAgICAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQpLFxuICAgIH0pO1xufVxuXG5jb25zdCByZXF1ZXN0ID0gd2l0aERlZmF1bHRzKGVuZHBvaW50LCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtcmVxdWVzdC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YCxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IHJlcXVlc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwidmFyIHJhd19jb25uZWN0ID0gcmVxdWlyZSgnLi9saWIvY29ubmVjdCcpLmNvbm5lY3Q7XG52YXIgQ2hhbm5lbE1vZGVsID0gcmVxdWlyZSgnLi9saWIvY2hhbm5lbF9tb2RlbCcpLkNoYW5uZWxNb2RlbDtcbnZhciBwcm9taXNpZnkgPSByZXF1aXJlKCd1dGlsJykucHJvbWlzaWZ5O1xuXG5mdW5jdGlvbiBjb25uZWN0KHVybCwgY29ubk9wdGlvbnMpIHtcbiAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYikge1xuICAgIHJldHVybiByYXdfY29ubmVjdCh1cmwsIGNvbm5PcHRpb25zLCBjYik7XG4gIH0pKClcbiAgLnRoZW4oZnVuY3Rpb24oY29ubikge1xuICAgIHJldHVybiBuZXcgQ2hhbm5lbE1vZGVsKGNvbm4pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xubW9kdWxlLmV4cG9ydHMuY3JlZGVudGlhbHMgPSByZXF1aXJlKCcuL2xpYi9jcmVkZW50aWFscycpO1xubW9kdWxlLmV4cG9ydHMuSWxsZWdhbE9wZXJhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9saWIvZXJyb3InKS5JbGxlZ2FsT3BlcmF0aW9uRXJyb3I7XG4iLCIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLypcblRoZSBjaGFubmVsIChwcm9taXNlKSBhbmQgY2FsbGJhY2sgQVBJcyBoYXZlIHNpbWlsYXIgc2lnbmF0dXJlcywgYW5kXG5pbiBwYXJ0aWN1bGFyLCBib3RoIG5lZWQgQU1RUCBmaWVsZHMgcHJlcGFyZWQgZnJvbSB0aGUgc2FtZSBhcmd1bWVudHNcbmFuZCBvcHRpb25zLiBUaGUgYXJndW1lbnRzIG1hcnNoYWxsaW5nIGlzIGRvbmUgaGVyZS4gRWFjaCBvZiB0aGVcbnByb2NlZHVyZXMgYmVsb3cgdGFrZXMgYXJndW1lbnRzIGFuZCBvcHRpb25zICh0aGUgbGF0dGVyIGluIGFuIG9iamVjdClcbnBhcnRpY3VsYXIgdG8gdGhlIG9wZXJhdGlvbiBpdCByZXByZXNlbnRzLCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuZmllbGRzIGZvciBoYW5kaW5nIHRvIHRoZSBlbmNvZGVyLlxuKi9cblxuLy8gQSBudW1iZXIgb2YgQU1RUCBtZXRob2RzIGhhdmUgYSB0YWJsZS10eXBlZCBmaWVsZCBjYWxsZWRcbi8vIGBhcmd1bWVudHNgLCB0aGF0IGlzIGludGVuZGVkIHRvIGNhcnJ5IGV4dGVuc2lvbi1zcGVjaWZpY1xuLy8gdmFsdWVzLiBSYWJiaXRNUSB1c2VzIHRoaXMgaW4gYSBudW1iZXIgb2YgcGxhY2VzOyBlLmcuLCB0byBzcGVjaWZ5XG4vLyBhbiAnYWx0ZXJuYXRlIGV4Y2hhbmdlJy5cbi8vXG4vLyBNYW55IG9mIHRoZSBtZXRob2RzIGluIHRoaXMgQVBJIGhhdmUgYW4gYG9wdGlvbnNgIGFyZ3VtZW50LCBmcm9tXG4vLyB3aGljaCBJIHRha2UgYm90aCB2YWx1ZXMgdGhhdCBoYXZlIGEgZGVmYXVsdCBpbiBBTVFQIChlLmcuLFxuLy8gYXV0b0RlbGV0ZSBpbiBRdWV1ZURlY2xhcmUpICphbmQqIHZhbHVlcyB0aGF0IGFyZSBzcGVjaWZpYyB0b1xuLy8gUmFiYml0TVEgKGUuZy4sICdhbHRlcm5hdGUtZXhjaGFuZ2UnKSwgd2hpY2ggd291bGQgbm9ybWFsbHkgYmVcbi8vIHN1cHBsaWVkIGluIGBhcmd1bWVudHNgLiBTbyB0aGF0IGV4dGVuc2lvbnMgSSBkb24ndCBzdXBwb3J0IHlldCBjYW5cbi8vIGJlIHVzZWQsIEkgaW5jbHVkZSBgYXJndW1lbnRzYCBpdHNlbGYgYW1vbmcgdGhlIG9wdGlvbnMuXG4vL1xuLy8gVGhlIHVwc2hvdCBvZiB0aGlzIGlzIHRoYXQgSSBvZnRlbiBuZWVkIHRvIHByZXBhcmUgYW4gYGFyZ3VtZW50c2Bcbi8vIHZhbHVlIHRoYXQgaGFzIGFueSB2YWx1ZXMgcGFzc2VkIGluIGBvcHRpb25zLmFyZ3VtZW50c2AgYXMgd2VsbCBhc1xuLy8gYW55IEkndmUgcHJvbW90ZWQgdG8gYmVpbmcgb3B0aW9ucyB0aGVtc2VsdmVzLiBTaW5jZSBJIGRvbid0IHdhbnRcbi8vIHRvIG11dGF0ZSBhbnl0aGluZyBwYXNzZWQgaW4sIHRoZSBnZW5lcmFsIHBhdHRlcm4gaXMgdG8gY3JlYXRlIGFcbi8vIGZyZXNoIG9iamVjdCB3aXRoIHRoZSBgYXJndW1lbnRzYCB2YWx1ZSBnaXZlbiBhcyBpdHMgcHJvdG90eXBlOyBhbGxcbi8vIGZpZWxkcyBpbiB0aGUgc3VwcGxpZWQgdmFsdWUgd2lsbCBiZSBzZXJpYWxpc2VkLCBhcyB3ZWxsIGFzIGFueSBJXG4vLyBzZXQgb24gdGhlIGZyZXNoIG9iamVjdC4gV2hhdCBJIGRvbid0IHdhbnQgdG8gZG8sIGhvd2V2ZXIsIGlzIHNldCBhXG4vLyBmaWVsZCB0byB1bmRlZmluZWQgYnkgY29weWluZyBwb3NzaWJseSBtaXNzaW5nIGZpZWxkIHZhbHVlcyxcbi8vIGJlY2F1c2UgdGhhdCB3aWxsIG1hc2sgYSB2YWx1ZSBpbiB0aGUgcHJvdG90eXBlLlxuLy9cbi8vIE5CIHRoZSBgYXJndW1lbnRzYCBmaWVsZCBhbHJlYWR5IGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgYHt9YCwgc29cbi8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBleHBsaWNpdGx5IGRlZmF1bHQgaXQgdW5sZXNzIEknbSBzZXR0aW5nIHZhbHVlcy5cbmZ1bmN0aW9uIHNldElmRGVmaW5lZChvYmosIHByb3AsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIG9ialtwcm9wXSA9IHZhbHVlO1xufVxuXG52YXIgRU1QVFlfT1BUSU9OUyA9IE9iamVjdC5mcmVlemUoe30pO1xuXG52YXIgQXJncyA9IHt9O1xuXG5BcmdzLmFzc2VydFF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgcXVldWUgPSBxdWV1ZSB8fCAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcblxuICB2YXIgYXJndCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5hcmd1bWVudHMgfHwgbnVsbCk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1leHBpcmVzJywgb3B0aW9ucy5leHBpcmVzKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1lc3NhZ2UtdHRsJywgb3B0aW9ucy5tZXNzYWdlVHRsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LWRlYWQtbGV0dGVyLWV4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVhZExldHRlckV4Y2hhbmdlKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LWRlYWQtbGV0dGVyLXJvdXRpbmcta2V5JyxcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVhZExldHRlclJvdXRpbmdLZXkpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtbWF4LWxlbmd0aCcsIG9wdGlvbnMubWF4TGVuZ3RoKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1heC1wcmlvcml0eScsIG9wdGlvbnMubWF4UHJpb3JpdHkpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtb3ZlcmZsb3cnLCBvcHRpb25zLm92ZXJmbG93KTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LXF1ZXVlLW1vZGUnLCBvcHRpb25zLnF1ZXVlTW9kZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgZXhjbHVzaXZlOiAhIW9wdGlvbnMuZXhjbHVzaXZlLFxuICAgIGR1cmFibGU6IChvcHRpb25zLmR1cmFibGUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5kdXJhYmxlLFxuICAgIGF1dG9EZWxldGU6ICEhb3B0aW9ucy5hdXRvRGVsZXRlLFxuICAgIGFyZ3VtZW50czogYXJndCxcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAvLyBkZXByZWNhdGVkIGJ1dCB3ZSBoYXZlIHRvIGluY2x1ZGUgaXRcbiAgICB0aWNrZXQ6IDAsXG4gICAgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5jaGVja1F1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgcGFzc2l2ZTogdHJ1ZSwgLy8gc3dpdGNoIHRvIFwiY29tcGxldGVseSBkaWZmZXJlbnRcIiBtb2RlXG4gICAgbm93YWl0OiBmYWxzZSxcbiAgICBkdXJhYmxlOiB0cnVlLCBhdXRvRGVsZXRlOiBmYWxzZSwgZXhjbHVzaXZlOiBmYWxzZSwgLy8gaWdub3JlZFxuICAgIHRpY2tldDogMCxcbiAgfTtcbn07XG5cbkFyZ3MuZGVsZXRlUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TO1xuICByZXR1cm4ge1xuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBpZlVudXNlZDogISFvcHRpb25zLmlmVW51c2VkLFxuICAgIGlmRW1wdHk6ICEhb3B0aW9ucy5pZkVtcHR5LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5wdXJnZVF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmJpbmRRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgZXhjaGFuZ2U6IHNvdXJjZSxcbiAgICByb3V0aW5nS2V5OiBwYXR0ZXJuLFxuICAgIGFyZ3VtZW50czogYXJndCxcbiAgICB0aWNrZXQ6IDAsIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MudW5iaW5kUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGV4Y2hhbmdlOiBzb3VyY2UsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmFzc2VydEV4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UsIHR5cGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgdmFyIGFyZ3QgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuYXJndW1lbnRzIHx8IG51bGwpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ2FsdGVybmF0ZS1leGNoYW5nZScsIG9wdGlvbnMuYWx0ZXJuYXRlRXhjaGFuZ2UpO1xuICByZXR1cm4ge1xuICAgIGV4Y2hhbmdlOiBleGNoYW5nZSxcbiAgICB0aWNrZXQ6IDAsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICBkdXJhYmxlOiAob3B0aW9ucy5kdXJhYmxlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuZHVyYWJsZSxcbiAgICBhdXRvRGVsZXRlOiAhIW9wdGlvbnMuYXV0b0RlbGV0ZSxcbiAgICBpbnRlcm5hbDogISFvcHRpb25zLmludGVybmFsLFxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgYXJndW1lbnRzOiBhcmd0XG4gIH07XG59O1xuXG5BcmdzLmNoZWNrRXhjaGFuZ2UgPSBmdW5jdGlvbihleGNoYW5nZSkge1xuICByZXR1cm4ge1xuICAgIGV4Y2hhbmdlOiBleGNoYW5nZSxcbiAgICBwYXNzaXZlOiB0cnVlLCAvLyBzd2l0Y2ggdG8gJ21heSBhcyB3ZWxsIGJlIGFub3RoZXIgbWV0aG9kJyBtb2RlXG4gICAgbm93YWl0OiBmYWxzZSxcbiAgICAvLyBmZiBhcmUgaWdub3JlZFxuICAgIGR1cmFibGU6IHRydWUsIGludGVybmFsOiBmYWxzZSwgIHR5cGU6ICcnLCAgYXV0b0RlbGV0ZTogZmFsc2UsXG4gICAgdGlja2V0OiAwXG4gIH07XG59O1xuXG5BcmdzLmRlbGV0ZUV4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgcmV0dXJuIHtcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgaWZVbnVzZWQ6ICEhb3B0aW9ucy5pZlVudXNlZCxcbiAgICB0aWNrZXQ6IDAsIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MuYmluZEV4Y2hhbmdlID0gZnVuY3Rpb24oZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgZGVzdGluYXRpb246IGRlc3QsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLnVuYmluZEV4Y2hhbmdlID0gZnVuY3Rpb24oZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgZGVzdGluYXRpb246IGRlc3QsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG4vLyBJdCdzIGNvbnZlbmllbnQgdG8gY29uc3RydWN0IHRoZSBwcm9wZXJ0aWVzIGFuZCB0aGUgbWV0aG9kIGZpZWxkc1xuLy8gYXQgdGhlIHNhbWUgdGltZSwgc2luY2UgaW4gdGhlIEFQSXMsIHZhbHVlcyBmb3IgYm90aCBjYW4gYXBwZWFyIGluXG4vLyBgb3B0aW9uc2AuIFNpbmNlIHRoZSBwcm9wZXJ0eSBvciBtdGhvZCBmaWVsZCBuYW1lcyBkb24ndCBvdmVybGFwLCBJXG4vLyBqdXN0IHJldHVybiBvbmUgYmlnIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGZvciBib3RoIHB1cnBvc2VzLCBhbmRcbi8vIHRoZSBlbmNvZGVyIHdpbGwgcGljayBvdXQgd2hhdCBpdCB3YW50cy5cbkFyZ3MucHVibGlzaCA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG5cbiAgLy8gVGhlIENDIGFuZCBCQ0MgZmllbGRzIGV4cGVjdCBhbiBhcnJheSBvZiBcImxvbmdzdHJcIiwgd2hpY2ggd291bGRcbiAgLy8gbm9ybWFsbHkgYmUgYnVmZmVyIHZhbHVlcyBpbiBKYXZhU2NyaXB0OyBob3dldmVyLCBzaW5jZSBhIGZpZWxkXG4gIC8vIGFycmF5IChvciB0YWJsZSkgY2Fubm90IGhhdmUgc2hvcnRzdHIgdmFsdWVzLCB0aGUgY29kZWMgd2lsbFxuICAvLyBlbmNvZGUgYWxsIHN0cmluZ3MgYXMgbG9uZ3N0cnMgYW55d2F5LlxuICBmdW5jdGlvbiBjb252ZXJ0Q0MoY2MpIHtcbiAgICBpZiAoY2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYykpIHtcbiAgICAgIHJldHVybiBjYy5tYXAoU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gW1N0cmluZyhjYyldO1xuICB9XG5cbiAgdmFyIGhlYWRlcnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuaGVhZGVycyB8fCBudWxsKTtcbiAgc2V0SWZEZWZpbmVkKGhlYWRlcnMsICdDQycsIGNvbnZlcnRDQyhvcHRpb25zLkNDKSk7XG4gIHNldElmRGVmaW5lZChoZWFkZXJzLCAnQkNDJywgY29udmVydENDKG9wdGlvbnMuQkNDKSk7XG5cbiAgdmFyIGRlbGl2ZXJ5TW9kZTsgLy8gdW5kZWZpbmVkIHdpbGwgZGVmYXVsdCB0byAxIChub24tcGVyc2lzdGVudClcblxuICAvLyBQcmV2aW91c2x5IEkgb3ZlcmxvYWRlZCBkZWxpdmVyeU1vZGUgYmUgYSBib29sZWFuIG1lYW5pbmdcbiAgLy8gJ3BlcnNpc3RlbnQgb3Igbm90JzsgYmV0dGVyIGlzIHRvIG5hbWUgdGhpcyBvcHRpb24gZm9yIHdoYXQgaXRcbiAgLy8gaXMsIGJ1dCBJIG5lZWQgdG8gaGF2ZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgZWl0aGVyIHN1cHBseSBhIG51bWVyaWMgb3IgYm9vbGVhbiB2YWx1ZS5cbiAgaWYgKG9wdGlvbnMucGVyc2lzdGVudCAhPT0gdW5kZWZpbmVkKVxuICAgIGRlbGl2ZXJ5TW9kZSA9IChvcHRpb25zLnBlcnNpc3RlbnQpID8gMiA6IDE7XG4gIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRlbGl2ZXJ5TW9kZSA9PT0gJ251bWJlcicpXG4gICAgZGVsaXZlcnlNb2RlID0gb3B0aW9ucy5kZWxpdmVyeU1vZGU7XG4gIGVsc2UgaWYgKG9wdGlvbnMuZGVsaXZlcnlNb2RlKSAvLyBpcyBzdXBwbGllZCBhbmQgdHJ1dGh5XG4gICAgZGVsaXZlcnlNb2RlID0gMjtcblxuICB2YXIgZXhwaXJhdGlvbiA9IG9wdGlvbnMuZXhwaXJhdGlvbjtcbiAgaWYgKGV4cGlyYXRpb24gIT09IHVuZGVmaW5lZCkgZXhwaXJhdGlvbiA9IGV4cGlyYXRpb24udG9TdHJpbmcoKTtcblxuICByZXR1cm4ge1xuICAgIC8vIG1ldGhvZCBmaWVsZHNcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgcm91dGluZ0tleTogcm91dGluZ0tleSxcbiAgICBtYW5kYXRvcnk6ICEhb3B0aW9ucy5tYW5kYXRvcnksXG4gICAgaW1tZWRpYXRlOiBmYWxzZSwgLy8gUmFiYml0TVEgZG9lc24ndCBpbXBsZW1lbnQgdGhpcyBhbnkgbW9yZVxuICAgIHRpY2tldDogdW5kZWZpbmVkLFxuICAgIC8vIHByb3BlcnRpZXNcbiAgICBjb250ZW50VHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RW5jb2Rpbmc6IG9wdGlvbnMuY29udGVudEVuY29kaW5nLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgZGVsaXZlcnlNb2RlOiBkZWxpdmVyeU1vZGUsXG4gICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHksXG4gICAgY29ycmVsYXRpb25JZDogb3B0aW9ucy5jb3JyZWxhdGlvbklkLFxuICAgIHJlcGx5VG86IG9wdGlvbnMucmVwbHlUbyxcbiAgICBleHBpcmF0aW9uOiBleHBpcmF0aW9uLFxuICAgIG1lc3NhZ2VJZDogb3B0aW9ucy5tZXNzYWdlSWQsXG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCxcbiAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgdXNlcklkOiBvcHRpb25zLnVzZXJJZCxcbiAgICBhcHBJZDogb3B0aW9ucy5hcHBJZCxcbiAgICBjbHVzdGVySWQ6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuQXJncy5jb25zdW1lID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgdmFyIGFyZ3QgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuYXJndW1lbnRzIHx8IG51bGwpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtcHJpb3JpdHknLCBvcHRpb25zLnByaW9yaXR5KTtcbiAgcmV0dXJuIHtcbiAgICB0aWNrZXQ6IDAsXG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGNvbnN1bWVyVGFnOiBvcHRpb25zLmNvbnN1bWVyVGFnIHx8ICcnLFxuICAgIG5vTG9jYWw6ICEhb3B0aW9ucy5ub0xvY2FsLFxuICAgIG5vQWNrOiAhIW9wdGlvbnMubm9BY2ssXG4gICAgZXhjbHVzaXZlOiAhIW9wdGlvbnMuZXhjbHVzaXZlLFxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgYXJndW1lbnRzOiBhcmd0XG4gIH07XG59O1xuXG5BcmdzLmNhbmNlbCA9IGZ1bmN0aW9uKGNvbnN1bWVyVGFnKSB7XG4gIHJldHVybiB7XG4gICAgY29uc3VtZXJUYWc6IGNvbnN1bWVyVGFnLFxuICAgIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MuZ2V0ID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgcmV0dXJuIHtcbiAgICB0aWNrZXQ6IDAsXG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIG5vQWNrOiAhIW9wdGlvbnMubm9BY2tcbiAgfTtcbn07XG5cbkFyZ3MuYWNrID0gZnVuY3Rpb24odGFnLCBhbGxVcFRvKSB7XG4gIHJldHVybiB7XG4gICAgZGVsaXZlcnlUYWc6IHRhZyxcbiAgICBtdWx0aXBsZTogISFhbGxVcFRvXG4gIH07XG59O1xuXG5BcmdzLm5hY2sgPSBmdW5jdGlvbih0YWcsIGFsbFVwVG8sIHJlcXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWxpdmVyeVRhZzogdGFnLFxuICAgIG11bHRpcGxlOiAhIWFsbFVwVG8sXG4gICAgcmVxdWV1ZTogKHJlcXVldWUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogcmVxdWV1ZVxuICB9O1xufTtcblxuQXJncy5yZWplY3QgPSBmdW5jdGlvbih0YWcsIHJlcXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWxpdmVyeVRhZzogdGFnLFxuICAgIHJlcXVldWU6IChyZXF1ZXVlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IHJlcXVldWVcbiAgfTtcbn07XG5cbkFyZ3MucHJlZmV0Y2ggPSBmdW5jdGlvbihjb3VudCwgZ2xvYmFsKSB7XG4gIHJldHVybiB7XG4gICAgcHJlZmV0Y2hDb3VudDogY291bnQgfHwgMCxcbiAgICBwcmVmZXRjaFNpemU6IDAsXG4gICAgZ2xvYmFsOiAhIWdsb2JhbFxuICB9O1xufTtcblxuQXJncy5yZWNvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7cmVxdWV1ZTogdHJ1ZX07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoQXJncyk7XG4iLCIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGJpdHNldCBpbXBsZW1lbnRhdGlvbiwgYWZ0ZXIgdGhhdCBpbiBqYXZhLnV0aWwuICBZZXMgdGhlcmVcbiAqIGFscmVhZHkgZXhpc3Qgc3VjaCB0aGluZ3MsIGJ1dCBub25lIGltcGxlbWVudCBuZXh0e0NsZWFyfFNldH1CaXQgb3JcbiAqIGVxdWl2YWxlbnQsIGFuZCBub25lIGludm9sdmVkIG1lIHRvb2xpbmcgYWJvdXQgZm9yIGFuIGV2ZW5pbmcuXG4gKi9cbmNsYXNzIEJpdFNldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemVdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIGNvbnN0IG51bVdvcmRzID0gTWF0aC5jZWlsKHNpemUgLyAzMik7XG4gICAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KG51bVdvcmRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLndvcmRzID0gW107XG4gICAgfVxuICAgIHRoaXMud29yZHNJblVzZSA9IDA7IC8vID0gbnVtYmVyLCBub3QgaW5kZXhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtV29yZHNcbiAgICovXG4gIGVuc3VyZVNpemUobnVtV29yZHMpIHtcbiAgICBjb25zdCB3b3Jkc1ByZXNlbnQgPSB0aGlzLndvcmRzLmxlbmd0aDtcbiAgICBpZiAod29yZHNQcmVzZW50IDwgbnVtV29yZHMpIHtcbiAgICAgIHRoaXMud29yZHMgPSB0aGlzLndvcmRzLmNvbmNhdChuZXcgQXJyYXkobnVtV29yZHMgLSB3b3Jkc1ByZXNlbnQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdEluZGV4XG4gICAqL1xuICBzZXQoYml0SW5kZXgpIHtcbiAgICBjb25zdCB3ID0gd29yZEluZGV4KGJpdEluZGV4KTtcbiAgICBpZiAodyA+PSB0aGlzLndvcmRzSW5Vc2UpIHtcbiAgICAgIHRoaXMuZW5zdXJlU2l6ZSh3ICsgMSk7XG4gICAgICB0aGlzLndvcmRzSW5Vc2UgPSB3ICsgMTtcbiAgICB9XG4gICAgY29uc3QgYml0ID0gMSA8PCBiaXRJbmRleDtcbiAgICB0aGlzLndvcmRzW3ddIHw9IGJpdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0SW5kZXhcbiAgICovXG4gIGNsZWFyKGJpdEluZGV4KSB7XG4gICAgY29uc3QgdyA9IHdvcmRJbmRleChiaXRJbmRleCk7XG4gICAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm47XG4gICAgY29uc3QgbWFzayA9IH4oMSA8PCBiaXRJbmRleCk7XG4gICAgdGhpcy53b3Jkc1t3XSAmPSBtYXNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRJbmRleFxuICAgKi9cbiAgZ2V0KGJpdEluZGV4KSB7XG4gICAgY29uc3QgdyA9IHdvcmRJbmRleChiaXRJbmRleCk7XG4gICAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gZmFsc2U7IC8vID49IHNpbmNlIGluZGV4IHZzIHNpemVcbiAgICBjb25zdCBiaXQgPSAxIDw8IGJpdEluZGV4O1xuICAgIHJldHVybiAhISh0aGlzLndvcmRzW3ddICYgYml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlIHRoZSBuZXh0IGJpdCB0aGF0IGlzIHNldCBvbiBvciBhZnRlciBmcm9tSW5kZXgsIG9yIC0xIGlmIG5vIHN1Y2ggYml0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXhcbiAgICovXG4gIG5leHRTZXRCaXQoZnJvbUluZGV4KSB7XG4gICAgbGV0IHcgPSB3b3JkSW5kZXgoZnJvbUluZGV4KTtcbiAgICBpZiAodyA+PSB0aGlzLndvcmRzSW5Vc2UpIHJldHVybiAtMTtcblxuICAgIC8vIHRoZSByaWdodC1oYW5kIHNpZGUgaXMgc2hpZnRlZCB0byBvbmx5IHRlc3QgdGhlIGJpdHMgb2YgdGhlIGZpcnN0XG4gICAgLy8gd29yZCB0aGF0IGFyZSA+IGZyb21JbmRleFxuICAgIGxldCB3b3JkID0gdGhpcy53b3Jkc1t3XSAmICgweGZmZmZmZmZmIDw8IGZyb21JbmRleCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh3b3JkKSByZXR1cm4gKHcgKiAzMikgKyB0cmFpbGluZ1plcm9zKHdvcmQpO1xuICAgICAgdysrO1xuICAgICAgaWYgKHcgPT09IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIC0xO1xuICAgICAgd29yZCA9IHRoaXMud29yZHNbd107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXhcbiAgICovXG4gIG5leHRDbGVhckJpdChmcm9tSW5kZXgpIHtcbiAgICBsZXQgdyA9IHdvcmRJbmRleChmcm9tSW5kZXgpO1xuICAgIGlmICh3ID49IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIGZyb21JbmRleDtcblxuICAgIGxldCB3b3JkID0gfih0aGlzLndvcmRzW3ddKSAmICgweGZmZmZmZmZmIDw8IGZyb21JbmRleCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh3b3JkKSByZXR1cm4gKHcgKiAzMikgKyB0cmFpbGluZ1plcm9zKHdvcmQpO1xuICAgICAgdysrO1xuICAgICAgaWYgKHcgPT0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gdyAqIDMyO1xuICAgICAgd29yZCA9IH4odGhpcy53b3Jkc1t3XSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdEluZGV4XG4gKi9cbmZ1bmN0aW9uIHdvcmRJbmRleChiaXRJbmRleCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihiaXRJbmRleCAvIDMyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKGkpIHtcbiAgLy8gRnJvbSBIYWNrZXIncyBEZWxpZ2h0LCB2aWEgSkRLLiBQcm9iYWJseSBmYXIgbGVzcyBlZmZlY3RpdmUgaGVyZSxcbiAgLy8gc2luY2UgYml0IG9wcyBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBxdWljayB3YXkgdG8gZG8gdGhpbmdzIGluXG4gIC8vIEpTLlxuICBpZiAoaSA9PT0gMCkgcmV0dXJuIDMyO1xuICBsZXQgeSwgbiA9IDMxO1xuICB5ID0gaSA8PCAxNjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtMTY7IGkgPSB5OyB9XG4gIHkgPSBpIDw8IDg7ICBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gODsgaSA9IHk7IH1cbiAgeSA9IGkgPDwgNDsgIGlmICh5ICE9IDApIHsgbiA9IG4gLSA0OyBpID0geTsgfVxuICB5ID0gaSA8PCAyOyAgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDI7IGkgPSB5OyB9XG4gIHJldHVybiBuIC0gKChpIDw8IDEpID4+PiAzMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLkJpdFNldCA9IEJpdFNldDtcbiIsIi8vXG4vL1xuLy9cblxuLy8gQ2hhbm5lbCBtYWNoaW5lcnkuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciBjbG9zZU1zZyA9IHJlcXVpcmUoJy4vZm9ybWF0JykuY2xvc2VNZXNzYWdlO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLmluc3BlY3Q7XG52YXIgbWV0aG9kTmFtZSA9IHJlcXVpcmUoJy4vZm9ybWF0JykubWV0aG9kTmFtZTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgZm10ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcbnZhciBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xudmFyIHN0YWNrQ2FwdHVyZSA9IHJlcXVpcmUoJy4vZXJyb3InKS5zdGFja0NhcHR1cmU7XG5mdW5jdGlvbiBDaGFubmVsKGNvbm5lY3Rpb24pIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwoIHRoaXMgKTtcbiAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgLy8gZm9yIHRoZSBwcmVzZW50bHkgb3V0c3RhbmRpbmcgUlBDXG4gIHRoaXMucmVwbHkgPSBudWxsO1xuICAvLyBmb3IgdGhlIFJQQ3MgYXdhaXRpbmcgYWN0aW9uXG4gIHRoaXMucGVuZGluZyA9IFtdO1xuICAvLyBmb3IgdW5jb25maXJtZWQgbWVzc2FnZXNcbiAgdGhpcy5sd20gPSAxOyAvLyB0aGUgbGVhc3QsIHVuY29uZmlybWVkIGRlbGl2ZXJ5VGFnXG4gIHRoaXMudW5jb25maXJtZWQgPSBbXTsgLy8gcm9sbGluZyB3aW5kb3cgb2YgZGVsaXZlcnkgY2FsbGJhY2tzXG4gIHRoaXMub24oJ2FjaycsIHRoaXMuaGFuZGxlQ29uZmlybS5iaW5kKHRoaXMsIGZ1bmN0aW9uKGNiKSB7XG4gICAgaWYgKGNiKSBjYihudWxsKTtcbiAgfSkpO1xuICB0aGlzLm9uKCduYWNrJywgdGhpcy5oYW5kbGVDb25maXJtLmJpbmQodGhpcywgZnVuY3Rpb24oY2IpIHtcbiAgICBpZiAoY2IpIGNiKG5ldyBFcnJvcignbWVzc2FnZSBuYWNrZWQnKSk7XG4gIH0pKTtcbiAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNiO1xuICAgIHdoaWxlIChjYiA9IHRoaXMudW5jb25maXJtZWQuc2hpZnQoKSkge1xuICAgICAgaWYgKGNiKSBjYihuZXcgRXJyb3IoJ2NoYW5uZWwgY2xvc2VkJykpO1xuICAgIH1cbiAgfSlcbiAgLy8gbWVzc2FnZSBmcmFtZSBzdGF0ZSBtYWNoaW5lXG4gIHRoaXMuaGFuZGxlTWVzc2FnZSA9IGFjY2VwdERlbGl2ZXJ5T3JSZXR1cm47XG59XG5pbmhlcml0cyhDaGFubmVsLCBFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbDtcbm1vZHVsZS5leHBvcnRzLmFjY2VwdE1lc3NhZ2UgPSBhY2NlcHRNZXNzYWdlO1xuXG52YXIgQyA9IENoYW5uZWwucHJvdG90eXBlO1xuXG5DLmFsbG9jYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2ggPSB0aGlzLmNvbm5lY3Rpb24uZnJlc2hDaGFubmVsKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gSW5jb21pbmcgZnJhbWVzIGFyZSBlaXRoZXIgbm90aWZpY2F0aW9ucyBvZiBlLmcuLCBtZXNzYWdlIGRlbGl2ZXJ5LFxuLy8gb3IgcmVwbGllcyB0byBzb21ldGhpbmcgd2UndmUgc2VudC4gSW4gZ2VuZXJhbCBJIGRlYWwgd2l0aCB0aGVcbi8vIGZvcm1lciBieSBlbWl0dGluZyBhbiBldmVudCwgYW5kIHdpdGggdGhlIGxhdHRlciBieSBrZWVwaW5nIGEgdHJhY2tcbi8vIG9mIHdoYXQncyBleHBlY3RpbmcgYSByZXBseS5cbi8vXG4vLyBUaGUgQU1RUCBzcGVjaWZpY2F0aW9uIGltcGxpZXMgdGhhdCBSUENzIGNhbid0IGJlIHBpcGVsaW5lZDsgdGhhdFxuLy8gaXMsIHlvdSBjYW4gaGF2ZSBvbmx5IG9uZSBvdXRzdGFuZGluZyBSUEMgb24gYSBjaGFubmVsIGF0IGFcbi8vIHRpbWUuIENlcnRhaW5seSB0aGF0J3Mgd2hhdCBSYWJiaXRNUSBhbmQgaXRzIGNsaWVudHMgYXNzdW1lLiBGb3Jcbi8vIHRoaXMgcmVhc29uLCBJIGJ1ZmZlciBSUENzIGlmIHRoZSBjaGFubmVsIGlzIGFscmVhZHkgd2FpdGluZyBmb3IgYVxuLy8gcmVwbHkuXG5cbi8vIEp1c3Qgc2VuZCB0aGUgZGFtbiBmcmFtZS5cbkMuc2VuZEltbWVkaWF0ZWx5ID0gZnVuY3Rpb24obWV0aG9kLCBmaWVsZHMpIHtcbiAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kTWV0aG9kKHRoaXMuY2gsIG1ldGhvZCwgZmllbGRzKTtcbn07XG5cbi8vIEludmFyaWFudDogIXRoaXMucmVwbHkgLT4gcGVuZGluZy5sZW5ndGggPT0gMC4gVGhhdCBpcywgd2hlbmV2ZXIgd2Vcbi8vIGNsZWFyIGEgcmVwbHksIHdlIG11c3Qgc2VuZCBhbm90aGVyIFJQQyAoYW5kIHRoZXJlYnkgZmlsbFxuLy8gdGhpcy5yZXBseSkgaWYgdGhlcmUgaXMgb25lIHdhaXRpbmcuIFRoZSBpbnZhcmlhbnQgcmVsZXZhbnQgaGVyZVxuLy8gYW5kIGluIGBhY2NlcHRgLlxuQy5zZW5kT3JFbnF1ZXVlID0gZnVuY3Rpb24obWV0aG9kLCBmaWVsZHMsIHJlcGx5KSB7XG4gIGlmICghdGhpcy5yZXBseSkgeyAvLyBpZiBubyByZXBseSB3YWl0aW5nLCB3ZSBjYW4gZ29cbiAgICBhc3NlcnQodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMCk7XG4gICAgdGhpcy5yZXBseSA9IHJlcGx5O1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KG1ldGhvZCwgZmllbGRzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnBlbmRpbmcucHVzaCh7bWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICByZXBseTogcmVwbHl9KTtcbiAgfVxufTtcblxuQy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKGZpZWxkcywgcHJvcGVydGllcywgY29udGVudCkge1xuICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRNZXNzYWdlKFxuICAgIHRoaXMuY2gsXG4gICAgZGVmcy5CYXNpY1B1Ymxpc2gsIGZpZWxkcyxcbiAgICBkZWZzLkJhc2ljUHJvcGVydGllcywgcHJvcGVydGllcyxcbiAgICBjb250ZW50KTtcbn07XG5cbi8vIEludGVybmFsLCBzeW5jaHJvbm91c2x5IHJlc29sdmVkIFJQQzsgdGhlIHJldHVybiB2YWx1ZSBpcyByZXNvbHZlZFxuLy8gd2l0aCB0aGUgd2hvbGUgZnJhbWUuXG5DLl9ycGMgPSBmdW5jdGlvbihtZXRob2QsIGZpZWxkcywgZXhwZWN0LCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gcmVwbHkoZXJyLCBmKSB7XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgaWYgKGYuaWQgPT09IGV4cGVjdCkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgZik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhIHByb2JsZW0sIHNvIGl0J3MgdXAgdG8gdXMgdG8gY2xvc2UgdGhlXG4gICAgICAgIC8vIGNoYW5uZWxcbiAgICAgICAgdmFyIGV4cGVjdGVkTmFtZSA9IG1ldGhvZE5hbWUoZXhwZWN0KTtcblxuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihmbXQoXCJFeHBlY3RlZCAlczsgZ290ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZE5hbWUsIGluc3BlY3QoZiwgZmFsc2UpKSk7XG4gICAgICAgIHNlbGYuY2xvc2VXaXRoRXJyb3IoZi5pZCwgZm10KCdFeHBlY3RlZCAlczsgZ290ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWROYW1lLCBtZXRob2ROYW1lKGYuaWQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLmNvbnN0YW50cy5VTkVYUEVDVEVEX0ZSQU1FLCBlKTtcbiAgICAgICAgcmV0dXJuIGNiKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBbiBlcnJvciB3aWxsIGJlIGdpdmVuIGlmLCBmb3IgZXhhbXBsZSwgdGhpcyBpcyB3YWl0aW5nIHRvIGJlXG4gICAgLy8gc2VudCBhbmQgdGhlIGNvbm5lY3Rpb24gY2xvc2VzXG4gICAgZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBjYihlcnIpO1xuICAgIC8vIEEgY2xvc2UgZnJhbWUgd2lsbCBiZSBnaXZlbiBpZiB0aGlzIGlzIHRoZSBSUEMgYXdhaXRpbmcgcmVwbHlcbiAgICAvLyBhbmQgdGhlIGNoYW5uZWwgaXMgY2xvc2VkIGJ5IHRoZSBzZXJ2ZXJcbiAgICBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSwgaXQncyBhIGNsb3NlIGZyYW1lXG4gICAgICB2YXIgY2xvc2VSZWFzb24gPVxuICAgICAgICAoZXJyLmZpZWxkcy5jbGFzc0lkIDw8IDE2KSArIGVyci5maWVsZHMubWV0aG9kSWQ7XG4gICAgICB2YXIgZSA9IChtZXRob2QgPT09IGNsb3NlUmVhc29uKVxuICAgICAgICA/IGZtdChcIk9wZXJhdGlvbiBmYWlsZWQ6ICVzOyAlc1wiLFxuICAgICAgICAgICAgICBtZXRob2ROYW1lKG1ldGhvZCksIGNsb3NlTXNnKGVycikpXG4gICAgICAgIDogZm10KFwiQ2hhbm5lbCBjbG9zZWQgYnkgc2VydmVyOiAlc1wiLCBjbG9zZU1zZyhlcnIpKTtcbiAgICAgIHZhciBjbG9zZUZyYW1lRXJyb3IgPSBuZXcgRXJyb3IoZSk7XG4gICAgICBjbG9zZUZyYW1lRXJyb3IuY29kZSA9IGVyci5maWVsZHMucmVwbHlDb2RlO1xuICAgICAgY2xvc2VGcmFtZUVycm9yLmNsYXNzSWQgPSBlcnIuZmllbGRzLmNsYXNzSWQ7XG4gICAgICBjbG9zZUZyYW1lRXJyb3IubWV0aG9kSWQgPSBlcnIuZmllbGRzLm1ldGhvZElkO1xuICAgICAgcmV0dXJuIGNiKGNsb3NlRnJhbWVFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZW5kT3JFbnF1ZXVlKG1ldGhvZCwgZmllbGRzLCByZXBseSk7XG59O1xuXG4vLyBTaHV0ZG93biBwcm90b2NvbC4gVGhlcmUncyB0aHJlZSBzY2VuYXJpb3M6XG4vL1xuLy8gMS4gVGhlIGFwcGxpY2F0aW9uIGRlY2lkZXMgdG8gc2h1dCB0aGUgY2hhbm5lbFxuLy8gMi4gVGhlIHNlcnZlciBkZWNpZGVzIHRvIHNodXQgdGhlIGNoYW5uZWwsIHBvc3NpYmx5IGJlY2F1c2Ugb2Zcbi8vIHNvbWV0aGluZyB0aGUgYXBwbGljYXRpb24gZGlkXG4vLyAzLiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nLCBzbyB0aGVyZSB3b24ndCBiZSBhbnkgbW9yZSBmcmFtZXNcbi8vIGdvaW5nIGJhY2sgYW5kIGZvcnRoLlxuLy9cbi8vIDEgYW5kIDIgaW52b2x2ZSBhbiBleGNoYW5nZSBvZiBtZXRob2QgZnJhbWVzIChDbG9zZSBhbmQgQ2xvc2VPayksXG4vLyB3aGlsZSAzIGRvZXNuJ3Q7IHRoZSBjb25uZWN0aW9uIHNpbXBseSBzYXlzIFwic2h1dGRvd25cIiB0byB0aGVcbi8vIGNoYW5uZWwsIHdoaWNoIHRoZW4gYWN0cyBhcyBpZiBpdCdzIGNsb3NpbmcsIHdpdGhvdXQgZ29pbmcgdGhyb3VnaFxuLy8gdGhlIGV4Y2hhbmdlLlxuXG5mdW5jdGlvbiBpbnZhbGlkT3AobXNnLCBzdGFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihtc2csIHN0YWNrKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZVNlbmQoY2gsIG1zZywgc3RhY2spIHtcbiAgY2guc2VuZEltbWVkaWF0ZWx5ID0gY2guc2VuZE9yRW5xdWV1ZSA9IGNoLnNlbmRNZXNzYWdlID1cbiAgICBpbnZhbGlkT3AobXNnLCBzdGFjayk7XG59XG5cbi8vIE1vdmUgdG8gZW50aXJlbHkgY2xvc2VkIHN0YXRlLlxuQy50b0Nsb3NlZCA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2spIHtcbiAgdGhpcy5fcmVqZWN0UGVuZGluZygpO1xuICBpbnZhbGlkYXRlU2VuZCh0aGlzLCAnQ2hhbm5lbCBjbG9zZWQnLCBjYXB0dXJlZFN0YWNrKTtcbiAgdGhpcy5hY2NlcHQgPSBpbnZhbGlkT3AoJ0NoYW5uZWwgY2xvc2VkJywgY2FwdHVyZWRTdGFjayk7XG4gIHRoaXMuY29ubmVjdGlvbi5yZWxlYXNlQ2hhbm5lbCh0aGlzLmNoKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuLy8gU3RvcCBiZWluZyBhYmxlIHRvIHNlbmQgYW5kIHJlY2VpdmUgbWV0aG9kcyBhbmQgY29udGVudC4gVXNlZCB3aGVuXG4vLyB3ZSBjbG9zZSB0aGUgY2hhbm5lbC4gSW52b2tlcyB0aGUgY29udGludWF0aW9uIG9uY2UgdGhlIHNlcnZlciBoYXNcbi8vIGFja25vd2xlZGdlZCB0aGUgY2xvc2UsIGJ1dCBiZWZvcmUgdGhlIGNoYW5uZWwgaXMgbW92ZWQgdG8gdGhlXG4vLyBjbG9zZWQgc3RhdGUuXG5DLnRvQ2xvc2luZyA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2ssIGspIHtcbiAgdmFyIHNlbmQgPSB0aGlzLnNlbmRJbW1lZGlhdGVseS5iaW5kKHRoaXMpO1xuICBpbnZhbGlkYXRlU2VuZCh0aGlzLCAnQ2hhbm5lbCBjbG9zaW5nJywgY2FwdHVyZWRTdGFjayk7XG5cbiAgdGhpcy5hY2NlcHQgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYgKGYuaWQgPT09IGRlZnMuQ2hhbm5lbENsb3NlT2spIHtcbiAgICAgIGlmIChrKSBrKCk7XG4gICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnQ2hhbm5lbENsb3NlT2sgZnJhbWUgcmVjZWl2ZWQnKTtcbiAgICAgIHRoaXMudG9DbG9zZWQocyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQ2hhbm5lbENsb3NlKSB7XG4gICAgICBzZW5kKGRlZnMuQ2hhbm5lbENsb3NlT2ssIHt9KTtcbiAgICB9XG4gICAgLy8gZWxzZSBpZ25vcmUgZnJhbWVcbiAgfTtcbn07XG5cbkMuX3JlamVjdFBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gcmVqKHIpIHtcbiAgICByKG5ldyBFcnJvcihcIkNoYW5uZWwgZW5kZWQsIG5vIHJlcGx5IHdpbGwgYmUgZm9ydGhjb21pbmdcIikpO1xuICB9XG4gIGlmICh0aGlzLnJlcGx5ICE9PSBudWxsKSByZWoodGhpcy5yZXBseSk7XG4gIHRoaXMucmVwbHkgPSBudWxsO1xuXG4gIHZhciBkaXNjYXJkO1xuICB3aGlsZSAoZGlzY2FyZCA9IHRoaXMucGVuZGluZy5zaGlmdCgpKSByZWooZGlzY2FyZC5yZXBseSk7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7IC8vIHNvIHB1c2hlcyB3aWxsIGJyZWFrXG59O1xuXG5DLmNsb3NlQmVjYXVzZSA9IGZ1bmN0aW9uKHJlYXNvbiwgY29kZSwgaykge1xuICB0aGlzLnNlbmRJbW1lZGlhdGVseShkZWZzLkNoYW5uZWxDbG9zZSwge1xuICAgIHJlcGx5VGV4dDogcmVhc29uLFxuICAgIHJlcGx5Q29kZTogY29kZSxcbiAgICBtZXRob2RJZDowLCBjbGFzc0lkOiAwXG4gIH0pO1xuICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnY2xvc2VCZWNhdXNlIGNhbGxlZDogJyArIHJlYXNvbik7XG4gIHRoaXMudG9DbG9zaW5nKHMsIGspO1xufTtcblxuLy8gSWYgd2UgY2xvc2UgYmVjYXVzZSB0aGVyZSdzIGJlZW4gYW4gZXJyb3IsIHdlIG5lZWQgdG8gZGlzdGluZ3Vpc2hcbi8vIGJldHdlZW4gd2hhdCB3ZSB0ZWxsIHRoZSBzZXJ2ZXIgKGByZWFzb25gKSBhbmQgd2hhdCB3ZSByZXBvcnQgYXNcbi8vIHRoZSBjYXVzZSBpbiB0aGUgY2xpZW50IChgZXJyb3JgKS5cbkMuY2xvc2VXaXRoRXJyb3IgPSBmdW5jdGlvbihpZCwgcmVhc29uLCBjb2RlLCBlcnJvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuY2xvc2VCZWNhdXNlKHJlYXNvbiwgY29kZSwgZnVuY3Rpb24oKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgLy8gY29udGVudCBmcmFtZXMgYW5kIGNvbnN1bWVyIGVycm9ycyBkbyBub3QgcHJvdmlkZSBhIG1ldGhvZCBhIGNsYXNzL21ldGhvZCBJRFxuICAgIGlmIChpZCkge1xuICAgICAgZXJyb3IuY2xhc3NJZCA9IGRlZnMuaW5mbyhpZCkuY2xhc3NJZDtcbiAgICAgIGVycm9yLm1ldGhvZElkID0gZGVmcy5pbmZvKGlkKS5tZXRob2RJZDtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfSk7XG59O1xuXG4vLyBBIHRyYW1wb2xpbmluZyBzdGF0ZSBtYWNoaW5lIGZvciBtZXNzYWdlIGZyYW1lcyBvbiBhIGNoYW5uZWwuIEFcbi8vIG1lc3NhZ2UgYXJyaXZlcyBpbiBhdCBsZWFzdCB0d28gZnJhbWVzOiBmaXJzdCwgYSBtZXRob2QgYW5ub3VuY2luZ1xuLy8gdGhlIG1lc3NhZ2UgKGVpdGhlciBhIEJhc2ljRGVsaXZlciBvciBCYXNpY0dldE9rKTsgdGhlbiwgYSBtZXNzYWdlXG4vLyBoZWFkZXIgd2l0aCB0aGUgbWVzc2FnZSBwcm9wZXJ0aWVzOyB0aGVuLCB6ZXJvIG9yIG1vcmUgY29udGVudFxuLy8gZnJhbWVzLlxuXG4vLyBLZWVwIHRoZSB0cnkvY2F0Y2ggbG9jYWxpc2VkLCBpbiBhbiBhdHRlbXB0IHRvIGF2b2lkIGRpc2FibGluZ1xuLy8gb3B0aW1pc2F0aW9uXG5DLmFjY2VwdE1lc3NhZ2VGcmFtZSA9IGZ1bmN0aW9uKGYpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UoZik7XG4gIH1cbiAgY2F0Y2ggKG1zZykge1xuICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihmLmlkLCBtc2csIGRlZnMuY29uc3RhbnRzLlVORVhQRUNURURfRlJBTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihtc2cpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZi5pZCwgJ0Vycm9yIHdoaWxlIHByb2Nlc3NpbmcgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLklOVEVSTkFMX0VSUk9SLCBtc2cpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZi5pZCwgJ0ludGVybmFsIGVycm9yIHdoaWxlIHByb2Nlc3NpbmcgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLklOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IobXNnLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEtpY2sgb2ZmIGEgbWVzc2FnZSBkZWxpdmVyeSBnaXZlbiBhIEJhc2ljRGVsaXZlciBvciBCYXNpY1JldHVyblxuLy8gZnJhbWUgKEJhc2ljR2V0IHVzZXMgdGhlIFJQQyBtZWNoYW5pc20pXG5mdW5jdGlvbiBhY2NlcHREZWxpdmVyeU9yUmV0dXJuKGYpIHtcbiAgdmFyIGV2ZW50O1xuICBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY0RlbGl2ZXIpIGV2ZW50ID0gJ2RlbGl2ZXJ5JztcbiAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY1JldHVybikgZXZlbnQgPSAncmV0dXJuJztcbiAgZWxzZSB0aHJvdyBmbXQoXCJFeHBlY3RlZCBCYXNpY0RlbGl2ZXIgb3IgQmFzaWNSZXR1cm47IGdvdCAlc1wiLFxuICAgICAgICAgICAgICAgICBpbnNwZWN0KGYpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBmaWVsZHMgPSBmLmZpZWxkcztcbiAgcmV0dXJuIGFjY2VwdE1lc3NhZ2UoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIG1lc3NhZ2UuZmllbGRzID0gZmllbGRzO1xuICAgIHNlbGYuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBNb3ZlIHRvIHRoZSBzdGF0ZSBvZiB3YWl0aW5nIGZvciBtZXNzYWdlIGZyYW1lcyAoaGVhZGVycywgdGhlblxuLy8gb25lIG9yIG1vcmUgY29udGVudCBmcmFtZXMpXG5mdW5jdGlvbiBhY2NlcHRNZXNzYWdlKGNvbnRpbnVhdGlvbikge1xuICB2YXIgdG90YWxTaXplID0gMCwgcmVtYWluaW5nID0gMDtcbiAgdmFyIGJ1ZmZlcnMgPSBudWxsO1xuXG4gIHZhciBtZXNzYWdlID0ge1xuICAgIGZpZWxkczogbnVsbCxcbiAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGxcbiAgfTtcblxuICByZXR1cm4gaGVhZGVycztcblxuICAvLyBleHBlY3QgYSBoZWFkZXJzIGZyYW1lXG4gIGZ1bmN0aW9uIGhlYWRlcnMoZikge1xuICAgIGlmIChmLmlkID09PSBkZWZzLkJhc2ljUHJvcGVydGllcykge1xuICAgICAgbWVzc2FnZS5wcm9wZXJ0aWVzID0gZi5maWVsZHM7XG4gICAgICB0b3RhbFNpemUgPSByZW1haW5pbmcgPSBmLnNpemU7XG5cbiAgICAgIC8vIGZvciB6ZXJvLWxlbmd0aCBtZXNzYWdlcywgY29udGVudCBmcmFtZXMgYXJlbid0IHJlcXVpcmVkLlxuICAgICAgaWYgKHRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIGNvbnRpbnVhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGFjY2VwdERlbGl2ZXJ5T3JSZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgXCJFeHBlY3RlZCBoZWFkZXJzIGZyYW1lIGFmdGVyIGRlbGl2ZXJ5XCI7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwZWN0IGEgY29udGVudCBmcmFtZVxuICAvLyAlJSUgVE9ETyBjYW5jZWxsZWQgbWVzc2FnZXMgKHNlbnQgYXMgemVyby1sZW5ndGggY29udGVudCBmcmFtZSlcbiAgZnVuY3Rpb24gY29udGVudChmKSB7XG4gICAgaWYgKGYuY29udGVudCkge1xuICAgICAgdmFyIHNpemUgPSBmLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgcmVtYWluaW5nIC09IHNpemU7XG4gICAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGlmIChidWZmZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVycy5wdXNoKGYuY29udGVudCk7XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBmLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWF0aW9uKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYWNjZXB0RGVsaXZlcnlPclJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgdGhyb3cgZm10KFwiVG9vIG11Y2ggY29udGVudCBzZW50ISBFeHBlY3RlZCAlZCBieXRlc1wiLFxuICAgICAgICAgICAgICAgICAgdG90YWxTaXplKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVycyAhPT0gbnVsbClcbiAgICAgICAgICBidWZmZXJzLnB1c2goZi5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1ZmZlcnMgPSBbZi5jb250ZW50XTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgdGhyb3cgXCJFeHBlY3RlZCBjb250ZW50IGZyYW1lIGFmdGVyIGhlYWRlcnNcIlxuICB9XG59XG5cbkMuaGFuZGxlQ29uZmlybSA9IGZ1bmN0aW9uKGhhbmRsZSwgZikge1xuICB2YXIgdGFnID0gZi5kZWxpdmVyeVRhZztcbiAgdmFyIG11bHRpID0gZi5tdWx0aXBsZTtcblxuICBpZiAobXVsdGkpIHtcbiAgICB2YXIgY29uZmlybWVkID0gdGhpcy51bmNvbmZpcm1lZC5zcGxpY2UoMCwgdGFnIC0gdGhpcy5sd20gKyAxKTtcbiAgICB0aGlzLmx3bSA9IHRhZyArIDE7XG4gICAgY29uZmlybWVkLmZvckVhY2goaGFuZGxlKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgYztcbiAgICBpZiAodGFnID09PSB0aGlzLmx3bSkge1xuICAgICAgYyA9IHRoaXMudW5jb25maXJtZWQuc2hpZnQoKTtcbiAgICAgIHRoaXMubHdtKys7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBMV00gYW5kIHRoZSB3aW5kb3cgdG8gdGhlIG5leHQgbm9uLWdhcCwgb3JcbiAgICAgIC8vIHBvc3NpYmx5IHRvIHRoZSBlbmRcbiAgICAgIHdoaWxlICh0aGlzLnVuY29uZmlybWVkWzBdID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5jb25maXJtZWQuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5sd20rKztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjID0gdGhpcy51bmNvbmZpcm1lZFt0YWcgLSB0aGlzLmx3bV07XG4gICAgICB0aGlzLnVuY29uZmlybWVkW3RhZyAtIHRoaXMubHdtXSA9IG51bGw7XG4gICAgfVxuICAgIC8vIFRlY2huaWNhbGx5LCBpbiB0aGUgc2luZ2xlLWRlbGl2ZXJ5VGFnIGNhc2UsIEkgc2hvdWxkIHJlcG9ydCBhXG4gICAgLy8gcHJvdG9jb2wgYnJlYWNoIGlmIGl0J3MgYWxyZWFkeSBiZWVuIGNvbmZpcm1lZC5cbiAgICBoYW5kbGUoYyk7XG4gIH1cbn07XG5cbkMucHVzaENvbmZpcm1DYWxsYmFjayA9IGZ1bmN0aW9uKGNiKSB7XG4gIC8vIGBudWxsYCBpcyB1c2VkIHNwZWNpZmljYWxseSBmb3IgbWFya2luZyBhbHJlYWR5IGNvbmZpcm1lZCBzbG90cyxcbiAgLy8gc28gSSBjb2VyY2UgYHVuZGVmaW5lZGAgYW5kIGBudWxsYCB0byBmYWxzZTsgZnVuY3Rpb25zIGFyZSBuZXZlclxuICAvLyBmYWxzZXkuXG4gIHRoaXMudW5jb25maXJtZWQucHVzaChjYiB8fCBmYWxzZSk7XG59O1xuXG4vLyBJbnRlcmZhY2UgZm9yIGNvbm5lY3Rpb24gdG8gdXNlXG5cbkMuYWNjZXB0ID0gZnVuY3Rpb24oZikge1xuXG4gIHN3aXRjaCAoZi5pZCkge1xuXG4gICAgLy8gTWVzc2FnZSBmcmFtZXNcbiAgY2FzZSB1bmRlZmluZWQ6IC8vIGNvbnRlbnQgZnJhbWUhXG4gIGNhc2UgZGVmcy5CYXNpY0RlbGl2ZXI6XG4gIGNhc2UgZGVmcy5CYXNpY1JldHVybjpcbiAgY2FzZSBkZWZzLkJhc2ljUHJvcGVydGllczpcbiAgICByZXR1cm4gdGhpcy5hY2NlcHRNZXNzYWdlRnJhbWUoZik7XG5cbiAgICAvLyBjb25maXJtYXRpb25zLCBuZWVkIHRvIGRvIGNvbmZpcm0uc2VsZWN0IGZpcnN0XG4gIGNhc2UgZGVmcy5CYXNpY0FjazpcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdhY2snLCBmLmZpZWxkcyk7XG4gIGNhc2UgZGVmcy5CYXNpY05hY2s6XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnbmFjaycsIGYuZmllbGRzKTtcbiAgY2FzZSBkZWZzLkJhc2ljQ2FuY2VsOlxuICAgIC8vIFRoZSBicm9rZXIgY2FuIHNlbmQgdGhpcyBpZiBlLmcuLCB0aGUgcXVldWUgaXMgZGVsZXRlZC5cbiAgICByZXR1cm4gdGhpcy5lbWl0KCdjYW5jZWwnLCBmLmZpZWxkcyk7XG5cbiAgY2FzZSBkZWZzLkNoYW5uZWxDbG9zZTpcbiAgICAvLyBBbnkgcmVtb3RlIGNsb3N1cmUgaXMgYW4gZXJyb3IgdG8gdXMuIFJlamVjdCB0aGUgcGVuZGluZyByZXBseVxuICAgIC8vIHdpdGggdGhlIGNsb3NlIGZyYW1lLCBzbyBpdCBjYW4gc2VlIHdoZXRoZXIgaXQgd2FzIHRoYXRcbiAgICAvLyBvcGVyYXRpb24gdGhhdCBjYXVzZWQgaXQgdG8gY2xvc2UuXG4gICAgaWYgKHRoaXMucmVwbHkpIHtcbiAgICAgIHZhciByZXBseSA9IHRoaXMucmVwbHk7IHRoaXMucmVwbHkgPSBudWxsO1xuICAgICAgcmVwbHkoZik7XG4gICAgfVxuICAgIHZhciBlbXNnID0gXCJDaGFubmVsIGNsb3NlZCBieSBzZXJ2ZXI6IFwiICsgY2xvc2VNc2coZik7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5DaGFubmVsQ2xvc2VPaywge30pO1xuXG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVtc2cpO1xuICAgIGVycm9yLmNvZGUgPSBmLmZpZWxkcy5yZXBseUNvZGU7XG4gICAgZXJyb3IuY2xhc3NJZCA9IGYuZmllbGRzLmNsYXNzSWQ7XG4gICAgZXJyb3IubWV0aG9kSWQgPSBmLmZpZWxkcy5tZXRob2RJZDtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoZW1zZyk7XG4gICAgdGhpcy50b0Nsb3NlZChzKTtcbiAgICByZXR1cm47XG5cbiAgY2FzZSBkZWZzLkJhc2ljRmxvdzpcbiAgICAvLyBSYWJiaXRNUSBkb2Vzbid0IHNlbmQgdGhpcywgaXQganVzdCBibG9ja3MgdGhlIFRDUCBzb2NrZXRcbiAgICByZXR1cm4gdGhpcy5jbG9zZVdpdGhFcnJvcihmLmlkLCBcIkZsb3cgbm90IGltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5jb25zdGFudHMuTk9UX0lNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignRmxvdyBub3QgaW1wbGVtZW50ZWQnKSk7XG5cbiAgZGVmYXVsdDogLy8gYXNzdW1lIGFsbCBvdGhlciB0aGluZ3MgYXJlIHJlcGxpZXNcbiAgICAvLyBSZXNvbHZpbmcgdGhlIHJlcGx5IG1heSBsZWFkIHRvIGFub3RoZXIgUlBDOyB0byBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCBob2xkIHRoYXQgdXAsIGNsZWFyIHRoaXMucmVwbHlcbiAgICB2YXIgcmVwbHkgPSB0aGlzLnJlcGx5OyB0aGlzLnJlcGx5ID0gbnVsbDtcbiAgICAvLyBob3dldmVyLCBtYXliZSB0aGVyZSdzIGFuIFJQQyB3YWl0aW5nIHRvIGdvPyBJZiBzbywgdGhhdCdsbFxuICAgIC8vIGZpbGwgdGhpcy5yZXBseSBhZ2FpbiwgcmVzdG9yaW5nIHRoZSBpbnZhcmlhbnQuIFRoaXMgZG9lcyByZWx5XG4gICAgLy8gb24gYW55IHJlc3BvbnNlIGJlaW5nIHJlY3YnZWQgYWZ0ZXIgcmVzb2x2aW5nIHRoZSBwcm9taXNlLFxuICAgIC8vIGJlbG93OyBoZW5jZSwgSSB1c2Ugc3luY2hyb25vdXMgZGVmZXIuXG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgc2VuZCA9IHRoaXMucGVuZGluZy5zaGlmdCgpO1xuICAgICAgdGhpcy5yZXBseSA9IHNlbmQucmVwbHk7XG4gICAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShzZW5kLm1ldGhvZCwgc2VuZC5maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbHkobnVsbCwgZik7XG4gIH1cbn07XG5cbkMub25CdWZmZXJEcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2RyYWluJyk7XG59O1xuXG5cbi8vIFRoaXMgYWRkcyBqdXN0IGEgYml0IG1vcmUgc3R1ZmYgdXNlZnVsIGZvciB0aGUgQVBJcywgYnV0IG5vdFxuLy8gbG93LWxldmVsIG1hY2hpbmVyeS5cbmZ1bmN0aW9uIEJhc2VDaGFubmVsKGNvbm5lY3Rpb24pIHtcbiAgQ2hhbm5lbC5jYWxsKHRoaXMsIGNvbm5lY3Rpb24pO1xuICB0aGlzLmNvbnN1bWVycyA9IG5ldyBNYXAoKTtcbn1cbmluaGVyaXRzKEJhc2VDaGFubmVsLCBDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMuQmFzZUNoYW5uZWwgPSBCYXNlQ2hhbm5lbDtcblxuLy8gTm90IHN1cmUgSSBsaWtlIHRoZSBmZiwgaXQncyBnb2luZyB0byBiZSBjaGFuZ2luZyBoaWRkZW4gY2xhc3Nlc1xuLy8gYWxsIG92ZXIgdGhlIHBsYWNlLiBPbiB0aGUgb3RoZXIgaGFuZCwgd2hhZGR5YSBkby5cbkJhc2VDaGFubmVsLnByb3RvdHlwZS5yZWdpc3RlckNvbnN1bWVyID0gZnVuY3Rpb24odGFnLCBjYWxsYmFjaykge1xuICB0aGlzLmNvbnN1bWVycy5zZXQodGFnLCBjYWxsYmFjayk7XG59O1xuXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUudW5yZWdpc3RlckNvbnN1bWVyID0gZnVuY3Rpb24odGFnKSB7XG4gIHRoaXMuY29uc3VtZXJzLmRlbGV0ZSh0YWcpO1xufTtcblxuQmFzZUNoYW5uZWwucHJvdG90eXBlLmRpc3BhdGNoTWVzc2FnZSA9IGZ1bmN0aW9uKGZpZWxkcywgbWVzc2FnZSkge1xuICB2YXIgY29uc3VtZXJUYWcgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZhciBjb25zdW1lciA9IHRoaXMuY29uc3VtZXJzLmdldChjb25zdW1lclRhZyk7XG4gIGlmIChjb25zdW1lcikge1xuICAgIHJldHVybiBjb25zdW1lcihtZXNzYWdlKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyAlJSUgU3VyZWx5IGEgcmFjZSBoZXJlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb25zdW1lcjogXCIgKyBjb25zdW1lclRhZyk7XG4gIH1cbn07XG5cbkJhc2VDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVEZWxpdmVyeSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hNZXNzYWdlKG1lc3NhZ2UuZmllbGRzLCBtZXNzYWdlKTtcbn07XG5cbkJhc2VDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVDYW5jZWwgPSBmdW5jdGlvbihmaWVsZHMpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuZGlzcGF0Y2hNZXNzYWdlKGZpZWxkcywgbnVsbCk7XG4gIHRoaXMudW5yZWdpc3RlckNvbnN1bWVyKGZpZWxkcy5jb25zdW1lclRhZyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy9cbi8vXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgndXRpbCcpLnByb21pc2lmeTtcbmNvbnN0IGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbmNvbnN0IHtCYXNlQ2hhbm5lbH0gPSByZXF1aXJlKCcuL2NoYW5uZWwnKTtcbmNvbnN0IHthY2NlcHRNZXNzYWdlfSA9IHJlcXVpcmUoJy4vY2hhbm5lbCcpO1xuY29uc3QgQXJncyA9IHJlcXVpcmUoJy4vYXBpX2FyZ3MnKTtcbmNvbnN0IHtpbnNwZWN0fSA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5cbmNsYXNzIENoYW5uZWxNb2RlbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG5cbiAgICBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Jsb2NrZWQnLCAndW5ibG9ja2VkJ10uZm9yRWFjaChldiA9PiB7XG4gICAgICBjb25uZWN0aW9uLm9uKGV2LCB0aGlzLmVtaXQuYmluZCh0aGlzLCBldikpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLmNvbm5lY3Rpb24uY2xvc2UuYmluZCh0aGlzLmNvbm5lY3Rpb24pKSgpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQ2hhbm5lbCgpIHtcbiAgICBjb25zdCBjaGFubmVsID0gbmV3IENoYW5uZWwodGhpcy5jb25uZWN0aW9uKTtcbiAgICBhd2FpdCBjaGFubmVsLm9wZW4oKTtcbiAgICByZXR1cm4gY2hhbm5lbDtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUNvbmZpcm1DaGFubmVsKCkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgQ29uZmlybUNoYW5uZWwodGhpcy5jb25uZWN0aW9uKTtcbiAgICBhd2FpdCBjaGFubmVsLm9wZW4oKTtcbiAgICBhd2FpdCBjaGFubmVsLnJwYyhkZWZzLkNvbmZpcm1TZWxlY3QsIHtub3dhaXQ6IGZhbHNlfSwgZGVmcy5Db25maXJtU2VsZWN0T2spO1xuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG59XG5cbi8vIENoYW5uZWxzXG5cbmNsYXNzIENoYW5uZWwgZXh0ZW5kcyBCYXNlQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICBzdXBlcihjb25uZWN0aW9uKTtcbiAgICB0aGlzLm9uKCdkZWxpdmVyeScsIHRoaXMuaGFuZGxlRGVsaXZlcnkuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbignY2FuY2VsJywgdGhpcy5oYW5kbGVDYW5jZWwuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvLyBBbiBSUEMgdGhhdCByZXR1cm5zIGEgJ3Byb3BlcicgcHJvbWlzZSwgd2hpY2ggcmVzb2x2ZXMgdG8ganVzdCB0aGVcbiAgLy8gcmVzcG9uc2UncyBmaWVsZHM7IHRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgc3VpdGFibGUgZm9yIGltcGxlbWVudGluZ1xuICAvLyBBUEkgcHJvY2VkdXJlcy5cbiAgYXN5bmMgcnBjKG1ldGhvZCwgZmllbGRzLCBleHBlY3QpIHtcbiAgICBjb25zdCBmID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9ycGMobWV0aG9kLCBmaWVsZHMsIGV4cGVjdCwgY2IpO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gZi5maWVsZHM7XG4gIH1cblxuICAvLyBEbyB0aGUgcmVtYXJrYWJseSBzaW1wbGUgY2hhbm5lbCBvcGVuIGhhbmRzaGFrZVxuICBhc3luYyBvcGVuKCkge1xuICAgIGNvbnN0IGNoID0gYXdhaXQgdGhpcy5hbGxvY2F0ZS5iaW5kKHRoaXMpKCk7XG4gICAgcmV0dXJuIGNoLnJwYyhkZWZzLkNoYW5uZWxPcGVuLCB7b3V0T2ZCYW5kOiBcIlwifSxcbiAgICAgICAgICAgICAgICAgIGRlZnMuQ2hhbm5lbE9wZW5Payk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGNiID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsb3NlQmVjYXVzZShcIkdvb2RieWVcIiwgZGVmcy5jb25zdGFudHMuUkVQTFlfU1VDQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgICBjYik7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8vID09PSBQdWJsaWMgQVBJLCBkZWNsYXJpbmcgcXVldWVzIGFuZCBzdHVmZiA9PT1cblxuICBhc3NlcnRRdWV1ZShxdWV1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlRGVjbGFyZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5hc3NlcnRRdWV1ZShxdWV1ZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVEZWNsYXJlT2spO1xuICB9XG5cbiAgY2hlY2tRdWV1ZShxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlRGVjbGFyZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5jaGVja1F1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5RdWV1ZURlY2xhcmVPayk7XG4gIH1cblxuICBkZWxldGVRdWV1ZShxdWV1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlRGVsZXRlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmRlbGV0ZVF1ZXVlKHF1ZXVlLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5RdWV1ZURlbGV0ZU9rKTtcbiAgfVxuXG4gIHB1cmdlUXVldWUocXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZVB1cmdlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLnB1cmdlUXVldWUocXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlUHVyZ2VPayk7XG4gIH1cblxuICBiaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlQmluZCxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5iaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVCaW5kT2spO1xuICB9XG5cbiAgdW5iaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlVW5iaW5kLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLnVuYmluZFF1ZXVlKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlVW5iaW5kT2spO1xuICB9XG5cbiAgYXNzZXJ0RXhjaGFuZ2UoZXhjaGFuZ2UsIHR5cGUsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGUgc2VydmVyIHJlcGx5IGlzIGFuIGVtcHR5IHNldCBvZiBmaWVsZHMsIGJ1dCBpdCdzIGNvbnZlbmllbnRcbiAgICAvLyB0byBoYXZlIHRoZSBleGNoYW5nZSBuYW1lIGhhbmRlZCB0byB0aGUgY29udGludWF0aW9uLlxuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlRGVjbGFyZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5hc3NlcnRFeGNoYW5nZShleGNoYW5nZSwgdHlwZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuRXhjaGFuZ2VEZWNsYXJlT2spXG4gICAgICAudGhlbihfb2sgPT4geyByZXR1cm4geyBleGNoYW5nZSB9OyB9KTtcbiAgfVxuXG4gIGNoZWNrRXhjaGFuZ2UoZXhjaGFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZURlY2xhcmUsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuY2hlY2tFeGNoYW5nZShleGNoYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuRXhjaGFuZ2VEZWNsYXJlT2spO1xuICB9XG5cbiAgZGVsZXRlRXhjaGFuZ2UobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlRGVsZXRlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmRlbGV0ZUV4Y2hhbmdlKG5hbWUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlRGVsZXRlT2spO1xuICB9XG5cbiAgYmluZEV4Y2hhbmdlKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlQmluZCxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5iaW5kRXhjaGFuZ2UoZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZUJpbmRPayk7XG4gIH1cblxuICB1bmJpbmRFeGNoYW5nZShkZXN0LCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZVVuYmluZCxcbiAgICAgICAgICAgICAgICAgICAgQXJncy51bmJpbmRFeGNoYW5nZShkZXN0LCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlVW5iaW5kT2spO1xuICB9XG5cbiAgLy8gV29ya2luZyB3aXRoIG1lc3NhZ2VzXG5cbiAgcHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpZWxkc0FuZFByb3BzID0gQXJncy5wdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShmaWVsZHNBbmRQcm9wcywgZmllbGRzQW5kUHJvcHMsIGNvbnRlbnQpO1xuICB9XG5cbiAgc2VuZFRvUXVldWUocXVldWUsIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCcnLCBxdWV1ZSwgY29udGVudCwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdW1lKHF1ZXVlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIE5CIHdlIHdhbnQgdGhlIGNhbGxiYWNrIHRvIGJlIHJ1biBzeW5jaHJvbm91c2x5LCBzbyB0aGF0IHdlJ3ZlXG4gICAgLy8gcmVnaXN0ZXJlZCB0aGUgY29uc3VtZXJUYWcgYmVmb3JlIGFueSBtZXNzYWdlcyBjYW4gYXJyaXZlLlxuICAgIGNvbnN0IGZpZWxkcyA9IEFyZ3MuY29uc3VtZShxdWV1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3JwYyhkZWZzLkJhc2ljQ29uc3VtZSwgZmllbGRzLCBkZWZzLkJhc2ljQ29uc3VtZU9rLCAoZXJyLCBvaykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb25zdW1lcihvay5maWVsZHMuY29uc3VtZXJUYWcsIGNhbGxiYWNrKTtcbiAgICAgICAgcmVzb2x2ZShvay5maWVsZHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjYW5jZWwoY29uc3VtZXJUYWcpIHtcbiAgICBjb25zdCBvayA9IGF3YWl0IHByb21pc2lmeShjYiA9PiB7XG4gICAgICB0aGlzLl9ycGMoZGVmcy5CYXNpY0NhbmNlbCwgQXJncy5jYW5jZWwoY29uc3VtZXJUYWcpLFxuICAgICAgICAgICAgZGVmcy5CYXNpY0NhbmNlbE9rLFxuICAgICAgICAgICAgY2IpO1xuICAgIH0pKClcbiAgICAudGhlbihvayA9PiB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJDb25zdW1lcihjb25zdW1lclRhZyk7XG4gICAgICByZXR1cm4gb2suZmllbGRzO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0KHF1ZXVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmllbGRzID0gQXJncy5nZXQocXVldWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnNlbmRPckVucXVldWUoZGVmcy5CYXNpY0dldCwgZmllbGRzLCAoZXJyLCBmKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgaWYgKGYuaWQgPT09IGRlZnMuQmFzaWNHZXRFbXB0eSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkJhc2ljR2V0T2spIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSBmLmZpZWxkcztcbiAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSBhY2NlcHRNZXNzYWdlKG0gPT4ge1xuICAgICAgICAgICAgbS5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgICAgICByZXNvbHZlKG0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcmVzcG9uc2UgdG8gQmFzaWNHZXQ6ICR7aW5zcGVjdChmKX1gKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYWNrKG1lc3NhZ2UsIGFsbFVwVG8pIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShcbiAgICAgIGRlZnMuQmFzaWNBY2ssXG4gICAgICBBcmdzLmFjayhtZXNzYWdlLmZpZWxkcy5kZWxpdmVyeVRhZywgYWxsVXBUbykpO1xuICB9XG5cbiAgYWNrQWxsKCkge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KGRlZnMuQmFzaWNBY2ssIEFyZ3MuYWNrKDAsIHRydWUpKTtcbiAgfVxuXG4gIG5hY2sobWVzc2FnZSwgYWxsVXBUbywgcmVxdWV1ZSkge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KFxuICAgICAgZGVmcy5CYXNpY05hY2ssXG4gICAgICBBcmdzLm5hY2sobWVzc2FnZS5maWVsZHMuZGVsaXZlcnlUYWcsIGFsbFVwVG8sIHJlcXVldWUpKTtcbiAgfVxuXG4gIG5hY2tBbGwocmVxdWV1ZSkge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KGRlZnMuQmFzaWNOYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgIEFyZ3MubmFjaygwLCB0cnVlLCByZXF1ZXVlKSk7XG4gIH1cblxuICAvLyBgQmFzaWMuTmFja2AgaXMgbm90IGF2YWlsYWJsZSBpbiBvbGRlciBSYWJiaXRNUSB2ZXJzaW9ucyAob3IgaW4gdGhlXG4gIC8vIEFNUVAgc3BlY2lmaWNhdGlvbiksIHNvIHlvdSBoYXZlIHRvIHVzZSB0aGUgb25lLWF0LWEtdGltZVxuICAvLyBgQmFzaWMuUmVqZWN0YC4gVGhpcyBpcyBvdGhlcndpc2Ugc3lub255bW91cyB3aXRoXG4gIC8vIGAjbmFjayhtZXNzYWdlLCBmYWxzZSwgcmVxdWV1ZSlgLlxuICByZWplY3QobWVzc2FnZSwgcmVxdWV1ZSkge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KFxuICAgICAgZGVmcy5CYXNpY1JlamVjdCxcbiAgICAgIEFyZ3MucmVqZWN0KG1lc3NhZ2UuZmllbGRzLmRlbGl2ZXJ5VGFnLCByZXF1ZXVlKSk7XG4gIH1cblxuICByZWNvdmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkJhc2ljUmVjb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgQXJncy5yZWNvdmVyKCksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuQmFzaWNSZWNvdmVyT2spO1xuICB9XG5cbiAgcW9zKGNvdW50LCBnbG9iYWwpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5CYXNpY1FvcyxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5wcmVmZXRjaChjb3VudCwgZ2xvYmFsKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5CYXNpY1Fvc09rKTtcbiAgfVxufVxuXG4vLyBUaGVyZSBhcmUgbW9yZSBvcHRpb25zIGluIEFNUVAgdGhhbiBleHBvc2VkIGhlcmU7IFJhYmJpdE1RIG9ubHlcbi8vIGltcGxlbWVudHMgcHJlZmV0Y2ggYmFzZWQgb24gbWVzc2FnZSBjb3VudCwgYW5kIG9ubHkgZm9yIGluZGl2aWR1YWxcbi8vIGNoYW5uZWxzIG9yIGNvbnN1bWVycy4gUmFiYml0TVEgdjMuMy4wIGFuZCBhZnRlciB0cmVhdCBwcmVmZXRjaFxuLy8gKHdpdGhvdXQgYGdsb2JhbGAgc2V0KSBhcyBwZXItY29uc3VtZXIgKGZvciBjb25zdW1lcnMgZm9sbG93aW5nKSxcbi8vIGFuZCBwcmVmZXRjaCB3aXRoIGBnbG9iYWxgIHNldCBhcyBwZXItY2hhbm5lbC5cbkNoYW5uZWwucHJvdG90eXBlLnByZWZldGNoID0gQ2hhbm5lbC5wcm90b3R5cGUucW9zXG5cbi8vIENvbmZpcm0gY2hhbm5lbC4gVGhpcyBpcyBhIGNoYW5uZWwgd2l0aCBjb25maXJtcyAnc3dpdGNoZWQgb24nLFxuLy8gbWVhbmluZyBzZW50IG1lc3NhZ2VzIHdpbGwgcHJvdm9rZSBhIHJlc3BvbmRpbmcgJ2Fjaycgb3IgJ25hY2snXG4vLyBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSB1cHNob3Qgb2YgdGhpcyBpcyB0aGF0IGBwdWJsaXNoYCBhbmRcbi8vIGBzZW5kVG9RdWV1ZWAgYm90aCB0YWtlIGEgY2FsbGJhY2ssIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGVpdGhlclxuLy8gd2l0aCBgbnVsbGAgYXMgaXRzIGFyZ3VtZW50IHRvIHNpZ25pZnkgJ2FjaycsIG9yIGFuIGV4Y2VwdGlvbiBhc1xuLy8gaXRzIGFyZ3VtZW50IHRvIHNpZ25pZnkgJ25hY2snLlxuXG5jbGFzcyBDb25maXJtQ2hhbm5lbCBleHRlbmRzIENoYW5uZWwge1xuICBwdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zLCBjYikge1xuICAgIHRoaXMucHVzaENvbmZpcm1DYWxsYmFjayhjYik7XG4gICAgcmV0dXJuIENoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2guY2FsbCh0aGlzLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucyk7XG4gIH1cblxuICBzZW5kVG9RdWV1ZShxdWV1ZSwgY29udGVudCwgb3B0aW9ucywgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCcnLCBxdWV1ZSwgY29udGVudCwgb3B0aW9ucywgY2IpO1xuICB9XG5cbiAgd2FpdEZvckNvbmZpcm1zKCkge1xuICAgIGNvbnN0IGF3YWl0aW5nID0gW107XG4gICAgY29uc3QgdW5jb25maXJtZWQgPSB0aGlzLnVuY29uZmlybWVkO1xuICAgIHVuY29uZmlybWVkLmZvckVhY2goKHZhbCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29uZmlybWVkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHVuY29uZmlybWVkW2luZGV4XSA9IGVyciA9PiB7XG4gICAgICAgICAgICBpZiAodmFsKSB2YWwoZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGVsc2UgcmVqZWN0KGVycik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0aW5nLnB1c2goY29uZmlybWVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDaGFubmVsIGNsb3NlZFxuICAgIGlmICghdGhpcy5wZW5kaW5nKSB7XG4gICAgICB2YXIgY2I7XG4gICAgICB3aGlsZSAoY2IgPSB0aGlzLnVuY29uZmlybWVkLnNoaWZ0KCkpIHtcbiAgICAgICAgaWYgKGNiKSBjYihuZXcgRXJyb3IoJ2NoYW5uZWwgY2xvc2VkJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXdhaXRpbmcpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNvbmZpcm1DaGFubmVsID0gQ29uZmlybUNoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbDtcbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxNb2RlbCA9IENoYW5uZWxNb2RlbDtcbiIsIi8vXG4vL1xuLy9cblxuLypcblxuVGhlIEFNUVAgMC05LTEgaXMgYSBtZXNzIHdoZW4gaXQgY29tZXMgdG8gdGhlIHR5cGVzIHRoYXQgY2FuIGJlXG5lbmNvZGVkIG9uIHRoZSB3aXJlLlxuXG5UaGVyZSBhcmUgZm91ciBlbmNvZGluZyBzY2hlbWVzLCBhbmQgdGhyZWUgb3ZlcmxhcHBpbmcgc2V0cyBvZiB0eXBlczpcbmZyYW1lcywgbWV0aG9kcywgKGZpZWxkLSl0YWJsZXMsIGFuZCBwcm9wZXJ0aWVzLlxuXG5FYWNoICpmcmFtZSB0eXBlKiBoYXMgYSBzZXQgbGF5b3V0IGluIHdoaWNoIHZhbHVlcyBvZiBnaXZlbiB0eXBlcyBhcmVcbmNvbmNhdGVuYXRlZCBhbG9uZyB3aXRoIHNlY3Rpb25zIG9mIFwicmF3IGJpbmFyeVwiIGRhdGEuXG5cbkluIGZyYW1lcyB0aGVyZSBhcmUgYHNob3J0c3RyYHMsIHRoYXQgaXMgbGVuZ3RoLXByZWZpeGVkIHN0cmluZ3Mgb2ZcblVURjggY2hhcnMsIDggYml0IHVuc2lnbmVkIGludGVnZXJzIChjYWxsZWQgYG9jdGV0YCksIHVuc2lnbmVkIDE2IGJpdFxuaW50ZWdlcnMgKGNhbGxlZCBgc2hvcnRgIG9yIGBzaG9ydC11aW50YCksIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2Vyc1xuKGNhbGxlZCBgbG9uZ2Agb3IgYGxvbmctdWludGApLCB1bnNpZ25lZCA2NCBiaXQgaW50ZWdlcnMgKGNhbGxlZFxuYGxvbmdsb25nYCBvciBgbG9uZ2xvbmctdWludGApLCBhbmQgZmxhZ3MgKGNhbGxlZCBgYml0YCkuXG5cbk1ldGhvZHMgYXJlIGVuY29kZWQgYXMgYSBmcmFtZSBnaXZpbmcgYSBtZXRob2QgSUQgYW5kIGEgc2VxdWVuY2Ugb2ZcbmFyZ3VtZW50cyBvZiBrbm93biB0eXBlcy4gVGhlIGVuY29kZWQgbWV0aG9kIGFyZ3VtZW50IHZhbHVlcyBhcmVcbmNvbmNhdGVuYXRlZCAod2l0aCBzb21lIGZ1biBjb21wbGljYXRpb25zIGFyb3VuZCBcInBhY2tpbmdcIiBjb25zZWN1dGl2ZVxuYml0IHZhbHVlcyBpbnRvIGJ5dGVzKS5cblxuQWxvbmcgd2l0aCB0aGUgdHlwZXMgZ2l2ZW4gaW4gZnJhbWVzLCBtZXRob2QgYXJndW1lbnRzIG1heSBiZSBsb25nXG5ieXRlIHN0cmluZ3MgKGBsb25nc3RyYCwgbm90IHJlcXVpcmVkIHRvIGJlIFVURjgpIG9yIDY0IGJpdCB1bnNpZ25lZFxuaW50ZWdlcnMgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgdGltZXN0YW1wcyAoeWVhaCBJIGRvbid0IGtub3cgd2h5XG5laXRoZXIpLCBvciBhcmJpdHJhcnkgc2V0cyBvZiBrZXktdmFsdWUgcGFpcnMgKGNhbGxlZCBgZmllbGQtdGFibGVgKS5cblxuSW5zaWRlIGEgZmllbGQgdGFibGUgdGhlIGtleXMgYXJlIGBzaG9ydHN0cmAgYW5kIHRoZSB2YWx1ZXMgYXJlXG5wcmVmaXhlZCB3aXRoIGEgYnl0ZSB0YWcgZ2l2aW5nIHRoZSB0eXBlLiBUaGUgdHlwZXMgYXJlIGFueSBvZiB0aGVcbmFib3ZlIGV4Y2VwdCBmb3IgYml0cyAod2hpY2ggYXJlIHJlcGxhY2VkIGJ5IGJ5dGUtd2lkZSBgYm9vbGApLCBhbG9uZ1xud2l0aCBhIE5VTEwgdmFsdWUgYHZvaWRgLCBhIHNwZWNpYWwgZml4ZWQtcHJlY2lzaW9uIG51bWJlciBlbmNvZGluZ1xuKGBkZWNpbWFsYCksIElFRUU3NTQgYGZsb2F0YHMgYW5kIGBkb3VibGVgcywgc2lnbmVkIGludGVnZXJzLFxuYGZpZWxkLWFycmF5YCAoYSBzZXF1ZW5jZSBvZiB0YWdnZWQgdmFsdWVzKSwgYW5kIG5lc3RlZCBmaWVsZC10YWJsZXMuXG5cblJhYmJpdE1RIGFuZCBRUGlkIHVzZSBhIHN1YnNldCBvZiB0aGUgZmllbGQtdGFibGUgdHlwZXMsIGFuZCBkaWZmZXJlbnRcbnZhbHVlIHRhZ3MsIGVzdGFibGlzaGVkIGJlZm9yZSB0aGUgQU1RUCAwLTktMSBzcGVjaWZpY2F0aW9uIHdhc1xucHVibGlzaGVkLiBTbyBmYXIgYXMgSSBrbm93LCBuby1vbmUgdXNlcyB0aGUgdHlwZXMgYW5kIHRhZ3MgYXNcbnB1Ymxpc2hlZC4gaHR0cDovL3d3dy5yYWJiaXRtcS5jb20vYW1xcC0wLTktMS1lcnJhdGEuaHRtbCBnaXZlcyB0aGVcbmxpc3Qgb2YgZmllbGQtdGFibGUgdHlwZXMuXG5cbkxhc3RseSwgdGhlcmUgYXJlIChzZXRzIG9mKSBwcm9wZXJ0aWVzLCBvbmx5IG9uZSBvZiB3aGljaCBpcyBnaXZlbiBpblxuQU1RUCAwLTktMTogYEJhc2ljUHJvcGVydGllc2AuIFRoZXNlIGFyZSBhbG1vc3QgdGhlIHNhbWUgYXMgbWV0aG9kcyxcbmV4Y2VwdCB0aGF0IHRoZXkgYXBwZWFyIGluIGNvbnRlbnQgaGVhZGVyIGZyYW1lcywgd2hpY2ggaW5jbHVkZSBhXG5jb250ZW50IHNpemUsIGFuZCB0aGV5IGNhcnJ5IGEgc2V0IG9mIGZsYWdzIGluZGljYXRpbmcgd2hpY2hcbnByb3BlcnRpZXMgYXJlIHByZXNlbnQuIFRoaXMgc2NoZW1lIGNhbiBzYXZlIG9uZXMgb2YgYnl0ZXMgcGVyIG1lc3NhZ2VcbihtZXNzYWdlcyB3aGljaCB0YWtlIGEgbWluaW11bSBvZiB0aHJlZSBmcmFtZXMgZWFjaCB0byBzZW5kKS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50cyA9IHJlcXVpcmUoJ2J1ZmZlci1tb3JlLWludHMnKTtcblxuLy8gSmF2YVNjcmlwdCB1c2VzIG9ubHkgZG91YmxlcyBzbyB3aGF0IEknbSB0ZXN0aW5nIGZvciBpcyB3aGV0aGVyXG4vLyBpdCdzICpiZXR0ZXIqIHRvIGVuY29kZSBhIG51bWJlciBhcyBhIGZsb2F0IG9yIGRvdWJsZS4gVGhpcyByZWFsbHlcbi8vIGp1c3QgYW1vdW50cyB0byB0ZXN0aW5nIHdoZXRoZXIgdGhlcmUncyBhIGZyYWN0aW9uYWwgcGFydCB0byB0aGVcbi8vIG51bWJlciwgZXhjZXB0IHRoYXQgc2VlIGJlbG93LiBOQiBJIGRvbid0IHVzZSBiaXR3aXNlIG9wZXJhdGlvbnMgdG9cbi8vIGRvIHRoaXMgJ2VmZmljaWVudGx5JyAtLSBpdCB3b3VsZCBtYXNrIHRoZSBudW1iZXIgdG8gMzIgYml0cy5cbi8vXG4vLyBBdCAyXjUwLCBkb3VibGVzIGRvbid0IGhhdmUgc3VmZmljaWVudCBwcmVjaXNpb24gdG8gZGlzdGluZ3Vpc2hcbi8vIGJldHdlZW4gZmxvYXRpbmcgcG9pbnQgYW5kIGludGVnZXIgbnVtYmVycyAoYE1hdGgucG93KDIsIDUwKSArIDAuMVxuLy8gPT09IE1hdGgucG93KDIsIDUwKWAgKGFuZCwgYWJvdmUgMl41MywgZG91YmxlcyBjYW5ub3QgcmVwcmVzZW50IGFsbFxuLy8gaW50ZWdlcnMgKGBNYXRoLnBvdygyLCA1MykgKyAxID09PSBNYXRoLnBvdygyLCA1MylgKSkuIEhlbmNlXG4vLyBhbnl0aGluZyB3aXRoIGEgbWFnbml0dWRlIGF0IG9yIGFib3ZlIDJeNTAgbWF5IGFzIHdlbGwgYmUgZW5jb2RlZFxuLy8gYXMgYSA2NC1iaXQgaW50ZWdlci4gRXhjZXB0IHRoYXQgb25seSBzaWduZWQgaW50ZWdlcnMgYXJlIHN1cHBvcnRlZFxuLy8gYnkgUmFiYml0TVEsIHNvIGFueXRoaW5nIGFib3ZlIDJeNjMgLSAxIG11c3QgYmUgYSBkb3VibGUuXG5mdW5jdGlvbiBpc0Zsb2F0aW5nUG9pbnQobikge1xuICAgIHJldHVybiBuID49IDB4ODAwMDAwMDAwMDAwMDAwMCB8fFxuICAgICAgICAoTWF0aC5hYnMobikgPCAweDQwMDAwMDAwMDAwMDBcbiAgICAgICAgICYmIE1hdGguZmxvb3IobikgIT09IG4pO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUYWJsZShidWZmZXIsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xuICAgIG9mZnNldCArPSA0OyAvLyBsZWF2ZSByb29tIGZvciB0aGUgdGFibGUgbGVuZ3RoXG4gICAgZm9yICh2YXIga2V5IGluIHZhbCkge1xuICAgICAgICBpZiAodmFsW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChrZXkpO1xuICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KGxlbiwgb2Zmc2V0KTsgb2Zmc2V0Kys7XG4gICAgICAgICAgYnVmZmVyLndyaXRlKGtleSwgb2Zmc2V0LCAndXRmOCcpOyBvZmZzZXQgKz0gbGVuO1xuICAgICAgICAgIG9mZnNldCArPSBlbmNvZGVGaWVsZFZhbHVlKGJ1ZmZlciwgdmFsW2tleV0sIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNpemUgPSBvZmZzZXQgLSBzdGFydDtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShzaXplIC0gNCwgc3RhcnQpO1xuICAgIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVBcnJheShidWZmZXIsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xuICAgIG9mZnNldCArPSA0O1xuICAgIGZvciAodmFyIGk9MCwgbnVtPXZhbC5sZW5ndGg7IGkgPCBudW07IGkrKykge1xuICAgICAgICBvZmZzZXQgKz0gZW5jb2RlRmllbGRWYWx1ZShidWZmZXIsIHZhbFtpXSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSBvZmZzZXQgLSBzdGFydDtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShzaXplIC0gNCwgc3RhcnQpO1xuICAgIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVGaWVsZFZhbHVlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSwgdmFsID0gdmFsdWU7XG4gICAgLy8gQSB0cmFwZG9vciBmb3Igc3BlY2lmeWluZyBhIHR5cGUsIGUuZy4sIHRpbWVzdGFtcFxuICAgIGlmICh2YWx1ZSAmJiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnIScpKSB7XG4gICAgICAgIHZhbCA9IHZhbHVlLnZhbHVlO1xuICAgICAgICB0eXBlID0gdmFsdWVbJyEnXTtcbiAgICB9XG5cbiAgICAvLyBJZiBpdCdzIGEgSlMgbnVtYmVyLCB3ZSdsbCBoYXZlIHRvIGd1ZXNzIHdoYXQgdHlwZSB0byBlbmNvZGUgaXRcbiAgICAvLyBhcy5cbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBNYWtpbmcgYXNzdW1wdGlvbnMgYWJvdXQgdGhlIGtpbmQgb2YgbnVtYmVyIChmbG9hdGluZyBwb2ludFxuICAgICAgICAvLyB2IGludGVnZXIsIHNpZ25lZCwgdW5zaWduZWQsIHNpemUpIGRlc2lyZWQgaXMgZGFuZ2Vyb3VzIGluXG4gICAgICAgIC8vIGdlbmVyYWw7IGhvd2V2ZXIsIGluIHByYWN0aWNlIFJhYmJpdE1RIHVzZXMgb25seVxuICAgICAgICAvLyBsb25nc3RyaW5ncyBhbmQgdW5zaWduZWQgaW50ZWdlcnMgaW4gaXRzIGFyZ3VtZW50cywgYW5kXG4gICAgICAgIC8vIG90aGVyIGNsaWVudHMgZ2VuZXJhbGx5IGNvbmZsYXRlIG51bWJlciB0eXBlcyBhbnl3YXkuIFNvXG4gICAgICAgIC8vIHRoZSBvbmx5IGRpc3RpbmN0aW9uIHdlIGNhcmUgYWJvdXQgaXMgZmxvYXRpbmcgcG9pbnQgdnNcbiAgICAgICAgLy8gaW50ZWdlcnMsIHByZWZlcnJpbmcgaW50ZWdlcnMgc2luY2UgdGhvc2UgY2FuIGJlIHByb21vdGVkXG4gICAgICAgIC8vIGlmIG5lY2Vzc2FyeS4gSWYgZmxvYXRpbmcgcG9pbnQgaXMgcmVxdWlyZWQsIHdlIG1heSBhcyB3ZWxsXG4gICAgICAgIC8vIHVzZSBkb3VibGUgcHJlY2lzaW9uLlxuICAgICAgICBpZiAoaXNGbG9hdGluZ1BvaW50KHZhbCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnZG91YmxlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gb25seSBzaWduZWQgdmFsdWVzIGFyZSB1c2VkIGluIHRhYmxlcyBieVxuICAgICAgICAgICAgICAgLy8gUmFiYml0TVEuIEl0ICp1c2VkKiB0byAoPCB2My4zLjApIHRyZWF0IHRoZSBieXRlICdiJ1xuICAgICAgICAgICAgICAgLy8gdHlwZSBhcyB1bnNpZ25lZCwgYnV0IG1vc3QgY2xpZW50cyAoYW5kIHRoZSBzcGVjKVxuICAgICAgICAgICAgICAgLy8gdGhpbmsgaXQncyBzaWduZWQsIGFuZCBub3cgUmFiYml0TVEgZG9lcyB0b28uXG4gICAgICAgICAgICBpZiAodmFsIDwgMTI4ICYmIHZhbCA+PSAtMTI4KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdieXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+PSAtMHg4MDAwICYmIHZhbCA8IDB4ODAwMCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnc2hvcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPj0gLTB4ODAwMDAwMDAgJiYgdmFsIDwgMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnaW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnbG9uZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0YWcodCkgeyBidWZmZXIud3JpdGUodCwgb2Zmc2V0KTsgb2Zmc2V0Kys7IH1cblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6IC8vIG5vIHNob3J0c3RyIGluIGZpZWxkIHRhYmxlc1xuICAgICAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCAndXRmOCcpO1xuICAgICAgICB0YWcoJ1MnKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCAndXRmOCcpOyBvZmZzZXQgKz0gbGVuO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0YWcoJ1YnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIHRhZygnQScpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGVuY29kZUFycmF5KGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgICAgICAgICB0YWcoJ3gnKTtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbC5sZW5ndGgsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpOyBvZmZzZXQgKz0gdmFsLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZygnRicpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGVuY29kZVRhYmxlKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICB0YWcoJ3QnKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoKHZhbCkgPyAxIDogMCwgb2Zmc2V0KTsgb2Zmc2V0Kys7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIFRoZXNlIGFyZSB0aGUgdHlwZXMgdGhhdCBhcmUgZWl0aGVyIGd1ZXNzZWQgYWJvdmUsIG9yXG4gICAgLy8gZXhwbGljaXRseSBnaXZlbiB1c2luZyB0aGUgeychJzogdHlwZX0gbm90YXRpb24uXG4gICAgY2FzZSAnZG91YmxlJzpcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgdGFnKCdkJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZURvdWJsZUJFKHZhbCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2J5dGUnOlxuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICB0YWcoJ2InKTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50OCh2YWwsIG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdzaG9ydCc6XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgICB0YWcoJ3MnKTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MTZCRSh2YWwsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdpbnQnOlxuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgdGFnKCdJJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDMyQkUodmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbG9uZyc6XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgICB0YWcoJ2wnKTtcbiAgICAgICAgaW50cy53cml0ZUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICBicmVhaztcblxuICAgIC8vIE5vdyBmb3IgZXhvdGljIHR5cGVzLCB0aG9zZSBjYW4gX29ubHlfIGJlIGRlbm90ZWQgYnkgdXNpbmdcbiAgICAvLyBgeychJzogdHlwZSwgdmFsdWU6IHZhbH1cbiAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICB0YWcoJ1QnKTtcbiAgICAgICAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICB0YWcoJ2YnKTtcbiAgICAgICAgYnVmZmVyLndyaXRlRmxvYXRCRSh2YWwsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgdGFnKCdEJyk7XG4gICAgICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkoJ3BsYWNlcycpICYmIHZhbC5oYXNPd25Qcm9wZXJ0eSgnZGlnaXRzJylcbiAgICAgICAgICAgICYmIHZhbC5wbGFjZXMgPj0gMCAmJiB2YWwucGxhY2VzIDwgMjU2KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbC5wbGFjZXM7IG9mZnNldCsrO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLmRpZ2l0cywgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCJEZWNpbWFsIHZhbHVlIG11c3QgYmUgeydwbGFjZXMnOiAwLi4yNTUsICdkaWdpdHMnOiB1aW50MzJ9LCBcIiArXG4gICAgICAgICAgICAgICAgXCJnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biB0eXBlIHRvIGVuY29kZTogJyArIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XG59XG5cbi8vIEFzc3VtZSB3ZSdyZSBnaXZlbiBhIHNsaWNlIG9mIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyBqdXN0IHRoZVxuLy8gZmllbGRzLlxuZnVuY3Rpb24gZGVjb2RlRmllbGRzKHNsaWNlKSB7XG4gICAgdmFyIGZpZWxkcyA9IHt9LCBvZmZzZXQgPSAwLCBzaXplID0gc2xpY2UubGVuZ3RoO1xuICAgIHZhciBsZW4sIGtleSwgdmFsO1xuXG4gICAgZnVuY3Rpb24gZGVjb2RlRmllbGRWYWx1ZSgpIHtcbiAgICAgICAgdmFyIHRhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc2xpY2Vbb2Zmc2V0XSk7IG9mZnNldCsrO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWRJbnQ4KG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgbGVuID0gc2xpY2UucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdmFsID0gc2xpY2UudG9TdHJpbmcoJ3V0ZjgnLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgdmFsID0gc2xpY2UucmVhZEludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRCc6IC8vIG9ubHkgcG9zaXRpdmUgZGVjaW1hbHMsIGFwcGFyZW50bHkuXG4gICAgICAgICAgICB2YXIgcGxhY2VzID0gc2xpY2Vbb2Zmc2V0XTsgb2Zmc2V0Kys7XG4gICAgICAgICAgICB2YXIgZGlnaXRzID0gc2xpY2UucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdmFsID0geychJzogJ2RlY2ltYWwnLCB2YWx1ZToge3BsYWNlczogcGxhY2VzLCBkaWdpdHM6IGRpZ2l0c319O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdmFsID0gaW50cy5yZWFkVUludDY0QkUoc2xpY2UsIG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFsID0geychJzogJ3RpbWVzdGFtcCcsIHZhbHVlOiB2YWx9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgbGVuID0gc2xpY2UucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdmFsID0gZGVjb2RlRmllbGRzKHNsaWNlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgbGVuID0gc2xpY2UucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgZGVjb2RlQXJyYXkob2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgICAgIC8vIE5CIGRlY29kZUFycmF5IHdpbGwgaXRzZWxmIHVwZGF0ZSBvZmZzZXQgYW5kIHZhbFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgdmFsID0gc2xpY2UucmVhZERvdWJsZUJFKG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgdmFsID0gc2xpY2UucmVhZEZsb2F0QkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICB2YWwgPSBpbnRzLnJlYWRJbnQ2NEJFKHNsaWNlLCBvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWRJbnQxNkJFKG9mZnNldCk7IG9mZnNldCArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgdmFsID0gc2xpY2Vbb2Zmc2V0XSAhPSAwOyBvZmZzZXQrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBsZW4gPSBzbGljZS5yZWFkVUludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIHR5cGUgdGFnIFwiJyArIHRhZyArJ1wiJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvZGVBcnJheSh1bnRpbCkge1xuICAgICAgICB2YXIgdmFscyA9IFtdO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgdW50aWwpIHtcbiAgICAgICAgICAgIGRlY29kZUZpZWxkVmFsdWUoKTtcbiAgICAgICAgICAgIHZhbHMucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9IHZhbHM7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IHNpemUpIHtcbiAgICAgICAgbGVuID0gc2xpY2UucmVhZFVJbnQ4KG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICBrZXkgPSBzbGljZS50b1N0cmluZygndXRmOCcsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgZGVjb2RlRmllbGRWYWx1ZSgpO1xuICAgICAgICBmaWVsZHNba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlVGFibGUgPSBlbmNvZGVUYWJsZTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZUZpZWxkcyA9IGRlY29kZUZpZWxkcztcbiIsIi8vXG4vL1xuLy9cblxuLy8gR2VuZXJhbC1wdXJwb3NlIEFQSSBmb3IgZ2x1ZWluZyBldmVyeXRoaW5nIHRvZ2V0aGVyLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcbnZhciBRUyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG52YXIgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpLkNvbm5lY3Rpb247XG52YXIgZm10ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcbnZhciBjcmVkZW50aWFscyA9IHJlcXVpcmUoJy4vY3JlZGVudGlhbHMnKTtcblxuZnVuY3Rpb24gY29weUludG8ob2JqLCB0YXJnZXQpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBBZGFwdGVkIGZyb20gdXRpbC5fZXh0ZW5kLCB3aGljaCBpcyB0b28gZnJpbmdlIHRvIHVzZS5cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICByZXR1cm4gY29weUludG8ob2JqLCB7fSk7XG59XG5cbnZhciBDTElFTlRfUFJPUEVSVElFUyA9IHtcbiAgXCJwcm9kdWN0XCI6IFwiYW1xcGxpYlwiLFxuICBcInZlcnNpb25cIjogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbiAgXCJwbGF0Zm9ybVwiOiBmbXQoJ05vZGUuSlMgJXMnLCBwcm9jZXNzLnZlcnNpb24pLFxuICBcImluZm9ybWF0aW9uXCI6IFwiaHR0cDovL3NxdWFyZW1vLmdpdGh1Yi5pby9hbXFwLm5vZGVcIixcbiAgXCJjYXBhYmlsaXRpZXNcIjoge1xuICAgIFwicHVibGlzaGVyX2NvbmZpcm1zXCI6IHRydWUsXG4gICAgXCJleGNoYW5nZV9leGNoYW5nZV9iaW5kaW5nc1wiOiB0cnVlLFxuICAgIFwiYmFzaWMubmFja1wiOiB0cnVlLFxuICAgIFwiY29uc3VtZXJfY2FuY2VsX25vdGlmeVwiOiB0cnVlLFxuICAgIFwiY29ubmVjdGlvbi5ibG9ja2VkXCI6IHRydWUsXG4gICAgXCJhdXRoZW50aWNhdGlvbl9mYWlsdXJlX2Nsb3NlXCI6IHRydWVcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0IHRoZSBtYWluIGZyYW1lcyB1c2VkIGluIHRoZSBvcGVuaW5nIGhhbmRzaGFrZVxuZnVuY3Rpb24gb3BlbkZyYW1lcyh2aG9zdCwgcXVlcnksIGNyZWRlbnRpYWxzLCBleHRyYUNsaWVudFByb3BlcnRpZXMpIHtcbiAgaWYgKCF2aG9zdClcbiAgICB2aG9zdCA9ICcvJztcbiAgZWxzZVxuICAgIHZob3N0ID0gUVMudW5lc2NhcGUodmhvc3QpO1xuXG4gIHZhciBxdWVyeSA9IHF1ZXJ5IHx8IHt9O1xuXG4gIGZ1bmN0aW9uIGludE9yRGVmYXVsdCh2YWwsIGRlZikge1xuICAgIHJldHVybiAodmFsID09PSB1bmRlZmluZWQpID8gZGVmIDogcGFyc2VJbnQodmFsKTtcbiAgfVxuXG4gIHZhciBjbGllbnRQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShDTElFTlRfUFJPUEVSVElFUyk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFydC1va1xuICAgICdjbGllbnRQcm9wZXJ0aWVzJzogY29weUludG8oZXh0cmFDbGllbnRQcm9wZXJ0aWVzLCBjbGllbnRQcm9wZXJ0aWVzKSxcbiAgICAnbWVjaGFuaXNtJzogY3JlZGVudGlhbHMubWVjaGFuaXNtLFxuICAgICdyZXNwb25zZSc6IGNyZWRlbnRpYWxzLnJlc3BvbnNlKCksXG4gICAgJ2xvY2FsZSc6IHF1ZXJ5LmxvY2FsZSB8fCAnZW5fVVMnLFxuXG4gICAgLy8gdHVuZS1va1xuICAgICdjaGFubmVsTWF4JzogaW50T3JEZWZhdWx0KHF1ZXJ5LmNoYW5uZWxNYXgsIDApLFxuICAgICdmcmFtZU1heCc6IGludE9yRGVmYXVsdChxdWVyeS5mcmFtZU1heCwgMHgxMDAwKSxcbiAgICAnaGVhcnRiZWF0JzogaW50T3JEZWZhdWx0KHF1ZXJ5LmhlYXJ0YmVhdCwgMCksXG5cbiAgICAvLyBvcGVuXG4gICAgJ3ZpcnR1YWxIb3N0Jzogdmhvc3QsXG4gICAgJ2NhcGFiaWxpdGllcyc6ICcnLFxuICAgICdpbnNpc3QnOiAwXG4gIH07XG59XG5cbi8vIERlY2lkZSBvbiBjcmVkZW50aWFscyBiYXNlZCBvbiB3aGF0IHdlJ3JlIHN1cHBsaWVkLlxuZnVuY3Rpb24gY3JlZGVudGlhbHNGcm9tVXJsKHBhcnRzKSB7XG4gIHZhciB1c2VyID0gJ2d1ZXN0JywgcGFzc3dkID0gJ2d1ZXN0JztcbiAgaWYgKHBhcnRzLnVzZXJuYW1lICE9ICcnIHx8IHBhcnRzLnBhc3N3b3JkICE9ICcnKSB7XG4gICAgdXNlciA9IChwYXJ0cy51c2VybmFtZSkgPyB1bmVzY2FwZShwYXJ0cy51c2VybmFtZSkgOiAnJztcbiAgICBwYXNzd2QgPSAocGFydHMucGFzc3dvcmQpID8gdW5lc2NhcGUocGFydHMucGFzc3dvcmQpIDogJyc7XG4gIH1cbiAgcmV0dXJuIGNyZWRlbnRpYWxzLnBsYWluKHVzZXIsIHBhc3N3ZCk7XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QodXJsLCBzb2NrZXRPcHRpb25zLCBvcGVuQ2FsbGJhY2spIHtcbiAgLy8gdGxzLmNvbm5lY3QgdXNlcyBgdXRpbC5fZXh0ZW5kKClgIG9uIHRoZSBvcHRpb25zIGdpdmVuIGl0LCB3aGljaFxuICAvLyBjb3BpZXMgb25seSBwcm9wZXJ0aWVzIG1lbnRpb25lZCBpbiBgT2JqZWN0LmtleXMoKWAsIHdoZW5cbiAgLy8gcHJvY2Vzc2luZyB0aGUgb3B0aW9ucy4gU28gSSBoYXZlIHRvIG1ha2UgY29waWVzIHRvbywgcmF0aGVyXG4gIC8vIHRoYW4gdXNpbmcgYE9iamVjdC5jcmVhdGUoKWAuXG4gIHZhciBzb2Nrb3B0cyA9IGNsb25lKHNvY2tldE9wdGlvbnMgfHwge30pO1xuICB1cmwgPSB1cmwgfHwgJ2FtcXA6Ly9sb2NhbGhvc3QnO1xuXG4gIHZhciBub0RlbGF5ID0gISFzb2Nrb3B0cy5ub0RlbGF5O1xuICB2YXIgdGltZW91dCA9IHNvY2tvcHRzLnRpbWVvdXQ7XG4gIHZhciBrZWVwQWxpdmUgPSAhIXNvY2tvcHRzLmtlZXBBbGl2ZTtcbiAgLy8gMCBpcyBkZWZhdWx0IGZvciBub2RlXG4gIHZhciBrZWVwQWxpdmVEZWxheSA9IHNvY2tvcHRzLmtlZXBBbGl2ZURlbGF5IHx8IDA7XG5cbiAgdmFyIGV4dHJhQ2xpZW50UHJvcGVydGllcyA9IHNvY2tvcHRzLmNsaWVudFByb3BlcnRpZXMgfHwge307XG5cbiAgdmFyIHByb3RvY29sLCBmaWVsZHM7XG4gIGlmICh0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgIHByb3RvY29sID0gKHVybC5wcm90b2NvbCB8fCAnYW1xcCcpICsgJzonO1xuICAgIHNvY2tvcHRzLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgc29ja29wdHMuc2VydmVybmFtZSA9IHNvY2tvcHRzLnNlcnZlcm5hbWUgfHwgdXJsLmhvc3RuYW1lO1xuICAgIHNvY2tvcHRzLnBvcnQgPSB1cmwucG9ydCB8fCAoKHByb3RvY29sID09PSAnYW1xcDonKSA/IDU2NzIgOiA1NjcxKTtcblxuICAgIHZhciB1c2VyLCBwYXNzO1xuICAgIC8vIE9ubHkgZGVmYXVsdCBpZiBib3RoIGFyZSBtaXNzaW5nLCB0byBoYXZlIHRoZSBzYW1lIGJlaGF2aW91ciBhc1xuICAgIC8vIHRoZSBzdHJpbmdseSBVUkwuXG4gICAgaWYgKHVybC51c2VybmFtZSA9PSB1bmRlZmluZWQgJiYgdXJsLnBhc3N3b3JkID09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlciA9ICdndWVzdCc7IHBhc3MgPSAnZ3Vlc3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyID0gdXJsLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgcGFzcyA9IHVybC5wYXNzd29yZCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgbG9jYWxlOiB1cmwubG9jYWxlLFxuICAgICAgY2hhbm5lbE1heDogdXJsLmNoYW5uZWxNYXgsXG4gICAgICBmcmFtZU1heDogdXJsLmZyYW1lTWF4LFxuICAgICAgaGVhcnRiZWF0OiB1cmwuaGVhcnRiZWF0LFxuICAgIH07XG5cbiAgICBmaWVsZHMgPSBvcGVuRnJhbWVzKHVybC52aG9zdCwgY29uZmlnLCBzb2Nrb3B0cy5jcmVkZW50aWFscyB8fCBjcmVkZW50aWFscy5wbGFpbih1c2VyLCBwYXNzKSwgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBVUkwodXJsLCB0cnVlKTsgLy8geWVzLCBwYXJzZSB0aGUgcXVlcnkgc3RyaW5nXG4gICAgcHJvdG9jb2wgPSBwYXJ0cy5wcm90b2NvbDtcbiAgICBzb2Nrb3B0cy5ob3N0ID0gcGFydHMuaG9zdG5hbWU7XG4gICAgc29ja29wdHMuc2VydmVybmFtZSA9IHNvY2tvcHRzLnNlcnZlcm5hbWUgfHwgcGFydHMuaG9zdG5hbWU7XG4gICAgc29ja29wdHMucG9ydCA9IHBhcnNlSW50KHBhcnRzLnBvcnQpIHx8ICgocHJvdG9jb2wgPT09ICdhbXFwOicpID8gNTY3MiA6IDU2NzEpO1xuICAgIHZhciB2aG9zdCA9IHBhcnRzLnBhdGhuYW1lID8gcGFydHMucGF0aG5hbWUuc3Vic3RyKDEpIDogbnVsbDtcbiAgICBmaWVsZHMgPSBvcGVuRnJhbWVzKHZob3N0LCBwYXJ0cy5xdWVyeSwgc29ja29wdHMuY3JlZGVudGlhbHMgfHwgY3JlZGVudGlhbHNGcm9tVXJsKHBhcnRzKSwgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHZhciBzb2Nrb2sgPSBmYWxzZTtcbiAgdmFyIHNvY2s7XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KCkge1xuICAgIHNvY2tvayA9IHRydWU7XG4gICAgc29jay5zZXROb0RlbGF5KG5vRGVsYXkpO1xuICAgIGlmIChrZWVwQWxpdmUpIHNvY2suc2V0S2VlcEFsaXZlKGtlZXBBbGl2ZSwga2VlcEFsaXZlRGVsYXkpO1xuXG4gICAgdmFyIGMgPSBuZXcgQ29ubmVjdGlvbihzb2NrKTtcbiAgICBjLm9wZW4oZmllbGRzLCBmdW5jdGlvbihlcnIsIG9rKSB7XG4gICAgICAvLyBkaXNhYmxlIHRpbWVvdXQgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyBpdCBmb3VsaW5nIHRoaW5nc1xuICAgICAgaWYgKHRpbWVvdXQpIHNvY2suc2V0VGltZW91dCgwKTtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgb3BlbkNhbGxiYWNrKG51bGwsIGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNvbm5lY3Rpb24gaXNuJ3QgY2xvc2VkIGJ5IHRoZSBzZXJ2ZXIgb24gZS5nLiB3cm9uZyBwYXNzd29yZFxuICAgICAgICBzb2NrLmVuZCgpO1xuICAgICAgICBzb2NrLmRlc3Ryb3koKTtcbiAgICAgICAgb3BlbkNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvdG9jb2wgPT09ICdhbXFwOicpIHtcbiAgICBzb2NrID0gcmVxdWlyZSgnbmV0JykuY29ubmVjdChzb2Nrb3B0cywgb25Db25uZWN0KTtcbiAgfVxuICBlbHNlIGlmIChwcm90b2NvbCA9PT0gJ2FtcXBzOicpIHtcbiAgICBzb2NrID0gcmVxdWlyZSgndGxzJykuY29ubmVjdChzb2Nrb3B0cywgb25Db25uZWN0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbXFwOiBvciBhbXFwczogYXMgdGhlIHByb3RvY29sOyBnb3QgXCIgKyBwcm90b2NvbCk7XG4gIH1cblxuICBpZiAodGltZW91dCkge1xuICAgIHNvY2suc2V0VGltZW91dCh0aW1lb3V0LCBmdW5jdGlvbigpIHtcbiAgICAgIHNvY2suZW5kKCk7XG4gICAgICBzb2NrLmRlc3Ryb3koKTtcbiAgICAgIG9wZW5DYWxsYmFjayhuZXcgRXJyb3IoJ2Nvbm5lY3QgRVRJTUVET1VUJykpO1xuICAgIH0pO1xuICB9XG5cbiAgc29jay5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmICghc29ja29rKSBvcGVuQ2FsbGJhY2soZXJyKTtcbiAgfSk7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5jcmVkZW50aWFsc0Zyb21VcmwgPSBjcmVkZW50aWFsc0Zyb21Vcmw7XG4iLCIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciBjb25zdGFudHMgPSBkZWZzLmNvbnN0YW50cztcbnZhciBmcmFtZSA9IHJlcXVpcmUoJy4vZnJhbWUnKTtcbnZhciBIRUFSVEJFQVQgPSBmcmFtZS5IRUFSVEJFQVQ7XG52YXIgTXV4ID0gcmVxdWlyZSgnLi9tdXgnKS5NdXg7XG5cbnZhciBEdXBsZXggPVxuICByZXF1aXJlKCdzdHJlYW0nKS5EdXBsZXggfHxcbiAgcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBIZWFydCA9IHJlcXVpcmUoJy4vaGVhcnRiZWF0JykuSGVhcnQ7XG5cbnZhciBtZXRob2ROYW1lID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5tZXRob2ROYW1lO1xudmFyIGNsb3NlTXNnID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5jbG9zZU1lc3NhZ2U7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vZm9ybWF0JykuaW5zcGVjdDtcblxudmFyIEJpdFNldCA9IHJlcXVpcmUoJy4vYml0c2V0JykuQml0U2V0O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIGZtdCA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaCB8fFxuICByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2gnKTtcbnZhciBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xudmFyIHN0YWNrQ2FwdHVyZSA9IHJlcXVpcmUoJy4vZXJyb3InKS5zdGFja0NhcHR1cmU7XG5cbi8vIEhpZ2gtd2F0ZXIgbWFyayBmb3IgY2hhbm5lbCB3cml0ZSBidWZmZXJzLCBpbiAnb2JqZWN0cycgKHdoaWNoIGFyZVxuLy8gZW5jb2RlZCBmcmFtZXMgYXMgYnVmZmVycykuXG52YXIgREVGQVVMVF9XUklURV9IV00gPSAxMDI0O1xuLy8gSWYgYWxsIHRoZSBmcmFtZXMgb2YgYSBtZXNzYWdlIChtZXRob2QsIHByb3BlcnRpZXMsIGNvbnRlbnQpIHRvdGFsXG4vLyB0byBsZXNzIHRoYW4gdGhpcywgY29weSB0aGVtIGludG8gYSBzaW5nbGUgYnVmZmVyIGFuZCB3cml0ZSBpdCBhbGxcbi8vIGF0IG9uY2UuIE5vdGUgdGhhdCB0aGlzIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBmcmFtZSBzaXplOiBpZiBpdFxuLy8gd2FzIGdyZWF0ZXIsIHdlIG1pZ2h0IGhhdmUgdG8gZnJhZ21lbnQgdGhlIGNvbnRlbnQuXG52YXIgU0lOR0xFX0NIVU5LX1RIUkVTSE9MRCA9IDIwNDg7XG5cbmZ1bmN0aW9uIENvbm5lY3Rpb24odW5kZXJseWluZykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCggdGhpcyApO1xuICB2YXIgc3RyZWFtID0gdGhpcy5zdHJlYW0gPSB3cmFwU3RyZWFtKHVuZGVybHlpbmcpO1xuICB0aGlzLm11eGVyID0gbmV3IE11eChzdHJlYW0pO1xuXG4gIC8vIGZyYW1lc1xuICB0aGlzLnJlc3QgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIHRoaXMuZnJhbWVNYXggPSBjb25zdGFudHMuRlJBTUVfTUlOX1NJWkU7XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG4gIHRoaXMucmVjdlNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG5cbiAgdGhpcy5leHBlY3RTb2NrZXRDbG9zZSA9IGZhbHNlO1xuICB0aGlzLmZyZWVDaGFubmVscyA9IG5ldyBCaXRTZXQoKTtcbiAgdGhpcy5jaGFubmVscyA9IFt7Y2hhbm5lbDoge2FjY2VwdDogY2hhbm5lbDAodGhpcyl9LFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHVuZGVybHlpbmd9XTtcbn1cbmluaGVyaXRzKENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbnZhciBDID0gQ29ubmVjdGlvbi5wcm90b3R5cGU7XG5cbi8vIFVzdWFsIGZyYW1lIGFjY2VwdCBtb2RlXG5mdW5jdGlvbiBtYWluQWNjZXB0KGZyYW1lKSB7XG4gIHZhciByZWMgPSB0aGlzLmNoYW5uZWxzW2ZyYW1lLmNoYW5uZWxdO1xuICBpZiAocmVjKSB7IHJldHVybiByZWMuY2hhbm5lbC5hY2NlcHQoZnJhbWUpOyB9XG4gIC8vIE5CIENIQU5ORUxfRVJST1IgbWF5IG5vdCBiZSByaWdodCwgYnV0IEkgZG9uJ3Qga25vdyB3aGF0IGlzIC4uXG4gIGVsc2VcbiAgICB0aGlzLmNsb3NlV2l0aEVycm9yKFxuICAgICAgZm10KCdGcmFtZSBvbiB1bmtub3duIGNoYW5uZWwgJWQnLCBmcmFtZS5jaGFubmVsKSxcbiAgICAgIGNvbnN0YW50cy5DSEFOTkVMX0VSUk9SLFxuICAgICAgbmV3IEVycm9yKGZtdChcIkZyYW1lIG9uIHVua25vd24gY2hhbm5lbDogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdChmcmFtZSwgZmFsc2UpKSkpO1xufVxuXG4vLyBIYW5kbGUgYW55dGhpbmcgdGhhdCBjb21lcyB0aHJvdWdoIG9uIGNoYW5uZWwgMCwgdGhhdCdzIHRoZVxuLy8gY29ubmVjdGlvbiBjb250cm9sIGNoYW5uZWwuIFRoaXMgaXMgb25seSB1c2VkIG9uY2UgbWFpbkFjY2VwdCBpc1xuLy8gaW5zdGFsbGVkIGFzIHRoZSBmcmFtZSBoYW5kbGVyLCBhZnRlciB0aGUgb3BlbmluZyBoYW5kc2hha2UuXG5mdW5jdGlvbiBjaGFubmVsMChjb25uZWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgLy8gT25jZSB3ZSBnZXQgYSAnY2xvc2UnLCB3ZSBrbm93IDEuIHdlJ2xsIGdldCBubyBtb3JlIGZyYW1lcywgYW5kXG4gICAgLy8gMi4gYW55dGhpbmcgd2Ugc2VuZCBleGNlcHQgY2xvc2UsIG9yIGNsb3NlLW9rLCB3aWxsIGJlXG4gICAgLy8gaWdub3JlZC4gSWYgd2UgYWxyZWFkeSBzZW50ICdjbG9zZScsIHRoaXMgd29uJ3QgYmUgaW52b2tlZCBzaW5jZVxuICAgIC8vIHdlJ3JlIGFscmVhZHkgaW4gY2xvc2luZyBtb2RlOyBpZiB3ZSBkaWRuJ3Qgd2VsbCB3ZSdyZSBub3QgZ29pbmdcbiAgICAvLyB0byBzZW5kIGl0IG5vdyBhcmUgd2UuXG4gICAgaWYgKGYgPT09IEhFQVJUQkVBVCk7IC8vIGlnbm9yZTsgaXQncyBhbHJlYWR5IGNvdW50ZWQgYXMgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIHNvY2tldCwgd2hpY2ggaXMgaXRzIHB1cnBvc2VcbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZSkge1xuICAgICAgLy8gT2guIE9LLiBJIGd1ZXNzIHdlJ3JlIGRvbmUgaGVyZSB0aGVuLlxuICAgICAgY29ubmVjdGlvbi5zZW5kTWV0aG9kKDAsIGRlZnMuQ29ubmVjdGlvbkNsb3NlT2ssIHt9KTtcbiAgICAgIHZhciBlbXNnID0gZm10KCdDb25uZWN0aW9uIGNsb3NlZDogJXMnLCBjbG9zZU1zZyhmKSk7XG4gICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZShlbXNnKTtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKGVtc2cpO1xuICAgICAgZS5jb2RlID0gZi5maWVsZHMucmVwbHlDb2RlO1xuICAgICAgaWYgKGlzRmF0YWxFcnJvcihlKSkge1xuICAgICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uLnRvQ2xvc2VkKHMsIGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25CbG9ja2VkKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Jsb2NrZWQnLCBmLmZpZWxkcy5yZWFzb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25VbmJsb2NrZWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uZW1pdCgndW5ibG9ja2VkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29ubmVjdGlvbi5jbG9zZVdpdGhFcnJvcihcbiAgICAgICAgZm10KFwiVW5leHBlY3RlZCBmcmFtZSBvbiBjaGFubmVsIDBcIiksXG4gICAgICAgIGNvbnN0YW50cy5VTkVYUEVDVEVEX0ZSQU1FLFxuICAgICAgICBuZXcgRXJyb3IoZm10KFwiVW5leHBlY3RlZCBmcmFtZSBvbiBjaGFubmVsIDA6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5zcGVjdChmLCBmYWxzZSkpKSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGlzIGNoYW5nZWQgYmV0d2VlbiB2ZXJzaW9ucywgYXMgZGlkIHRoZSBjb2RlYywgbWV0aG9kcywgZXRjLiBBTVFQXG4vLyAwLTktMSBpcyBmYWlybHkgc2ltaWxhciB0byAwLjgsIGJ1dCBiZXR0ZXIsIGFuZCBub3RoaW5nIGltcGxlbWVudHNcbi8vIDAuOCB0aGF0IGRvZXNuJ3QgaW1wbGVtZW50IDAtOS0xLiBJbiBvdGhlciB3b3JkcywgaXQgZG9lc24ndCBtYWtlXG4vLyBtdWNoIHNlbnNlIHRvIGdlbmVyYWxpc2UgaGVyZS5cbkMuc2VuZFByb3RvY29sSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VuZEJ5dGVzKGZyYW1lLlBST1RPQ09MX0hFQURFUik7XG59O1xuXG4vKlxuICBUaGUgZnJpZ2h0ZW5pbmdseSBjb21wbGljYXRlZCBvcGVuaW5nIHByb3RvY29sIChzcGVjIHNlY3Rpb24gMi4yLjQpOlxuXG4gICAgIENsaWVudCAtPiBTZXJ2ZXJcblxuICAgICAgIHByb3RvY29sIGhlYWRlciAtPlxuICAgICAgICAgPC0gc3RhcnRcbiAgICAgICBzdGFydC1vayAtPlxuICAgICAuLiBuZXh0IHR3byB6ZXJvIG9yIG1vcmUgdGltZXMgLi5cbiAgICAgICAgIDwtIHNlY3VyZVxuICAgICAgIHNlY3VyZS1vayAtPlxuICAgICAgICAgPC0gdHVuZVxuICAgICAgIHR1bmUtb2sgLT5cbiAgICAgICBvcGVuIC0+XG4gICAgICAgICA8LSBvcGVuLW9rXG5cbklmIEknbSBvbmx5IHN1cHBvcnRpbmcgU0FTTCdzIFBMQUlOIG1lY2hhbmlzbSAod2hpY2ggSSBhbSBmb3IgdGhlIHRpbWVcbmJlaW5nKSwgaXQgZ2V0cyBhIGJpdCBlYXNpZXIgc2luY2UgdGhlIHNlcnZlciB3b24ndCBpbiBnZW5lcmFsIHNlbmRcbmJhY2sgYSBgc2VjdXJlYCwgaXQnbGwganVzdCBzZW5kIGB0dW5lYCBhZnRlciB0aGUgYHN0YXJ0LW9rYC5cbihTQVNMIFBMQUlOOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NjE2KVxuXG4qL1xuXG5DLm9wZW4gPSBmdW5jdGlvbihhbGxGaWVsZHMsIG9wZW5DYWxsYmFjazApIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3BlbkNhbGxiYWNrID0gb3BlbkNhbGxiYWNrMCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIC8vIFRoaXMgaXMgd2hlcmUgd2UnbGwgcHV0IG91ciBuZWdvdGlhdGVkIHZhbHVlc1xuICB2YXIgdHVuZWRPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShhbGxGaWVsZHMpO1xuXG4gIGZ1bmN0aW9uIHdhaXQoaykge1xuICAgIHNlbGYuc3RlcChmdW5jdGlvbihlcnIsIGZyYW1lKSB7XG4gICAgICBpZiAoZXJyICE9PSBudWxsKSBiYWlsKGVycik7XG4gICAgICBlbHNlIGlmIChmcmFtZS5jaGFubmVsICE9PSAwKSB7XG4gICAgICAgIGJhaWwobmV3IEVycm9yKFxuICAgICAgICAgIGZtdChcIkZyYW1lIG9uIGNoYW5uZWwgIT0gMCBkdXJpbmcgaGFuZHNoYWtlOiAlc1wiLFxuICAgICAgICAgICAgICBpbnNwZWN0KGZyYW1lLCBmYWxzZSkpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGsoZnJhbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0KE1ldGhvZCwgaykge1xuICAgIHdhaXQoZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgIGlmIChmcmFtZS5pZCA9PT0gTWV0aG9kKSBrKGZyYW1lKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgICBmbXQoXCJFeHBlY3RlZCAlczsgZ290ICVzXCIsXG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUoTWV0aG9kKSwgaW5zcGVjdChmcmFtZSwgZmFsc2UpKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFpbChlcnIpIHtcbiAgICBvcGVuQ2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbmQoTWV0aG9kKSB7XG4gICAgLy8gVGhpcyBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZXJlJ3Mgc29tZSBwcm9ibGVtIHdpdGggdGhlXG4gICAgLy8gb3B0aW9uczsgZS5nLiwgc29tZXRoaW5nIGlzIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBudW1iZXIuXG4gICAgc2VsZi5zZW5kTWV0aG9kKDAsIE1ldGhvZCwgdHVuZWRPcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZ290aWF0ZShzZXJ2ZXIsIGRlc2lyZWQpIHtcbiAgICAvLyBXZSBnZXQgc2VudCB2YWx1ZXMgZm9yIGNoYW5uZWxNYXgsIGZyYW1lTWF4IGFuZCBoZWFydGJlYXQsXG4gICAgLy8gd2hpY2ggd2UgbWF5IGFjY2VwdCBvciBsb3dlciAoc3ViamVjdCB0byBhIG1pbmltdW0gZm9yXG4gICAgLy8gZnJhbWVNYXgsIGJ1dCB3ZSdsbCBsZWF2ZSB0aGF0IHRvIHRoZSBzZXJ2ZXIgdG8gZW5mb3JjZSkuIEluXG4gICAgLy8gYWxsIGNhc2VzLCBgMGAgcmVhbGx5IG1lYW5zIFwibm8gbGltaXRcIiwgb3IgcmF0aGVyIHRoZSBoaWdoZXN0XG4gICAgLy8gdmFsdWUgaW4gdGhlIGVuY29kaW5nLCBlLmcuLCB1bnNpZ25lZCBzaG9ydCBmb3IgY2hhbm5lbE1heC5cbiAgICBpZiAoc2VydmVyID09PSAwIHx8IGRlc2lyZWQgPT09IDApIHtcbiAgICAgIC8vIGkuZS4sIHdoaWNoZXZlciBwbGFjZXMgYSBsaW1pdCwgaWYgZWl0aGVyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoc2VydmVyLCBkZXNpcmVkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oc2VydmVyLCBkZXNpcmVkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblN0YXJ0KHN0YXJ0KSB7XG4gICAgdmFyIG1lY2hhbmlzbXMgPSBzdGFydC5maWVsZHMubWVjaGFuaXNtcy50b1N0cmluZygpLnNwbGl0KCcgJyk7XG4gICAgaWYgKG1lY2hhbmlzbXMuaW5kZXhPZihhbGxGaWVsZHMubWVjaGFuaXNtKSA8IDApIHtcbiAgICAgIGJhaWwobmV3IEVycm9yKGZtdCgnU0FTTCBtZWNoYW5pc20gJXMgaXMgbm90IHByb3ZpZGVkIGJ5IHRoZSBzZXJ2ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZpZWxkcy5tZWNoYW5pc20pKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuc2VydmVyUHJvcGVydGllcyA9IHN0YXJ0LmZpZWxkcy5zZXJ2ZXJQcm9wZXJ0aWVzO1xuICAgIHRyeSB7XG4gICAgICBzZW5kKGRlZnMuQ29ubmVjdGlvblN0YXJ0T2spO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgYmFpbChlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YWl0KGFmdGVyU3RhcnRPayk7XG4gIH1cblxuICBmdW5jdGlvbiBhZnRlclN0YXJ0T2socmVwbHkpIHtcbiAgICBzd2l0Y2ggKHJlcGx5LmlkKSB7XG4gICAgY2FzZSBkZWZzLkNvbm5lY3Rpb25TZWN1cmU6XG4gICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgXCJXYXNuJ3QgZXhwZWN0aW5nIHRvIGhhdmUgdG8gZ28gdGhyb3VnaCBzZWN1cmVcIikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBkZWZzLkNvbm5lY3Rpb25DbG9zZTpcbiAgICAgIGJhaWwobmV3IEVycm9yKGZtdChcIkhhbmRzaGFrZSB0ZXJtaW5hdGVkIGJ5IHNlcnZlcjogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZU1zZyhyZXBseSkpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGRlZnMuQ29ubmVjdGlvblR1bmU6XG4gICAgICB2YXIgZmllbGRzID0gcmVwbHkuZmllbGRzO1xuICAgICAgdHVuZWRPcHRpb25zLmZyYW1lTWF4ID1cbiAgICAgICAgbmVnb3RpYXRlKGZpZWxkcy5mcmFtZU1heCwgYWxsRmllbGRzLmZyYW1lTWF4KTtcbiAgICAgIHR1bmVkT3B0aW9ucy5jaGFubmVsTWF4ID1cbiAgICAgICAgbmVnb3RpYXRlKGZpZWxkcy5jaGFubmVsTWF4LCBhbGxGaWVsZHMuY2hhbm5lbE1heCk7XG4gICAgICB0dW5lZE9wdGlvbnMuaGVhcnRiZWF0ID1cbiAgICAgICAgbmVnb3RpYXRlKGZpZWxkcy5oZWFydGJlYXQsIGFsbEZpZWxkcy5oZWFydGJlYXQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VuZChkZWZzLkNvbm5lY3Rpb25UdW5lT2spO1xuICAgICAgICBzZW5kKGRlZnMuQ29ubmVjdGlvbk9wZW4pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGJhaWwoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXhwZWN0KGRlZnMuQ29ubmVjdGlvbk9wZW5Paywgb25PcGVuT2spO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJhaWwobmV3IEVycm9yKFxuICAgICAgICBmbXQoXCJFeHBlY3RlZCBjb25uZWN0aW9uLnNlY3VyZSwgY29ubmVjdGlvbi5jbG9zZSwgXCIgK1xuICAgICAgICAgICAgXCJvciBjb25uZWN0aW9uLnR1bmUgZHVyaW5nIGhhbmRzaGFrZTsgZ290ICVzXCIsXG4gICAgICAgICAgICBpbnNwZWN0KHJlcGx5LCBmYWxzZSkpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk9wZW5PayhvcGVuT2spIHtcbiAgICAvLyBJbXBvc2UgdGhlIG1heGltdW0gb2YgdGhlIGVuY29kZWQgdmFsdWUsIGlmIHRoZSBuZWdvdGlhdGVkXG4gICAgLy8gdmFsdWUgaXMgemVybywgbWVhbmluZyBcIm5vLCBubyBsaW1pdHNcIlxuICAgIHNlbGYuY2hhbm5lbE1heCA9IHR1bmVkT3B0aW9ucy5jaGFubmVsTWF4IHx8IDB4ZmZmZjtcbiAgICBzZWxmLmZyYW1lTWF4ID0gdHVuZWRPcHRpb25zLmZyYW1lTWF4IHx8IDB4ZmZmZmZmZmY7XG4gICAgLy8gMCBtZWFucyBcIm5vIGhlYXJ0YmVhdFwiLCByYXRoZXIgdGhhbiBcIm1heGltdW0gcGVyaW9kIG9mXG4gICAgLy8gaGVhcnRiZWF0aW5nXCJcbiAgICBzZWxmLmhlYXJ0YmVhdCA9IHR1bmVkT3B0aW9ucy5oZWFydGJlYXQ7XG4gICAgc2VsZi5oZWFydGJlYXRlciA9IHNlbGYuc3RhcnRIZWFydGJlYXRlcigpO1xuICAgIHNlbGYuYWNjZXB0ID0gbWFpbkFjY2VwdDtcbiAgICBzdWNjZWVkKG9wZW5Payk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2VydmVyIGNsb3NlcyB0aGUgY29ubmVjdGlvbiwgaXQncyBwcm9iYWJseSBiZWNhdXNlIG9mXG4gIC8vIHNvbWV0aGluZyB3ZSBkaWRcbiAgZnVuY3Rpb24gZW5kV2hpbGVPcGVuaW5nKGVycikge1xuICAgIGJhaWwoZXJyIHx8IG5ldyBFcnJvcignU29ja2V0IGNsb3NlZCBhYnJ1cHRseSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2R1cmluZyBvcGVuaW5nIGhhbmRzaGFrZScpKTtcbiAgfVxuXG4gIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCBlbmRXaGlsZU9wZW5pbmcpO1xuICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBlbmRXaGlsZU9wZW5pbmcpO1xuXG4gIGZ1bmN0aW9uIHN1Y2NlZWQob2spIHtcbiAgICBzZWxmLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kV2hpbGVPcGVuaW5nKTtcbiAgICBzZWxmLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlbmRXaGlsZU9wZW5pbmcpO1xuICAgIHNlbGYuc3RyZWFtLm9uKCdlcnJvcicsIHNlbGYub25Tb2NrZXRFcnJvci5iaW5kKHNlbGYpKTtcbiAgICBzZWxmLnN0cmVhbS5vbignZW5kJywgc2VsZi5vblNvY2tldEVycm9yLmJpbmQoXG4gICAgICBzZWxmLCBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY2xvc2UnKSkpO1xuICAgIHNlbGYub24oJ2ZyYW1lRXJyb3InLCBzZWxmLm9uU29ja2V0RXJyb3IuYmluZChzZWxmKSk7XG4gICAgc2VsZi5hY2NlcHRMb29wKCk7XG4gICAgb3BlbkNhbGxiYWNrKG51bGwsIG9rKTtcbiAgfVxuXG4gIC8vIE5vdyBraWNrIG9mZiB0aGUgaGFuZHNoYWtlIGJ5IHByb21wdGluZyB0aGUgc2VydmVyXG4gIHRoaXMuc2VuZFByb3RvY29sSGVhZGVyKCk7XG4gIGV4cGVjdChkZWZzLkNvbm5lY3Rpb25TdGFydCwgb25TdGFydCk7XG59O1xuXG4vLyBDbG9zaW5nIHRoaW5nczogQU1RUCBoYXMgYSBjbG9zaW5nIGhhbmRzaGFrZSB0aGF0IGFwcGxpZXMgdG9cbi8vIGNsb3NpbmcgYm90aCBjb25uZWN0cyBhbmQgY2hhbm5lbHMuIEFzIHRoZSBpbml0aWF0aW5nIHBhcnR5LCBJIHNlbmRcbi8vIENsb3NlLCB0aGVuIGlnbm9yZSBhbGwgZnJhbWVzIHVudGlsIEkgc2VlIGVpdGhlciBDbG9zZU9LIC0tXG4vLyB3aGljaCBzaWduaWZpZXMgdGhhdCB0aGUgb3RoZXIgcGFydHkgaGFzIHNlZW4gdGhlIENsb3NlIGFuZCBzaHV0XG4vLyB0aGUgY29ubmVjdGlvbiBvciBjaGFubmVsIGRvd24sIHNvIGl0J3MgZmluZSB0byBmcmVlIHJlc291cmNlczsgb3Jcbi8vIENsb3NlLCB3aGljaCBtZWFucyB0aGUgb3RoZXIgcGFydHkgYWxzbyB3YW50ZWQgdG8gY2xvc2UgdGhlXG4vLyB3aGF0ZXZlciwgYW5kIEkgc2hvdWxkIHNlbmQgQ2xvc2VPayBzbyBpdCBjYW4gZnJlZSByZXNvdXJjZXMsXG4vLyB0aGVuIGdvIGJhY2sgdG8gd2FpdGluZyBmb3IgdGhlIENsb3NlT2suIElmIEkgcmVjZWl2ZSBhIENsb3NlXG4vLyBvdXQgb2YgdGhlIGJsdWUsIEkgc2hvdWxkIHRocm93IGF3YXkgYW55IHVuc2VudCBmcmFtZXMgKHRoZXkgd2lsbFxuLy8gYmUgaWdub3JlZCBhbnl3YXkpIGFuZCBzZW5kIENsb3NlT2ssIHRoZW4gY2xlYW4gdXAgcmVzb3VyY2VzLiBJblxuLy8gZ2VuZXJhbCwgQ2xvc2Ugb3V0IG9mIHRoZSBibHVlIHNpZ25hbHMgYW4gZXJyb3IgKG9yIGEgZm9yY2VkXG4vLyBjbG9zdXJlLCB3aGljaCBtYXkgYXMgd2VsbCBiZSBhbiBlcnJvcikuXG4vL1xuLy8gIFJVTk5JTkcgWzFdIC0tLSBzZW5kIENsb3NlIC0tLT4gQ2xvc2luZyBbMl0gLS0tPiByZWN2IENsb3NlIC0tK1xuLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICBbM11cbi8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0gc2VuZCBDbG9zZU9rIC0tLS0tLStcbi8vICByZWN2IENsb3NlICAgICAgICAgICAgICAgICAgIHJlY3YgQ2xvc2VPa1xuLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgIFYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuLy8gIEVuZGVkIFs0XSAtLS0tIHNlbmQgQ2xvc2VPayAtLS0+IENsb3NlZCBbNV1cbi8vXG4vLyBbMV0gQWxsIGZyYW1lcyBhY2NlcHRlZDsgZ2V0dGluZyBhIENsb3NlIGZyYW1lIGZyb20gdGhlIHNlcnZlclxuLy8gbW92ZXMgdG8gRW5kZWQ7IGNsaWVudCBtYXkgaW5pdGlhdGUgYSBjbG9zZSBieSBzZW5kaW5nIENsb3NlXG4vLyBpdHNlbGYuXG4vLyBbMl0gQ2xpZW50IGhhcyBpbml0aWF0ZWQgYSBjbG9zZTsgb25seSBDbG9zZU9rIG9yIChzaW11bGF0YW5lb3VzbHlcbi8vIHNlbnQpIENsb3NlIGlzIGFjY2VwdGVkLlxuLy8gWzNdIFNpbXVsdGFuZW91cyBjbG9zZVxuLy8gWzRdIFNlcnZlciB3b24ndCBzZW5kIGFueSBtb3JlIGZyYW1lczsgYWNjZXB0IG5vIG1vcmUgZnJhbWVzLCBzZW5kXG4vLyBDbG9zZU9rLlxuLy8gWzVdIEZ1bGx5IGNsb3NlZCwgY2xpZW50IHdpbGwgc2VuZCBubyBtb3JlLCBzZXJ2ZXIgd2lsbCBzZW5kIG5vXG4vLyBtb3JlLiBTaWduYWwgJ2Nsb3NlJyBvciAnZXJyb3InLlxuLy9cbi8vIFRoZXJlIGFyZSB0d28gc2lnbmFsbGluZyBtZWNoYW5pc21zIHVzZWQgaW4gdGhlIEFQSS4gVGhlIGZpcnN0IGlzXG4vLyB0aGF0IGNhbGxpbmcgYGNsb3NlYCB3aWxsIHJldHVybiBhIHByb21pc2UsIHRoYXQgd2lsbCBlaXRoZXJcbi8vIHJlc29sdmUgb25jZSB0aGUgY29ubmVjdGlvbiBvciBjaGFubmVsIGlzIGNsZWFubHkgc2h1dCBkb3duLCBvclxuLy8gd2lsbCByZWplY3QgaWYgdGhlIHNodXRkb3duIHRpbWVzIG91dC5cbi8vXG4vLyBUaGUgc2Vjb25kIGlzIHRoZSAnY2xvc2UnIGFuZCAnZXJyb3InIGV2ZW50cy4gVGhlc2UgYXJlXG4vLyBlbWl0dGVkIGFzIGFib3ZlLiBUaGUgZXZlbnRzIHdpbGwgZmlyZSAqYmVmb3JlKiBwcm9taXNlcyBhcmVcbi8vIHJlc29sdmVkLlxuXG4vLyBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRob3V0IGV2ZW4gZ2l2aW5nIGEgcmVhc29uLiBUeXBpY2FsLlxuQy5jbG9zZSA9IGZ1bmN0aW9uKGNsb3NlQ2FsbGJhY2spIHtcbiAgdmFyIGsgPSBjbG9zZUNhbGxiYWNrICYmIGZ1bmN0aW9uKCkgeyBjbG9zZUNhbGxiYWNrKG51bGwpOyB9O1xuICB0aGlzLmNsb3NlQmVjYXVzZShcIkNoZWVycywgdGhhbmtzXCIsIGNvbnN0YW50cy5SRVBMWV9TVUNDRVNTLCBrKTtcbn07XG5cbi8vIENsb3NlIHdpdGggYSByZWFzb24gYW5kIGEgJ2NvZGUnLiBJJ20gcHJldHR5IHN1cmUgUmFiYml0TVEgdG90YWxseVxuLy8gaWdub3JlcyB0aGVzZTsgbWF5YmUgaXQgbG9ncyB0aGVtLiBUaGUgY29udGludWF0aW9uIHdpbGwgYmUgaW52b2tlZFxuLy8gd2hlbiB0aGUgQ2xvc2VPayBoYXMgYmVlbiByZWNlaXZlZCwgYW5kIGJlZm9yZSB0aGUgJ2Nsb3NlJyBldmVudC5cbkMuY2xvc2VCZWNhdXNlID0gZnVuY3Rpb24ocmVhc29uLCBjb2RlLCBrKSB7XG4gIHRoaXMuc2VuZE1ldGhvZCgwLCBkZWZzLkNvbm5lY3Rpb25DbG9zZSwge1xuICAgIHJlcGx5VGV4dDogcmVhc29uLFxuICAgIHJlcGx5Q29kZTogY29kZSxcbiAgICBtZXRob2RJZDogMCwgY2xhc3NJZDogMFxuICB9KTtcbiAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ2Nsb3NlQmVjYXVzZSBjYWxsZWQ6ICcgKyByZWFzb24pO1xuICB0aGlzLnRvQ2xvc2luZyhzLCBrKTtcbn07XG5cbkMuY2xvc2VXaXRoRXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIGNvZGUsIGVycm9yKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIHRoaXMuY2xvc2VCZWNhdXNlKHJlYXNvbiwgY29kZSk7XG59O1xuXG5DLm9uU29ja2V0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKCF0aGlzLmV4cGVjdFNvY2tldENsb3NlKSB7XG4gICAgLy8gZm9yZXN0YWxsIGFueSBtb3JlIGNhbGxzIHRvIG9uU29ja2V0RXJyb3IsIHNpbmNlIHdlJ3JlIHNpZ25lZFxuICAgIC8vIHVwIGZvciBgJ2Vycm9yJ2AgKmFuZCogYCdlbmQnYFxuICAgIHRoaXMuZXhwZWN0U29ja2V0Q2xvc2UgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKCdTb2NrZXQgZXJyb3InKTtcbiAgICB0aGlzLnRvQ2xvc2VkKHMsIGVycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludmFsaWRPcChtc2csIHN0YWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKG1zZywgc3RhY2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlU2VuZChjb25uLCBtc2csIHN0YWNrKSB7XG4gIGNvbm4uc2VuZE1ldGhvZCA9IGNvbm4uc2VuZENvbnRlbnQgPSBjb25uLnNlbmRNZXNzYWdlID1cbiAgICBpbnZhbGlkT3AobXNnLCBzdGFjayk7XG59XG5cbi8vIEEgY2xvc2UgaGFzIGJlZW4gaW5pdGlhdGVkLiBSZXBlYXQ6IGEgY2xvc2UgaGFzIGJlZW4gaW5pdGlhdGVkLlxuLy8gVGhpcyBtZWFucyB3ZSBzaG91bGQgbm90IHNlbmQgbW9yZSBmcmFtZXMsIGFueXdheSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuIFdlIGFsc28gaGF2ZSB0byBzaHV0IGRvd24gYWxsIHRoZSBjaGFubmVscy5cbkMudG9DbG9zaW5nID0gZnVuY3Rpb24oY2FwdHVyZWRTdGFjaywgaykge1xuICB2YXIgc2VuZCA9IHRoaXMuc2VuZE1ldGhvZC5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuYWNjZXB0ID0gZnVuY3Rpb24oZikge1xuICAgIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZU9rKSB7XG4gICAgICBpZiAoaykgaygpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ0Nvbm5lY3Rpb25DbG9zZU9rIHJlY2VpdmVkJyk7XG4gICAgICB0aGlzLnRvQ2xvc2VkKHMsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQ29ubmVjdGlvbkNsb3NlKSB7XG4gICAgICBzZW5kKDAsIGRlZnMuQ29ubmVjdGlvbkNsb3NlT2ssIHt9KTtcbiAgICB9XG4gICAgLy8gZWxzZSBpZ25vcmUgZnJhbWVcbiAgfTtcbiAgaW52YWxpZGF0ZVNlbmQodGhpcywgJ0Nvbm5lY3Rpb24gY2xvc2luZycsIGNhcHR1cmVkU3RhY2spO1xufTtcblxuQy5fY2xvc2VDaGFubmVscyA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2spIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICBpZiAoY2ggIT09IG51bGwpIHtcbiAgICAgIGNoLmNoYW5uZWwudG9DbG9zZWQoY2FwdHVyZWRTdGFjayk7IC8vICUlJSBvciB3aXRoIGFuIGVycm9yPyBub3QgY2xlYXJcbiAgICB9XG4gIH1cbn07XG5cbi8vIEEgY2xvc2UgaGFzIGJlZW4gY29uZmlybWVkLiBDZWFzZSBhbGwgY29tbXVuaWNhdGlvbi5cbkMudG9DbG9zZWQgPSBmdW5jdGlvbihjYXB0dXJlZFN0YWNrLCBtYXliZUVycikge1xuICB0aGlzLl9jbG9zZUNoYW5uZWxzKGNhcHR1cmVkU3RhY2spO1xuICB2YXIgaW5mbyA9IGZtdCgnQ29ubmVjdGlvbiBjbG9zZWQgKCVzKScsXG4gICAgICAgICAgICAgICAgIChtYXliZUVycikgPyBtYXliZUVyci50b1N0cmluZygpIDogJ2J5IGNsaWVudCcpO1xuICAvLyBUaWR5IHVwLCBpbnZhbGlkYXRlIGVudmVyeXRoaW5nLCBkeW5hbWl0ZSB0aGUgYnJpZGdlcy5cbiAgaW52YWxpZGF0ZVNlbmQodGhpcywgaW5mbywgY2FwdHVyZWRTdGFjayk7XG4gIHRoaXMuYWNjZXB0ID0gaW52YWxpZE9wKGluZm8sIGNhcHR1cmVkU3RhY2spO1xuICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oY2IpIHtcbiAgICBjYiAmJiBjYihuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKGluZm8sIGNhcHR1cmVkU3RhY2spKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGVhcnRiZWF0ZXIpIHRoaXMuaGVhcnRiZWF0ZXIuY2xlYXIoKTtcbiAgLy8gVGhpcyBpcyBjZXJ0YWlubHkgdHJ1ZSBub3csIGlmIGl0IHdhc24ndCBiZWZvcmVcbiAgdGhpcy5leHBlY3RTb2NrZXRDbG9zZSA9IHRydWU7XG4gIHRoaXMuc3RyZWFtLmVuZCgpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbWF5YmVFcnIpO1xufTtcblxuLy8gPT09XG5cbkMuc3RhcnRIZWFydGJlYXRlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5oZWFydGJlYXQgPT09IDApIHJldHVybiBudWxsO1xuICBlbHNlIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGhiID0gbmV3IEhlYXJ0KHRoaXMuaGVhcnRiZWF0LFxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2VuZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUmVjdi5iaW5kKHRoaXMpKTtcbiAgICBoYi5vbigndGltZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhiZXJyID0gbmV3IEVycm9yKFwiSGVhcnRiZWF0IHRpbWVvdXRcIik7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgaGJlcnIpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ0hlYXJ0YmVhdCB0aW1lb3V0Jyk7XG4gICAgICBzZWxmLnRvQ2xvc2VkKHMsIGhiZXJyKTtcbiAgICB9KTtcbiAgICBoYi5vbignYmVhdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5zZW5kSGVhcnRiZWF0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhiO1xuICB9XG59O1xuXG4vLyBJIHVzZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSBjaGFubmVscywgcmF0aGVyIHRoYW4gYW5cbi8vIG9iamVjdC4gVGhlIGNoYW5uZWwgaWRlbnRpZmllcnMgYXJlIG51bWJlcnMsIGFuZCBhbGxvY2F0ZWQgYnkgdGhlXG4vLyBjb25uZWN0aW9uLiBJZiBJIHRyeSB0byBhbGxvY2F0ZSBsb3cgbnVtYmVycyB3aGVuIHRoZXkgYXJlXG4vLyBhdmFpbGFibGUgKHdoaWNoIEkgZG8sIGJ5IGxvb2tpbmcgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGJpdHNldCksXG4vLyB0aGlzIG91Z2h0IHRvIGtlZXAgdGhlIGFycmF5IHNtYWxsLCBhbmQgb3V0IG9mICdzcGFyc2UgYXJyYXlcbi8vIHN0b3JhZ2UnLiBJIGFsc28gc2V0IGVudHJpZXMgdG8gbnVsbCwgcmF0aGVyIHRoYW4gZGVsZXRpbmcgdGhlbSwgaW5cbi8vIHRoZSBleHBlY3RhdGlvbiB0aGF0IHRoZSBuZXh0IGNoYW5uZWwgYWxsb2NhdGlvbiB3aWxsIGZpbGwgdGhlIHNsb3Rcbi8vIGFnYWluIHJhdGhlciB0aGFuIGdyb3dpbmcgdGhlIGFycmF5LiBTZWVcbi8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3NwZWVkL3Y4L1xuQy5mcmVzaENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsLCBvcHRpb25zKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5mcmVlQ2hhbm5lbHMubmV4dENsZWFyQml0KDEpO1xuICBpZiAobmV4dCA8IDAgfHwgbmV4dCA+IHRoaXMuY2hhbm5lbE1heClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFubmVscyBsZWZ0IHRvIGFsbG9jYXRlXCIpO1xuICB0aGlzLmZyZWVDaGFubmVscy5zZXQobmV4dCk7XG5cbiAgdmFyIGh3bSA9IChvcHRpb25zICYmIG9wdGlvbnMuaGlnaFdhdGVyTWFyaykgfHwgREVGQVVMVF9XUklURV9IV007XG4gIHZhciB3cml0ZUJ1ZmZlciA9IG5ldyBQYXNzVGhyb3VnaCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogaHdtXG4gIH0pO1xuICB0aGlzLmNoYW5uZWxzW25leHRdID0ge2NoYW5uZWw6IGNoYW5uZWwsIGJ1ZmZlcjogd3JpdGVCdWZmZXJ9O1xuICB3cml0ZUJ1ZmZlci5vbignZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICBjaGFubmVsLm9uQnVmZmVyRHJhaW4oKTtcbiAgfSk7XG4gIHRoaXMubXV4ZXIucGlwZUZyb20od3JpdGVCdWZmZXIpO1xuICByZXR1cm4gbmV4dDtcbn07XG5cbkMucmVsZWFzZUNoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKSB7XG4gIHRoaXMuZnJlZUNoYW5uZWxzLmNsZWFyKGNoYW5uZWwpO1xuICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG4gIGJ1ZmZlci5lbmQoKTsgLy8gd2lsbCBhbHNvIGNhdXNlIGl0IHRvIGJlIHVucGlwZWRcbiAgdGhpcy5jaGFubmVsc1tjaGFubmVsXSA9IG51bGw7XG59O1xuXG5DLmFjY2VwdExvb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGdvKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZjsgd2hpbGUgKGYgPSBzZWxmLnJlY3ZGcmFtZSgpKSBzZWxmLmFjY2VwdChmKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHNlbGYuZW1pdCgnZnJhbWVFcnJvcicsIGUpO1xuICAgIH1cbiAgfVxuICBzZWxmLnN0cmVhbS5vbigncmVhZGFibGUnLCBnbyk7XG4gIGdvKCk7XG59O1xuXG5DLnN0ZXAgPSBmdW5jdGlvbihjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIHJlY3YoKSB7XG4gICAgdmFyIGY7XG4gICAgdHJ5IHtcbiAgICAgIGYgPSBzZWxmLnJlY3ZGcmFtZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmKSBjYihudWxsLCBmKTtcbiAgICBlbHNlIHNlbGYuc3RyZWFtLm9uY2UoJ3JlYWRhYmxlJywgcmVjdik7XG4gIH1cbiAgcmVjdigpO1xufTtcblxuQy5jaGVja1NlbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoZWNrID0gdGhpcy5zZW50U2luY2VMYXN0Q2hlY2s7XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG4gIHJldHVybiBjaGVjaztcbn1cblxuQy5jaGVja1JlY3YgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoZWNrID0gdGhpcy5yZWN2U2luY2VMYXN0Q2hlY2s7XG4gIHRoaXMucmVjdlNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG4gIHJldHVybiBjaGVjaztcbn1cblxuQy5zZW5kQnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gIHRoaXMuc3RyZWFtLndyaXRlKGJ5dGVzKTtcbn07XG5cbkMuc2VuZEhlYXJ0YmVhdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZW5kQnl0ZXMoZnJhbWUuSEVBUlRCRUFUX0JVRik7XG59O1xuXG52YXIgZW5jb2RlTWV0aG9kID0gZGVmcy5lbmNvZGVNZXRob2Q7XG52YXIgZW5jb2RlUHJvcGVydGllcyA9IGRlZnMuZW5jb2RlUHJvcGVydGllcztcblxuQy5zZW5kTWV0aG9kID0gZnVuY3Rpb24oY2hhbm5lbCwgTWV0aG9kLCBmaWVsZHMpIHtcbiAgdmFyIGZyYW1lID0gZW5jb2RlTWV0aG9kKE1ldGhvZCwgY2hhbm5lbCwgZmllbGRzKTtcbiAgdGhpcy5zZW50U2luY2VMYXN0Q2hlY2sgPSB0cnVlO1xuICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG4gIHJldHVybiBidWZmZXIud3JpdGUoZnJhbWUpO1xufTtcblxuQy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKGNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgTWV0aG9kLCBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgUHJvcGVydGllcywgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250ZW50IGlzIG5vdCBhIGJ1ZmZlcicpO1xuXG4gIHZhciBtZnJhbWUgPSBlbmNvZGVNZXRob2QoTWV0aG9kLCBjaGFubmVsLCBmaWVsZHMpO1xuICB2YXIgcGZyYW1lID0gZW5jb2RlUHJvcGVydGllcyhQcm9wZXJ0aWVzLCBjaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Lmxlbmd0aCwgcHJvcHMpO1xuICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcblxuICB2YXIgbWV0aG9kSGVhZGVyTGVuID0gbWZyYW1lLmxlbmd0aCArIHBmcmFtZS5sZW5ndGg7XG4gIHZhciBib2R5TGVuID0gKGNvbnRlbnQubGVuZ3RoID4gMCkgP1xuICAgIGNvbnRlbnQubGVuZ3RoICsgRlJBTUVfT1ZFUkhFQUQgOiAwO1xuICB2YXIgYWxsTGVuID0gbWV0aG9kSGVhZGVyTGVuICsgYm9keUxlbjtcblxuICBpZiAoYWxsTGVuIDwgU0lOR0xFX0NIVU5LX1RIUkVTSE9MRCkge1xuICAgIC8vIFVzZSBgYWxsb2NVbnNhZmVgIHRvIGF2b2lkIGV4Y2Vzc2l2ZSBhbGxvY2F0aW9ucyBhbmQgQ1BVIHVzYWdlXG4gICAgLy8gZnJvbSB6ZXJvaW5nLiBUaGUgcmV0dXJuZWQgQnVmZmVyIGlzIG5vdCB6ZXJvZWQgYW5kIHNvIG11c3QgYmVcbiAgICAvLyBjb21wbGV0ZWx5IGZpbGxlZCB0byBiZSB1c2VkIHNhZmVseS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FtcXAtbm9kZS9hbXFwbGliL3B1bGwvNjk1XG4gICAgdmFyIGFsbCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShhbGxMZW4pO1xuICAgIHZhciBvZmZzZXQgPSBtZnJhbWUuY29weShhbGwsIDApO1xuICAgIG9mZnNldCArPSBwZnJhbWUuY29weShhbGwsIG9mZnNldCk7XG5cbiAgICBpZiAoYm9keUxlbiA+IDApXG4gICAgICBtYWtlQm9keUZyYW1lKGNoYW5uZWwsIGNvbnRlbnQpLmNvcHkoYWxsLCBvZmZzZXQpO1xuICAgIHJldHVybiBidWZmZXIud3JpdGUoYWxsKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAobWV0aG9kSGVhZGVyTGVuIDwgU0lOR0xFX0NIVU5LX1RIUkVTSE9MRCkge1xuICAgICAgLy8gVXNlIGBhbGxvY1Vuc2FmZWAgdG8gYXZvaWQgZXhjZXNzaXZlIGFsbG9jYXRpb25zIGFuZCBDUFUgdXNhZ2VcbiAgICAgIC8vIGZyb20gemVyb2luZy4gVGhlIHJldHVybmVkIEJ1ZmZlciBpcyBub3QgemVyb2VkIGFuZCBzbyBtdXN0IGJlXG4gICAgICAvLyBjb21wbGV0ZWx5IGZpbGxlZCB0byBiZSB1c2VkIHNhZmVseS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW1xcC1ub2RlL2FtcXBsaWIvcHVsbC82OTVcbiAgICAgIHZhciBib3RoID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1ldGhvZEhlYWRlckxlbik7XG4gICAgICB2YXIgb2Zmc2V0ID0gbWZyYW1lLmNvcHkoYm90aCwgMCk7XG4gICAgICBwZnJhbWUuY29weShib3RoLCBvZmZzZXQpO1xuICAgICAgYnVmZmVyLndyaXRlKGJvdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJ1ZmZlci53cml0ZShtZnJhbWUpO1xuICAgICAgYnVmZmVyLndyaXRlKHBmcmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlbmRDb250ZW50KGNoYW5uZWwsIGNvbnRlbnQpO1xuICB9XG59O1xuXG52YXIgRlJBTUVfT1ZFUkhFQUQgPSBkZWZzLkZSQU1FX09WRVJIRUFEO1xudmFyIG1ha2VCb2R5RnJhbWUgPSBmcmFtZS5tYWtlQm9keUZyYW1lO1xuXG5DLnNlbmRDb250ZW50ID0gZnVuY3Rpb24oY2hhbm5lbCwgYm9keSkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZm10KFwiRXhwZWN0ZWQgYnVmZmVyOyBnb3QgJXNcIiwgYm9keSkpO1xuICB9XG4gIHZhciB3cml0ZVJlc3VsdCA9IHRydWU7XG4gIHZhciBidWZmZXIgPSB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmJ1ZmZlcjtcblxuICB2YXIgbWF4Qm9keSA9IHRoaXMuZnJhbWVNYXggLSBGUkFNRV9PVkVSSEVBRDtcblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBib2R5Lmxlbmd0aDsgb2Zmc2V0ICs9IG1heEJvZHkpIHtcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgbWF4Qm9keTtcbiAgICB2YXIgc2xpY2UgPSAoZW5kID4gYm9keS5sZW5ndGgpID8gYm9keS5zbGljZShvZmZzZXQpIDogYm9keS5zbGljZShvZmZzZXQsIGVuZCk7XG4gICAgdmFyIGJvZHlGcmFtZSA9IG1ha2VCb2R5RnJhbWUoY2hhbm5lbCwgc2xpY2UpO1xuICAgIHdyaXRlUmVzdWx0ID0gYnVmZmVyLndyaXRlKGJvZHlGcmFtZSk7XG4gIH1cbiAgdGhpcy5zZW50U2luY2VMYXN0Q2hlY2sgPSB0cnVlO1xuICByZXR1cm4gd3JpdGVSZXN1bHQ7XG59O1xuXG52YXIgcGFyc2VGcmFtZSA9IGZyYW1lLnBhcnNlRnJhbWU7XG52YXIgZGVjb2RlRnJhbWUgPSBmcmFtZS5kZWNvZGVGcmFtZTtcblxuQy5yZWN2RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgLy8gJSUlIGlkZW50aWZ5aW5nIGludmFyaWFudHMgbWlnaHQgaGVscCBoZXJlP1xuICB2YXIgZnJhbWUgPSBwYXJzZUZyYW1lKHRoaXMucmVzdCwgdGhpcy5mcmFtZU1heCk7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHZhciBpbmNvbWluZyA9IHRoaXMuc3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoaW5jb21pbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gICAgICB0aGlzLnJlc3QgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlc3QsIGluY29taW5nXSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWN2RnJhbWUoKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5yZXN0ID0gZnJhbWUucmVzdDtcbiAgICByZXR1cm4gZGVjb2RlRnJhbWUoZnJhbWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cmFwU3RyZWFtKHMpIHtcbiAgaWYgKHMgaW5zdGFuY2VvZiBEdXBsZXgpIHJldHVybiBzO1xuICBlbHNlIHtcbiAgICB2YXIgd3MgPSBuZXcgRHVwbGV4KCk7XG4gICAgd3Mud3JhcChzKTsgLy93cmFwcyB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGluZ3NcbiAgICB3cy5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcy53cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiB3cztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ZhdGFsRXJyb3IoZXJyb3IpIHtcbiAgc3dpdGNoIChlcnJvciAmJiBlcnJvci5jb2RlKSB7XG4gIGNhc2UgZGVmcy5jb25zdGFudHMuQ09OTkVDVElPTl9GT1JDRUQ6XG4gIGNhc2UgZGVmcy5jb25zdGFudHMuUkVQTFlfU1VDQ0VTUzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5pc0ZhdGFsRXJyb3IgPSBpc0ZhdGFsRXJyb3I7XG4iLCIvL1xuLy9cbi8vXG5cbi8vIERpZmZlcmVudCBraW5kIG9mIGNyZWRlbnRpYWxzIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHdoZW4gb3BlbmluZyBhXG4vLyBjb25uZWN0aW9uLCBjb3JyZXNwb25kaW5nIHRvIFNBU0wgbWVjaGFuaXNtcyBUaGVyZSdzIG9ubHkgdHdvXG4vLyB1c2VmdWwgbWVjaGFuaXNtcyB0aGF0IFJhYmJpdE1RIGltcGxlbWVudHM6XG4vLyAgKiBQTEFJTiAoc2VuZCB1c2VybmFtZSBhbmQgcGFzc3dvcmQgaW4gdGhlIHBsYWluKVxuLy8gICogRVhURVJOQUwgKGFzc3VtZSB0aGUgc2VydmVyIHdpbGwgZmlndXJlIG91dCB3aG8geW91IGFyZSBmcm9tXG4vLyAgICBjb250ZXh0LCBpLmUuLCB5b3VyIFNTTCBjZXJ0aWZpY2F0ZSlcbnZhciBjb2RlYyA9IHJlcXVpcmUoJy4vY29kZWMnKVxuXG5tb2R1bGUuZXhwb3J0cy5wbGFpbiA9IGZ1bmN0aW9uKHVzZXIsIHBhc3N3ZCkge1xuICByZXR1cm4ge1xuICAgIG1lY2hhbmlzbTogJ1BMQUlOJyxcbiAgICByZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oWycnLCB1c2VyLCBwYXNzd2RdLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZSgwKSkpXG4gICAgfSxcbiAgICB1c2VybmFtZTogdXNlcixcbiAgICBwYXNzd29yZDogcGFzc3dkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuYW1xcGxhaW4gPSBmdW5jdGlvbih1c2VyLCBwYXNzd2QpIHtcbiAgcmV0dXJuIHtcbiAgICBtZWNoYW5pc206ICdBTVFQTEFJTicsXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2Mzg0KTtcbiAgICAgIGNvbnN0IHNpemUgPSBjb2RlYy5lbmNvZGVUYWJsZShidWZmZXIsIHsgTE9HSU46IHVzZXIsIFBBU1NXT1JEOiBwYXNzd2R9LCAwKTtcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoNCwgc2l6ZSk7XG4gICAgfSxcbiAgICB1c2VybmFtZTogdXNlcixcbiAgICBwYXNzd29yZDogcGFzc3dkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuZXh0ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZWNoYW5pc206ICdFWFRFUk5BTCcsXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVyLmZyb20oJycpOyB9XG4gIH1cbn1cbiIsIi8qKiBAcHJlc2VydmUgVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSB0aGUgc2NyaXB0XG4gKiAuLi9iaW4vZ2VuZXJhdGUtZGVmcy5qcywgd2hpY2ggaXMgbm90IGluIGdlbmVyYWwgaW5jbHVkZWQgaW4gYVxuICogZGlzdHJpYnV0aW9uLCBidXQgaXMgYXZhaWxhYmxlIGluIHRoZSBzb3VyY2UgcmVwb3NpdG9yeSBlLmcuIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3F1YXJlbW8vYW1xcC5ub2RlL1xuICovXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblN0YXJ0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB2ZXJzaW9uTWFqb3I6IHZvaWQgMCxcbiAgICB2ZXJzaW9uTWlub3I6IHZvaWQgMCxcbiAgICBzZXJ2ZXJQcm9wZXJ0aWVzOiB2b2lkIDAsXG4gICAgbWVjaGFuaXNtczogdm9pZCAwLFxuICAgIGxvY2FsZXM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgb2Zmc2V0Kys7XG4gIGZpZWxkcy52ZXJzaW9uTWFqb3IgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlcltvZmZzZXRdO1xuICBvZmZzZXQrKztcbiAgZmllbGRzLnZlcnNpb25NaW5vciA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuc2VydmVyUHJvcGVydGllcyA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLm1lY2hhbmlzbXMgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5sb2NhbGVzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uU3RhcnQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5zZXJ2ZXJQcm9wZXJ0aWVzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnc2VydmVyUHJvcGVydGllcydcIik7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnc2VydmVyUHJvcGVydGllcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgc2VydmVyUHJvcGVydGllc19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IHNlcnZlclByb3BlcnRpZXNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5tZWNoYW5pc21zO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IEJ1ZmZlci5mcm9tKFwiUExBSU5cIik7IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZWNoYW5pc21zJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFsID0gZmllbGRzLmxvY2FsZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gQnVmZmVyLmZyb20oXCJlbl9VU1wiKTsgZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2xvY2FsZXMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIyICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy52ZXJzaW9uTWFqb3I7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndmVyc2lvbk1ham9yJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50OCh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBmaWVsZHMudmVyc2lvbk1pbm9yO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDk7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ZlcnNpb25NaW5vcicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDgodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgb2Zmc2V0ICs9IHNlcnZlclByb3BlcnRpZXNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgdmFsID0gZmllbGRzLm1lY2hhbmlzbXM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbShcIlBMQUlOXCIpKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICB2YWwgPSBmaWVsZHMubG9jYWxlcztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKFwiZW5fVVNcIikpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblN0YXJ0T2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNsaWVudFByb3BlcnRpZXM6IHZvaWQgMCxcbiAgICBtZWNoYW5pc206IHZvaWQgMCxcbiAgICByZXNwb25zZTogdm9pZCAwLFxuICAgIGxvY2FsZTogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNsaWVudFByb3BlcnRpZXMgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMubWVjaGFuaXNtID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVzcG9uc2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMubG9jYWxlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uU3RhcnRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLmNsaWVudFByb3BlcnRpZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjbGllbnRQcm9wZXJ0aWVzJ1wiKTtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbGllbnRQcm9wZXJ0aWVzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBjbGllbnRQcm9wZXJ0aWVzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gY2xpZW50UHJvcGVydGllc19lbmNvZGVkLmxlbmd0aDtcbiAgdmFsID0gZmllbGRzLm1lY2hhbmlzbTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlBMQUlOXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lY2hhbmlzbScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBtZWNoYW5pc21fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IG1lY2hhbmlzbV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3Jlc3BvbnNlJ1wiKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXNwb25zZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5sb2NhbGU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJlbl9VU1wiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdsb2NhbGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgbG9jYWxlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBsb2NhbGVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE4ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIG9mZnNldCArPSBjbGllbnRQcm9wZXJ0aWVzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIHZhbCA9IGZpZWxkcy5tZWNoYW5pc207XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlBMQUlOXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IG1lY2hhbmlzbV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IG1lY2hhbmlzbV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKHZvaWQgMCkpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIHZhbCA9IGZpZWxkcy5sb2NhbGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcImVuX1VTXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGxvY2FsZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGxvY2FsZV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblNlY3VyZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbGxlbmdlOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNoYWxsZW5nZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblNlY3VyZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2hhbGxlbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY2hhbGxlbmdlJ1wiKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjaGFsbGVuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzgwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jaGFsbGVuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbSh2b2lkIDApKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25TZWN1cmVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVzcG9uc2U6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVzcG9uc2UgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25TZWN1cmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVzcG9uc2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZXNwb25zZSdcIik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVzcG9uc2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzgxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKHZvaWQgMCkpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblR1bmUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjaGFubmVsTWF4OiB2b2lkIDAsXG4gICAgZnJhbWVNYXg6IHZvaWQgMCxcbiAgICBoZWFydGJlYXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMuY2hhbm5lbE1heCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLmZyYW1lTWF4ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMuaGVhcnRiZWF0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uVHVuZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMCk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzOTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxNYXg7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbE1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmZyYW1lTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2ZyYW1lTWF4JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBmaWVsZHMuaGVhcnRiZWF0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2hlYXJ0YmVhdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uVHVuZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbE1heDogdm9pZCAwLFxuICAgIGZyYW1lTWF4OiB2b2lkIDAsXG4gICAgaGVhcnRiZWF0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNoYW5uZWxNYXggPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5mcmFtZU1heCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmhlYXJ0YmVhdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblR1bmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMCk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzOTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxNYXg7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbE1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmZyYW1lTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2ZyYW1lTWF4JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBmaWVsZHMuaGVhcnRiZWF0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2hlYXJ0YmVhdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uT3BlbihidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdmlydHVhbEhvc3Q6IHZvaWQgMCxcbiAgICBjYXBhYmlsaXRpZXM6IHZvaWQgMCxcbiAgICBpbnNpc3Q6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnZpcnR1YWxIb3N0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNhcGFiaWxpdGllcyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmluc2lzdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbk9wZW4oY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMudmlydHVhbEhvc3Q7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCIvXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ZpcnR1YWxIb3N0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHZpcnR1YWxIb3N0X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2aXJ0dWFsSG9zdF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jYXBhYmlsaXRpZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2FwYWJpbGl0aWVzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNhcGFiaWxpdGllc19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY2FwYWJpbGl0aWVzX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNSArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQwMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudmlydHVhbEhvc3Q7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIi9cIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gdmlydHVhbEhvc3RfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSB2aXJ0dWFsSG9zdF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jYXBhYmlsaXRpZXM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjYXBhYmlsaXRpZXNfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjYXBhYmlsaXRpZXNfbGVuO1xuICB2YWwgPSBmaWVsZHMuaW5zaXN0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbk9wZW5PayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAga25vd25Ib3N0czogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMua25vd25Ib3N0cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbk9wZW5PayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmtub3duSG9zdHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAna25vd25Ib3N0cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBrbm93bkhvc3RzX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBrbm93bkhvc3RzX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQwMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMua25vd25Ib3N0cztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGtub3duSG9zdHNfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBrbm93bkhvc3RzX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uQ2xvc2UoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlcGx5Q29kZTogdm9pZCAwLFxuICAgIHJlcGx5VGV4dDogdm9pZCAwLFxuICAgIGNsYXNzSWQ6IHZvaWQgMCxcbiAgICBtZXRob2RJZDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5yZXBseUNvZGUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVwbHlUZXh0ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMuY2xhc3NJZCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLm1ldGhvZElkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uQ2xvc2UoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRleHQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlUZXh0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJlcGx5VGV4dF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcmVwbHlUZXh0X2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOSArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVwbHlDb2RlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVwbHlDb2RlJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5Q29kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VGV4dF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jbGFzc0lkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY2xhc3NJZCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbGFzc0lkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMubWV0aG9kSWQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXRob2RJZCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXRob2RJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uQ2xvc2VPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uQ2xvc2VPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uQmxvY2tlZChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVhc29uOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZWFzb24gPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25CbG9ja2VkKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVhc29uO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlYXNvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZWFzb25fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlYXNvbl9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlYXNvbjtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlYXNvbl9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlYXNvbl9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblVuYmxvY2tlZChidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uVW5ibG9ja2VkKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQyMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxPcGVuKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBvdXRPZkJhbmQ6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLm91dE9mQmFuZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbE9wZW4oY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5vdXRPZkJhbmQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnb3V0T2ZCYW5kJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIG91dE9mQmFuZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gb3V0T2ZCYW5kX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3MzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm91dE9mQmFuZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IG91dE9mQmFuZF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IG91dE9mQmFuZF9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbE9wZW5PayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbElkOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNoYW5uZWxJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbE9wZW5PayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2hhbm5lbElkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IEJ1ZmZlci5mcm9tKFwiXCIpOyBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3MzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxJZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKFwiXCIpKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxGbG93KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBmaWVsZHMgPSB7XG4gICAgYWN0aXZlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlclswXSk7XG4gIGZpZWxkcy5hY3RpdmUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxGbG93KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzQwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdhY3RpdmUnXCIpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbEZsb3dPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgZmllbGRzID0ge1xuICAgIGFjdGl2ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbMF0pO1xuICBmaWVsZHMuYWN0aXZlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDaGFubmVsRmxvd09rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzQxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdhY3RpdmUnXCIpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbENsb3NlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXBseUNvZGU6IHZvaWQgMCxcbiAgICByZXBseVRleHQ6IHZvaWQgMCxcbiAgICBjbGFzc0lkOiB2b2lkIDAsXG4gICAgbWV0aG9kSWQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucmVwbHlDb2RlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlcGx5VGV4dCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNsYXNzSWQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5tZXRob2RJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbENsb3NlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTkgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzYwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXBseUNvZGU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZXBseUNvZGUnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlDb2RlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcmVwbHlUZXh0X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVwbHlUZXh0X2xlbjtcbiAgdmFsID0gZmllbGRzLmNsYXNzSWQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjbGFzc0lkJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsYXNzSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5tZXRob2RJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21ldGhvZElkJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21ldGhvZElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxDbG9zZU9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxDbG9zZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3NjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBY2Nlc3NSZXF1ZXN0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZWFsbTogdm9pZCAwLFxuICAgIGV4Y2x1c2l2ZTogdm9pZCAwLFxuICAgIHBhc3NpdmU6IHZvaWQgMCxcbiAgICBhY3RpdmU6IHZvaWQgMCxcbiAgICB3cml0ZTogdm9pZCAwLFxuICAgIHJlYWQ6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlYWxtID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZXhjbHVzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucGFzc2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmFjdGl2ZSA9IHZhbDtcbiAgdmFsID0gISEoOCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLndyaXRlID0gdmFsO1xuICB2YWwgPSAhISgxNiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlYWQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUFjY2Vzc1JlcXVlc3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVhbG07XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCIvZGF0YVwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZWFsbScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZWFsbV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcmVhbG1fbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE0ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMTk2NjA5MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVhbG07XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIi9kYXRhXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlYWxtX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVhbG1fbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjbHVzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5wYXNzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMCk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLndyaXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIHZhbCA9IGZpZWxkcy5yZWFkO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMTYpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUFjY2Vzc1JlcXVlc3RPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUFjY2Vzc1JlcXVlc3RPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNCk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxOTY2MDkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMTsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlRGVjbGFyZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICB0eXBlOiB2b2lkIDAsXG4gICAgcGFzc2l2ZTogdm9pZCAwLFxuICAgIGR1cmFibGU6IHZvaWQgMCxcbiAgICBhdXRvRGVsZXRlOiB2b2lkIDAsXG4gICAgaW50ZXJuYWw6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnR5cGUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5wYXNzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZHVyYWJsZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmF1dG9EZWxldGUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5pbnRlcm5hbCA9IHZhbDtcbiAgdmFsID0gISEoMTYgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlRGVjbGFyZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiZGlyZWN0XCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3R5cGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgdHlwZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdHlwZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJkaXJlY3RcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gdHlwZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHR5cGVfbGVuO1xuICB2YWwgPSBmaWVsZHMucGFzc2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuZHVyYWJsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICB2YWwgPSBmaWVsZHMuYXV0b0RlbGV0ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICB2YWwgPSBmaWVsZHMuaW50ZXJuYWw7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA4KTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZURlY2xhcmVPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlY2xhcmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWxldGUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgaWZVbnVzZWQ6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaWZVbnVzZWQgPSB2YWw7XG4gIHZhbCA9ICEhKDIgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5pZlVudXNlZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWxldGVPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZUJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGRlc3RpbmF0aW9uOiB2b2lkIDAsXG4gICAgc291cmNlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZGVzdGluYXRpb24gPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuc291cmNlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlQmluZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5kZXN0aW5hdGlvbjtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2Rlc3RpbmF0aW9uJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2Rlc3RpbmF0aW9uJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGRlc3RpbmF0aW9uX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBkZXN0aW5hdGlvbl9sZW47XG4gIHZhbCA9IGZpZWxkcy5zb3VyY2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdzb3VyY2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnc291cmNlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHNvdXJjZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gc291cmNlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE4ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmRlc3RpbmF0aW9uO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBkZXN0aW5hdGlvbl9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGRlc3RpbmF0aW9uX2xlbjtcbiAgdmFsID0gZmllbGRzLnNvdXJjZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gc291cmNlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gc291cmNlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZUJpbmRPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZUJpbmRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VVbmJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGRlc3RpbmF0aW9uOiB2b2lkIDAsXG4gICAgc291cmNlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZGVzdGluYXRpb24gPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuc291cmNlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLmRlc3RpbmF0aW9uO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZGVzdGluYXRpb24nXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVzdGluYXRpb24nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZGVzdGluYXRpb25fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGRlc3RpbmF0aW9uX2xlbjtcbiAgdmFsID0gZmllbGRzLnNvdXJjZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3NvdXJjZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdzb3VyY2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgc291cmNlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBzb3VyY2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMuYXJndW1lbnRzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IHt9OyBlbHNlIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnYXJndW1lbnRzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBhcmd1bWVudHNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICB2YXJ5aW5nU2l6ZSArPSBhcmd1bWVudHNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTggKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDgwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMuZGVzdGluYXRpb247XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGRlc3RpbmF0aW9uX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZGVzdGluYXRpb25fbGVuO1xuICB2YWwgPSBmaWVsZHMuc291cmNlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBzb3VyY2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBzb3VyY2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlVW5iaW5kT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VVbmJpbmRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWNsYXJlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIHBhc3NpdmU6IHZvaWQgMCxcbiAgICBkdXJhYmxlOiB2b2lkIDAsXG4gICAgZXhjbHVzaXZlOiB2b2lkIDAsXG4gICAgYXV0b0RlbGV0ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5wYXNzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZHVyYWJsZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmV4Y2x1c2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoOCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmF1dG9EZWxldGUgPSB2YWw7XG4gIHZhbCA9ICEhKDE2ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5wYXNzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5kdXJhYmxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5leGNsdXNpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLmF1dG9EZWxldGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA4KTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZURlY2xhcmVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBtZXNzYWdlQ291bnQ6IHZvaWQgMCxcbiAgICBjb25zdW1lckNvdW50OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLmNvbnN1bWVyQ291bnQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdxdWV1ZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgxMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMubWVzc2FnZUNvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWVzc2FnZUNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lc3NhZ2VDb3VudCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lckNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVCaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmFyZ3VtZW50cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVCaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlQmluZE9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlQmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZVB1cmdlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlUHVyZ2UoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVQdXJnZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgbWVzc2FnZUNvdW50OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVQdXJnZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21lc3NhZ2VDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWxldGUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgaWZVbnVzZWQ6IHZvaWQgMCxcbiAgICBpZkVtcHR5OiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmlmVW51c2VkID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaWZFbXB0eSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVEZWxldGUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuaWZVbnVzZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgdmFsID0gZmllbGRzLmlmRW1wdHk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAyKTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlRGVsZXRlT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBtZXNzYWdlQ291bnQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMubWVzc2FnZUNvdW50ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NDEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21lc3NhZ2VDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVVbmJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgYXJndW1lbnRzOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3Njg1MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVVbmJpbmRPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZVVuYmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1FvcyhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHByZWZldGNoU2l6ZTogdm9pZCAwLFxuICAgIHByZWZldGNoQ291bnQ6IHZvaWQgMCxcbiAgICBnbG9iYWw6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMucHJlZmV0Y2hTaXplID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucHJlZmV0Y2hDb3VudCA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmdsb2JhbCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNRb3MoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE5KTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxNzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnByZWZldGNoU2l6ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdwcmVmZXRjaFNpemUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGZpZWxkcy5wcmVmZXRjaENvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ByZWZldGNoQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5nbG9iYWw7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1Fvc09rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUW9zT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQ29uc3VtZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIG5vTG9jYWw6IHZvaWQgMCxcbiAgICBub0Fjazogdm9pZCAwLFxuICAgIGV4Y2x1c2l2ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY29uc3VtZXJUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub0xvY2FsID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9BY2sgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5leGNsdXNpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljQ29uc3VtZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMubm9Mb2NhbDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMubm9BY2s7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAyKTtcbiAgdmFsID0gZmllbGRzLmV4Y2x1c2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDb25zdW1lT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDb25zdW1lT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NvbnN1bWVyVGFnJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyVGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNvbnN1bWVyVGFnX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMTgxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY29uc3VtZXJUYWdfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjb25zdW1lclRhZ19sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDYW5jZWwoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDYW5jZWwoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE0ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE5MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDYW5jZWxPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY29uc3VtZXJUYWc6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0NhbmNlbE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE5MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUHVibGlzaChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgbWFuZGF0b3J5OiB2b2lkIDAsXG4gICAgaW1tZWRpYXRlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubWFuZGF0b3J5ID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaW1tZWRpYXRlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1B1Ymxpc2goY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyMDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm1hbmRhdG9yeTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuaW1tZWRpYXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZXR1cm4oYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlcGx5Q29kZTogdm9pZCAwLFxuICAgIHJlcGx5VGV4dDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5yZXBseUNvZGUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVwbHlUZXh0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmV0dXJuKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncm91dGluZ0tleSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVwbHlDb2RlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVwbHlDb2RlJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5Q29kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VGV4dF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNEZWxpdmVyKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgcmVkZWxpdmVyZWQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICBmaWVsZHMuZGVsaXZlcnlUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZWRlbGl2ZXJlZCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNEZWxpdmVyKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY29uc3VtZXJUYWcnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyb3V0aW5nS2V5J1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjQgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjIwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY29uc3VtZXJUYWdfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVkZWxpdmVyZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNHZXQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgbm9BY2s6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9BY2sgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljR2V0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vQWNrO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNHZXRPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICByZWRlbGl2ZXJlZDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG1lc3NhZ2VDb3VudDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlZGVsaXZlcmVkID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMubWVzc2FnZUNvdW50ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyb3V0aW5nS2V5J1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjcgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVkZWxpdmVyZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXNzYWdlQ291bnQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVzc2FnZUNvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljR2V0RW1wdHkoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNsdXN0ZXJJZDogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY2x1c3RlcklkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldEVtcHR5KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2x1c3RlcklkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsdXN0ZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjbHVzdGVySWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNsdXN0ZXJJZF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMyLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jbHVzdGVySWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjbHVzdGVySWRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjbHVzdGVySWRfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQWNrKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICBtdWx0aXBsZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm11bHRpcGxlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0FjayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjEpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI0MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIHZhbCA9IGZpZWxkcy5tdWx0aXBsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVqZWN0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICByZXF1ZXVlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gaW50cy5yZWFkVUludDY0QkUoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgZmllbGRzLmRlbGl2ZXJ5VGFnID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNSZWplY3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmRlbGl2ZXJ5VGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZGVsaXZlcnlUYWcnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIHZhbCA9IGZpZWxkcy5yZXF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZWNvdmVyQXN5bmMoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGZpZWxkcyA9IHtcbiAgICByZXF1ZXVlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlclswXSk7XG4gIGZpZWxkcy5yZXF1ZXVlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1JlY292ZXJBc3luYyhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI2MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVjb3ZlcihidWZmZXIpIHtcbiAgdmFyIHZhbCwgZmllbGRzID0ge1xuICAgIHJlcXVldWU6IHZvaWQgMFxuICB9O1xuICB2YWwgPSAhISgxICYgYnVmZmVyWzBdKTtcbiAgZmllbGRzLnJlcXVldWUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmVjb3ZlcihjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVjb3Zlck9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmVjb3Zlck9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY05hY2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBkZWxpdmVyeVRhZzogdm9pZCAwLFxuICAgIG11bHRpcGxlOiB2b2lkIDAsXG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm11bHRpcGxlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNOYWNrKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjgwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZWxpdmVyeVRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgdmFsID0gZmllbGRzLm11bHRpcGxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5yZXF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhTZWxlY3QoYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhTZWxlY3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTg5ODI1MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4U2VsZWN0T2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhTZWxlY3RPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhDb21taXQoYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhDb21taXQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTg5ODI2MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4Q29tbWl0T2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhDb21taXRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjYxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhSb2xsYmFjayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeFJvbGxiYWNrKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeFJvbGxiYWNrT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhSb2xsYmFja09rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25maXJtU2VsZWN0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBmaWVsZHMgPSB7XG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlclswXSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbmZpcm1TZWxlY3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU1NzA1NzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbmZpcm1TZWxlY3RPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25maXJtU2VsZWN0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTU3MDU3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUHJvcGVydGllcyhjaGFubmVsLCBzaXplLCBmaWVsZHMpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmbGFncyA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50VHlwZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29udGVudFR5cGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBjb250ZW50VHlwZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGNvbnRlbnRUeXBlX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuY29udGVudEVuY29kaW5nO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb250ZW50RW5jb2RpbmcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBjb250ZW50RW5jb2RpbmdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBjb250ZW50RW5jb2RpbmdfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5oZWFkZXJzO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnaGVhZGVycycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gICAgdmFyIGhlYWRlcnNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gICAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gICAgdmFyeWluZ1NpemUgKz0gaGVhZGVyc19lbmNvZGVkLmxlbmd0aDtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlNb2RlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZWxpdmVyeU1vZGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgfVxuICB2YWwgPSBmaWVsZHMucHJpb3JpdHk7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ByaW9yaXR5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gIH1cbiAgdmFsID0gZmllbGRzLmNvcnJlbGF0aW9uSWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvcnJlbGF0aW9uSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBjb3JyZWxhdGlvbklkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gY29ycmVsYXRpb25JZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLnJlcGx5VG87XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VG8nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciByZXBseVRvX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gcmVwbHlUb19sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmV4cGlyYXRpb247XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4cGlyYXRpb24nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBleHBpcmF0aW9uX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gZXhwaXJhdGlvbl9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVzc2FnZUlkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgbWVzc2FnZUlkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gbWVzc2FnZUlkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMudGltZXN0YW1wO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aW1lc3RhbXAnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gODtcbiAgfVxuICB2YWwgPSBmaWVsZHMudHlwZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndHlwZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIHR5cGVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSB0eXBlX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMudXNlcklkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd1c2VySWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciB1c2VySWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSB1c2VySWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5hcHBJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnYXBwSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBhcHBJZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGFwcElkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuY2x1c3RlcklkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbHVzdGVySWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBjbHVzdGVySWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBjbHVzdGVySWRfbGVuO1xuICB9XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDI7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMTYwLCA3KTtcbiAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgc2l6ZSwgMTEpO1xuICBmbGFncyA9IDA7XG4gIG9mZnNldCA9IDIxO1xuICB2YWwgPSBmaWVsZHMuY29udGVudFR5cGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMzI3Njg7XG4gICAgYnVmZmVyW29mZnNldF0gPSBjb250ZW50VHlwZV9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGNvbnRlbnRUeXBlX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuY29udGVudEVuY29kaW5nO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDE2Mzg0O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gY29udGVudEVuY29kaW5nX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gY29udGVudEVuY29kaW5nX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuaGVhZGVycztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA4MTkyO1xuICAgIG9mZnNldCArPSBoZWFkZXJzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIH1cbiAgdmFsID0gZmllbGRzLmRlbGl2ZXJ5TW9kZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA0MDk2O1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgfVxuICB2YWwgPSBmaWVsZHMucHJpb3JpdHk7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMjA0ODtcbiAgICBidWZmZXIud3JpdGVVSW50OCh2YWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gIH1cbiAgdmFsID0gZmllbGRzLmNvcnJlbGF0aW9uSWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMTAyNDtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGNvcnJlbGF0aW9uSWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBjb3JyZWxhdGlvbklkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMucmVwbHlUbztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA1MTI7XG4gICAgYnVmZmVyW29mZnNldF0gPSByZXBseVRvX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gcmVwbHlUb19sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmV4cGlyYXRpb247XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMjU2O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gZXhwaXJhdGlvbl9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGV4cGlyYXRpb25fbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlSWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMTI4O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gbWVzc2FnZUlkX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gbWVzc2FnZUlkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMudGltZXN0YW1wO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDY0O1xuICAgIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gODtcbiAgfVxuICB2YWwgPSBmaWVsZHMudHlwZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAzMjtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHR5cGVfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSB0eXBlX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMudXNlcklkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDE2O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdXNlcklkX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gdXNlcklkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuYXBwSWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gODtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGFwcElkX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gYXBwSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jbHVzdGVySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gNDtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGNsdXN0ZXJJZF9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGNsdXN0ZXJJZF9sZW47XG4gIH1cbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShmbGFncywgMTkpO1xuICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG9mZnNldCArIDEpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1Byb3BlcnRpZXMoYnVmZmVyKSB7XG4gIHZhciBmbGFncywgdmFsLCBsZW4sIG9mZnNldCA9IDI7XG4gIGZsYWdzID0gYnVmZmVyLnJlYWRVSW50MTZCRSgwKTtcbiAgaWYgKDAgPT09IGZsYWdzKSByZXR1cm4ge307XG4gIHZhciBmaWVsZHMgPSB7XG4gICAgY29udGVudFR5cGU6IHZvaWQgMCxcbiAgICBjb250ZW50RW5jb2Rpbmc6IHZvaWQgMCxcbiAgICBoZWFkZXJzOiB2b2lkIDAsXG4gICAgZGVsaXZlcnlNb2RlOiB2b2lkIDAsXG4gICAgcHJpb3JpdHk6IHZvaWQgMCxcbiAgICBjb3JyZWxhdGlvbklkOiB2b2lkIDAsXG4gICAgcmVwbHlUbzogdm9pZCAwLFxuICAgIGV4cGlyYXRpb246IHZvaWQgMCxcbiAgICBtZXNzYWdlSWQ6IHZvaWQgMCxcbiAgICB0aW1lc3RhbXA6IHZvaWQgMCxcbiAgICB0eXBlOiB2b2lkIDAsXG4gICAgdXNlcklkOiB2b2lkIDAsXG4gICAgYXBwSWQ6IHZvaWQgMCxcbiAgICBjbHVzdGVySWQ6IHZvaWQgMFxuICB9O1xuICBpZiAoMzI3NjggJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5jb250ZW50VHlwZSA9IHZhbDtcbiAgfVxuICBpZiAoMTYzODQgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5jb250ZW50RW5jb2RpbmcgPSB2YWw7XG4gIH1cbiAgaWYgKDgxOTIgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuaGVhZGVycyA9IHZhbDtcbiAgfVxuICBpZiAoNDA5NiAmIGZsYWdzKSB7XG4gICAgdmFsID0gYnVmZmVyW29mZnNldF07XG4gICAgb2Zmc2V0Kys7XG4gICAgZmllbGRzLmRlbGl2ZXJ5TW9kZSA9IHZhbDtcbiAgfVxuICBpZiAoMjA0OCAmIGZsYWdzKSB7XG4gICAgdmFsID0gYnVmZmVyW29mZnNldF07XG4gICAgb2Zmc2V0Kys7XG4gICAgZmllbGRzLnByaW9yaXR5ID0gdmFsO1xuICB9XG4gIGlmICgxMDI0ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuY29ycmVsYXRpb25JZCA9IHZhbDtcbiAgfVxuICBpZiAoNTEyICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMucmVwbHlUbyA9IHZhbDtcbiAgfVxuICBpZiAoMjU2ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuZXhwaXJhdGlvbiA9IHZhbDtcbiAgfVxuICBpZiAoMTI4ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMubWVzc2FnZUlkID0gdmFsO1xuICB9XG4gIGlmICg2NCAmIGZsYWdzKSB7XG4gICAgdmFsID0gaW50cy5yZWFkVUludDY0QkUoYnVmZmVyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA4O1xuICAgIGZpZWxkcy50aW1lc3RhbXAgPSB2YWw7XG4gIH1cbiAgaWYgKDMyICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMudHlwZSA9IHZhbDtcbiAgfVxuICBpZiAoMTYgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy51c2VySWQgPSB2YWw7XG4gIH1cbiAgaWYgKDggJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5hcHBJZCA9IHZhbDtcbiAgfVxuICBpZiAoNCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmNsdXN0ZXJJZCA9IHZhbDtcbiAgfVxuICByZXR1cm4gZmllbGRzO1xufVxuXG52YXIgY29kZWMgPSByZXF1aXJlKFwiLi9jb2RlY1wiKSwgaW50cyA9IHJlcXVpcmUoXCJidWZmZXItbW9yZS1pbnRzXCIpLCBlbmNvZGVUYWJsZSA9IGNvZGVjLmVuY29kZVRhYmxlLCBkZWNvZGVGaWVsZHMgPSBjb2RlYy5kZWNvZGVGaWVsZHMsIFNDUkFUQ0ggPSBCdWZmZXIuYWxsb2MoNjU1MzYpLCBFTVBUWV9PQkpFQ1QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICBGUkFNRV9NRVRIT0Q6IDEsXG4gIEZSQU1FX0hFQURFUjogMixcbiAgRlJBTUVfQk9EWTogMyxcbiAgRlJBTUVfSEVBUlRCRUFUOiA4LFxuICBGUkFNRV9NSU5fU0laRTogNDA5NixcbiAgRlJBTUVfRU5EOiAyMDYsXG4gIFJFUExZX1NVQ0NFU1M6IDIwMCxcbiAgQ09OVEVOVF9UT09fTEFSR0U6IDMxMSxcbiAgTk9fUk9VVEU6IDMxMixcbiAgTk9fQ09OU1VNRVJTOiAzMTMsXG4gIEFDQ0VTU19SRUZVU0VEOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBSRVNPVVJDRV9MT0NLRUQ6IDQwNSxcbiAgUFJFQ09ORElUSU9OX0ZBSUxFRDogNDA2LFxuICBDT05ORUNUSU9OX0ZPUkNFRDogMzIwLFxuICBJTlZBTElEX1BBVEg6IDQwMixcbiAgRlJBTUVfRVJST1I6IDUwMSxcbiAgU1lOVEFYX0VSUk9SOiA1MDIsXG4gIENPTU1BTkRfSU5WQUxJRDogNTAzLFxuICBDSEFOTkVMX0VSUk9SOiA1MDQsXG4gIFVORVhQRUNURURfRlJBTUU6IDUwNSxcbiAgUkVTT1VSQ0VfRVJST1I6IDUwNixcbiAgTk9UX0FMTE9XRUQ6IDUzMCxcbiAgTk9UX0lNUExFTUVOVEVEOiA1NDAsXG4gIElOVEVSTkFMX0VSUk9SOiA1NDFcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvbnN0YW50X3N0cnMgPSB7XG4gIFwiMVwiOiBcIkZSQU1FLU1FVEhPRFwiLFxuICBcIjJcIjogXCJGUkFNRS1IRUFERVJcIixcbiAgXCIzXCI6IFwiRlJBTUUtQk9EWVwiLFxuICBcIjhcIjogXCJGUkFNRS1IRUFSVEJFQVRcIixcbiAgXCIyMDBcIjogXCJSRVBMWS1TVUNDRVNTXCIsXG4gIFwiMjA2XCI6IFwiRlJBTUUtRU5EXCIsXG4gIFwiMzExXCI6IFwiQ09OVEVOVC1UT08tTEFSR0VcIixcbiAgXCIzMTJcIjogXCJOTy1ST1VURVwiLFxuICBcIjMxM1wiOiBcIk5PLUNPTlNVTUVSU1wiLFxuICBcIjMyMFwiOiBcIkNPTk5FQ1RJT04tRk9SQ0VEXCIsXG4gIFwiNDAyXCI6IFwiSU5WQUxJRC1QQVRIXCIsXG4gIFwiNDAzXCI6IFwiQUNDRVNTLVJFRlVTRURcIixcbiAgXCI0MDRcIjogXCJOT1QtRk9VTkRcIixcbiAgXCI0MDVcIjogXCJSRVNPVVJDRS1MT0NLRURcIixcbiAgXCI0MDZcIjogXCJQUkVDT05ESVRJT04tRkFJTEVEXCIsXG4gIFwiNTAxXCI6IFwiRlJBTUUtRVJST1JcIixcbiAgXCI1MDJcIjogXCJTWU5UQVgtRVJST1JcIixcbiAgXCI1MDNcIjogXCJDT01NQU5ELUlOVkFMSURcIixcbiAgXCI1MDRcIjogXCJDSEFOTkVMLUVSUk9SXCIsXG4gIFwiNTA1XCI6IFwiVU5FWFBFQ1RFRC1GUkFNRVwiLFxuICBcIjUwNlwiOiBcIlJFU09VUkNFLUVSUk9SXCIsXG4gIFwiNTMwXCI6IFwiTk9ULUFMTE9XRURcIixcbiAgXCI1NDBcIjogXCJOT1QtSU1QTEVNRU5URURcIixcbiAgXCI1NDFcIjogXCJJTlRFUk5BTC1FUlJPUlwiLFxuICBcIjQwOTZcIjogXCJGUkFNRS1NSU4tU0laRVwiXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5GUkFNRV9PVkVSSEVBRCA9IDg7XG5cbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlkLCBidWYpIHtcbiAgc3dpdGNoIChpZCkge1xuICAgY2FzZSA2NTUzNzA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TdGFydChidWYpO1xuXG4gICBjYXNlIDY1NTM3MTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblN0YXJ0T2soYnVmKTtcblxuICAgY2FzZSA2NTUzODA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TZWN1cmUoYnVmKTtcblxuICAgY2FzZSA2NTUzODE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TZWN1cmVPayhidWYpO1xuXG4gICBjYXNlIDY1NTM5MDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblR1bmUoYnVmKTtcblxuICAgY2FzZSA2NTUzOTE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25UdW5lT2soYnVmKTtcblxuICAgY2FzZSA2NTU0MDA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25PcGVuKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDAxOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uT3Blbk9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDEwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uQ2xvc2UoYnVmKTtcblxuICAgY2FzZSA2NTU0MTE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25DbG9zZU9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDIwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uQmxvY2tlZChidWYpO1xuXG4gICBjYXNlIDY1NTQyMTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblVuYmxvY2tlZChidWYpO1xuXG4gICBjYXNlIDEzMTA3MzA6XG4gICAgcmV0dXJuIGRlY29kZUNoYW5uZWxPcGVuKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDczMTpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbE9wZW5PayhidWYpO1xuXG4gICBjYXNlIDEzMTA3NDA6XG4gICAgcmV0dXJuIGRlY29kZUNoYW5uZWxGbG93KGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc0MTpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbEZsb3dPayhidWYpO1xuXG4gICBjYXNlIDEzMTA3NjA6XG4gICAgcmV0dXJuIGRlY29kZUNoYW5uZWxDbG9zZShidWYpO1xuXG4gICBjYXNlIDEzMTA3NjE6XG4gICAgcmV0dXJuIGRlY29kZUNoYW5uZWxDbG9zZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMTk2NjA5MDpcbiAgICByZXR1cm4gZGVjb2RlQWNjZXNzUmVxdWVzdChidWYpO1xuXG4gICBjYXNlIDE5NjYwOTE6XG4gICAgcmV0dXJuIGRlY29kZUFjY2Vzc1JlcXVlc3RPayhidWYpO1xuXG4gICBjYXNlIDI2MjE0NTA6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlRGVjbGFyZShidWYpO1xuXG4gICBjYXNlIDI2MjE0NTE6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlRGVjbGFyZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ2MDpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VEZWxldGUoYnVmKTtcblxuICAgY2FzZSAyNjIxNDYxOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZURlbGV0ZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ3MDpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VCaW5kKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ3MTpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VCaW5kT2soYnVmKTtcblxuICAgY2FzZSAyNjIxNDgwOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZVVuYmluZChidWYpO1xuXG4gICBjYXNlIDI2MjE0OTE6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlVW5iaW5kT2soYnVmKTtcblxuICAgY2FzZSAzMjc2ODEwOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZURlY2xhcmUoYnVmKTtcblxuICAgY2FzZSAzMjc2ODExOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZURlY2xhcmVPayhidWYpO1xuXG4gICBjYXNlIDMyNzY4MjA6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlQmluZChidWYpO1xuXG4gICBjYXNlIDMyNzY4MjE6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlQmluZE9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgzMDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVQdXJnZShidWYpO1xuXG4gICBjYXNlIDMyNzY4MzE6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlUHVyZ2VPayhidWYpO1xuXG4gICBjYXNlIDMyNzY4NDA6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlRGVsZXRlKGJ1Zik7XG5cbiAgIGNhc2UgMzI3Njg0MTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVEZWxldGVPayhidWYpO1xuXG4gICBjYXNlIDMyNzY4NTA6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlVW5iaW5kKGJ1Zik7XG5cbiAgIGNhc2UgMzI3Njg1MTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVVbmJpbmRPayhidWYpO1xuXG4gICBjYXNlIDM5MzIxNzA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUW9zKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE3MTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNRb3NPayhidWYpO1xuXG4gICBjYXNlIDM5MzIxODA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQ29uc3VtZShidWYpO1xuXG4gICBjYXNlIDM5MzIxODE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQ29uc3VtZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE5MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNDYW5jZWwoYnVmKTtcblxuICAgY2FzZSAzOTMyMTkxOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0NhbmNlbE9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIwMDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNQdWJsaXNoKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIxMDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZXR1cm4oYnVmKTtcblxuICAgY2FzZSAzOTMyMjIwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0RlbGl2ZXIoYnVmKTtcblxuICAgY2FzZSAzOTMyMjMwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0dldChidWYpO1xuXG4gICBjYXNlIDM5MzIyMzE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljR2V0T2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjMyOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0dldEVtcHR5KGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI0MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNBY2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjUwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1JlamVjdChidWYpO1xuXG4gICBjYXNlIDM5MzIyNjA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUmVjb3ZlckFzeW5jKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI3MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZWNvdmVyKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI3MTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZWNvdmVyT2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjgwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY05hY2soYnVmKTtcblxuICAgY2FzZSA1ODk4MjUwOlxuICAgIHJldHVybiBkZWNvZGVUeFNlbGVjdChidWYpO1xuXG4gICBjYXNlIDU4OTgyNTE6XG4gICAgcmV0dXJuIGRlY29kZVR4U2VsZWN0T2soYnVmKTtcblxuICAgY2FzZSA1ODk4MjYwOlxuICAgIHJldHVybiBkZWNvZGVUeENvbW1pdChidWYpO1xuXG4gICBjYXNlIDU4OTgyNjE6XG4gICAgcmV0dXJuIGRlY29kZVR4Q29tbWl0T2soYnVmKTtcblxuICAgY2FzZSA1ODk4MjcwOlxuICAgIHJldHVybiBkZWNvZGVUeFJvbGxiYWNrKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI3MTpcbiAgICByZXR1cm4gZGVjb2RlVHhSb2xsYmFja09rKGJ1Zik7XG5cbiAgIGNhc2UgNTU3MDU3MDpcbiAgICByZXR1cm4gZGVjb2RlQ29uZmlybVNlbGVjdChidWYpO1xuXG4gICBjYXNlIDU1NzA1NzE6XG4gICAgcmV0dXJuIGRlY29kZUNvbmZpcm1TZWxlY3RPayhidWYpO1xuXG4gICBjYXNlIDYwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1Byb3BlcnRpZXMoYnVmKTtcblxuICAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNsYXNzL21ldGhvZCBJRFwiKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlTWV0aG9kID0gZnVuY3Rpb24oaWQsIGNoYW5uZWwsIGZpZWxkcykge1xuICBzd2l0Y2ggKGlkKSB7XG4gICBjYXNlIDY1NTM3MDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblN0YXJ0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzcxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU3RhcnRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTM4MDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblNlY3VyZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTM4MTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblNlY3VyZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzkwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uVHVuZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTM5MTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvblR1bmVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQwMDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbk9wZW4oY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MDE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25PcGVuT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MTA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25DbG9zZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQxMTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbkNsb3NlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MjA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25CbG9ja2VkKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDIxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uVW5ibG9ja2VkKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDczMDpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbE9wZW4oY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxMzEwNzMxOlxuICAgIHJldHVybiBlbmNvZGVDaGFubmVsT3Blbk9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDc0MDpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbEZsb3coY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxMzEwNzQxOlxuICAgIHJldHVybiBlbmNvZGVDaGFubmVsRmxvd09rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDc2MDpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbENsb3NlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDc2MTpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbENsb3NlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxOTY2MDkwOlxuICAgIHJldHVybiBlbmNvZGVBY2Nlc3NSZXF1ZXN0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTk2NjA5MTpcbiAgICByZXR1cm4gZW5jb2RlQWNjZXNzUmVxdWVzdE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ1MDpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VEZWNsYXJlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ1MTpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VEZWNsYXJlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDYwOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZURlbGV0ZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NjE6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlRGVsZXRlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDcwOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZUJpbmQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDcxOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZUJpbmRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0ODA6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ5MTpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VVbmJpbmRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MTA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlRGVjbGFyZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MTE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgyMDpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVCaW5kKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgyMTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVCaW5kT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODMwOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZVB1cmdlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgzMTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVQdXJnZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3Njg0MDpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVEZWxldGUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODQxOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3Njg1MDpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVVbmJpbmQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODUxOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZVVuYmluZE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE3MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNRb3MoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTcxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1Fvc09rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE4MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNDb25zdW1lKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE4MTpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNDb25zdW1lT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTkwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0NhbmNlbChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxOTE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQ2FuY2VsT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjAwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1B1Ymxpc2goY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjEwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1JldHVybihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMjA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljRGVsaXZlcihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMzA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljR2V0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIzMTpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNHZXRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMzI6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljR2V0RW1wdHkoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjQwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0FjayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNTA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmVqZWN0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI2MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNSZWNvdmVyQXN5bmMoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjcwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1JlY292ZXIoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjcxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1JlY292ZXJPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyODA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljTmFjayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNTA6XG4gICAgcmV0dXJuIGVuY29kZVR4U2VsZWN0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI1MTpcbiAgICByZXR1cm4gZW5jb2RlVHhTZWxlY3RPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNjA6XG4gICAgcmV0dXJuIGVuY29kZVR4Q29tbWl0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI2MTpcbiAgICByZXR1cm4gZW5jb2RlVHhDb21taXRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNzA6XG4gICAgcmV0dXJuIGVuY29kZVR4Um9sbGJhY2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjcxOlxuICAgIHJldHVybiBlbmNvZGVUeFJvbGxiYWNrT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1NTcwNTcwOlxuICAgIHJldHVybiBlbmNvZGVDb25maXJtU2VsZWN0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTU3MDU3MTpcbiAgICByZXR1cm4gZW5jb2RlQ29uZmlybVNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjbGFzcy9tZXRob2QgSURcIik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZVByb3BlcnRpZXMgPSBmdW5jdGlvbihpZCwgY2hhbm5lbCwgc2l6ZSwgZmllbGRzKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgIGNhc2UgNjA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUHJvcGVydGllcyhjaGFubmVsLCBzaXplLCBmaWVsZHMpO1xuXG4gICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2xhc3MvcHJvcGVydGllcyBJRFwiKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaW5mbyA9IGZ1bmN0aW9uKGlkKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgIGNhc2UgNjU1MzcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0O1xuXG4gICBjYXNlIDY1NTM3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydE9rO1xuXG4gICBjYXNlIDY1NTM4MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmU7XG5cbiAgIGNhc2UgNjU1MzgxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZU9rO1xuXG4gICBjYXNlIDY1NTM5MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lO1xuXG4gICBjYXNlIDY1NTM5MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lT2s7XG5cbiAgIGNhc2UgNjU1NDAwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvbk9wZW47XG5cbiAgIGNhc2UgNjU1NDAxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvbk9wZW5PaztcblxuICAgY2FzZSA2NTU0MTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2U7XG5cbiAgIGNhc2UgNjU1NDExOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlT2s7XG5cbiAgIGNhc2UgNjU1NDIwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvbkJsb2NrZWQ7XG5cbiAgIGNhc2UgNjU1NDIxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblVuYmxvY2tlZDtcblxuICAgY2FzZSAxMzEwNzMwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbE9wZW47XG5cbiAgIGNhc2UgMTMxMDczMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxPcGVuT2s7XG5cbiAgIGNhc2UgMTMxMDc0MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxGbG93O1xuXG4gICBjYXNlIDEzMTA3NDE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsRmxvd09rO1xuXG4gICBjYXNlIDEzMTA3NjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsQ2xvc2U7XG5cbiAgIGNhc2UgMTMxMDc2MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxDbG9zZU9rO1xuXG4gICBjYXNlIDE5NjYwOTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0O1xuXG4gICBjYXNlIDE5NjYwOTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0T2s7XG5cbiAgIGNhc2UgMjYyMTQ1MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZTtcblxuICAgY2FzZSAyNjIxNDUxOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlT2s7XG5cbiAgIGNhc2UgMjYyMTQ2MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlO1xuXG4gICBjYXNlIDI2MjE0NjE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZU9rO1xuXG4gICBjYXNlIDI2MjE0NzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZUJpbmQ7XG5cbiAgIGNhc2UgMjYyMTQ3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlQmluZE9rO1xuXG4gICBjYXNlIDI2MjE0ODA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZVVuYmluZDtcblxuICAgY2FzZSAyNjIxNDkxOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmRPaztcblxuICAgY2FzZSAzMjc2ODEwOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVEZWNsYXJlO1xuXG4gICBjYXNlIDMyNzY4MTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZURlY2xhcmVPaztcblxuICAgY2FzZSAzMjc2ODIwOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVCaW5kO1xuXG4gICBjYXNlIDMyNzY4MjE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZUJpbmRPaztcblxuICAgY2FzZSAzMjc2ODMwOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVQdXJnZTtcblxuICAgY2FzZSAzMjc2ODMxOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVQdXJnZU9rO1xuXG4gICBjYXNlIDMyNzY4NDA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZURlbGV0ZTtcblxuICAgY2FzZSAzMjc2ODQxOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVEZWxldGVPaztcblxuICAgY2FzZSAzMjc2ODUwOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVVbmJpbmQ7XG5cbiAgIGNhc2UgMzI3Njg1MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlVW5iaW5kT2s7XG5cbiAgIGNhc2UgMzkzMjE3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUW9zO1xuXG4gICBjYXNlIDM5MzIxNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1Fvc09rO1xuXG4gICBjYXNlIDM5MzIxODA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0NvbnN1bWU7XG5cbiAgIGNhc2UgMzkzMjE4MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljQ29uc3VtZU9rO1xuXG4gICBjYXNlIDM5MzIxOTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0NhbmNlbDtcblxuICAgY2FzZSAzOTMyMTkxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNDYW5jZWxPaztcblxuICAgY2FzZSAzOTMyMjAwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNQdWJsaXNoO1xuXG4gICBjYXNlIDM5MzIyMTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JldHVybjtcblxuICAgY2FzZSAzOTMyMjIwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNEZWxpdmVyO1xuXG4gICBjYXNlIDM5MzIyMzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0dldDtcblxuICAgY2FzZSAzOTMyMjMxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNHZXRPaztcblxuICAgY2FzZSAzOTMyMjMyOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNHZXRFbXB0eTtcblxuICAgY2FzZSAzOTMyMjQwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNBY2s7XG5cbiAgIGNhc2UgMzkzMjI1MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUmVqZWN0O1xuXG4gICBjYXNlIDM5MzIyNjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JlY292ZXJBc3luYztcblxuICAgY2FzZSAzOTMyMjcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNSZWNvdmVyO1xuXG4gICBjYXNlIDM5MzIyNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JlY292ZXJPaztcblxuICAgY2FzZSAzOTMyMjgwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNOYWNrO1xuXG4gICBjYXNlIDU4OTgyNTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeFNlbGVjdDtcblxuICAgY2FzZSA1ODk4MjUxOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhTZWxlY3RPaztcblxuICAgY2FzZSA1ODk4MjYwOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhDb21taXQ7XG5cbiAgIGNhc2UgNTg5ODI2MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Q29tbWl0T2s7XG5cbiAgIGNhc2UgNTg5ODI3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Um9sbGJhY2s7XG5cbiAgIGNhc2UgNTg5ODI3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Um9sbGJhY2tPaztcblxuICAgY2FzZSA1NTcwNTcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29uZmlybVNlbGVjdDtcblxuICAgY2FzZSA1NTcwNTcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29uZmlybVNlbGVjdE9rO1xuXG4gICBjYXNlIDYwOlxuICAgIHJldHVybiBwcm9wZXJ0aWVzSW5mb0Jhc2ljUHJvcGVydGllcztcblxuICAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNsYXNzL21ldGhvZCBJRFwiKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblN0YXJ0ID0gNjU1MzcwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnQgPSB7XG4gIGlkOiA2NTUzNzAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblN0YXJ0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcInZlcnNpb25NYWpvclwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcInZlcnNpb25NaW5vclwiLFxuICAgIGRlZmF1bHQ6IDlcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcInNlcnZlclByb3BlcnRpZXNcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJtZWNoYW5pc21zXCIsXG4gICAgZGVmYXVsdDogXCJQTEFJTlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcImxvY2FsZXNcIixcbiAgICBkZWZhdWx0OiBcImVuX1VTXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uU3RhcnRPayA9IDY1NTM3MTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnRPayA9IHtcbiAgaWQ6IDY1NTM3MSxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJDb25uZWN0aW9uU3RhcnRPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJjbGllbnRQcm9wZXJ0aWVzXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcIm1lY2hhbmlzbVwiLFxuICAgIGRlZmF1bHQ6IFwiUExBSU5cIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJyZXNwb25zZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJsb2NhbGVcIixcbiAgICBkZWZhdWx0OiBcImVuX1VTXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uU2VjdXJlID0gNjU1MzgwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZSA9IHtcbiAgaWQ6IDY1NTM4MCxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiAyMCxcbiAgbmFtZTogXCJDb25uZWN0aW9uU2VjdXJlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwiY2hhbGxlbmdlXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uU2VjdXJlT2sgPSA2NTUzODE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmVPayA9IHtcbiAgaWQ6IDY1NTM4MSxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiAyMSxcbiAgbmFtZTogXCJDb25uZWN0aW9uU2VjdXJlT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJyZXNwb25zZVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblR1bmUgPSA2NTUzOTA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblR1bmUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblR1bmUgPSB7XG4gIGlkOiA2NTUzOTAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogMzAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblR1bmVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiY2hhbm5lbE1heFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwiZnJhbWVNYXhcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJoZWFydGJlYXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblR1bmVPayA9IDY1NTM5MTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lT2sgPSB7XG4gIGlkOiA2NTUzOTEsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogMzEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblR1bmVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJjaGFubmVsTWF4XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJmcmFtZU1heFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImhlYXJ0YmVhdFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uT3BlbiA9IDY1NTQwMDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uT3BlbiA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uT3BlbiA9IHtcbiAgaWQ6IDY1NTQwMCxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiA0MCxcbiAgbmFtZTogXCJDb25uZWN0aW9uT3BlblwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJ2aXJ0dWFsSG9zdFwiLFxuICAgIGRlZmF1bHQ6IFwiL1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjYXBhYmlsaXRpZXNcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiaW5zaXN0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uT3Blbk9rID0gNjU1NDAxO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvbk9wZW5PayA9IHtcbiAgaWQ6IDY1NTQwMSxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiA0MSxcbiAgbmFtZTogXCJDb25uZWN0aW9uT3Blbk9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImtub3duSG9zdHNcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbkNsb3NlID0gNjU1NDEwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2UgPSB7XG4gIGlkOiA2NTU0MTAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNTAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbkNsb3NlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInJlcGx5Q29kZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyZXBseVRleHRcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJjbGFzc0lkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcIm1ldGhvZElkXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uQ2xvc2VPayA9IDY1NTQxMTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2VPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2VPayA9IHtcbiAgaWQ6IDY1NTQxMSxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiA1MSxcbiAgbmFtZTogXCJDb25uZWN0aW9uQ2xvc2VPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbkJsb2NrZWQgPSA2NTU0MjA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbkJsb2NrZWQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvbkJsb2NrZWQgPSB7XG4gIGlkOiA2NTU0MjAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNjAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbkJsb2NrZWRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVhc29uXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25VbmJsb2NrZWQgPSA2NTU0MjE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblVuYmxvY2tlZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uVW5ibG9ja2VkID0ge1xuICBpZDogNjU1NDIxLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDYxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25VbmJsb2NrZWRcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxPcGVuID0gMTMxMDczMDtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsT3BlbiA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9DaGFubmVsT3BlbiA9IHtcbiAgaWQ6IDEzMTA3MzAsXG4gIGNsYXNzSWQ6IDIwLFxuICBtZXRob2RJZDogMTAsXG4gIG5hbWU6IFwiQ2hhbm5lbE9wZW5cIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwib3V0T2ZCYW5kXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxPcGVuT2sgPSAxMzEwNzMxO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxPcGVuT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbE9wZW5PayA9IHtcbiAgaWQ6IDEzMTA3MzEsXG4gIGNsYXNzSWQ6IDIwLFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiQ2hhbm5lbE9wZW5Pa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcImNoYW5uZWxJZFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsRmxvdyA9IDEzMTA3NDA7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbEZsb3cgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbEZsb3cgPSB7XG4gIGlkOiAxMzEwNzQwLFxuICBjbGFzc0lkOiAyMCxcbiAgbWV0aG9kSWQ6IDIwLFxuICBuYW1lOiBcIkNoYW5uZWxGbG93XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJhY3RpdmVcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxGbG93T2sgPSAxMzEwNzQxO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxGbG93T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbEZsb3dPayA9IHtcbiAgaWQ6IDEzMTA3NDEsXG4gIGNsYXNzSWQ6IDIwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiQ2hhbm5lbEZsb3dPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYWN0aXZlXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsQ2xvc2UgPSAxMzEwNzYwO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxDbG9zZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9DaGFubmVsQ2xvc2UgPSB7XG4gIGlkOiAxMzEwNzYwLFxuICBjbGFzc0lkOiAyMCxcbiAgbWV0aG9kSWQ6IDQwLFxuICBuYW1lOiBcIkNoYW5uZWxDbG9zZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJyZXBseUNvZGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVwbHlUZXh0XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiY2xhc3NJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJtZXRob2RJZFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbENsb3NlT2sgPSAxMzEwNzYxO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxDbG9zZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxDbG9zZU9rID0ge1xuICBpZDogMTMxMDc2MSxcbiAgY2xhc3NJZDogMjAsXG4gIG1ldGhvZElkOiA0MSxcbiAgbmFtZTogXCJDaGFubmVsQ2xvc2VPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQWNjZXNzUmVxdWVzdCA9IDE5NjYwOTA7XG5cbnZhciBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0ID0ge1xuICBpZDogMTk2NjA5MCxcbiAgY2xhc3NJZDogMzAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJBY2Nlc3NSZXF1ZXN0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlYWxtXCIsXG4gICAgZGVmYXVsdDogXCIvZGF0YVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZXhjbHVzaXZlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJwYXNzaXZlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJhY3RpdmVcIixcbiAgICBkZWZhdWx0OiAhMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIndyaXRlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZWFkXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5BY2Nlc3NSZXF1ZXN0T2sgPSAxOTY2MDkxO1xuXG52YXIgbWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3RPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0T2sgPSB7XG4gIGlkOiAxOTY2MDkxLFxuICBjbGFzc0lkOiAzMCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkFjY2Vzc1JlcXVlc3RPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAxXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VEZWNsYXJlID0gMjYyMTQ1MDtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlID0ge1xuICBpZDogMjYyMTQ1MCxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJFeGNoYW5nZURlY2xhcmVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwidHlwZVwiLFxuICAgIGRlZmF1bHQ6IFwiZGlyZWN0XCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJwYXNzaXZlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJkdXJhYmxlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJhdXRvRGVsZXRlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpbnRlcm5hbFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VEZWNsYXJlT2sgPSAyNjIxNDUxO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZU9rID0ge1xuICBpZDogMjYyMTQ1MSxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJFeGNoYW5nZURlY2xhcmVPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VEZWxldGUgPSAyNjIxNDYwO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlID0ge1xuICBpZDogMjYyMTQ2MCxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiAyMCxcbiAgbmFtZTogXCJFeGNoYW5nZURlbGV0ZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiaWZVbnVzZWRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VEZWxldGVPayA9IDI2MjE0NjE7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VEZWxldGVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZU9rID0ge1xuICBpZDogMjYyMTQ2MSxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiAyMSxcbiAgbmFtZTogXCJFeGNoYW5nZURlbGV0ZU9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZUJpbmQgPSAyNjIxNDcwO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlQmluZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZUJpbmQgPSB7XG4gIGlkOiAyNjIxNDcwLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDMwLFxuICBuYW1lOiBcIkV4Y2hhbmdlQmluZFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJkZXN0aW5hdGlvblwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJzb3VyY2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZUJpbmRPayA9IDI2MjE0NzE7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VCaW5kT2sgPSB7XG4gIGlkOiAyNjIxNDcxLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIkV4Y2hhbmdlQmluZE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZVVuYmluZCA9IDI2MjE0ODA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmQgPSB7XG4gIGlkOiAyNjIxNDgwLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDQwLFxuICBuYW1lOiBcIkV4Y2hhbmdlVW5iaW5kXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImRlc3RpbmF0aW9uXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInNvdXJjZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyb3V0aW5nS2V5XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlVW5iaW5kT2sgPSAyNjIxNDkxO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmRPayA9IHtcbiAgaWQ6IDI2MjE0OTEsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogNTEsXG4gIG5hbWU6IFwiRXhjaGFuZ2VVbmJpbmRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVEZWNsYXJlID0gMzI3NjgxMDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZURlY2xhcmUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVEZWNsYXJlID0ge1xuICBpZDogMzI3NjgxMCxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJRdWV1ZURlY2xhcmVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicGFzc2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZHVyYWJsZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZXhjbHVzaXZlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJhdXRvRGVsZXRlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlY2xhcmVPayA9IDMyNzY4MTE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVEZWNsYXJlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVEZWNsYXJlT2sgPSB7XG4gIGlkOiAzMjc2ODExLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIlF1ZXVlRGVjbGFyZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwibWVzc2FnZUNvdW50XCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJDb3VudFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVCaW5kID0gMzI3NjgyMDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZUJpbmQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVCaW5kID0ge1xuICBpZDogMzI3NjgyMCxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiAyMCxcbiAgbmFtZTogXCJRdWV1ZUJpbmRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyb3V0aW5nS2V5XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlQmluZE9rID0gMzI3NjgyMTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZUJpbmRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZUJpbmRPayA9IHtcbiAgaWQ6IDMyNzY4MjEsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiUXVldWVCaW5kT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlUHVyZ2UgPSAzMjc2ODMwO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlUHVyZ2UgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVQdXJnZSA9IHtcbiAgaWQ6IDMyNzY4MzAsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogMzAsXG4gIG5hbWU6IFwiUXVldWVQdXJnZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlUHVyZ2VPayA9IDMyNzY4MzE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVQdXJnZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlUHVyZ2VPayA9IHtcbiAgaWQ6IDMyNzY4MzEsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogMzEsXG4gIG5hbWU6IFwiUXVldWVQdXJnZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwibWVzc2FnZUNvdW50XCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlbGV0ZSA9IDMyNzY4NDA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVEZWxldGUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVEZWxldGUgPSB7XG4gIGlkOiAzMjc2ODQwLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDQwLFxuICBuYW1lOiBcIlF1ZXVlRGVsZXRlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImlmVW51c2VkXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpZkVtcHR5XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVsZXRlT2sgPSAzMjc2ODQxO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlRGVsZXRlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVEZWxldGVPayA9IHtcbiAgaWQ6IDMyNzY4NDEsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogNDEsXG4gIG5hbWU6IFwiUXVldWVEZWxldGVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VDb3VudFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVVbmJpbmQgPSAzMjc2ODUwO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlVW5iaW5kID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlVW5iaW5kID0ge1xuICBpZDogMzI3Njg1MCxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiA1MCxcbiAgbmFtZTogXCJRdWV1ZVVuYmluZFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlVW5iaW5kT2sgPSAzMjc2ODUxO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlVW5iaW5kT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVVbmJpbmRPayA9IHtcbiAgaWQ6IDMyNzY4NTEsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogNTEsXG4gIG5hbWU6IFwiUXVldWVVbmJpbmRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNRb3MgPSAzOTMyMTcwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUW9zID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUW9zID0ge1xuICBpZDogMzkzMjE3MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJCYXNpY1Fvc1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcInByZWZldGNoU2l6ZVwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInByZWZldGNoQ291bnRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZ2xvYmFsXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1Fvc09rID0gMzkzMjE3MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY1Fvc09rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUW9zT2sgPSB7XG4gIGlkOiAzOTMyMTcxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkJhc2ljUW9zT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ29uc3VtZSA9IDM5MzIxODA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNDb25zdW1lID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ29uc3VtZSA9IHtcbiAgaWQ6IDM5MzIxODAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiQmFzaWNDb25zdW1lXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9Mb2NhbFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9BY2tcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImV4Y2x1c2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNDb25zdW1lT2sgPSAzOTMyMTgxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQ29uc3VtZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ29uc3VtZU9rID0ge1xuICBpZDogMzkzMjE4MSxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAyMSxcbiAgbmFtZTogXCJCYXNpY0NvbnN1bWVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb25zdW1lclRhZ1wiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNDYW5jZWwgPSAzOTMyMTkwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQ2FuY2VsID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ2FuY2VsID0ge1xuICBpZDogMzkzMjE5MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJCYXNpY0NhbmNlbFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb25zdW1lclRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0NhbmNlbE9rID0gMzkzMjE5MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NhbmNlbE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ2FuY2VsT2sgPSB7XG4gIGlkOiAzOTMyMTkxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIkJhc2ljQ2FuY2VsT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUHVibGlzaCA9IDM5MzIyMDA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNQdWJsaXNoID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUHVibGlzaCA9IHtcbiAgaWQ6IDM5MzIyMDAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNDAsXG4gIG5hbWU6IFwiQmFzaWNQdWJsaXNoXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJtYW5kYXRvcnlcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImltbWVkaWF0ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZXR1cm4gPSAzOTMyMjEwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmV0dXJuID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmV0dXJuID0ge1xuICBpZDogMzkzMjIxMCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA1MCxcbiAgbmFtZTogXCJCYXNpY1JldHVyblwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJyZXBseUNvZGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVwbHlUZXh0XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNEZWxpdmVyID0gMzkzMjIyMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0RlbGl2ZXIgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNEZWxpdmVyID0ge1xuICBpZDogMzkzMjIyMCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA2MCxcbiAgbmFtZTogXCJCYXNpY0RlbGl2ZXJcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nbG9uZ1wiLFxuICAgIG5hbWU6IFwiZGVsaXZlcnlUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlZGVsaXZlcmVkXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0ID0gMzkzMjIzMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0dldCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0dldCA9IHtcbiAgaWQ6IDM5MzIyMzAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNzAsXG4gIG5hbWU6IFwiQmFzaWNHZXRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9BY2tcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0T2sgPSAzOTMyMjMxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljR2V0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNHZXRPayA9IHtcbiAgaWQ6IDM5MzIyMzEsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNzEsXG4gIG5hbWU6IFwiQmFzaWNHZXRPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVkZWxpdmVyZWRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VDb3VudFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNHZXRFbXB0eSA9IDM5MzIyMzI7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNHZXRFbXB0eSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0dldEVtcHR5ID0ge1xuICBpZDogMzkzMjIzMixcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA3MixcbiAgbmFtZTogXCJCYXNpY0dldEVtcHR5XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNsdXN0ZXJJZFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0FjayA9IDM5MzIyNDA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNBY2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNBY2sgPSB7XG4gIGlkOiAzOTMyMjQwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDgwLFxuICBuYW1lOiBcIkJhc2ljQWNrXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm11bHRpcGxlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlamVjdCA9IDM5MzIyNTA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWplY3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWplY3QgPSB7XG4gIGlkOiAzOTMyMjUwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDkwLFxuICBuYW1lOiBcIkJhc2ljUmVqZWN0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZXF1ZXVlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlY292ZXJBc3luYyA9IDM5MzIyNjA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWNvdmVyQXN5bmMgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWNvdmVyQXN5bmMgPSB7XG4gIGlkOiAzOTMyMjYwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDEwMCxcbiAgbmFtZTogXCJCYXNpY1JlY292ZXJBc3luY1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZWNvdmVyID0gMzkzMjI3MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1JlY292ZXIgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWNvdmVyID0ge1xuICBpZDogMzkzMjI3MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMTAsXG4gIG5hbWU6IFwiQmFzaWNSZWNvdmVyXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZXF1ZXVlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlY292ZXJPayA9IDM5MzIyNzE7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWNvdmVyT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWNvdmVyT2sgPSB7XG4gIGlkOiAzOTMyMjcxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDExMSxcbiAgbmFtZTogXCJCYXNpY1JlY292ZXJPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNOYWNrID0gMzkzMjI4MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY05hY2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNOYWNrID0ge1xuICBpZDogMzkzMjI4MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMjAsXG4gIG5hbWU6IFwiQmFzaWNOYWNrXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm11bHRpcGxlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZXF1ZXVlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFNlbGVjdCA9IDU4OTgyNTA7XG5cbnZhciBtZXRob2RJbmZvVHhTZWxlY3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhTZWxlY3QgPSB7XG4gIGlkOiA1ODk4MjUwLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIlR4U2VsZWN0XCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFNlbGVjdE9rID0gNTg5ODI1MTtcblxudmFyIG1ldGhvZEluZm9UeFNlbGVjdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1R4U2VsZWN0T2sgPSB7XG4gIGlkOiA1ODk4MjUxLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIlR4U2VsZWN0T2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Q29tbWl0ID0gNTg5ODI2MDtcblxudmFyIG1ldGhvZEluZm9UeENvbW1pdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeENvbW1pdCA9IHtcbiAgaWQ6IDU4OTgyNjAsXG4gIGNsYXNzSWQ6IDkwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiVHhDb21taXRcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Q29tbWl0T2sgPSA1ODk4MjYxO1xuXG52YXIgbWV0aG9kSW5mb1R4Q29tbWl0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhDb21taXRPayA9IHtcbiAgaWQ6IDU4OTgyNjEsXG4gIGNsYXNzSWQ6IDkwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiVHhDb21taXRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuVHhSb2xsYmFjayA9IDU4OTgyNzA7XG5cbnZhciBtZXRob2RJbmZvVHhSb2xsYmFjayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFJvbGxiYWNrID0ge1xuICBpZDogNTg5ODI3MCxcbiAgY2xhc3NJZDogOTAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJUeFJvbGxiYWNrXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFJvbGxiYWNrT2sgPSA1ODk4MjcxO1xuXG52YXIgbWV0aG9kSW5mb1R4Um9sbGJhY2tPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFJvbGxiYWNrT2sgPSB7XG4gIGlkOiA1ODk4MjcxLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIlR4Um9sbGJhY2tPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29uZmlybVNlbGVjdCA9IDU1NzA1NzA7XG5cbnZhciBtZXRob2RJbmZvQ29uZmlybVNlbGVjdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25maXJtU2VsZWN0ID0ge1xuICBpZDogNTU3MDU3MCxcbiAgY2xhc3NJZDogODUsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJDb25maXJtU2VsZWN0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbmZpcm1TZWxlY3RPayA9IDU1NzA1NzE7XG5cbnZhciBtZXRob2RJbmZvQ29uZmlybVNlbGVjdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NvbmZpcm1TZWxlY3RPayA9IHtcbiAgaWQ6IDU1NzA1NzEsXG4gIGNsYXNzSWQ6IDg1LFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiQ29uZmlybVNlbGVjdE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1Byb3BlcnRpZXMgPSA2MDtcblxudmFyIHByb3BlcnRpZXNJbmZvQmFzaWNQcm9wZXJ0aWVzID0gbW9kdWxlLmV4cG9ydHMucHJvcGVydGllc0luZm9CYXNpY1Byb3BlcnRpZXMgPSB7XG4gIGlkOiA2MCxcbiAgbmFtZTogXCJCYXNpY1Byb3BlcnRpZXNcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29udGVudFR5cGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29udGVudEVuY29kaW5nXCJcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImhlYWRlcnNcIlxuICB9LCB7XG4gICAgdHlwZTogXCJvY3RldFwiLFxuICAgIG5hbWU6IFwiZGVsaXZlcnlNb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcInByaW9yaXR5XCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvcnJlbGF0aW9uSWRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVwbHlUb1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleHBpcmF0aW9uXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInRpbWVzdGFtcFwiLFxuICAgIG5hbWU6IFwidGltZXN0YW1wXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInR5cGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwidXNlcklkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImFwcElkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNsdXN0ZXJJZFwiXG4gIH0gXVxufTsiLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIHRyaW1TdGFjayhzdGFjaywgbnVtKSB7XG4gIHJldHVybiBzdGFjayAmJiBzdGFjay5zcGxpdCgnXFxuJykuc2xpY2UobnVtKS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gSWxsZWdhbE9wZXJhdGlvbkVycm9yKG1zZywgc3RhY2spIHtcbiAgdmFyIHRtcCA9IG5ldyBFcnJvcigpO1xuICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gIHRoaXMuc3RhY2sgPSB0aGlzLnRvU3RyaW5nKCkgKyAnXFxuJyArIHRyaW1TdGFjayh0bXAuc3RhY2ssIDIpO1xuICB0aGlzLnN0YWNrQXRTdGF0ZUNoYW5nZSA9IHN0YWNrO1xufVxuaW5oZXJpdHMoSWxsZWdhbE9wZXJhdGlvbkVycm9yLCBFcnJvcik7XG5cbklsbGVnYWxPcGVyYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbGxlZ2FsT3BlcmF0aW9uRXJyb3InO1xuXG5mdW5jdGlvbiBzdGFja0NhcHR1cmUocmVhc29uKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKCk7XG4gIHJldHVybiAnU3RhY2sgY2FwdHVyZTogJyArIHJlYXNvbiArICdcXG4nICtcbiAgICB0cmltU3RhY2soZS5zdGFjaywgMik7XG59XG5cbm1vZHVsZS5leHBvcnRzLklsbGVnYWxPcGVyYXRpb25FcnJvciA9IElsbGVnYWxPcGVyYXRpb25FcnJvcjtcbm1vZHVsZS5leHBvcnRzLnN0YWNrQ2FwdHVyZSA9IHN0YWNrQ2FwdHVyZTtcbiIsIi8vXG4vL1xuLy9cblxuLy8gU3RyaW5naWZ5aW5nIHZhcmlvdXMgdGhpbmdzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIEhFQVJUQkVBVCA9IHJlcXVpcmUoJy4vZnJhbWUnKS5IRUFSVEJFQVQ7XG5cbm1vZHVsZS5leHBvcnRzLmNsb3NlTWVzc2FnZSA9IGZ1bmN0aW9uKGNsb3NlKSB7XG4gIHZhciBjb2RlID0gY2xvc2UuZmllbGRzLnJlcGx5Q29kZTtcbiAgcmV0dXJuIGZvcm1hdCgnJWQgKCVzKSB3aXRoIG1lc3NhZ2UgXCIlc1wiJyxcbiAgICAgICAgICAgICAgICBjb2RlLCBkZWZzLmNvbnN0YW50X3N0cnNbY29kZV0sXG4gICAgICAgICAgICAgICAgY2xvc2UuZmllbGRzLnJlcGx5VGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1ldGhvZE5hbWUgPSBmdW5jdGlvbihpZCkge1xuICByZXR1cm4gZGVmcy5pbmZvKGlkKS5uYW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaW5zcGVjdCA9IGZ1bmN0aW9uKGZyYW1lLCBzaG93RmllbGRzKSB7XG4gIGlmIChmcmFtZSA9PT0gSEVBUlRCRUFUKSB7XG4gICAgcmV0dXJuICc8SGVhcnRiZWF0Pic7XG4gIH1cbiAgZWxzZSBpZiAoIWZyYW1lLmlkKSB7XG4gICAgcmV0dXJuIGZvcm1hdCgnPENvbnRlbnQgY2hhbm5lbDolZCBzaXplOiVkPicsXG4gICAgICAgICAgICAgICAgICBmcmFtZS5jaGFubmVsLCBmcmFtZS5zaXplKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgaW5mbyA9IGRlZnMuaW5mbyhmcmFtZS5pZCk7XG4gICAgcmV0dXJuIGZvcm1hdCgnPCVzIGNoYW5uZWw6JWQlcz4nLCBpbmZvLm5hbWUsIGZyYW1lLmNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAoc2hvd0ZpZWxkcylcbiAgICAgICAgICAgICAgICAgID8gJyAnICsgSlNPTi5zdHJpbmdpZnkoZnJhbWUuZmllbGRzLCB1bmRlZmluZWQsIDIpXG4gICAgICAgICAgICAgICAgICA6ICcnKTtcbiAgfVxufVxuIiwiLy8gVGhlIHJpdmVyIHN3ZWVwcyB0aHJvdWdoXG4vLyBTaWx0IGFuZCB0d2lncywgZ3JhdmVsIGFuZCBsZWF2ZXNcbi8vIERyaXZpbmcgdGhlIHdoZWVsIG9uXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciBjb25zdGFudHMgPSBkZWZzLmNvbnN0YW50cztcbnZhciBkZWNvZGUgPSBkZWZzLmRlY29kZTtcblxudmFyIEJpdHMgPSByZXF1aXJlKCdAYWN1bWlub3VzL2JpdHN5bnRheCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5QUk9UT0NPTF9IRUFERVIgPSBcIkFNUVBcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCwgOSwgMSk7XG5cbi8qXG4gIEZyYW1lIGZvcm1hdDpcblxuICAwICAgICAgMSAgICAgICAgIDMgICAgICAgICAgICAgNyAgICAgICAgICAgICAgICBzaXplKzcgc2l6ZSs4XG4gICstLS0tLS0rLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rICstLS0tLS0tLS0tLS0rICstLS0tLS0tLS0tLStcbiAgfCB0eXBlIHwgY2hhbm5lbCB8IHNpemUgICAgICAgIHwgfCBwYXlsb2FkICAgIHwgfCBmcmFtZS1lbmQgfFxuICArLS0tLS0tKy0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKyArLS0tLS0tLS0tLS0tKyArLS0tLS0tLS0tLS0rXG4gIG9jdGV0ICAgc2hvcnQgICAgIGxvbmcgICAgICAgICAgICBzaXplIG9jdGV0cyAgICBvY3RldFxuXG4gIEluIGdlbmVyYWwgSSB3YW50IHRvIGtub3cgdGhvc2UgZmlyc3QgdGhyZWUgdGhpbmdzIHN0cmFpZ2h0IGF3YXksIHNvIElcbiAgY2FuIGRpc2NhcmQgZnJhbWVzIGVhcmx5LlxuXG4qL1xuXG4vLyBmcmFtaW5nIGNvbnN0YW50c1xudmFyIEZSQU1FX01FVEhPRCA9IGNvbnN0YW50cy5GUkFNRV9NRVRIT0QsXG5GUkFNRV9IRUFSVEJFQVQgPSBjb25zdGFudHMuRlJBTUVfSEVBUlRCRUFULFxuRlJBTUVfSEVBREVSID0gY29uc3RhbnRzLkZSQU1FX0hFQURFUixcbkZSQU1FX0JPRFkgPSBjb25zdGFudHMuRlJBTUVfQk9EWSxcbkZSQU1FX0VORCA9IGNvbnN0YW50cy5GUkFNRV9FTkQ7XG5cbnZhciBib2R5Q29ucyA9XG4gIEJpdHMuYnVpbGRlcihGUkFNRV9CT0RZLFxuICAgICAgICAgICAgICAgJ2NoYW5uZWw6MTYsIHNpemU6MzIsIHBheWxvYWQ6c2l6ZS9iaW5hcnknLFxuICAgICAgICAgICAgICAgRlJBTUVfRU5EKTtcblxuLy8gJSUlIFRFU1RNRSBwb3NzaWJseSBiZXR0ZXIgdG8gY29ucyB0aGUgZmlyc3QgYml0IGFuZCB3cml0ZSB0aGVcbi8vIHNlY29uZCBkaXJlY3RseSwgaW4gdGhlIGFic2VuY2Ugb2YgSU8gbGlzdHNcbm1vZHVsZS5leHBvcnRzLm1ha2VCb2R5RnJhbWUgPSBmdW5jdGlvbihjaGFubmVsLCBwYXlsb2FkKSB7XG4gIHJldHVybiBib2R5Q29ucyh7Y2hhbm5lbDogY2hhbm5lbCwgc2l6ZTogcGF5bG9hZC5sZW5ndGgsIHBheWxvYWQ6IHBheWxvYWR9KTtcbn07XG5cbnZhciBmcmFtZUhlYWRlclBhdHRlcm4gPSBCaXRzLm1hdGNoZXIoJ3R5cGU6OCcsICdjaGFubmVsOjE2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6MzInLCAncmVzdC9iaW5hcnknKTtcblxuZnVuY3Rpb24gcGFyc2VGcmFtZShiaW4sIG1heCkge1xuICB2YXIgZmggPSBmcmFtZUhlYWRlclBhdHRlcm4oYmluKTtcbiAgaWYgKGZoKSB7XG4gICAgdmFyIHNpemUgPSBmaC5zaXplLCByZXN0ID0gZmgucmVzdDtcbiAgICBpZiAoc2l6ZSA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZSBzaXplIGV4Y2VlZHMgZnJhbWUgbWF4Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3QubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgaWYgKHJlc3Rbc2l6ZV0gIT09IEZSQU1FX0VORClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZyYW1lJyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGZoLnR5cGUsXG4gICAgICAgIGNoYW5uZWw6IGZoLmNoYW5uZWwsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHBheWxvYWQ6IHJlc3Quc2xpY2UoMCwgc2l6ZSksXG4gICAgICAgIHJlc3Q6IHJlc3Quc2xpY2Uoc2l6ZSArIDEpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlRnJhbWUgPSBwYXJzZUZyYW1lO1xuXG52YXIgaGVhZGVyUGF0dGVybiA9IEJpdHMubWF0Y2hlcignY2xhc3M6MTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ193ZWlnaHQ6MTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6NjQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZsYWdzQW5kZmllbGRzL2JpbmFyeScpO1xuXG52YXIgbWV0aG9kUGF0dGVybiA9IEJpdHMubWF0Y2hlcignaWQ6MzIsIGFyZ3MvYmluYXJ5Jyk7XG5cbnZhciBIRUFSVEJFQVQgPSB7Y2hhbm5lbDogMH07XG5cbm1vZHVsZS5leHBvcnRzLmRlY29kZUZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgdmFyIHBheWxvYWQgPSBmcmFtZS5wYXlsb2FkO1xuICBzd2l0Y2ggKGZyYW1lLnR5cGUpIHtcbiAgY2FzZSBGUkFNRV9NRVRIT0Q6XG4gICAgdmFyIGlkQW5kQXJncyA9IG1ldGhvZFBhdHRlcm4ocGF5bG9hZCk7XG4gICAgdmFyIGlkID0gaWRBbmRBcmdzLmlkO1xuICAgIHZhciBmaWVsZHMgPSBkZWNvZGUoaWQsIGlkQW5kQXJncy5hcmdzKTtcbiAgICByZXR1cm4ge2lkOiBpZCwgY2hhbm5lbDogZnJhbWUuY2hhbm5lbCwgZmllbGRzOiBmaWVsZHN9O1xuICBjYXNlIEZSQU1FX0hFQURFUjpcbiAgICB2YXIgcGFydHMgPSBoZWFkZXJQYXR0ZXJuKHBheWxvYWQpO1xuICAgIHZhciBpZCA9IHBhcnRzWydjbGFzcyddO1xuICAgIHZhciBmaWVsZHMgPSBkZWNvZGUoaWQsIHBhcnRzLmZsYWdzQW5kZmllbGRzKTtcbiAgICByZXR1cm4ge2lkOiBpZCwgY2hhbm5lbDogZnJhbWUuY2hhbm5lbCxcbiAgICAgICAgICAgIHNpemU6IHBhcnRzLnNpemUsIGZpZWxkczogZmllbGRzfTtcbiAgY2FzZSBGUkFNRV9CT0RZOlxuICAgIHJldHVybiB7Y2hhbm5lbDogZnJhbWUuY2hhbm5lbCwgY29udGVudDogZnJhbWUucGF5bG9hZH07XG4gIGNhc2UgRlJBTUVfSEVBUlRCRUFUOlxuICAgIHJldHVybiBIRUFSVEJFQVQ7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZyYW1lIHR5cGUgJyArIGZyYW1lLnR5cGUpO1xuICB9XG59XG5cbi8vIGVuY29kZWQgaGVhcnRiZWF0XG5tb2R1bGUuZXhwb3J0cy5IRUFSVEJFQVRfQlVGID0gQnVmZmVyLmZyb20oW2NvbnN0YW50cy5GUkFNRV9IRUFSVEJFQVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgLy8gc2l6ZSA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAvLyBjaGFubmVsID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5GUkFNRV9FTkRdKTtcblxubW9kdWxlLmV4cG9ydHMuSEVBUlRCRUFUID0gSEVBUlRCRUFUO1xuIiwiLy9cbi8vXG4vL1xuXG4vLyBIZWFydGJlYXRzLiBJbiBBTVFQIGJvdGggY2xpZW50cyBhbmQgc2VydmVycyBtYXkgZXhwZWN0IGEgaGVhcnRiZWF0XG4vLyBmcmFtZSBpZiB0aGVyZSBpcyBubyBhY3Rpdml0eSBvbiB0aGUgY29ubmVjdGlvbiBmb3IgYSBuZWdvdGlhdGVkXG4vLyBwZXJpb2Qgb2YgdGltZS4gSWYgdGhlcmUncyBubyBhY3Rpdml0eSBmb3IgdHdvIHN1Y2ggaW50ZXJ2YWxzLCB0aGVcbi8vIHNlcnZlciBvciBjbGllbnQgaXMgYWxsb3dlZCB0byBjbG9zZSB0aGUgY29ubmVjdGlvbiBvbiB0aGVcbi8vIHByZXN1bXB0aW9uIHRoYXQgdGhlIG90aGVyIHBhcnR5IGlzIGRlYWQuXG4vL1xuLy8gVGhlIGNsaWVudCBoYXMgdHdvIGpvYnMgaGVyZTogdGhlIGZpcnN0IGlzIHRvIHNlbmQgYSBoZWFydGJlYXRcbi8vIGZyYW1lIGlmIGl0J3Mgbm90IHNlbnQgYW55IGZyYW1lcyBmb3IgYSB3aGlsZSwgc28gdGhhdCB0aGUgc2VydmVyXG4vLyBkb2Vzbid0IHRoaW5rIGl0J3MgZGVhZDsgdGhlIHNlY29uZCBpcyB0byBjaGVjayBwZXJpb2RpY2FsbHkgdGhhdFxuLy8gaXQncyBzZWVuIGFjdGl2aXR5IGZyb20gdGhlIHNlcnZlciwgYW5kIHRvIGFkdmlzZSBpZiB0aGVyZSBkb2Vzbid0XG4vLyBhcHBlYXIgdG8gaGF2ZSBiZWVuIGFueSBmb3Igb3ZlciB0d28gaW50ZXJ2YWxzLlxuLy9cbi8vIE5vZGUuSlMgdGltZXJzIGFyZSBhIGJpdCB1bnJlbGlhYmxlLCBpbiB0aGF0IHRoZXkgZW5kZWF2b3VyIG9ubHkgdG9cbi8vIGZpcmUgYXQgc29tZSBpbmRldGVybWluYXRlIHBvaW50ICphZnRlciogdGhlIGdpdmVuIHRpbWUgKHJhdGhlclxuLy8gZ2l2ZXMgdGhlIGxpZSB0byAncmVhbHRpbWUnLCBkdW5uaXQpLiBCZWNhdXNlIHRoZSBzY2hlZHVsZXIgaXMganVzdFxuLy8gYW4gZXZlbnQgbG9vcCwgaXQncyBxdWl0ZSBlYXN5IHRvIGRlbGF5IHRpbWVycyBpbmRlZmluaXRlbHkgYnlcbi8vIHJlYWN0aW5nIHRvIHNvbWUgSS9PIHdpdGggYSBsb3Qgb2YgY29tcHV0YXRpb24uXG4vL1xuLy8gVG8gbWl0aWdhdGUgdGhpcyBJIG5lZWQgYSBiaXQgb2YgY3JlYXRpdmUgaW50ZXJwcmV0YXRpb246XG4vL1xuLy8gIC0gSSdsbCBzY2hlZHVsZSBhIHNlcnZlciBhY3Rpdml0eSBjaGVjayBmb3IgZXZlcnkgYGludGVydmFsYCwgYW5kXG4vLyAgICBjaGVjayBqdXN0IGhvdyBtdWNoIHRpbWUgaGFzIHBhc3NlZC4gSXQgd2lsbCBvdmVyc2hvb3QgYnkgYXRcbi8vICAgIGxlYXN0IGEgc21hbGwgbWFyZ2luOyBtb2R1bG8gbWlzc2luZyB0aW1lciBkZWFkbGluZXMsIGl0J2xsXG4vLyAgICBub3RpY2UgYmV0d2VlbiB0d28gYW5kIHRocmVlIGludGVydmFscyBhZnRlciBhY3Rpdml0eSBhY3R1YWxseVxuLy8gICAgc3RvcHMgKG90aGVyd2lzZSwgYXQgc29tZSBwb2ludCBhZnRlciB0d28gaW50ZXJ2YWxzKS5cbi8vXG4vLyAgLSBFdmVyeSBgaW50ZXJ2YWwgLyAyYCBJJ2xsIGNoZWNrIHRoYXQgd2UndmUgc2VudCBzb21ldGhpbmcgc2luY2Vcbi8vICAgIHRoZSBsYXN0IGNoZWNrLCBhbmQgaWYgbm90LCBzZW5kIGEgaGVhcnRiZWF0IGZyYW1lLiBJZiB3ZSdyZVxuLy8gICAgcmVhbGx5IHRvbyBidXN5IHRvIGV2ZW4gcnVuIHRoZSBjaGVjayBmb3IgdHdvIHdob2xlIGhlYXJ0YmVhdFxuLy8gICAgaW50ZXJ2YWxzLCB0aGVyZSBtdXN0IGJlIGEgbG90IG9mIEkgKGJ1dCBub3QgTywgYXQgbGVhc3Qgbm90IG9uXG4vLyAgICB0aGUgY29ubmVjdGlvbiksIG9yIGNvbXB1dGF0aW9uLCBpbiB3aGljaCBjYXNlIHBlcmhhcHMgaXQncyBiZXN0XG4vLyAgICB0aGUgc2VydmVyIGN1dHMgdXMgb2ZmIGFueXdheS4gV2h5IGBpbnRlcnZhbCAvIDJgPyBCZWNhdXNlIHRoZVxuLy8gICAgZWRnZSBjYXNlIGlzIHRoYXQgdGhlIGNsaWVudCBzZW50IGEgZnJhbWUganVzdCBhZnRlciBhXG4vLyAgICBoZWFydGJlYXQsIHdoaWNoIHdvdWxkIG1lYW4gSSBvbmx5IHNlbmQgb25lIGFmdGVyIGFsbW9zdCB0d29cbi8vICAgIGludGVydmFscy4gKE5CIGEgaGVhcnRiZWF0IGNvdW50cyBhcyBhIHNlbmQsIHNvIGl0J2xsIGJlIGNoZWNrZWRcbi8vICAgIGF0IGxlYXN0IHR3aWNlIGJlZm9yZSBzZW5kaW5nIGFub3RoZXIpXG4vL1xuLy8gVGhpcyBkZXNpZ24gaXMgYmFzZWQgbGFyZ2VseSBvbiBSYWJiaXRNUSdzIGhlYXJ0YmVhdGluZzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWJiaXRtcS9yYWJiaXRtcS1jb21tb24vYmxvYi9tYXN0ZXIvc3JjL3JhYmJpdF9oZWFydGJlYXQuZXJsXG5cbi8vICUlIFllcywgSSBjb3VsZCBhcHBseSB0aGUgc2FtZSAnYWN0dWFsbHkgcGFzc2FnZSBvZiB0aW1lJyB0aGluZyB0b1xuLy8gJSUgc2VuZCBhcyB3ZWxsIGFzIHRvIHJlY3YuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLy8gRXhwb3J0ZWQgc28gdGhhdCB3ZSBjYW4gbWVzcyB3aXRoIGl0IGluIHRlc3RzXG5tb2R1bGUuZXhwb3J0cy5VTklUU19UT19NUyA9IDEwMDA7XG5cbmZ1bmN0aW9uIEhlYXJ0KGludGVydmFsLCBjaGVja1NlbmQsIGNoZWNrUmVjdikge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuXG4gIHZhciBpbnRlcnZhbE1zID0gaW50ZXJ2YWwgKiBtb2R1bGUuZXhwb3J0cy5VTklUU19UT19NUztcbiAgLy8gRnVuY3Rpb24jYmluZCBpcyBteSBuZXcgYmVzdCBmcmllbmRcbiAgdmFyIGJlYXQgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnYmVhdCcpO1xuICB2YXIgdGltZW91dCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICd0aW1lb3V0Jyk7XG5cbiAgdGhpcy5zZW5kVGltZXIgPSBzZXRJbnRlcnZhbChcbiAgICB0aGlzLnJ1bkhlYXJ0YmVhdC5iaW5kKHRoaXMsIGNoZWNrU2VuZCwgYmVhdCksIGludGVydmFsTXMgLyAyKTtcblxuICAvLyBBIHRpbWVvdXQgb2NjdXJzIGlmIEkgc2VlIG5vdGhpbmcgZm9yICp0d28gY29uc2VjdXRpdmUqIGludGVydmFsc1xuICB2YXIgcmVjdk1pc3NlZCA9IDA7XG4gIGZ1bmN0aW9uIG1pc3NlZFR3bygpIHtcbiAgICBpZiAoIWNoZWNrUmVjdigpKSByZXR1cm4gKCsrcmVjdk1pc3NlZCA8IDIpO1xuICAgIGVsc2UgeyByZWN2TWlzc2VkID0gMDsgcmV0dXJuIHRydWU7IH1cbiAgfVxuICB0aGlzLnJlY3ZUaW1lciA9IHNldEludGVydmFsKFxuICAgIHRoaXMucnVuSGVhcnRiZWF0LmJpbmQodGhpcywgbWlzc2VkVHdvLCB0aW1lb3V0KSwgaW50ZXJ2YWxNcyk7XG59XG5pbmhlcml0cyhIZWFydCwgRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMuSGVhcnQgPSBIZWFydDtcblxuSGVhcnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFySW50ZXJ2YWwodGhpcy5zZW5kVGltZXIpO1xuICBjbGVhckludGVydmFsKHRoaXMucmVjdlRpbWVyKTtcbn07XG5cbkhlYXJ0LnByb3RvdHlwZS5ydW5IZWFydGJlYXQgPSBmdW5jdGlvbihjaGVjaywgZmFpbCkge1xuICAvLyBIYXZlIHdlIHNlZW4gYWN0aXZpdHk/XG4gIGlmICghY2hlY2soKSkgZmFpbCgpO1xufTtcbiIsIi8vXG4vL1xuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBIE11eCBpcyBhbiBvYmplY3QgaW50byB3aGljaCBvdGhlciByZWFkYWJsZSBzdHJlYW1zIG1heSBiZSBwaXBlZDtcbi8vIGl0IHRoZW4gd3JpdGVzICdwYWNrZXRzJyBmcm9tIHRoZSB1cHN0cmVhbXMgdG8gdGhlIGdpdmVuXG4vLyBkb3duc3RyZWFtLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBzY2hlZHVsZSA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSA/XG4gIHNldEltbWVkaWF0ZSA6IHByb2Nlc3MubmV4dFRpY2s7XG5cbmZ1bmN0aW9uIE11eChkb3duc3RyZWFtKSB7XG4gIHRoaXMubmV3U3RyZWFtcyA9IFtdO1xuICB0aGlzLm9sZFN0cmVhbXMgPSBbXTtcbiAgdGhpcy5ibG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuc2NoZWR1bGVkUmVhZCA9IGZhbHNlO1xuXG4gIHRoaXMub3V0ID0gZG93bnN0cmVhbTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkb3duc3RyZWFtLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlO1xuICAgIHNlbGYuX3JlYWRJbmNvbWluZygpO1xuICB9KTtcbn1cblxuLy8gVGhlcmUgYXJlIDIgc3RhdGVzIHdlIGNhbiBiZSBpbjpcblxuLy8gLSB3YWl0aW5nIGZvciBvdXRib3VuZCBjYXBhY2l0eSwgd2hpY2ggd2lsbCBiZSBzaWduYWxsZWQgYnkgYVxuLy8gLSAnZHJhaW4nIGV2ZW50IG9uIHRoZSBkb3duc3RyZWFtOyBvcixcblxuLy8gLSBubyBwYWNrZXRzIHRvIHNlbmQsIHdhaXRpbmcgZm9yIGFuIGluYm91bmQgYnVmZmVyIHRvIGhhdmVcbi8vICAgcGFja2V0cywgd2hpY2ggd2lsbCBiZSBzaWduYWxsZWQgYnkgYSAncmVhZGFibGUnIGV2ZW50XG5cbi8vIElmIHdlIHdyaXRlIGFsbCBwYWNrZXRzIGF2YWlsYWJsZSB3aGVuZXZlciB0aGVyZSBpcyBvdXRib3VuZFxuLy8gY2FwYWNpdHksIHdlIHdpbGwgZWl0aGVyIHJ1biBvdXQgb2Ygb3V0Ym91bmQgY2FwYWNpdHkgKGAjd3JpdGVgXG4vLyByZXR1cm5zIGZhbHNlKSwgb3IgcnVuIG91dCBvZiBwYWNrZXRzIChhbGwgY2FsbHMgdG8gYW5cbi8vIGBpbmJvdW5kLnJlYWQoKWAgaGF2ZSByZXR1cm5lZCBudWxsKS5cblxuTXV4LnByb3RvdHlwZS5fcmVhZEluY29taW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gV2UgbWF5IGJlIHNlbnQgaGVyZSBzcGVjdWxhdGl2ZWx5LCBpZiBhbiBpbmNvbWluZyBzdHJlYW0gaGFzXG4gIC8vIGJlY29tZSByZWFkYWJsZVxuICBpZiAodGhpcy5ibG9ja2VkKSByZXR1cm47XG5cbiAgdmFyIGFjY2VwdGluZyA9IHRydWU7XG4gIHZhciBvdXQgPSB0aGlzLm91dDtcblxuICAvLyBUcnkgdG8gcmVhZCBhIGNodW5rIGZyb20gZWFjaCBzdHJlYW0gaW4gdHVybiwgdW50aWwgYWxsIHN0cmVhbXNcbiAgLy8gYXJlIGVtcHR5LCBvciB3ZSBleGhhdXN0IG91ciBhYmlsaXR5IHRvIGFjY2VwdCBjaHVua3MuXG4gIGZ1bmN0aW9uIHJvdW5kcm9iaW4oc3RyZWFtcykge1xuICAgIHZhciBzO1xuICAgIHdoaWxlIChhY2NlcHRpbmcgJiYgKHMgPSBzdHJlYW1zLnNoaWZ0KCkpKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzLnJlYWQoKTtcbiAgICAgIGlmIChjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICBhY2NlcHRpbmcgPSBvdXQud3JpdGUoY2h1bmspO1xuICAgICAgICBzdHJlYW1zLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm91bmRyb2Jpbih0aGlzLm5ld1N0cmVhbXMpO1xuXG4gIC8vIEVpdGhlciB3ZSBleGhhdXN0ZWQgdGhlIG5ldyBxdWV1ZXMsIG9yIHdlIHJhbiBvdXQgb2YgY2FwYWNpdHkuIElmXG4gIC8vIHdlIHJhbiBvdXQgb2YgY2FwYWNpdHksIGFsbCB0aGUgcmVtYWluaW5nIG5ldyBzdHJlYW1zIChpLmUuLFxuICAvLyB0aG9zZSB3aXRoIHBhY2tldHMgbGVmdCkgYmVjb21lIG9sZCBzdHJlYW1zLiBUaGlzIGVmZmVjdGl2ZWx5XG4gIC8vIHByaW9yaXRpc2VzIHN0cmVhbXMgdGhhdCBrZWVwIHRoZWlyIGJ1ZmZlcnMgY2xvc2UgdG8gZW1wdHkgb3ZlclxuICAvLyB0aG9zZSB0aGF0IGFyZSBjb25zdGFudGx5IG5lYXIgZnVsbC5cblxuICBpZiAoYWNjZXB0aW5nKSB7IC8vIGFsbCBuZXcgcXVldWVzIGFyZSBleGhhdXN0ZWQsIHdyaXRlIGFzIG1hbnkgYXNcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gZnJvbSB0aGUgb2xkIHN0cmVhbXNcbiAgICBhc3NlcnQuZXF1YWwoMCwgdGhpcy5uZXdTdHJlYW1zLmxlbmd0aCk7XG4gICAgcm91bmRyb2Jpbih0aGlzLm9sZFN0cmVhbXMpO1xuICB9XG4gIGVsc2UgeyAvLyByYW4gb3V0IG9mIHJvb21cbiAgICBhc3NlcnQodGhpcy5uZXdTdHJlYW1zLmxlbmd0aCA+IDAsIFwiRXhwZWN0IHNvbWUgbmV3IHN0cmVhbXMgdG8gcmVtYWluXCIpO1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMub2xkU3RyZWFtcywgdGhpcy5uZXdTdHJlYW1zKTtcbiAgICB0aGlzLm5ld1N0cmVhbXMgPSBbXTtcbiAgfVxuICAvLyBXZSBtYXkgaGF2ZSBleGhhdXN0ZWQgYWxsIHRoZSBvbGQgcXVldWVzLCBvciBydW4gb3V0IG9mIHJvb207XG4gIC8vIGVpdGhlciB3YXksIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHJlY29yZCB3aGV0aGVyIHdlIGhhdmUgY2FwYWNpdHlcbiAgLy8gb3Igbm90LCBzbyBhbnkgc3BlY3VsYXRpdmUgcmVhZHMgd2lsbCBrbm93XG4gIHRoaXMuYmxvY2tlZCA9ICFhY2NlcHRpbmc7XG59O1xuXG5NdXgucHJvdG90eXBlLl9zY2hlZHVsZVJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5zY2hlZHVsZWRSZWFkKSB7XG4gICAgc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnNjaGVkdWxlZFJlYWQgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3JlYWRJbmNvbWluZygpO1xuICAgIH0pO1xuICAgIHNlbGYuc2NoZWR1bGVkUmVhZCA9IHRydWU7XG4gIH1cbn07XG5cbk11eC5wcm90b3R5cGUucGlwZUZyb20gPSBmdW5jdGlvbihyZWFkYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gZW5xdWV1ZSgpIHtcbiAgICBzZWxmLm5ld1N0cmVhbXMucHVzaChyZWFkYWJsZSk7XG4gICAgc2VsZi5fc2NoZWR1bGVSZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGVucXVldWUpO1xuICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNsZWFudXApO1xuICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICByZWFkYWJsZS5yZW1vdmVMaXN0ZW5lcigndW5waXBlRnJvbScsIGNsZWFudXBJZk1lKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhbnVwSWZNZShkZXN0KSB7XG4gICAgaWYgKGRlc3QgPT09IHNlbGYpIGNsZWFudXAoKTtcbiAgfVxuXG4gIHJlYWRhYmxlLm9uKCd1bnBpcGVGcm9tJywgY2xlYW51cElmTWUpO1xuICByZWFkYWJsZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHJlYWRhYmxlLm9uKCdlcnJvcicsIGNsZWFudXApO1xuICByZWFkYWJsZS5vbigncmVhZGFibGUnLCBlbnF1ZXVlKTtcbn07XG5cbk11eC5wcm90b3R5cGUudW5waXBlRnJvbSA9IGZ1bmN0aW9uKHJlYWRhYmxlKSB7XG4gIHJlYWRhYmxlLmVtaXQoJ3VucGlwZUZyb20nLCB0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLk11eCA9IE11eDtcbiIsInZhciByZWdpc3RlciA9IHJlcXVpcmUoXCIuL2xpYi9yZWdpc3RlclwiKTtcbnZhciBhZGRIb29rID0gcmVxdWlyZShcIi4vbGliL2FkZFwiKTtcbnZhciByZW1vdmVIb29rID0gcmVxdWlyZShcIi4vbGliL3JlbW92ZVwiKTtcblxuLy8gYmluZCB3aXRoIGFycmF5IG9mIGFyZ3VtZW50czogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxNzkyOTEzXG52YXIgYmluZCA9IEZ1bmN0aW9uLmJpbmQ7XG52YXIgYmluZGFibGUgPSBiaW5kLmJpbmQoYmluZCk7XG5cbmZ1bmN0aW9uIGJpbmRBcGkoaG9vaywgc3RhdGUsIG5hbWUpIHtcbiAgdmFyIHJlbW92ZUhvb2tSZWYgPSBiaW5kYWJsZShyZW1vdmVIb29rLCBudWxsKS5hcHBseShcbiAgICBudWxsLFxuICAgIG5hbWUgPyBbc3RhdGUsIG5hbWVdIDogW3N0YXRlXVxuICApO1xuICBob29rLmFwaSA9IHsgcmVtb3ZlOiByZW1vdmVIb29rUmVmIH07XG4gIGhvb2sucmVtb3ZlID0gcmVtb3ZlSG9va1JlZjtcbiAgW1wiYmVmb3JlXCIsIFwiZXJyb3JcIiwgXCJhZnRlclwiLCBcIndyYXBcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkge1xuICAgIHZhciBhcmdzID0gbmFtZSA/IFtzdGF0ZSwga2luZCwgbmFtZV0gOiBbc3RhdGUsIGtpbmRdO1xuICAgIGhvb2tba2luZF0gPSBob29rLmFwaVtraW5kXSA9IGJpbmRhYmxlKGFkZEhvb2ssIG51bGwpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gSG9va1Npbmd1bGFyKCkge1xuICB2YXIgc2luZ3VsYXJIb29rTmFtZSA9IFwiaFwiO1xuICB2YXIgc2luZ3VsYXJIb29rU3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuICB2YXIgc2luZ3VsYXJIb29rID0gcmVnaXN0ZXIuYmluZChudWxsLCBzaW5ndWxhckhvb2tTdGF0ZSwgc2luZ3VsYXJIb29rTmFtZSk7XG4gIGJpbmRBcGkoc2luZ3VsYXJIb29rLCBzaW5ndWxhckhvb2tTdGF0ZSwgc2luZ3VsYXJIb29rTmFtZSk7XG4gIHJldHVybiBzaW5ndWxhckhvb2s7XG59XG5cbmZ1bmN0aW9uIEhvb2tDb2xsZWN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuXG4gIHZhciBob29rID0gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSk7XG4gIGJpbmRBcGkoaG9vaywgc3RhdGUpO1xuXG4gIHJldHVybiBob29rO1xufVxuXG52YXIgY29sbGVjdGlvbkhvb2tEZXByZWNhdGlvbk1lc3NhZ2VEaXNwbGF5ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIEhvb2soKSB7XG4gIGlmICghY29sbGVjdGlvbkhvb2tEZXByZWNhdGlvbk1lc3NhZ2VEaXNwbGF5ZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW2JlZm9yZS1hZnRlci1ob29rXTogXCJIb29rKClcIiByZXB1cnBvc2luZyB3YXJuaW5nLCB1c2UgXCJIb29rLkNvbGxlY3Rpb24oKVwiLiBSZWFkIG1vcmU6IGh0dHBzOi8vZ2l0LmlvL3VwZ3JhZGUtYmVmb3JlLWFmdGVyLWhvb2stdG8tMS40J1xuICAgICk7XG4gICAgY29sbGVjdGlvbkhvb2tEZXByZWNhdGlvbk1lc3NhZ2VEaXNwbGF5ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiBIb29rQ29sbGVjdGlvbigpO1xufVxuXG5Ib29rLlNpbmd1bGFyID0gSG9va1Npbmd1bGFyLmJpbmQoKTtcbkhvb2suQ29sbGVjdGlvbiA9IEhvb2tDb2xsZWN0aW9uLmJpbmQoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIb29rO1xuLy8gZXhwb3NlIGNvbnN0cnVjdG9ycyBhcyBhIG5hbWVkIHByb3BlcnR5IGZvciBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5Ib29rID0gSG9vaztcbm1vZHVsZS5leHBvcnRzLlNpbmd1bGFyID0gSG9vay5TaW5ndWxhcjtcbm1vZHVsZS5leHBvcnRzLkNvbGxlY3Rpb24gPSBIb29rLkNvbGxlY3Rpb247XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZEhvb2s7XG5cbmZ1bmN0aW9uIGFkZEhvb2soc3RhdGUsIGtpbmQsIG5hbWUsIGhvb2spIHtcbiAgdmFyIG9yaWcgPSBob29rO1xuICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgc3RhdGUucmVnaXN0cnlbbmFtZV0gPSBbXTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImJlZm9yZVwiKSB7XG4gICAgaG9vayA9IGZ1bmN0aW9uIChtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihvcmlnLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiYWZ0ZXJcIikge1xuICAgIGhvb2sgPSBmdW5jdGlvbiAobWV0aG9kLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0Xykge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdF87XG4gICAgICAgICAgcmV0dXJuIG9yaWcocmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJlcnJvclwiKSB7XG4gICAgaG9vayA9IGZ1bmN0aW9uIChtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihtZXRob2QuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBvcmlnKGVycm9yLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnB1c2goe1xuICAgIGhvb2s6IGhvb2ssXG4gICAgb3JpZzogb3JpZyxcbiAgfSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG5mdW5jdGlvbiByZWdpc3RlcihzdGF0ZSwgbmFtZSwgbWV0aG9kLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgZm9yIGJlZm9yZSBob29rIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoY2FsbGJhY2ssIG5hbWUpIHtcbiAgICAgIHJldHVybiByZWdpc3Rlci5iaW5kKG51bGwsIHN0YXRlLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSwgbWV0aG9kKSgpO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICAgIHJldHVybiBtZXRob2Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnJlZHVjZShmdW5jdGlvbiAobWV0aG9kLCByZWdpc3RlcmVkKSB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJlZC5ob29rLmJpbmQobnVsbCwgbWV0aG9kLCBvcHRpb25zKTtcbiAgICB9LCBtZXRob2QpKCk7XG4gIH0pO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZW1vdmVIb29rO1xuXG5mdW5jdGlvbiByZW1vdmVIb29rKHN0YXRlLCBuYW1lLCBtZXRob2QpIHtcbiAgaWYgKCFzdGF0ZS5yZWdpc3RyeVtuYW1lXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHN0YXRlLnJlZ2lzdHJ5W25hbWVdXG4gICAgLm1hcChmdW5jdGlvbiAocmVnaXN0ZXJlZCkge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQub3JpZztcbiAgICB9KVxuICAgIC5pbmRleE9mKG1ldGhvZCk7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnNwbGljZShpbmRleCwgMSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEphdmFTY3JpcHQgaXMgbnVtZXJpY2FsbHkgY2hhbGxlbmdlZFxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNik7XG52YXIgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMjtcblxuLy8gVGhlIG1heGltdW0gY29udGlndW91cyBpbnRlZ2VyIHRoYXQgY2FuIGJlIGhlbGQgaW4gYSBJRUVFNzU0IGRvdWJsZVxudmFyIE1BWF9JTlQgPSAweDFmZmZmZmZmZmZmZmZmO1xuXG5mdW5jdGlvbiBpc0NvbnRpZ3VvdXNJbnQodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA8PSBNQVhfSU5UICYmIHZhbCA+PSAtTUFYX0lOVDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29udGlndW91c0ludCh2YWwpIHtcbiAgICBpZiAoIWlzQ29udGlndW91c0ludCh2YWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJudW1iZXIgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgY29udGlndW91cyBpbnRlZ2VyXCIpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuaXNDb250aWd1b3VzSW50ID0gaXNDb250aWd1b3VzSW50O1xubW9kdWxlLmV4cG9ydHMuYXNzZXJ0Q29udGlndW91c0ludCA9IGFzc2VydENvbnRpZ3VvdXNJbnQ7XG5cbi8vIEZpbGwgaW4gdGhlIHJlZ3VsYXIgcHJvY2VkdXJlc1xuWydVSW50JywgJ0ludCddLmZvckVhY2goZnVuY3Rpb24gKHNpZ24pIHtcbiAgdmFyIHN1ZmZpeCA9IHNpZ24gKyAnOCc7XG4gIG1vZHVsZS5leHBvcnRzWydyZWFkJyArIHN1ZmZpeF0gPVxuICAgIEJ1ZmZlci5wcm90b3R5cGVbJ3JlYWQnICsgc3VmZml4XS5jYWxsO1xuICBtb2R1bGUuZXhwb3J0c1snd3JpdGUnICsgc3VmZml4XSA9XG4gICAgQnVmZmVyLnByb3RvdHlwZVsnd3JpdGUnICsgc3VmZml4XS5jYWxsO1xuXG4gIFsnMTYnLCAnMzInXS5mb3JFYWNoKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgWydMRScsICdCRSddLmZvckVhY2goZnVuY3Rpb24gKGVuZGlhbikge1xuICAgICAgdmFyIHN1ZmZpeCA9IHNpZ24gKyBzaXplICsgZW5kaWFuO1xuICAgICAgdmFyIHJlYWQgPSBCdWZmZXIucHJvdG90eXBlWydyZWFkJyArIHN1ZmZpeF07XG4gICAgICBtb2R1bGUuZXhwb3J0c1sncmVhZCcgKyBzdWZmaXhdID1cbiAgICAgICAgZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWQuY2FsbChidWYsIG9mZnNldCk7XG4gICAgICAgIH07XG4gICAgICB2YXIgd3JpdGUgPSBCdWZmZXIucHJvdG90eXBlWyd3cml0ZScgKyBzdWZmaXhdO1xuICAgICAgbW9kdWxlLmV4cG9ydHNbJ3dyaXRlJyArIHN1ZmZpeF0gPVxuICAgICAgICBmdW5jdGlvbiAoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgICAgICAgIHJldHVybiB3cml0ZS5jYWxsKGJ1ZiwgdmFsLCBvZmZzZXQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBDaGVjayB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlXG5mdW5jdGlvbiBjaGVja192YWx1ZSh2YWwsIG1pbiwgbWF4KSB7XG4gICAgdmFsID0gK3ZhbDtcbiAgICBpZiAodHlwZW9mKHZhbCkgIT0gJ251bWJlcicgfHwgdmFsIDwgbWluIHx8IHZhbCA+IG1heCB8fCBNYXRoLmZsb29yKHZhbCkgIT09IHZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxcInZhbHVlXFxcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vLyBDaGVjayB0aGF0IHNvbWV0aGluZyBpcyB3aXRoaW4gdGhlIEJ1ZmZlciBib3VuZHNcbmZ1bmN0aW9uIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgbGVuKSB7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgbGVuID4gYnVmLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MjRCRShidWYsIG9mZnNldCkge1xuICByZXR1cm4gYnVmLnJlYWRVSW50OChvZmZzZXQpIDw8IDE2IHwgYnVmLnJlYWRVSW50MTZCRShvZmZzZXQgKyAxKTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50MjRCRSA9IHJlYWRVSW50MjRCRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MjRCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCAzKTtcbiAgICBidWYud3JpdGVVSW50OCh2YWwgPj4+IDE2LCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkJFKHZhbCAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQyNEJFID0gd3JpdGVVSW50MjRCRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ0MEJFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZFVJbnQ4KG9mZnNldCkgfHwgMCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyAxKTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50NDBCRSA9IHJlYWRVSW50NDBCRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50NDBCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNSk7XG4gICAgYnVmLndyaXRlVUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCk7XG4gICAgYnVmLndyaXRlSW50MzJCRSh2YWwgJiAtMSwgb2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ0MEJFID0gd3JpdGVVSW50NDBCRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ0OEJFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDIpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ0OEJFID0gcmVhZFVJbnQ0OEJFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ0OEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDYpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkJFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDIpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NDhCRSA9IHdyaXRlVUludDQ4QkU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50NTZCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoKGJ1Zi5yZWFkVUludDgob2Zmc2V0KSB8fCAwKSA8PCAxNiB8IGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0ICsgMSkpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMyk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDU2QkUgPSByZWFkVUludDU2QkU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDU2QkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA3KTtcblxuICAgIGlmICh2YWwgPCAweDEwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKTtcbiAgICAgICAgYnVmLndyaXRlVUludDgoaGkgPj4+IDE2LCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZCRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBiZWNhdXNlIDJeNTYtMSBnZXRzIHJvdW5kZWQgdXAgdG8gMl41NlxuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzJdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCszXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzVdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs2XSA9IDB4ZmY7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NTZCRSA9IHdyaXRlVUludDU2QkU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50NjRCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZFVJbnQzMkJFKG9mZnNldCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50NjRCRSA9IHJlYWRVSW50NjRCRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50NjRCRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgOCk7XG5cbiAgICBpZiAodmFsIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICBidWYud3JpdGVVSW50MzJCRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRSh2YWwgJiAtMSwgb2Zmc2V0ICsgNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl42NC0xIGdldHMgcm91bmRlZCB1cCB0byAyXjY0XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs3XSA9IDB4ZmY7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NjRCRSA9IHdyaXRlVUludDY0QkU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50MjRMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZFVJbnQ4KG9mZnNldCArIDIpIDw8IDE2IHwgYnVmLnJlYWRVSW50MTZMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQyNExFID0gcmVhZFVJbnQyNExFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQyNExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIDAsIDB4ZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDMpO1xuXG4gICAgYnVmLndyaXRlVUludDE2TEUodmFsICYgMHhmZmZmLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KHZhbCA+Pj4gMTYsIG9mZnNldCArIDIpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50MjRMRSA9IHdyaXRlVUludDI0TEU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50NDBMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoYnVmLnJlYWRVSW50OChvZmZzZXQgKyA0KSB8fCAwKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDQwTEUgPSByZWFkVUludDQwTEU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDQwTEUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDUpO1xuICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCk7XG4gICAgYnVmLndyaXRlVUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCArIDQpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NDBMRSA9IHdyaXRlVUludDQwTEU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50NDhMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZFVJbnQxNkxFKG9mZnNldCArIDQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRVSW50NDhMRSA9IHJlYWRVSW50NDhMRTtcblxuZnVuY3Rpb24gd3JpdGVVSW50NDhMRShidWYsIHZhbCwgb2Zmc2V0KSB7XG4gICAgdmFsID0gY2hlY2tfdmFsdWUodmFsLCAwLCAweGZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA2KTtcbiAgICBidWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDQ4TEUgPSB3cml0ZVVJbnQ0OExFO1xuXG5mdW5jdGlvbiByZWFkVUludDU2TEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKChidWYucmVhZFVJbnQ4KG9mZnNldCArIDYpIHx8IDApIDw8IDE2IHwgYnVmLnJlYWRVSW50MTZMRShvZmZzZXQgKyA0KSkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ1NkxFID0gcmVhZFVJbnQ1NkxFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ1NkxFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgNyk7XG5cbiAgICBpZiAodmFsIDwgMHgxMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMik7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKGhpICYgMHhmZmZmLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDgoaGkgPj4+IDE2LCBvZmZzZXQgKyA2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjU2LTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNTZcbiAgICAgICAgYnVmW29mZnNldF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDU2TEUgPSB3cml0ZVVJbnQ1NkxFO1xuXG5mdW5jdGlvbiByZWFkVUludDY0TEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDY0TEUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgMCwgMHhmZmZmZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDgpO1xuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCArIDQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBiZWNhdXNlIDJeNjQtMSBnZXRzIHJvdW5kZWQgdXAgdG8gMl42NFxuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzJdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCszXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzVdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs2XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrN10gPSAweGZmO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDY0TEUgPSB3cml0ZVVJbnQ2NExFO1xuXG5cbmZ1bmN0aW9uIHJlYWRJbnQyNEJFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZEludDgob2Zmc2V0KSA8PCAxNikgKyBidWYucmVhZFVJbnQxNkJFKG9mZnNldCArIDEpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDI0QkUgPSByZWFkSW50MjRCRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQyNEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMCwgMHg3ZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgMyk7XG4gICAgYnVmLndyaXRlSW50OCh2YWwgPj4gMTYsIG9mZnNldCk7XG4gICAgYnVmLndyaXRlVUludDE2QkUodmFsICYgMHhmZmZmLCBvZmZzZXQgKyAxKTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50MjRCRSA9IHdyaXRlSW50MjRCRTtcblxuZnVuY3Rpb24gcmVhZEludDQwQkUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGJ1Zi5yZWFkSW50OChvZmZzZXQpIHx8IDApICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NDBCRSA9IHJlYWRJbnQ0MEJFO1xuXG5mdW5jdGlvbiB3cml0ZUludDQwQkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgLTB4ODAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDUpO1xuICAgIGJ1Zi53cml0ZUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCk7XG4gICAgYnVmLndyaXRlSW50MzJCRSh2YWwgJiAtMSwgb2Zmc2V0ICsgMSk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDQwQkUgPSB3cml0ZUludDQwQkU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ0OEJFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkSW50MTZCRShvZmZzZXQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMik7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NDhCRSA9IHJlYWRJbnQ0OEJFO1xuXG5mdW5jdGlvbiB3cml0ZUludDQ4QkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgLTB4ODAwMDAwMDAwMDAwLCAweDdmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA2KTtcbiAgICBidWYud3JpdGVJbnQxNkJFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDIpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ0OEJFID0gd3JpdGVJbnQ0OEJFO1xuXG5mdW5jdGlvbiByZWFkSW50NTZCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoKChidWYucmVhZEludDgob2Zmc2V0KSB8fCAwKSA8PCAxNikgKyBidWYucmVhZFVJbnQxNkJFKG9mZnNldCArIDEpKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDMpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDU2QkUgPSByZWFkSW50NTZCRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ1NkJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA3KTtcblxuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpO1xuICAgICAgICBidWYud3JpdGVJbnQ4KGhpID4+IDE2LCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZCRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBiZWNhdXNlIDJeNTUtMSBnZXRzIHJvdW5kZWQgdXAgdG8gMl41NVxuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4N2Y7XG4gICAgICAgIGJ1ZltvZmZzZXQrMV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzJdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCszXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzVdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs2XSA9IDB4ZmY7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ1NkJFID0gd3JpdGVJbnQ1NkJFO1xuXG5mdW5jdGlvbiByZWFkSW50NjRCRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWYucmVhZEludDMyQkUob2Zmc2V0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDY0QkUgPSByZWFkSW50NjRCRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDgpO1xuXG4gICAgaWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyA0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjYzLTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNjNcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDdmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzddID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDY0QkUgPSB3cml0ZUludDY0QkU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQyNExFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZEludDgob2Zmc2V0ICsgMikgPDwgMTYpICsgYnVmLnJlYWRVSW50MTZMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDI0TEUgPSByZWFkSW50MjRMRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQyNExFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMCwgMHg3ZmZmZmYpO1xuICAgIGNoZWNrX2JvdW5kcyhidWYsIG9mZnNldCwgMyk7XG4gICAgYnVmLndyaXRlVUludDE2TEUodmFsICYgMHhmZmZmLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDgodmFsID4+IDE2LCBvZmZzZXQgKyAyKTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50MjRMRSA9IHdyaXRlSW50MjRMRTtcblxuZnVuY3Rpb24gcmVhZEludDQwTEUoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGJ1Zi5yZWFkSW50OChvZmZzZXQgKyA0KSB8fCAwKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NDBMRSA9IHJlYWRJbnQ0MExFO1xuXG5mdW5jdGlvbiB3cml0ZUludDQwTEUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgLTB4ODAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDUpO1xuICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCk7XG4gICAgYnVmLndyaXRlSW50OChNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0ICsgNCk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDQwTEUgPSB3cml0ZUludDQwTEU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ0OExFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkSW50MTZMRShvZmZzZXQgKyA0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NDhMRSA9IHJlYWRJbnQ0OExFO1xuXG5mdW5jdGlvbiB3cml0ZUludDQ4TEUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgLTB4ODAwMDAwMDAwMDAwLCAweDdmZmZmZmZmZmZmZik7XG4gICAgY2hlY2tfYm91bmRzKGJ1Ziwgb2Zmc2V0LCA2KTtcbiAgICBidWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCBvZmZzZXQpO1xuICAgIGJ1Zi53cml0ZUludDE2TEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCArIDQpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ0OExFID0gd3JpdGVJbnQ0OExFO1xuXG5mdW5jdGlvbiByZWFkSW50NTZMRShidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoKChidWYucmVhZEludDgob2Zmc2V0ICsgNikgfHwgMCkgPDwgMTYpICsgYnVmLnJlYWRVSW50MTZMRShvZmZzZXQgKyA0KSkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDU2TEUgPSByZWFkSW50NTZMRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ1NkxFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YWwgPSBjaGVja192YWx1ZSh2YWwsIC0weDgwMDAwMDAwMDAwMDAwLCAweDdmZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDcpO1xuXG4gICAgaWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMik7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKGhpICYgMHhmZmZmLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgYnVmLndyaXRlSW50OChoaSA+PiAxNiwgb2Zmc2V0ICsgNik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41NS0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU1XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHg3ZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDU2TEUgPSB3cml0ZUludDU2TEU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ2NExFKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkSW50MzJMRShvZmZzZXQgKyA0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NjRMRSA9IHJlYWRJbnQ2NExFO1xuXG5mdW5jdGlvbiB3cml0ZUludDY0TEUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgIHZhbCA9IGNoZWNrX3ZhbHVlKHZhbCwgLTB4ODAwMDAwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmZmZmZmKTtcbiAgICBjaGVja19ib3VuZHMoYnVmLCBvZmZzZXQsIDgpO1xuXG4gICAgaWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICBidWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjU1LTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNTVcbiAgICAgICAgYnVmW29mZnNldF0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzddID0gMHg3ZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDY0TEUgPSB3cml0ZUludDY0TEU7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsImNsYXNzIERlcHJlY2F0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7IC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ0RlcHJlY2F0aW9uJztcbiAgfVxuXG59XG5cbmV4cG9ydCB7IERlcHJlY2F0aW9uIH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuXHQvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0Ly8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG5cdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblx0dGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbE9iamVjdCA9IGdldEdsb2JhbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBnbG9iYWxPYmplY3QuZmV0Y2g7XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdCBhbmQgV2VicGFjay5cbmlmIChnbG9iYWxPYmplY3QuZmV0Y2gpIHtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsT2JqZWN0LmZldGNoLmJpbmQoZ2xvYmFsT2JqZWN0KTtcbn1cblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsT2JqZWN0LkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWxPYmplY3QuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWxPYmplY3QuUmVzcG9uc2U7XG4iLCJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5Jylcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KG9uY2UpXG5tb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdClcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlU3RyaWN0Jywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZi5jYWxsZWQpIHJldHVybiBmLnZhbHVlXG4gICAgZi5jYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgZi5jYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZlxufVxuXG5mdW5jdGlvbiBvbmNlU3RyaWN0IChmbikge1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZi5jYWxsZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZi5vbmNlRXJyb3IpXG4gICAgZi5jYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgdmFyIG5hbWUgPSBmbi5uYW1lIHx8ICdGdW5jdGlvbiB3cmFwcGVkIHdpdGggYG9uY2VgJ1xuICBmLm9uY2VFcnJvciA9IG5hbWUgKyBcIiBzaG91bGRuJ3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXCJcbiAgZi5jYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZlxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHVuZGVmO1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmNvZGUgYSBnaXZlbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyMmXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBjYXNlIGlmIGZhaWxlZCBkZWNvZGluZywgd2Ugd2FudCB0byBvbWl0IHRoZSBrZXkvdmFsdWUgcGFpcnNcbiAgICAvLyBmcm9tIHRoZSByZXN1bHQuXG4gICAgLy9cbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsIHx8IGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW11cbiAgICAsIHZhbHVlXG4gICAgLCBrZXk7XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVkZ2UgY2FzZXMgd2hlcmUgd2UgYWN0dWFsbHkgd2FudCB0byBlbmNvZGUgdGhlIHZhbHVlIHRvIGFuIGVtcHR5XG4gICAgICAvLyBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgc3RyaW5naWZpZWQgdmFsdWUuXG4gICAgICAvL1xuICAgICAgaWYgKCF2YWx1ZSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmIHx8IGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAga2V5ID0gZW5jb2RlKGtleSk7XG4gICAgICB2YWx1ZSA9IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gZW5jb2RlIHRoZSBzdHJpbmdzLCB3ZSBzaG91bGQgYmFpbCBvdXQgYXMgd2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gYWRkIGludmFsaWQgc3RyaW5ncyB0byB0aGUgcXVlcnkuXG4gICAgICAvL1xuICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBwYWlycy5wdXNoKGtleSArJz0nKyB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChkYXRhKSlcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24odGhpcy5fZmx1c2gpKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbCh0cy53cml0ZWNodW5rKSAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFtcXBsaWJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW1xcGxpYlwiKSk7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBhY3Rpb25zL2NvcmVcIikpO1xuY29uc3QgZ2l0aHViXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBhY3Rpb25zL2dpdGh1YlwiKSk7XG5mdW5jdGlvbiBtYWluKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IGNvcmVfMS5kZWZhdWx0LmdldElucHV0KFwiYnJhbmNoXCIpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgYW1xcGxpYl8xLmRlZmF1bHQuY29ubmVjdChcImFtcXA6Ly9sb2NhbGhvc3RcIik7IC8vIEFsdGVyYXIgcGFyYSBJUCBkbyBzZXJ2aWRvciAobGFwdG9wKVxuICAgICAgICBjb25zdCBjaGFubmVsID0geWllbGQgY29ubmVjdGlvbi5jcmVhdGVDaGFubmVsKCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gXCJub3RpZnktZGlzY29yZFwiO1xuICAgICAgICB5aWVsZCBjaGFubmVsLmFzc2VydFF1ZXVlKHF1ZXVlLCB7IGR1cmFibGU6IHRydWUgfSk7XG4gICAgICAgIGNoYW5uZWwuc2VuZFRvUXVldWUocXVldWUsIEJ1ZmZlci5mcm9tKGJyYW5jaCkpO1xuICAgICAgICBjb25zb2xlLmxvZyhgW3hdIFNlbnQgJHticmFuY2h9IHRvICR7cXVldWV9YCk7XG4gICAgICAgIHlpZWxkIGNoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgeWllbGQgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoZ2l0aHViXzEuZGVmYXVsdC5jb250ZXh0LnBheWxvYWQsIHVuZGVmaW5lZCwgMik7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUaGUgZXZlbnQgcGF5bG9hZDogJHtwYXlsb2FkfWApO1xuICAgIH0pO1xufVxubWFpbigpLmNhdGNoKGVycm9yID0+IHtcbiAgICBjb25zb2xlLmxvZyhlcnJvci5tZXNzYWdlKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi90dW5uZWwnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xudmFyIHRscyA9IHJlcXVpcmUoJ3RscycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuZXhwb3J0cy5odHRwT3Zlckh0dHAgPSBodHRwT3Zlckh0dHA7XG5leHBvcnRzLmh0dHBzT3Zlckh0dHAgPSBodHRwc092ZXJIdHRwO1xuZXhwb3J0cy5odHRwT3Zlckh0dHBzID0gaHR0cE92ZXJIdHRwcztcbmV4cG9ydHMuaHR0cHNPdmVySHR0cHMgPSBodHRwc092ZXJIdHRwcztcblxuXG5mdW5jdGlvbiBodHRwT3Zlckh0dHAob3B0aW9ucykge1xuICB2YXIgYWdlbnQgPSBuZXcgVHVubmVsaW5nQWdlbnQob3B0aW9ucyk7XG4gIGFnZW50LnJlcXVlc3QgPSBodHRwLnJlcXVlc3Q7XG4gIHJldHVybiBhZ2VudDtcbn1cblxuZnVuY3Rpb24gaHR0cHNPdmVySHR0cChvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKTtcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHAucmVxdWVzdDtcbiAgYWdlbnQuY3JlYXRlU29ja2V0ID0gY3JlYXRlU2VjdXJlU29ja2V0O1xuICBhZ2VudC5kZWZhdWx0UG9ydCA9IDQ0MztcbiAgcmV0dXJuIGFnZW50O1xufVxuXG5mdW5jdGlvbiBodHRwT3Zlckh0dHBzKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpO1xuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdDtcbiAgcmV0dXJuIGFnZW50O1xufVxuXG5mdW5jdGlvbiBodHRwc092ZXJIdHRwcyhvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKTtcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Q7XG4gIGFnZW50LmNyZWF0ZVNvY2tldCA9IGNyZWF0ZVNlY3VyZVNvY2tldDtcbiAgYWdlbnQuZGVmYXVsdFBvcnQgPSA0NDM7XG4gIHJldHVybiBhZ2VudDtcbn1cblxuXG5mdW5jdGlvbiBUdW5uZWxpbmdBZ2VudChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgc2VsZi5wcm94eU9wdGlvbnMgPSBzZWxmLm9wdGlvbnMucHJveHkgfHwge307XG4gIHNlbGYubWF4U29ja2V0cyA9IHNlbGYub3B0aW9ucy5tYXhTb2NrZXRzIHx8IGh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHM7XG4gIHNlbGYucmVxdWVzdHMgPSBbXTtcbiAgc2VsZi5zb2NrZXRzID0gW107XG5cbiAgc2VsZi5vbignZnJlZScsIGZ1bmN0aW9uIG9uRnJlZShzb2NrZXQsIGhvc3QsIHBvcnQsIGxvY2FsQWRkcmVzcykge1xuICAgIHZhciBvcHRpb25zID0gdG9PcHRpb25zKGhvc3QsIHBvcnQsIGxvY2FsQWRkcmVzcyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYucmVxdWVzdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBwZW5kaW5nID0gc2VsZi5yZXF1ZXN0c1tpXTtcbiAgICAgIGlmIChwZW5kaW5nLmhvc3QgPT09IG9wdGlvbnMuaG9zdCAmJiBwZW5kaW5nLnBvcnQgPT09IG9wdGlvbnMucG9ydCkge1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHJlcXVlc3QgdG8gY29ubmVjdCBzYW1lIG9yaWdpbiBzZXJ2ZXIsXG4gICAgICAgIC8vIHJldXNlIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICBzZWxmLnJlcXVlc3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcGVuZGluZy5yZXF1ZXN0Lm9uU29ja2V0KHNvY2tldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICBzZWxmLnJlbW92ZVNvY2tldChzb2NrZXQpO1xuICB9KTtcbn1cbnV0aWwuaW5oZXJpdHMoVHVubmVsaW5nQWdlbnQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIGFkZFJlcXVlc3QocmVxLCBob3N0LCBwb3J0LCBsb2NhbEFkZHJlc3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh7cmVxdWVzdDogcmVxfSwgc2VsZi5vcHRpb25zLCB0b09wdGlvbnMoaG9zdCwgcG9ydCwgbG9jYWxBZGRyZXNzKSk7XG5cbiAgaWYgKHNlbGYuc29ja2V0cy5sZW5ndGggPj0gdGhpcy5tYXhTb2NrZXRzKSB7XG4gICAgLy8gV2UgYXJlIG92ZXIgbGltaXQgc28gd2UnbGwgYWRkIGl0IHRvIHRoZSBxdWV1ZS5cbiAgICBzZWxmLnJlcXVlc3RzLnB1c2gob3B0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UgYXJlIHVuZGVyIG1heFNvY2tldHMgY3JlYXRlIGEgbmV3IG9uZS5cbiAgc2VsZi5jcmVhdGVTb2NrZXQob3B0aW9ucywgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZU9yUmVtb3ZlKTtcbiAgICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25DbG9zZU9yUmVtb3ZlKTtcbiAgICByZXEub25Tb2NrZXQoc29ja2V0KTtcblxuICAgIGZ1bmN0aW9uIG9uRnJlZSgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZnJlZScsIHNvY2tldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZU9yUmVtb3ZlKGVycikge1xuICAgICAgc2VsZi5yZW1vdmVTb2NrZXQoc29ja2V0KTtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZnJlZScsIG9uRnJlZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZU9yUmVtb3ZlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0ID0gZnVuY3Rpb24gY3JlYXRlU29ja2V0KG9wdGlvbnMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBsYWNlaG9sZGVyID0ge307XG4gIHNlbGYuc29ja2V0cy5wdXNoKHBsYWNlaG9sZGVyKTtcblxuICB2YXIgY29ubmVjdE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoe30sIHNlbGYucHJveHlPcHRpb25zLCB7XG4gICAgbWV0aG9kOiAnQ09OTkVDVCcsXG4gICAgcGF0aDogb3B0aW9ucy5ob3N0ICsgJzonICsgb3B0aW9ucy5wb3J0LFxuICAgIGFnZW50OiBmYWxzZSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBob3N0OiBvcHRpb25zLmhvc3QgKyAnOicgKyBvcHRpb25zLnBvcnRcbiAgICB9XG4gIH0pO1xuICBpZiAob3B0aW9ucy5sb2NhbEFkZHJlc3MpIHtcbiAgICBjb25uZWN0T3B0aW9ucy5sb2NhbEFkZHJlc3MgPSBvcHRpb25zLmxvY2FsQWRkcmVzcztcbiAgfVxuICBpZiAoY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKSB7XG4gICAgY29ubmVjdE9wdGlvbnMuaGVhZGVycyA9IGNvbm5lY3RPcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgY29ubmVjdE9wdGlvbnMuaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gJ0Jhc2ljICcgK1xuICAgICAgICBuZXcgQnVmZmVyKGNvbm5lY3RPcHRpb25zLnByb3h5QXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgZGVidWcoJ21ha2luZyBDT05ORUNUIHJlcXVlc3QnKTtcbiAgdmFyIGNvbm5lY3RSZXEgPSBzZWxmLnJlcXVlc3QoY29ubmVjdE9wdGlvbnMpO1xuICBjb25uZWN0UmVxLnVzZUNodW5rZWRFbmNvZGluZ0J5RGVmYXVsdCA9IGZhbHNlOyAvLyBmb3IgdjAuNlxuICBjb25uZWN0UmVxLm9uY2UoJ3Jlc3BvbnNlJywgb25SZXNwb25zZSk7IC8vIGZvciB2MC42XG4gIGNvbm5lY3RSZXEub25jZSgndXBncmFkZScsIG9uVXBncmFkZSk7ICAgLy8gZm9yIHYwLjZcbiAgY29ubmVjdFJlcS5vbmNlKCdjb25uZWN0Jywgb25Db25uZWN0KTsgICAvLyBmb3IgdjAuNyBvciBsYXRlclxuICBjb25uZWN0UmVxLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gIGNvbm5lY3RSZXEuZW5kKCk7XG5cbiAgZnVuY3Rpb24gb25SZXNwb25zZShyZXMpIHtcbiAgICAvLyBWZXJ5IGhhY2t5LiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBodHRwLXBhcnNlciBsZWFrcy5cbiAgICByZXMudXBncmFkZSA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblVwZ3JhZGUocmVzLCBzb2NrZXQsIGhlYWQpIHtcbiAgICAvLyBIYWNreS5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgb25Db25uZWN0KHJlcywgc29ja2V0LCBoZWFkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdChyZXMsIHNvY2tldCwgaGVhZCkge1xuICAgIGNvbm5lY3RSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgIGRlYnVnKCd0dW5uZWxpbmcgc29ja2V0IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCwgc3RhdHVzQ29kZT0lZCcsXG4gICAgICAgIHJlcy5zdGF0dXNDb2RlKTtcbiAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCAnICtcbiAgICAgICAgJ3N0YXR1c0NvZGU9JyArIHJlcy5zdGF0dXNDb2RlKTtcbiAgICAgIGVycm9yLmNvZGUgPSAnRUNPTk5SRVNFVCc7XG4gICAgICBvcHRpb25zLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICBzZWxmLnJlbW92ZVNvY2tldChwbGFjZWhvbGRlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlYnVnKCdnb3QgaWxsZWdhbCByZXNwb25zZSBib2R5IGZyb20gcHJveHknKTtcbiAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ2dvdCBpbGxlZ2FsIHJlc3BvbnNlIGJvZHkgZnJvbSBwcm94eScpO1xuICAgICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJztcbiAgICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIHNlbGYucmVtb3ZlU29ja2V0KHBsYWNlaG9sZGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVidWcoJ3R1bm5lbGluZyBjb25uZWN0aW9uIGhhcyBlc3RhYmxpc2hlZCcpO1xuICAgIHNlbGYuc29ja2V0c1tzZWxmLnNvY2tldHMuaW5kZXhPZihwbGFjZWhvbGRlcildID0gc29ja2V0O1xuICAgIHJldHVybiBjYihzb2NrZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvcihjYXVzZSkge1xuICAgIGNvbm5lY3RSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICBkZWJ1ZygndHVubmVsaW5nIHNvY2tldCBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsIGNhdXNlPSVzXFxuJyxcbiAgICAgICAgICBjYXVzZS5tZXNzYWdlLCBjYXVzZS5zdGFjayk7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCd0dW5uZWxpbmcgc29ja2V0IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdjYXVzZT0nICsgY2F1c2UubWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJztcbiAgICBvcHRpb25zLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgc2VsZi5yZW1vdmVTb2NrZXQocGxhY2Vob2xkZXIpO1xuICB9XG59O1xuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUucmVtb3ZlU29ja2V0ID0gZnVuY3Rpb24gcmVtb3ZlU29ja2V0KHNvY2tldCkge1xuICB2YXIgcG9zID0gdGhpcy5zb2NrZXRzLmluZGV4T2Yoc29ja2V0KVxuICBpZiAocG9zID09PSAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnNvY2tldHMuc3BsaWNlKHBvcywgMSk7XG5cbiAgdmFyIHBlbmRpbmcgPSB0aGlzLnJlcXVlc3RzLnNoaWZ0KCk7XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHJlcXVlc3RzIGFuZCBhIHNvY2tldCBnZXRzIGNsb3NlZCBhIG5ldyBvbmVcbiAgICAvLyBuZWVkcyB0byBiZSBjcmVhdGVkIHRvIHRha2Ugb3ZlciBpbiB0aGUgcG9vbCBmb3IgdGhlIG9uZSB0aGF0IGNsb3NlZC5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldChwZW5kaW5nLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICAgIHBlbmRpbmcucmVxdWVzdC5vblNvY2tldChzb2NrZXQpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTZWN1cmVTb2NrZXQob3B0aW9ucywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBUdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0LmNhbGwoc2VsZiwgb3B0aW9ucywgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgdmFyIGhvc3RIZWFkZXIgPSBvcHRpb25zLnJlcXVlc3QuZ2V0SGVhZGVyKCdob3N0Jyk7XG4gICAgdmFyIHRsc09wdGlvbnMgPSBtZXJnZU9wdGlvbnMoe30sIHNlbGYub3B0aW9ucywge1xuICAgICAgc29ja2V0OiBzb2NrZXQsXG4gICAgICBzZXJ2ZXJuYW1lOiBob3N0SGVhZGVyID8gaG9zdEhlYWRlci5yZXBsYWNlKC86LiokLywgJycpIDogb3B0aW9ucy5ob3N0XG4gICAgfSk7XG5cbiAgICAvLyAwIGlzIGR1bW15IHBvcnQgZm9yIHYwLjZcbiAgICB2YXIgc2VjdXJlU29ja2V0ID0gdGxzLmNvbm5lY3QoMCwgdGxzT3B0aW9ucyk7XG4gICAgc2VsZi5zb2NrZXRzW3NlbGYuc29ja2V0cy5pbmRleE9mKHNvY2tldCldID0gc2VjdXJlU29ja2V0O1xuICAgIGNiKHNlY3VyZVNvY2tldCk7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIHRvT3B0aW9ucyhob3N0LCBwb3J0LCBsb2NhbEFkZHJlc3MpIHtcbiAgaWYgKHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJykgeyAvLyBzaW5jZSB2MC4xMFxuICAgIHJldHVybiB7XG4gICAgICBob3N0OiBob3N0LFxuICAgICAgcG9ydDogcG9ydCxcbiAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxBZGRyZXNzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gaG9zdDsgLy8gZm9yIHYwLjExIG9yIGxhdGVyXG59XG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBvdmVycmlkZXMgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHR5cGVvZiBvdmVycmlkZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcyk7XG4gICAgICBmb3IgKHZhciBqID0gMCwga2V5TGVuID0ga2V5cy5sZW5ndGg7IGogPCBrZXlMZW47ICsraikge1xuICAgICAgICB2YXIgayA9IGtleXNbal07XG4gICAgICAgIGlmIChvdmVycmlkZXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldFtrXSA9IG92ZXJyaWRlc1trXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbnZhciBkZWJ1ZztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmIC9cXGJ0dW5uZWxcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgYXJnc1swXSA9ICdUVU5ORUw6ICcgKyBhcmdzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQoJ1RVTk5FTDonKTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xufVxuZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnOyAvLyBmb3IgdGVzdFxuIiwiZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgXCJ2ZXJzaW9uXCIgaW4gcHJvY2Vzcykge1xuICAgICAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtwcm9jZXNzLmFyY2h9KWA7XG4gICAgfVxuICAgIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG5cbmV4cG9ydCB7IGdldFVzZXJBZ2VudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIGNvbnRyb2xPcldoaXRlc3BhY2UgPSAvXltcXHgwMC1cXHgyMFxcdTAwYTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXSsvXG4gICwgQ1JIVExGID0gL1tcXG5cXHJcXHRdL2dcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vXG4gICwgcG9ydCA9IC86XFxkKyQvXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFxcL10rKT8oW1xcU1xcc10qKS9pXG4gICwgd2luZG93c0RyaXZlTGV0dGVyID0gL15bYS16QS1aXTovO1xuXG4vKipcbiAqIFJlbW92ZSBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc3RyIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge1N0cmluZ30gQSBuZXcgc3RyaW5nIHJlcHJlc2VudGluZyBgc3RyYCBzdHJpcHBlZCBvZiBjb250cm9sXG4gKiAgICAgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIGl0cyBiZWdpbm5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UoY29udHJvbE9yV2hpdGVzcGFjZSwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzLCB1cmwpIHsgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/IGFkZHJlc3MucmVwbGFjZSgvXFxcXC9nLCAnLycpIDogYWRkcmVzcztcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKikkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFRoZSBwcm90b2NvbCBzY2hlbWUgb2YgdGhlIFVSTFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1NwZWNpYWwoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lID09PSAnZmlsZTonIHx8XG4gICAgc2NoZW1lID09PSAnZnRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwczonIHx8XG4gICAgc2NoZW1lID09PSAnd3M6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzczonXG4gICk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb25cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MsIGxvY2F0aW9uKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShDUkhUTEYsICcnKTtcbiAgbG9jYXRpb24gPSBsb2NhdGlvbiB8fCB7fTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnO1xuICB2YXIgZm9yd2FyZFNsYXNoZXMgPSAhIW1hdGNoWzJdO1xuICB2YXIgb3RoZXJTbGFzaGVzID0gISFtYXRjaFszXTtcbiAgdmFyIHNsYXNoZXNDb3VudCA9IDA7XG4gIHZhciByZXN0O1xuXG4gIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzRdXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgaWYgKHNsYXNoZXNDb3VudCA+PSAyKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfSBlbHNlIGlmIChwcm90b2NvbCkge1xuICAgIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNsYXNoZXNDb3VudCA+PSAyICYmIGlzU3BlY2lhbChsb2NhdGlvbi5wcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBmb3J3YXJkU2xhc2hlcyB8fCBpc1NwZWNpYWwocHJvdG9jb2wpLFxuICAgIHNsYXNoZXNDb3VudDogc2xhc2hlc0NvdW50LFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKENSSFRMRiwgJycpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnLCBsb2NhdGlvbik7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoXG4gICAgZXh0cmFjdGVkLnByb3RvY29sID09PSAnZmlsZTonICYmIChcbiAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgIT09IDIgfHwgd2luZG93c0RyaXZlTGV0dGVyLnRlc3QoYWRkcmVzcykpIHx8XG4gICAgKCFleHRyYWN0ZWQuc2xhc2hlcyAmJlxuICAgICAgKGV4dHJhY3RlZC5wcm90b2NvbCB8fFxuICAgICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50IDwgMiB8fFxuICAgICAgICAhaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpKVxuICApIHtcbiAgICBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcywgdXJsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpbmRleCA9IHBhcnNlID09PSAnQCdcbiAgICAgICAgPyBhZGRyZXNzLmxhc3RJbmRleE9mKHBhcnNlKVxuICAgICAgICA6IGFkZHJlc3MuaW5kZXhPZihwYXJzZSk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBhIC8gZm9yIHBhdGhuYW1lIGlmIG5vbmUgZXhpc3RzLiBUaGlzIG5vcm1hbGl6ZXMgdGhlIFVSTFxuICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgLy9cbiAgaWYgKHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSkge1xuICAgIHVybC5wYXRobmFtZSA9ICcvJyArIHVybC5wYXRobmFtZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuXG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluZGV4ID0gdXJsLmF1dGguaW5kZXhPZignOicpO1xuXG4gICAgaWYgKH5pbmRleCkge1xuICAgICAgdXJsLnVzZXJuYW1lID0gdXJsLmF1dGguc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcblxuICAgICAgdXJsLnBhc3N3b3JkID0gdXJsLmF1dGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgIHVybC5wYXNzd29yZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnBhc3N3b3JkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwuYXV0aCkpO1xuICAgIH1cblxuICAgIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsnOicrIHVybC5wYXNzd29yZCA6IHVybC51c2VybmFtZTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgdXJsLmhvc3RcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHBvcnQudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VzZXJuYW1lJzpcbiAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICB1cmxbcGFydF0gPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRoJzpcbiAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJzonKTtcblxuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICB1cmwudXNlcm5hbWUgPSB2YWx1ZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSk7XG5cbiAgICAgICAgdXJsLnBhc3N3b3JkID0gdmFsdWUuc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgICAgdXJsLnBhc3N3b3JkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwuYXV0aCA9IHVybC5wYXNzd29yZCA/IHVybC51c2VybmFtZSArJzonKyB1cmwucGFzc3dvcmQgOiB1cmwudXNlcm5hbWU7XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGhvc3QgPSB1cmwuaG9zdFxuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9XG4gICAgcHJvdG9jb2wgK1xuICAgICgodXJsLnByb3RvY29sICYmIHVybC5zbGFzaGVzKSB8fCBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH0gZWxzZSBpZiAodXJsLnBhc3N3b3JkKSB7XG4gICAgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH0gZWxzZSBpZiAoXG4gICAgdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiZcbiAgICAhaG9zdCAmJlxuICAgIHVybC5wYXRobmFtZSAhPT0gJy8nXG4gICkge1xuICAgIC8vXG4gICAgLy8gQWRkIGJhY2sgdGhlIGVtcHR5IHVzZXJpbmZvLCBvdGhlcndpc2UgdGhlIG9yaWdpbmFsIGludmFsaWQgVVJMXG4gICAgLy8gbWlnaHQgYmUgdHJhbnNmb3JtZWQgaW50byBhIHZhbGlkIG9uZSB3aXRoIGB1cmwucGF0aG5hbWVgIGFzIGhvc3QuXG4gICAgLy9cbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgLy9cbiAgLy8gVHJhaWxpbmcgY29sb24gaXMgcmVtb3ZlZCBmcm9tIGB1cmwuaG9zdGAgd2hlbiBpdCBpcyBwYXJzZWQuIElmIGl0IHN0aWxsXG4gIC8vIGVuZHMgd2l0aCBhIGNvbG9uLCB0aGVuIGFkZCBiYWNrIHRoZSB0cmFpbGluZyBjb2xvbiB0aGF0IHdhcyByZW1vdmVkLiBUaGlzXG4gIC8vIHByZXZlbnRzIGFuIGludmFsaWQgVVJMIGZyb20gYmVpbmcgdHJhbnNmb3JtZWQgaW50byBhIHZhbGlkIG9uZS5cbiAgLy9cbiAgaWYgKGhvc3RbaG9zdC5sZW5ndGggLSAxXSA9PT0gJzonIHx8IChwb3J0LnRlc3QodXJsLmhvc3RuYW1lKSAmJiAhdXJsLnBvcnQpKSB7XG4gICAgaG9zdCArPSAnOic7XG4gIH1cblxuICByZXN1bHQgKz0gaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiLCIvKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgdmFyIGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICB2YXIgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgdmFyIGhleCA9IHBhcnNlSW50KGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZiksIDE2KTtcbiAgICBvdXRwdXQucHVzaChoZXgpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG91dHB1dCBsZW5ndGggd2l0aCBwYWRkaW5nIGFuZCBiaXQgbGVuZ3RoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XG4gIHJldHVybiAoaW5wdXRMZW5ndGg4ICsgNjQgPj4+IDkgPDwgNCkgKyAxNCArIDE7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbZ2V0T3V0cHV0TGVuZ3RoKGxlbikgLSAxXSA9IGxlbjtcbiAgdmFyIGEgPSAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIHZhciBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGxlbmd0aDgpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7IiwiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCIvLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICB9XG59XG5cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xufVxuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIHZhciBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMucHVzaChtc2cuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIC8vIENvbnZlcnQgQXJyYXktbGlrZSB0byBBcnJheVxuICAgIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMpO1xuICB9XG5cbiAgYnl0ZXMucHVzaCgweDgwKTtcbiAgdmFyIGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgdmFyIE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgdmFyIE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE47ICsrX2kpIHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgYXJyW2pdID0gYnl0ZXNbX2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDFdIDw8IDE2IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1bX2ldID0gYXJyO1xuICB9XG5cbiAgTVtOIC0gMV1bMTRdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKTtcbiAgTVtOIC0gMV1bMTRdID0gTWF0aC5mbG9vcihNW04gLSAxXVsxNF0pO1xuICBNW04gLSAxXVsxNV0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4ICYgMHhmZmZmZmZmZjtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBOOyArK19pMikge1xuICAgIHZhciBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMTY7ICsrdCkge1xuICAgICAgV1t0XSA9IE1bX2kyXVt0XTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfdCA9IDE2OyBfdCA8IDgwOyArK190KSB7XG4gICAgICBXW190XSA9IFJPVEwoV1tfdCAtIDNdIF4gV1tfdCAtIDhdIF4gV1tfdCAtIDE0XSBeIFdbX3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIHZhciBhID0gSFswXTtcbiAgICB2YXIgYiA9IEhbMV07XG4gICAgdmFyIGMgPSBIWzJdO1xuICAgIHZhciBkID0gSFszXTtcbiAgICB2YXIgZSA9IEhbNF07XG5cbiAgICBmb3IgKHZhciBfdDIgPSAwOyBfdDIgPCA4MDsgKytfdDIpIHtcbiAgICAgIHZhciBzID0gTWF0aC5mbG9vcihfdDIgLyAyMCk7XG4gICAgICB2YXIgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW190Ml0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xuXG52YXIgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTsgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW3NlZWRCeXRlc1swXSB8IDB4MDEsIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcbiAgICB9XG5cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH0gLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG5cblxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIHZhciBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICB2YXIgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBzdHJpbmdpZnkoYik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHYxOyIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG52YXIgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyIsImltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IHZhciBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCB2YXIgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSBwYXJzZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iLCJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiLCJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG52YXIgdjUgPSB2MzUoJ3Y1JywgMHg1MCwgc2hhMSk7XG5leHBvcnQgZGVmYXVsdCB2NTsiLCJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnN1YnN0cigxNCwgMSksIDE2KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmVyc2lvbjsiLCIvLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICB2YXIgY3Rvcixwcm90O1xuXG4gIGlmIChpc09iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcbiAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kXG4gIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7IGlzUGxhaW5PYmplY3QgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9